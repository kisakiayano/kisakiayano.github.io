<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/logo.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/logo.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"ayan0.top","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.24.1","exturl":false,"sidebar":{"position":"left","width_expanded":280,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":false,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":"mac"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="探究base64的安全性 前段时间打N1Junior遇到一题利用了Python和Linux对base64 padding的处理差异来绕过 当时是乱尝试无意中就试出来了，现在想想其实如果看看源码可能事情会简单很多吧。。">
<meta property="og:type" content="article">
<meta property="og:title" content="从N1Junoir探究各种环境下的base64处理安全性">
<meta property="og:url" content="https://ayan0.top/2025/09/20/%E4%BB%8EN1Junoir%E6%8E%A2%E7%A9%B6%E5%90%84%E7%A7%8D%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84base64%E5%A4%84%E7%90%86%E5%AE%89%E5%85%A8%E6%80%A7/">
<meta property="og:site_name" content="Blog of AyaN0">
<meta property="og:description" content="探究base64的安全性 前段时间打N1Junior遇到一题利用了Python和Linux对base64 padding的处理差异来绕过 当时是乱尝试无意中就试出来了，现在想想其实如果看看源码可能事情会简单很多吧。。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250917213348645.png">
<meta property="og:image" content="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250917220344846.png">
<meta property="article:published_time" content="2025-09-20T13:02:39.000Z">
<meta property="article:modified_time" content="2025-09-20T13:07:13.582Z">
<meta property="article:author" content="AyaN0">
<meta property="article:tag" content="Web">
<meta property="article:tag" content="源码挖掘">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250917213348645.png">


<link rel="canonical" href="https://ayan0.top/2025/09/20/%E4%BB%8EN1Junoir%E6%8E%A2%E7%A9%B6%E5%90%84%E7%A7%8D%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84base64%E5%A4%84%E7%90%86%E5%AE%89%E5%85%A8%E6%80%A7/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://ayan0.top/2025/09/20/%E4%BB%8EN1Junoir%E6%8E%A2%E7%A9%B6%E5%90%84%E7%A7%8D%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84base64%E5%A4%84%E7%90%86%E5%AE%89%E5%85%A8%E6%80%A7/","path":"2025/09/20/从N1Junoir探究各种环境下的base64处理安全性/","title":"从N1Junoir探究各种环境下的base64处理安全性"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>从N1Junoir探究各种环境下的base64处理安全性 | Blog of AyaN0</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>







  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">
      <img class="custom-logo-image" src="/images/lly.jpg" alt="Blog of AyaN0">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Blog of AyaN0</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8E%A2%E7%A9%B6base64%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7"><span class="nav-number">1.</span> <span class="nav-text"> 探究base64的安全性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#python"><span class="nav-number">1.1.</span> <span class="nav-text"> Python</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#php"><span class="nav-number">1.2.</span> <span class="nav-text"> PHP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5x"><span class="nav-number">1.2.1.</span> <span class="nav-text"> 5.x</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#70"><span class="nav-number">1.2.2.</span> <span class="nav-text"> 7.0</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#71-72"><span class="nav-number">1.2.3.</span> <span class="nav-text"> 7.1-7.2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#73~84"><span class="nav-number">1.2.4.</span> <span class="nav-text"> 7.3~8.4</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#golang"><span class="nav-number">1.3.</span> <span class="nav-text"> Golang</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java"><span class="nav-number">1.4.</span> <span class="nav-text"> Java</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ruby"><span class="nav-number">1.5.</span> <span class="nav-text"> Ruby</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#linux"><span class="nav-number">1.6.</span> <span class="nav-text"> Linux</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="AyaN0"
      src="/images/lly.jpg">
  <p class="site-author-name" itemprop="name">AyaN0</p>
  <div class="site-description" itemprop="description">不断的前进的人:只有0次摔倒或无数次的爬起</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/kisakiayano" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;kisakiayano" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/1594453512@qq.com" title="E-Mail → 1594453512@qq.com" rel="noopener me"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ayan0.top/2025/09/20/%E4%BB%8EN1Junoir%E6%8E%A2%E7%A9%B6%E5%90%84%E7%A7%8D%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84base64%E5%A4%84%E7%90%86%E5%AE%89%E5%85%A8%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lly.jpg">
      <meta itemprop="name" content="AyaN0">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of AyaN0">
      <meta itemprop="description" content="不断的前进的人:只有0次摔倒或无数次的爬起">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="从N1Junoir探究各种环境下的base64处理安全性 | Blog of AyaN0">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          从N1Junoir探究各种环境下的base64处理安全性
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-09-20 21:02:39 / 修改时间：21:07:13" itemprop="dateCreated datePublished" datetime="2025-09-20T21:02:39+08:00">2025-09-20</time>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>31k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>57 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="探究base64的安全性"><a class="markdownIt-Anchor" href="#探究base64的安全性"></a> 探究base64的安全性</h1>
<p>前段时间打N1Junior遇到一题利用了Python和Linux对base64 padding的处理差异来绕过</p>
<p>当时是乱尝试无意中就试出来了，现在想想其实如果看看源码可能事情会简单很多吧。。</p>
<h2 id="python"><a class="markdownIt-Anchor" href="#python"></a> Python</h2>
<p>调试之后可以看到这里</p>
<pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">b64decode</span>(<span class="params">s, altchars=<span class="literal">None</span>, validate=<span class="literal">False</span></span>):
    <span class="string">&quot;&quot;&quot;Decode the Base64 encoded bytes-like object or ASCII string s.</span>
<span class="string"></span>
<span class="string">    Optional altchars must be a bytes-like object or ASCII string of length 2</span>
<span class="string">    which specifies the alternative alphabet used instead of the &#x27;+&#x27; and &#x27;/&#x27;</span>
<span class="string">    characters.</span>
<span class="string"></span>
<span class="string">    The result is returned as a bytes object.  A binascii.Error is raised if</span>
<span class="string">    s is incorrectly padded.</span>
<span class="string"></span>
<span class="string">    If validate is False (the default), characters that are neither in the</span>
<span class="string">    normal base-64 alphabet nor the alternative alphabet are discarded prior</span>
<span class="string">    to the padding check.  If validate is True, these non-alphabet characters</span>
<span class="string">    in the input result in a binascii.Error.</span>
<span class="string">    For more information about the strict base64 check, see:</span>
<span class="string"></span>
<span class="string">    https://docs.python.org/3.11/library/binascii.html#binascii.a2b_base64</span>
<span class="string">    &quot;&quot;&quot;</span>
    s = _bytes_from_decode_data(s)
    <span class="keyword">if</span> altchars <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:
        altchars = _bytes_from_decode_data(altchars)
        <span class="keyword">assert</span> <span class="built_in">len</span>(altchars) == <span class="number">2</span>, <span class="built_in">repr</span>(altchars)
        s = s.translate(<span class="built_in">bytes</span>.maketrans(altchars, <span class="string">b&#x27;+/&#x27;</span>))
    <span class="keyword">return</span> binascii.a2b_base64(s, strict_mode=validate)</code></pre>
<p>先跟进<code>_bytes_from_decode_data</code>这个函数看两眼</p>
<pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">_bytes_from_decode_data</span>(<span class="params">s</span>):
    <span class="keyword">if</span> <span class="built_in">isinstance</span>(s, <span class="built_in">str</span>):
        <span class="keyword">try</span>:
            <span class="keyword">return</span> s.encode(<span class="string">&#x27;ascii&#x27;</span>)
        <span class="keyword">except</span> UnicodeEncodeError:
            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;string argument should contain only ASCII characters&#x27;</span>)
    <span class="keyword">if</span> <span class="built_in">isinstance</span>(s, bytes_types):
        <span class="keyword">return</span> s
    <span class="keyword">try</span>:
        <span class="keyword">return</span> <span class="built_in">memoryview</span>(s).tobytes()
    <span class="keyword">except</span> TypeError:
        <span class="keyword">raise</span> TypeError(<span class="string">&quot;argument should be a bytes-like object or ASCII &quot;</span>
                        <span class="string">&quot;string, not %r&quot;</span> % s.__class__.__name__) <span class="keyword">from</span> <span class="literal">None</span></code></pre>
<p>这里其实就是对解码字符的判断，必须是ASCII字符，其他没什么新奇的</p>
<p>最后走到这个函数</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250917213348645.png" alt="image-20250917213348645"></p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250917220344846.png" alt="image-20250917220344846"></p>
<p>并且可以发现一般的解码下采用的都是非strict的模式</p>
<pre><code class="highlight plaintext">def a2b_base64(*args, **kwargs): # real signature unknown
    &quot;&quot;&quot;
    Decode a line of base64 data.
    
      strict_mode
        When set to True, bytes that are not part of the base64 standard are not allowed.
        The same applies to excess data after padding (= / ==).
    &quot;&quot;&quot;
    pass</code></pre>
<p>这里没东西了，感觉要去翻更底层一点的东西</p>
<p>找到了cPython里面对应的函数<code>binascii_a2b_base64_impl</code></p>
<pre><code class="highlight c"><span class="type">static</span> PyObject *
<span class="title function_">binascii_a2b_base64_impl</span><span class="params">(PyObject *module, Py_buffer *data, <span class="type">int</span> strict_mode)</span>
<span class="comment">/*[clinic end generated code: output=5409557788d4f975 input=13c797187acc9c40]*/</span>
&#123;
    assert(data-&gt;len &gt;= <span class="number">0</span>);

    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *ascii_data = data-&gt;buf;
    <span class="type">size_t</span> ascii_len = data-&gt;len;
    binascii_state *state = <span class="literal">NULL</span>;
    <span class="type">char</span> padding_started = <span class="number">0</span>;

    <span class="comment">/* Allocate the buffer */</span>
    Py_ssize_t bin_len = ((ascii_len+<span class="number">3</span>)/<span class="number">4</span>)*<span class="number">3</span>; <span class="comment">/* Upper bound, corrected later */</span>
    PyBytesWriter *writer = PyBytesWriter_Create(bin_len);
    <span class="keyword">if</span> (writer == <span class="literal">NULL</span>) &#123;
        <span class="keyword">return</span> <span class="literal">NULL</span>;
    &#125;
    <span class="type">unsigned</span> <span class="type">char</span> *bin_data = PyBytesWriter_GetData(writer);

    <span class="keyword">if</span> (strict_mode &amp;&amp; ascii_len &gt; <span class="number">0</span> &amp;&amp; ascii_data[<span class="number">0</span>] == <span class="string">&#x27;=&#x27;</span>) &#123;
        state = get_binascii_state(module);
        <span class="keyword">if</span> (state) &#123;
            PyErr_SetString(state-&gt;Error, <span class="string">&quot;Leading padding not allowed&quot;</span>);
        &#125;
        <span class="keyword">goto</span> error_end;
    &#125;

    <span class="type">int</span> quad_pos = <span class="number">0</span>;
    <span class="type">unsigned</span> <span class="type">char</span> leftchar = <span class="number">0</span>;
    <span class="type">int</span> pads = <span class="number">0</span>;
    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; ascii_len; i++) &#123;
        <span class="type">unsigned</span> <span class="type">char</span> this_ch = ascii_data[i];

        <span class="comment">/* Check for pad sequences and ignore</span>
<span class="comment">        ** the invalid ones.</span>
<span class="comment">        */</span>
        <span class="keyword">if</span> (this_ch == BASE64_PAD) &#123;
            padding_started = <span class="number">1</span>;

            <span class="keyword">if</span> (strict_mode &amp;&amp; quad_pos == <span class="number">0</span>) &#123;
                state = get_binascii_state(module);
                <span class="keyword">if</span> (state) &#123;
                    PyErr_SetString(state-&gt;Error, <span class="string">&quot;Excess padding not allowed&quot;</span>);
                &#125;
                <span class="keyword">goto</span> error_end;
            &#125;
            <span class="keyword">if</span> (quad_pos &gt;= <span class="number">2</span> &amp;&amp; quad_pos + ++pads &gt;= <span class="number">4</span>) &#123;
                <span class="comment">/* A pad sequence means we should not parse more input.</span>
<span class="comment">                ** We&#x27;ve already interpreted the data from the quad at this point.</span>
<span class="comment">                ** in strict mode, an error should raise if there&#x27;s excess data after the padding.</span>
<span class="comment">                */</span>
                <span class="keyword">if</span> (strict_mode &amp;&amp; i + <span class="number">1</span> &lt; ascii_len) &#123;
                    state = get_binascii_state(module);
                    <span class="keyword">if</span> (state) &#123;
                        PyErr_SetString(state-&gt;Error, <span class="string">&quot;Excess data after padding&quot;</span>);
                    &#125;
                    <span class="keyword">goto</span> error_end;
                &#125;

                <span class="keyword">goto</span> done;
            &#125;
            <span class="keyword">continue</span>;
        &#125;

        this_ch = table_a2b_base64[this_ch];
        <span class="keyword">if</span> (this_ch &gt;= <span class="number">64</span>) &#123;
            <span class="keyword">if</span> (strict_mode) &#123;
                state = get_binascii_state(module);
                <span class="keyword">if</span> (state) &#123;
                    PyErr_SetString(state-&gt;Error, <span class="string">&quot;Only base64 data is allowed&quot;</span>);
                &#125;
                <span class="keyword">goto</span> error_end;
            &#125;
            <span class="keyword">continue</span>;
        &#125;

        <span class="comment">// Characters that are not &#x27;=&#x27;, in the middle of the padding, are not allowed</span>
        <span class="keyword">if</span> (strict_mode &amp;&amp; padding_started) &#123;
            state = get_binascii_state(module);
            <span class="keyword">if</span> (state) &#123;
                PyErr_SetString(state-&gt;Error, <span class="string">&quot;Discontinuous padding not allowed&quot;</span>);
            &#125;
            <span class="keyword">goto</span> error_end;
        &#125;
        pads = <span class="number">0</span>;

        <span class="keyword">switch</span> (quad_pos) &#123;
            <span class="keyword">case</span> <span class="number">0</span>:
                quad_pos = <span class="number">1</span>;
                leftchar = this_ch;
                <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="number">1</span>:
                quad_pos = <span class="number">2</span>;
                *bin_data++ = (leftchar &lt;&lt; <span class="number">2</span>) | (this_ch &gt;&gt; <span class="number">4</span>);
                leftchar = this_ch &amp; <span class="number">0x0f</span>;
                <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="number">2</span>:
                quad_pos = <span class="number">3</span>;
                *bin_data++ = (leftchar &lt;&lt; <span class="number">4</span>) | (this_ch &gt;&gt; <span class="number">2</span>);
                leftchar = this_ch &amp; <span class="number">0x03</span>;
                <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="number">3</span>:
                quad_pos = <span class="number">0</span>;
                *bin_data++ = (leftchar &lt;&lt; <span class="number">6</span>) | (this_ch);
                leftchar = <span class="number">0</span>;
                <span class="keyword">break</span>;
        &#125;
    &#125;

    <span class="keyword">if</span> (quad_pos != <span class="number">0</span>) &#123;
        state = get_binascii_state(module);
        <span class="keyword">if</span> (state == <span class="literal">NULL</span>) &#123;
            <span class="comment">/* error already set, from get_binascii_state */</span>
            assert(PyErr_Occurred());
        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (quad_pos == <span class="number">1</span>) &#123;
            <span class="comment">/*</span>
<span class="comment">            ** There is exactly one extra valid, non-padding, base64 character.</span>
<span class="comment">            ** This is an invalid length, as there is no possible input that</span>
<span class="comment">            ** could encoded into such a base64 string.</span>
<span class="comment">            */</span>
            <span class="type">unsigned</span> <span class="type">char</span> *bin_data_start = PyBytesWriter_GetData(writer);
            PyErr_Format(state-&gt;Error,
                         <span class="string">&quot;Invalid base64-encoded string: &quot;</span>
                         <span class="string">&quot;number of data characters (%zd) cannot be 1 more &quot;</span>
                         <span class="string">&quot;than a multiple of 4&quot;</span>,
                         (bin_data - bin_data_start) / <span class="number">3</span> * <span class="number">4</span> + <span class="number">1</span>);
        &#125; <span class="keyword">else</span> &#123;
            PyErr_SetString(state-&gt;Error, <span class="string">&quot;Incorrect padding&quot;</span>);
        &#125;
        <span class="keyword">goto</span> error_end;
    &#125;

done:
    <span class="keyword">return</span> PyBytesWriter_FinishWithPointer(writer, bin_data);

error_end:
    PyBytesWriter_Discard(writer);
    <span class="keyword">return</span> <span class="literal">NULL</span>;
&#125;</code></pre>
<p>主要关注这一段，这一段已经在处理非字符串头出现的padding段了</p>
<pre><code class="highlight c"><span class="keyword">if</span> (this_ch == BASE64_PAD) &#123;
            padding_started = <span class="number">1</span>;

            <span class="keyword">if</span> (strict_mode &amp;&amp; quad_pos == <span class="number">0</span>) &#123;
                state = get_binascii_state(module);
                <span class="keyword">if</span> (state) &#123;
                    PyErr_SetString(state-&gt;Error, <span class="string">&quot;Excess padding not allowed&quot;</span>);
                &#125;
                <span class="keyword">goto</span> error_end;
            &#125;
            <span class="keyword">if</span> (quad_pos &gt;= <span class="number">2</span> &amp;&amp; quad_pos + ++pads &gt;= <span class="number">4</span>) &#123;
                <span class="comment">/* A pad sequence means we should not parse more input.</span>
<span class="comment">                ** We&#x27;ve already interpreted the data from the quad at this point.</span>
<span class="comment">                ** in strict mode, an error should raise if there&#x27;s excess data after the padding.</span>
<span class="comment">                */</span>
                <span class="keyword">if</span> (strict_mode &amp;&amp; i + <span class="number">1</span> &lt; ascii_len) &#123;
                    state = get_binascii_state(module);
                    <span class="keyword">if</span> (state) &#123;
                        PyErr_SetString(state-&gt;Error, <span class="string">&quot;Excess data after padding&quot;</span>);
                    &#125;
                    <span class="keyword">goto</span> error_end;
                &#125;

                <span class="keyword">goto</span> done;
            &#125;
            <span class="keyword">continue</span>;
        &#125;</code></pre>
<p>由于不是strict模式我们直接看第三个if</p>
<p>这里判断至少已经读了两个字符并且后续的pad加起来&gt;=4，看似符合了到达base64末尾的条件(但是在严格模式下实则会检测=的后面的是不是还有东西)</p>
<p>那么如果这个字符串本身就是一个带有padding的base64，在非strict模式下就会忽略padding后面的字符从而判断这个base64字符串是<strong>合法的</strong></p>
<p>那么如果我们强行加了padding试图瞒天过海呢?</p>
<p>由于此时quad_pos=0,根本进不了出去的循环，就会忽略==，继续做后面有效的字符的解码</p>
<p>也就是说，在宽松情况下对于一个本身没有padding的字符串来说</p>
<p>这个==其实和没加一样。但是当然，如果你尝试在strict模式下这么干，毫无疑问会收获报错。</p>
<p>总结就是，<strong>在宽松情况/默认的b64解码中，对于一个含有padding的base64来说，后面可以被塞入任何的数据而python不会做出任何的解码/报错</strong></p>
<h2 id="php"><a class="markdownIt-Anchor" href="#php"></a> PHP</h2>
<p>php就是直接看C的处理逻辑了</p>
<p>因为PHP好几个版本并且变动比较大的缘故按版本看</p>
<h3 id="5x"><a class="markdownIt-Anchor" href="#5x"></a> 5.x</h3>
<p>5.x版本的base.c基本上没有啥变动</p>
<pre><code class="highlight c">PHPAPI <span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">php_base64_decode_ex</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *str, <span class="type">int</span> length, <span class="type">int</span> *ret_length, zend_bool strict)</span> <span class="comment">/* &#123;&#123;&#123; */</span>
&#123;
	<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *current = str;
	<span class="type">int</span> ch, i = <span class="number">0</span>, j = <span class="number">0</span>, k;
	<span class="comment">/* this sucks for threaded environments */</span>
	<span class="type">unsigned</span> <span class="type">char</span> *result;

	result = (<span class="type">unsigned</span> <span class="type">char</span> *)safe_emalloc(length, <span class="number">1</span>, <span class="number">1</span>);

	<span class="comment">/* run through the whole string, converting as we go */</span>
	<span class="keyword">while</span> ((ch = *current++) != <span class="string">&#x27;\0&#x27;</span> &amp;&amp; length-- &gt; <span class="number">0</span>) &#123;
		<span class="keyword">if</span> (ch == base64_pad) &#123;
			<span class="keyword">if</span> (*current != <span class="string">&#x27;=&#x27;</span> &amp;&amp; ((i % <span class="number">4</span>) == <span class="number">1</span> || (strict &amp;&amp; length &gt; <span class="number">0</span>))) &#123;
				<span class="keyword">if</span> ((i % <span class="number">4</span>) != <span class="number">1</span>) &#123;
					<span class="keyword">while</span> (<span class="built_in">isspace</span>(*(++current))) &#123;
						<span class="keyword">continue</span>;
					&#125;
					<span class="keyword">if</span> (*current == <span class="string">&#x27;\0&#x27;</span>) &#123;
						<span class="keyword">continue</span>;
					&#125;
				&#125;
				efree(result);
				<span class="keyword">return</span> <span class="literal">NULL</span>;
			&#125;
			<span class="keyword">continue</span>;
		&#125;

		ch = base64_reverse_table[ch];
		<span class="keyword">if</span> ((!strict &amp;&amp; ch &lt; <span class="number">0</span>) || ch == <span class="number">-1</span>) &#123; <span class="comment">/* a space or some other separator character, we simply skip over */</span>
			<span class="keyword">continue</span>;
		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="number">-2</span>) &#123;
			efree(result);
			<span class="keyword">return</span> <span class="literal">NULL</span>;
		&#125;

		<span class="keyword">switch</span>(i % <span class="number">4</span>) &#123;
		<span class="keyword">case</span> <span class="number">0</span>:
			result[j] = ch &lt;&lt; <span class="number">2</span>;
			<span class="keyword">break</span>;
		<span class="keyword">case</span> <span class="number">1</span>:
			result[j++] |= ch &gt;&gt; <span class="number">4</span>;
			result[j] = (ch &amp; <span class="number">0x0f</span>) &lt;&lt; <span class="number">4</span>;
			<span class="keyword">break</span>;
		<span class="keyword">case</span> <span class="number">2</span>:
			result[j++] |= ch &gt;&gt;<span class="number">2</span>;
			result[j] = (ch &amp; <span class="number">0x03</span>) &lt;&lt; <span class="number">6</span>;
			<span class="keyword">break</span>;
		<span class="keyword">case</span> <span class="number">3</span>:
			result[j++] |= ch;
			<span class="keyword">break</span>;
		&#125;
		i++;
	&#125;

	k = j;
	<span class="comment">/* mop things up if we ended on a boundary */</span>
	<span class="keyword">if</span> (ch == base64_pad) &#123;
		<span class="keyword">switch</span>(i % <span class="number">4</span>) &#123;
		<span class="keyword">case</span> <span class="number">1</span>:
			efree(result);
			<span class="keyword">return</span> <span class="literal">NULL</span>;
		<span class="keyword">case</span> <span class="number">2</span>:
			k++;
		<span class="keyword">case</span> <span class="number">3</span>:
			result[k] = <span class="number">0</span>;
		&#125;
	&#125;
	<span class="keyword">if</span>(ret_length) &#123;
		*ret_length = j;
	&#125;
	result[j] = <span class="string">&#x27;\0&#x27;</span>;
	<span class="keyword">return</span> result;
&#125;
<span class="comment">/* &#125;&#125;&#125; */</span></code></pre>
<p>大致的审计了一下非严格情况下的处理逻辑</p>
<pre><code class="highlight plaintext">当读取的字符的是=会检查padding的位置是否符合规范，不符合就会直接返回空;
遇到非法字符就会直接返回空  遇到\t,\n,\r,空格就会跳过这一轮循环</code></pre>
<p>非常的令人安心，找不出什么可以利用的地方</p>
<h3 id="70"><a class="markdownIt-Anchor" href="#70"></a> 7.0</h3>
<pre><code class="highlight c">PHPAPI zend_string *<span class="title function_">php_base64_decode_ex</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *str, <span class="type">size_t</span> length, zend_bool strict)</span> <span class="comment">/* &#123;&#123;&#123; */</span>
&#123;
	<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *current = str;
	<span class="type">int</span> ch, i = <span class="number">0</span>, j = <span class="number">0</span>, padding = <span class="number">0</span>;
	zend_string *result;

	result = zend_string_alloc(length, <span class="number">0</span>);

	<span class="comment">/* run through the whole string, converting as we go */</span>
	<span class="keyword">while</span> (length-- &gt; <span class="number">0</span>) &#123;
		ch = *current++;
		<span class="comment">/* stop on null byte in non-strict mode (<span class="doctag">FIXME:</span> is this really desired?) */</span>
		<span class="keyword">if</span> (ch == <span class="number">0</span> &amp;&amp; !strict) &#123;
			<span class="keyword">break</span>;
		&#125;
		<span class="keyword">if</span> (ch == base64_pad) &#123;
			<span class="comment">/* fail if the padding character is second in a group (like V===) */</span>
			<span class="comment">/* <span class="doctag">FIXME:</span> why do we still allow invalid padding in other places in the middle of the string? */</span>
			<span class="keyword">if</span> (i % <span class="number">4</span> == <span class="number">1</span>) &#123;
				zend_string_free(result);
				<span class="keyword">return</span> <span class="literal">NULL</span>;
			&#125;
			padding++;
			<span class="keyword">continue</span>;
		&#125;

		ch = base64_reverse_table[ch];
		<span class="keyword">if</span> (!strict) &#123;
			<span class="comment">/* skip unknown characters and whitespace */</span>
			<span class="keyword">if</span> (ch &lt; <span class="number">0</span>) &#123;
				<span class="keyword">continue</span>;
			&#125;
		&#125; <span class="keyword">else</span> &#123;
			<span class="comment">/* skip whitespace */</span>
			<span class="keyword">if</span> (ch == <span class="number">-1</span>) &#123;
				<span class="keyword">continue</span>;
			&#125;
			<span class="comment">/* fail on bad characters or if any data follows padding */</span>
			<span class="keyword">if</span> (ch == <span class="number">-2</span> || padding) &#123;
				zend_string_free(result);
				<span class="keyword">return</span> <span class="literal">NULL</span>;
			&#125;
		&#125;

		<span class="keyword">switch</span>(i % <span class="number">4</span>) &#123;
		<span class="keyword">case</span> <span class="number">0</span>:
			ZSTR_VAL(result)[j] = ch &lt;&lt; <span class="number">2</span>;
			<span class="keyword">break</span>;
		<span class="keyword">case</span> <span class="number">1</span>:
			ZSTR_VAL(result)[j++] |= ch &gt;&gt; <span class="number">4</span>;
			ZSTR_VAL(result)[j] = (ch &amp; <span class="number">0x0f</span>) &lt;&lt; <span class="number">4</span>;
			<span class="keyword">break</span>;
		<span class="keyword">case</span> <span class="number">2</span>:
			ZSTR_VAL(result)[j++] |= ch &gt;&gt;<span class="number">2</span>;
			ZSTR_VAL(result)[j] = (ch &amp; <span class="number">0x03</span>) &lt;&lt; <span class="number">6</span>;
			<span class="keyword">break</span>;
		<span class="keyword">case</span> <span class="number">3</span>:
			ZSTR_VAL(result)[j++] |= ch;
			<span class="keyword">break</span>;
		&#125;
		i++;
	&#125;

	ZSTR_LEN(result) = j;
	ZSTR_VAL(result)[ZSTR_LEN(result)] = <span class="string">&#x27;\0&#x27;</span>;

	<span class="keyword">return</span> result;
&#125;</code></pre>
<h3 id="71-72"><a class="markdownIt-Anchor" href="#71-72"></a> 7.1-7.2</h3>
<pre><code class="highlight c">PHPAPI zend_string *<span class="title function_">php_base64_decode_ex</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *str, <span class="type">size_t</span> length, zend_bool strict)</span> <span class="comment">/* &#123;&#123;&#123; */</span>
&#123;
	<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *current = str;
	<span class="type">int</span> ch, i = <span class="number">0</span>, j = <span class="number">0</span>, padding = <span class="number">0</span>;
	zend_string *result;

	result = zend_string_alloc(length, <span class="number">0</span>);

	<span class="comment">/* run through the whole string, converting as we go */</span>
	<span class="keyword">while</span> (length-- &gt; <span class="number">0</span>) &#123;
		ch = *current++;
		<span class="keyword">if</span> (ch == base64_pad) &#123;
			padding++;
			<span class="keyword">continue</span>;
		&#125;

		ch = base64_reverse_table[ch];
		<span class="keyword">if</span> (!strict) &#123;
			<span class="comment">/* skip unknown characters and whitespace */</span>
			<span class="keyword">if</span> (ch &lt; <span class="number">0</span>) &#123;
				<span class="keyword">continue</span>;
			&#125;
		&#125; <span class="keyword">else</span> &#123;
			<span class="comment">/* skip whitespace */</span>
			<span class="keyword">if</span> (ch == <span class="number">-1</span>) &#123;
				<span class="keyword">continue</span>;
			&#125;
			<span class="comment">/* fail on bad characters or if any data follows padding */</span>
			<span class="keyword">if</span> (ch == <span class="number">-2</span> || padding) &#123;
				<span class="keyword">goto</span> fail;
			&#125;
		&#125;

		<span class="keyword">switch</span>(i % <span class="number">4</span>) &#123;
		<span class="keyword">case</span> <span class="number">0</span>:
			ZSTR_VAL(result)[j] = ch &lt;&lt; <span class="number">2</span>;
			<span class="keyword">break</span>;
		<span class="keyword">case</span> <span class="number">1</span>:
			ZSTR_VAL(result)[j++] |= ch &gt;&gt; <span class="number">4</span>;
			ZSTR_VAL(result)[j] = (ch &amp; <span class="number">0x0f</span>) &lt;&lt; <span class="number">4</span>;
			<span class="keyword">break</span>;
		<span class="keyword">case</span> <span class="number">2</span>:
			ZSTR_VAL(result)[j++] |= ch &gt;&gt;<span class="number">2</span>;
			ZSTR_VAL(result)[j] = (ch &amp; <span class="number">0x03</span>) &lt;&lt; <span class="number">6</span>;
			<span class="keyword">break</span>;
		<span class="keyword">case</span> <span class="number">3</span>:
			ZSTR_VAL(result)[j++] |= ch;
			<span class="keyword">break</span>;
		&#125;
		i++;
	&#125;
	<span class="comment">/* fail if the input is truncated (only one char in last group) */</span>
	<span class="keyword">if</span> (strict &amp;&amp; i % <span class="number">4</span> == <span class="number">1</span>) &#123;
		<span class="keyword">goto</span> fail;
	&#125;
	<span class="comment">/* fail if the padding length is wrong (not VV==, VVV=), but accept zero padding</span>
<span class="comment">	 * RFC 4648: &quot;In some circumstances, the use of padding [--] is not required&quot; */</span>
	<span class="keyword">if</span> (strict &amp;&amp; padding &amp;&amp; (padding &gt; <span class="number">2</span> || (i + padding) % <span class="number">4</span> != <span class="number">0</span>)) &#123;
		<span class="keyword">goto</span> fail;
	&#125;

	ZSTR_LEN(result) = j;
	ZSTR_VAL(result)[ZSTR_LEN(result)] = <span class="string">&#x27;\0&#x27;</span>;

	<span class="keyword">return</span> result;

fail:
	zend_string_free(result);
	<span class="keyword">return</span> <span class="literal">NULL</span>;
&#125;</code></pre>
<h3 id="73~84"><a class="markdownIt-Anchor" href="#73~84"></a> 7.3~8.4</h3>
<pre><code class="highlight c"><span class="type">static</span> zend_always_inline <span class="type">int</span> <span class="title function_">php_base64_decode_impl</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *in, <span class="type">size_t</span> inl, <span class="type">unsigned</span> <span class="type">char</span> *out, <span class="type">size_t</span> *outl, <span class="type">bool</span> strict)</span> <span class="comment">/* &#123;&#123;&#123; */</span>
&#123;
	<span class="type">int</span> ch;
	<span class="type">size_t</span> i = <span class="number">0</span>, padding = <span class="number">0</span>, j = *outl;
<span class="comment">//下面这段在7.3没有</span>
<span class="meta">#<span class="keyword">if</span> defined(__aarch64__) || defined(_M_ARM64)</span>
	<span class="keyword">if</span> (inl &gt;= <span class="number">16</span> * <span class="number">4</span>) &#123;
		<span class="type">size_t</span> left = <span class="number">0</span>;
		j += neon_base64_decode(in, inl, out, &amp;left);
		i = inl - left;
		in += i;
		inl = left;
	&#125;
<span class="meta">#<span class="keyword">endif</span></span>
<span class="comment">//</span>
    
	<span class="comment">/* run through the whole string, converting as we go */</span>
	<span class="keyword">while</span> (inl-- &gt; <span class="number">0</span>) &#123;
		ch = *in++;
		<span class="keyword">if</span> (ch == base64_pad) &#123;
			padding++;
			<span class="keyword">continue</span>;
		&#125;

		ch = base64_reverse_table[ch];
		<span class="keyword">if</span> (!strict) &#123;
			<span class="comment">/* skip unknown characters and whitespace */</span>
			<span class="keyword">if</span> (ch &lt; <span class="number">0</span>) &#123;
				<span class="keyword">continue</span>;
			&#125;
		&#125; <span class="keyword">else</span> &#123;
			<span class="comment">/* skip whitespace */</span>
			<span class="keyword">if</span> (ch == <span class="number">-1</span>) &#123;
				<span class="keyword">continue</span>;
			&#125;
			<span class="comment">/* fail on bad characters or if any data follows padding */</span>
			<span class="keyword">if</span> (ch == <span class="number">-2</span> || padding) &#123;
				<span class="keyword">goto</span> fail;
			&#125;
		&#125;

		<span class="keyword">switch</span> (i % <span class="number">4</span>) &#123;
			<span class="keyword">case</span> <span class="number">0</span>:
				out[j] = ch &lt;&lt; <span class="number">2</span>;
				<span class="keyword">break</span>;
			<span class="keyword">case</span> <span class="number">1</span>:
				out[j++] |= ch &gt;&gt; <span class="number">4</span>;
				out[j] = (ch &amp; <span class="number">0x0f</span>) &lt;&lt; <span class="number">4</span>;
				<span class="keyword">break</span>;
			<span class="keyword">case</span> <span class="number">2</span>:
				out[j++] |= ch &gt;&gt;<span class="number">2</span>;
				out[j] = (ch &amp; <span class="number">0x03</span>) &lt;&lt; <span class="number">6</span>;
				<span class="keyword">break</span>;
			<span class="keyword">case</span> <span class="number">3</span>:
				out[j++] |= ch;
				<span class="keyword">break</span>;
		&#125;
		i++;
	&#125;

	<span class="comment">/* fail if the input is truncated (only one char in last group) */</span>
	<span class="keyword">if</span> (strict &amp;&amp; i % <span class="number">4</span> == <span class="number">1</span>) &#123;
		<span class="keyword">goto</span> fail;
	&#125;

	<span class="comment">/* fail if the padding length is wrong (not VV==, VVV=), but accept zero padding</span>
<span class="comment">	 * RFC 4648: &quot;In some circumstances, the use of padding [--] is not required&quot; */</span>
	<span class="keyword">if</span> (strict &amp;&amp; padding &amp;&amp; (padding &gt; <span class="number">2</span> || (i + padding) % <span class="number">4</span> != <span class="number">0</span>)) &#123;
		<span class="keyword">goto</span> fail;
	&#125;

	*outl = j;
	out[j] = <span class="string">&#x27;\0&#x27;</span>;

	<span class="keyword">return</span> <span class="number">1</span>;

fail:
	<span class="keyword">return</span> <span class="number">0</span>;
&#125;
<span class="comment">/* &#125;&#125;&#125; */</span></code></pre>
<p>感觉PHP的逻辑写的比Python的简单的很多</p>
<p>亿眼看下来感觉没有什么大问题，主要的点就是php在非严格模式下<code>=</code>实际就是一个爱加不加的状态。</p>
<p>加不加，加在哪里都不会影响解码，如果是特殊字符就会被直接跳过(因为板子是写好的所以其实就算是其他字符也不能被触发)</p>
<h2 id="golang"><a class="markdownIt-Anchor" href="#golang"></a> Golang</h2>
<p>很长的调用链。。<s>好麻烦</s></p>
<pre><code class="highlight go"><span class="comment">// Copyright 2009 The Go Authors. All rights reserved.</span>
<span class="comment">// Use of this source code is governed by a BSD-style</span>
<span class="comment">// license that can be found in the LICENSE file.</span>

<span class="comment">// Package base64 implements base64 encoding as specified by RFC 4648.</span>
<span class="keyword">package</span> base64

<span class="keyword">import</span> (
	<span class="string">&quot;encoding/binary&quot;</span>
	<span class="string">&quot;io&quot;</span>
	<span class="string">&quot;slices&quot;</span>
	<span class="string">&quot;strconv&quot;</span>
)

<span class="comment">/*</span>
<span class="comment"> * Encodings</span>
<span class="comment"> */</span>

<span class="comment">// An Encoding is a radix 64 encoding/decoding scheme, defined by a</span>
<span class="comment">// 64-character alphabet. The most common encoding is the &quot;base64&quot;</span>
<span class="comment">// encoding defined in RFC 4648 and used in MIME (RFC 2045) and PEM</span>
<span class="comment">// (RFC 1421).  RFC 4648 also defines an alternate encoding, which is</span>
<span class="comment">// the standard encoding with - and _ substituted for + and /.</span>
<span class="keyword">type</span> Encoding <span class="keyword">struct</span> &#123;
	encode    [<span class="number">64</span>]<span class="type">byte</span>   <span class="comment">// mapping of symbol index to symbol byte value</span>
	decodeMap [<span class="number">256</span>]<span class="type">uint8</span> <span class="comment">// mapping of symbol byte value to symbol index</span>
	padChar   <span class="type">rune</span>
	strict    <span class="type">bool</span>
&#125;

<span class="keyword">const</span> (
	StdPadding <span class="type">rune</span> = <span class="string">&#x27;=&#x27;</span> <span class="comment">// Standard padding character</span>
	NoPadding  <span class="type">rune</span> = <span class="number">-1</span>  <span class="comment">// No padding</span>
)

<span class="keyword">const</span> (
	decodeMapInitialize = <span class="string">&quot;&quot;</span> +
		<span class="string">&quot;\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff&quot;</span> +
		<span class="string">&quot;\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff&quot;</span> +
		<span class="string">&quot;\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff&quot;</span> +
		<span class="string">&quot;\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff&quot;</span> +
		<span class="string">&quot;\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff&quot;</span> +
		<span class="string">&quot;\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff&quot;</span> +
		<span class="string">&quot;\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff&quot;</span> +
		<span class="string">&quot;\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff&quot;</span> +
		<span class="string">&quot;\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff&quot;</span> +
		<span class="string">&quot;\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff&quot;</span> +
		<span class="string">&quot;\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff&quot;</span> +
		<span class="string">&quot;\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff&quot;</span> +
		<span class="string">&quot;\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff&quot;</span> +
		<span class="string">&quot;\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff&quot;</span> +
		<span class="string">&quot;\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff&quot;</span> +
		<span class="string">&quot;\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff&quot;</span>
	invalidIndex = <span class="string">&#x27;\xff&#x27;</span>
)

<span class="comment">// NewEncoding returns a new padded Encoding defined by the given alphabet,</span>
<span class="comment">// which must be a 64-byte string that contains unique byte values and</span>
<span class="comment">// does not contain the padding character or CR / LF (&#x27;\r&#x27;, &#x27;\n&#x27;).</span>
<span class="comment">// The alphabet is treated as a sequence of byte values</span>
<span class="comment">// without any special treatment for multi-byte UTF-8.</span>
<span class="comment">// The resulting Encoding uses the default padding character (&#x27;=&#x27;),</span>
<span class="comment">// which may be changed or disabled via [Encoding.WithPadding].</span>
<span class="function"><span class="keyword">func</span> <span class="title">NewEncoding</span><span class="params">(encoder <span class="type">string</span>)</span></span> *Encoding &#123;
	<span class="keyword">if</span> <span class="built_in">len</span>(encoder) != <span class="number">64</span> &#123;
		<span class="built_in">panic</span>(<span class="string">&quot;encoding alphabet is not 64-bytes long&quot;</span>)
	&#125;

	e := <span class="built_in">new</span>(Encoding)
	e.padChar = StdPadding
	<span class="built_in">copy</span>(e.encode[:], encoder)
	<span class="built_in">copy</span>(e.decodeMap[:], decodeMapInitialize)

	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(encoder); i++ &#123;
		<span class="comment">// Note: While we document that the alphabet cannot contain</span>
		<span class="comment">// the padding character, we do not enforce it since we do not know</span>
		<span class="comment">// if the caller intends to switch the padding from StdPadding later.</span>
		<span class="keyword">switch</span> &#123;
		<span class="keyword">case</span> encoder[i] == <span class="string">&#x27;\n&#x27;</span> || encoder[i] == <span class="string">&#x27;\r&#x27;</span>:
			<span class="built_in">panic</span>(<span class="string">&quot;encoding alphabet contains newline character&quot;</span>)
		<span class="keyword">case</span> e.decodeMap[encoder[i]] != invalidIndex:
			<span class="built_in">panic</span>(<span class="string">&quot;encoding alphabet includes duplicate symbols&quot;</span>)
		&#125;
		e.decodeMap[encoder[i]] = <span class="type">uint8</span>(i)
	&#125;
	<span class="keyword">return</span> e
&#125;

<span class="comment">// WithPadding creates a new encoding identical to enc except</span>
<span class="comment">// with a specified padding character, or [NoPadding] to disable padding.</span>
<span class="comment">// The padding character must not be &#x27;\r&#x27; or &#x27;\n&#x27;,</span>
<span class="comment">// must not be contained in the encoding&#x27;s alphabet,</span>
<span class="comment">// must not be negative, and must be a rune equal or below &#x27;\xff&#x27;.</span>
<span class="comment">// Padding characters above &#x27;\x7f&#x27; are encoded as their exact byte value</span>
<span class="comment">// rather than using the UTF-8 representation of the codepoint.</span>
<span class="function"><span class="keyword">func</span> <span class="params">(enc Encoding)</span></span> WithPadding(padding <span class="type">rune</span>) *Encoding &#123;
	<span class="keyword">switch</span> &#123;
	<span class="keyword">case</span> padding &lt; NoPadding || padding == <span class="string">&#x27;\r&#x27;</span> || padding == <span class="string">&#x27;\n&#x27;</span> || padding &gt; <span class="number">0xff</span>:
		<span class="built_in">panic</span>(<span class="string">&quot;invalid padding&quot;</span>)
	<span class="keyword">case</span> padding != NoPadding &amp;&amp; enc.decodeMap[<span class="type">byte</span>(padding)] != invalidIndex:
		<span class="built_in">panic</span>(<span class="string">&quot;padding contained in alphabet&quot;</span>)
	&#125;
	enc.padChar = padding
	<span class="keyword">return</span> &amp;enc
&#125;

<span class="comment">// Strict creates a new encoding identical to enc except with</span>
<span class="comment">// strict decoding enabled. In this mode, the decoder requires that</span>
<span class="comment">// trailing padding bits are zero, as described in RFC 4648 section 3.5.</span>
<span class="comment">//</span>
<span class="comment">// Note that the input is still malleable, as new line characters</span>
<span class="comment">// (CR and LF) are still ignored.</span>
<span class="function"><span class="keyword">func</span> <span class="params">(enc Encoding)</span></span> Strict() *Encoding &#123;
	enc.strict = <span class="literal">true</span>
	<span class="keyword">return</span> &amp;enc
&#125;

<span class="comment">// StdEncoding is the standard base64 encoding, as defined in RFC 4648.</span>
<span class="keyword">var</span> StdEncoding = NewEncoding(<span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span>)

<span class="comment">// URLEncoding is the alternate base64 encoding defined in RFC 4648.</span>
<span class="comment">// It is typically used in URLs and file names.</span>
<span class="keyword">var</span> URLEncoding = NewEncoding(<span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_&quot;</span>)

<span class="comment">// RawStdEncoding is the standard raw, unpadded base64 encoding,</span>
<span class="comment">// as defined in RFC 4648 section 3.2.</span>
<span class="comment">// This is the same as [StdEncoding] but omits padding characters.</span>
<span class="keyword">var</span> RawStdEncoding = StdEncoding.WithPadding(NoPadding)

<span class="comment">// RawURLEncoding is the unpadded alternate base64 encoding defined in RFC 4648.</span>
<span class="comment">// It is typically used in URLs and file names.</span>
<span class="comment">// This is the same as [URLEncoding] but omits padding characters.</span>
<span class="keyword">var</span> RawURLEncoding = URLEncoding.WithPadding(NoPadding)

<span class="comment">/*</span>
<span class="comment"> * Encoder</span>
<span class="comment"> */</span>

<span class="comment">// Encode encodes src using the encoding enc,</span>
<span class="comment">// writing [Encoding.EncodedLen](len(src)) bytes to dst.</span>
<span class="comment">//</span>
<span class="comment">// The encoding pads the output to a multiple of 4 bytes,</span>
<span class="comment">// so Encode is not appropriate for use on individual blocks</span>
<span class="comment">// of a large data stream. Use [NewEncoder] instead.</span>
<span class="function"><span class="keyword">func</span> <span class="params">(enc *Encoding)</span></span> Encode(dst, src []<span class="type">byte</span>) &#123;
	<span class="keyword">if</span> <span class="built_in">len</span>(src) == <span class="number">0</span> &#123;
		<span class="keyword">return</span>
	&#125;
	<span class="comment">// enc is a pointer receiver, so the use of enc.encode within the hot</span>
	<span class="comment">// loop below means a nil check at every operation. Lift that nil check</span>
	<span class="comment">// outside of the loop to speed up the encoder.</span>
	_ = enc.encode

	di, si := <span class="number">0</span>, <span class="number">0</span>
	n := (<span class="built_in">len</span>(src) / <span class="number">3</span>) * <span class="number">3</span>
	<span class="keyword">for</span> si &lt; n &#123;
		<span class="comment">// Convert 3x 8bit source bytes into 4 bytes</span>
		val := <span class="type">uint</span>(src[si+<span class="number">0</span>])&lt;&lt;<span class="number">16</span> | <span class="type">uint</span>(src[si+<span class="number">1</span>])&lt;&lt;<span class="number">8</span> | <span class="type">uint</span>(src[si+<span class="number">2</span>])

		dst[di+<span class="number">0</span>] = enc.encode[val&gt;&gt;<span class="number">18</span>&amp;<span class="number">0x3F</span>]
		dst[di+<span class="number">1</span>] = enc.encode[val&gt;&gt;<span class="number">12</span>&amp;<span class="number">0x3F</span>]
		dst[di+<span class="number">2</span>] = enc.encode[val&gt;&gt;<span class="number">6</span>&amp;<span class="number">0x3F</span>]
		dst[di+<span class="number">3</span>] = enc.encode[val&amp;<span class="number">0x3F</span>]

		si += <span class="number">3</span>
		di += <span class="number">4</span>
	&#125;

	remain := <span class="built_in">len</span>(src) - si
	<span class="keyword">if</span> remain == <span class="number">0</span> &#123;
		<span class="keyword">return</span>
	&#125;
	<span class="comment">// Add the remaining small block</span>
	val := <span class="type">uint</span>(src[si+<span class="number">0</span>]) &lt;&lt; <span class="number">16</span>
	<span class="keyword">if</span> remain == <span class="number">2</span> &#123;
		val |= <span class="type">uint</span>(src[si+<span class="number">1</span>]) &lt;&lt; <span class="number">8</span>
	&#125;

	dst[di+<span class="number">0</span>] = enc.encode[val&gt;&gt;<span class="number">18</span>&amp;<span class="number">0x3F</span>]
	dst[di+<span class="number">1</span>] = enc.encode[val&gt;&gt;<span class="number">12</span>&amp;<span class="number">0x3F</span>]

	<span class="keyword">switch</span> remain &#123;
	<span class="keyword">case</span> <span class="number">2</span>:
		dst[di+<span class="number">2</span>] = enc.encode[val&gt;&gt;<span class="number">6</span>&amp;<span class="number">0x3F</span>]
		<span class="keyword">if</span> enc.padChar != NoPadding &#123;
			dst[di+<span class="number">3</span>] = <span class="type">byte</span>(enc.padChar)
		&#125;
	<span class="keyword">case</span> <span class="number">1</span>:
		<span class="keyword">if</span> enc.padChar != NoPadding &#123;
			dst[di+<span class="number">2</span>] = <span class="type">byte</span>(enc.padChar)
			dst[di+<span class="number">3</span>] = <span class="type">byte</span>(enc.padChar)
		&#125;
	&#125;
&#125;

<span class="comment">// AppendEncode appends the base64 encoded src to dst</span>
<span class="comment">// and returns the extended buffer.</span>
<span class="function"><span class="keyword">func</span> <span class="params">(enc *Encoding)</span></span> AppendEncode(dst, src []<span class="type">byte</span>) []<span class="type">byte</span> &#123;
	n := enc.EncodedLen(<span class="built_in">len</span>(src))
	dst = slices.Grow(dst, n)
	enc.Encode(dst[<span class="built_in">len</span>(dst):][:n], src)
	<span class="keyword">return</span> dst[:<span class="built_in">len</span>(dst)+n]
&#125;

<span class="comment">// EncodeToString returns the base64 encoding of src.</span>
<span class="function"><span class="keyword">func</span> <span class="params">(enc *Encoding)</span></span> EncodeToString(src []<span class="type">byte</span>) <span class="type">string</span> &#123;
	buf := <span class="built_in">make</span>([]<span class="type">byte</span>, enc.EncodedLen(<span class="built_in">len</span>(src)))
	enc.Encode(buf, src)
	<span class="keyword">return</span> <span class="type">string</span>(buf)
&#125;

<span class="keyword">type</span> encoder <span class="keyword">struct</span> &#123;
	err  <span class="type">error</span>
	enc  *Encoding
	w    io.Writer
	buf  [<span class="number">3</span>]<span class="type">byte</span>    <span class="comment">// buffered data waiting to be encoded</span>
	nbuf <span class="type">int</span>        <span class="comment">// number of bytes in buf</span>
	out  [<span class="number">1024</span>]<span class="type">byte</span> <span class="comment">// output buffer</span>
&#125;

<span class="function"><span class="keyword">func</span> <span class="params">(e *encoder)</span></span> Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>) &#123;
	<span class="keyword">if</span> e.err != <span class="literal">nil</span> &#123;
		<span class="keyword">return</span> <span class="number">0</span>, e.err
	&#125;

	<span class="comment">// Leading fringe.</span>
	<span class="keyword">if</span> e.nbuf &gt; <span class="number">0</span> &#123;
		<span class="keyword">var</span> i <span class="type">int</span>
		<span class="keyword">for</span> i = <span class="number">0</span>; i &lt; <span class="built_in">len</span>(p) &amp;&amp; e.nbuf &lt; <span class="number">3</span>; i++ &#123;
			e.buf[e.nbuf] = p[i]
			e.nbuf++
		&#125;
		n += i
		p = p[i:]
		<span class="keyword">if</span> e.nbuf &lt; <span class="number">3</span> &#123;
			<span class="keyword">return</span>
		&#125;
		e.enc.Encode(e.out[:], e.buf[:])
		<span class="keyword">if</span> _, e.err = e.w.Write(e.out[:<span class="number">4</span>]); e.err != <span class="literal">nil</span> &#123;
			<span class="keyword">return</span> n, e.err
		&#125;
		e.nbuf = <span class="number">0</span>
	&#125;

	<span class="comment">// Large interior chunks.</span>
	<span class="keyword">for</span> <span class="built_in">len</span>(p) &gt;= <span class="number">3</span> &#123;
		nn := <span class="built_in">len</span>(e.out) / <span class="number">4</span> * <span class="number">3</span>
		<span class="keyword">if</span> nn &gt; <span class="built_in">len</span>(p) &#123;
			nn = <span class="built_in">len</span>(p)
			nn -= nn % <span class="number">3</span>
		&#125;
		e.enc.Encode(e.out[:], p[:nn])
		<span class="keyword">if</span> _, e.err = e.w.Write(e.out[<span class="number">0</span> : nn/<span class="number">3</span>*<span class="number">4</span>]); e.err != <span class="literal">nil</span> &#123;
			<span class="keyword">return</span> n, e.err
		&#125;
		n += nn
		p = p[nn:]
	&#125;

	<span class="comment">// Trailing fringe.</span>
	<span class="built_in">copy</span>(e.buf[:], p)
	e.nbuf = <span class="built_in">len</span>(p)
	n += <span class="built_in">len</span>(p)
	<span class="keyword">return</span>
&#125;

<span class="comment">// Close flushes any pending output from the encoder.</span>
<span class="comment">// It is an error to call Write after calling Close.</span>
<span class="function"><span class="keyword">func</span> <span class="params">(e *encoder)</span></span> Close() <span class="type">error</span> &#123;
	<span class="comment">// If there&#x27;s anything left in the buffer, flush it out</span>
	<span class="keyword">if</span> e.err == <span class="literal">nil</span> &amp;&amp; e.nbuf &gt; <span class="number">0</span> &#123;
		e.enc.Encode(e.out[:], e.buf[:e.nbuf])
		_, e.err = e.w.Write(e.out[:e.enc.EncodedLen(e.nbuf)])
		e.nbuf = <span class="number">0</span>
	&#125;
	<span class="keyword">return</span> e.err
&#125;

<span class="comment">// NewEncoder returns a new base64 stream encoder. Data written to</span>
<span class="comment">// the returned writer will be encoded using enc and then written to w.</span>
<span class="comment">// Base64 encodings operate in 4-byte blocks; when finished</span>
<span class="comment">// writing, the caller must Close the returned encoder to flush any</span>
<span class="comment">// partially written blocks.</span>
<span class="function"><span class="keyword">func</span> <span class="title">NewEncoder</span><span class="params">(enc *Encoding, w io.Writer)</span></span> io.WriteCloser &#123;
	<span class="keyword">return</span> &amp;encoder&#123;enc: enc, w: w&#125;
&#125;

<span class="comment">// EncodedLen returns the length in bytes of the base64 encoding</span>
<span class="comment">// of an input buffer of length n.</span>
<span class="function"><span class="keyword">func</span> <span class="params">(enc *Encoding)</span></span> EncodedLen(n <span class="type">int</span>) <span class="type">int</span> &#123;
	<span class="keyword">if</span> enc.padChar == NoPadding &#123;
		<span class="keyword">return</span> n/<span class="number">3</span>*<span class="number">4</span> + (n%<span class="number">3</span>*<span class="number">8</span>+<span class="number">5</span>)/<span class="number">6</span> <span class="comment">// minimum # chars at 6 bits per char</span>
	&#125;
	<span class="keyword">return</span> (n + <span class="number">2</span>) / <span class="number">3</span> * <span class="number">4</span> <span class="comment">// minimum # 4-char quanta, 3 bytes each</span>
&#125;

<span class="comment">/*</span>
<span class="comment"> * Decoder</span>
<span class="comment"> */</span>

<span class="keyword">type</span> CorruptInputError <span class="type">int64</span>

<span class="function"><span class="keyword">func</span> <span class="params">(e CorruptInputError)</span></span> Error() <span class="type">string</span> &#123;
	<span class="keyword">return</span> <span class="string">&quot;illegal base64 data at input byte &quot;</span> + strconv.FormatInt(<span class="type">int64</span>(e), <span class="number">10</span>)
&#125;

<span class="comment">// decodeQuantum decodes up to 4 base64 bytes. The received parameters are</span>
<span class="comment">// the destination buffer dst, the source buffer src and an index in the</span>
<span class="comment">// source buffer si.</span>
<span class="comment">// It returns the number of bytes read from src, the number of bytes written</span>
<span class="comment">// to dst, and an error, if any.</span>
<span class="function"><span class="keyword">func</span> <span class="params">(enc *Encoding)</span></span> decodeQuantum(dst, src []<span class="type">byte</span>, si <span class="type">int</span>) (nsi, n <span class="type">int</span>, err <span class="type">error</span>) &#123;
	<span class="comment">// Decode quantum using the base64 alphabet</span>
	<span class="keyword">var</span> dbuf [<span class="number">4</span>]<span class="type">byte</span>
	dlen := <span class="number">4</span>

	<span class="comment">// Lift the nil check outside of the loop.</span>
	_ = enc.decodeMap

	<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(dbuf); j++ &#123;
		<span class="keyword">if</span> <span class="built_in">len</span>(src) == si &#123;
			<span class="keyword">switch</span> &#123;
			<span class="keyword">case</span> j == <span class="number">0</span>:
				<span class="keyword">return</span> si, <span class="number">0</span>, <span class="literal">nil</span>
			<span class="keyword">case</span> j == <span class="number">1</span>, enc.padChar != NoPadding:
				<span class="keyword">return</span> si, <span class="number">0</span>, CorruptInputError(si - j)
			&#125;
			dlen = j
			<span class="keyword">break</span>
		&#125;
		in := src[si]
		si++

		out := enc.decodeMap[in]
		<span class="keyword">if</span> out != <span class="number">0xff</span> &#123;
			dbuf[j] = out
			<span class="keyword">continue</span>
		&#125;

		<span class="keyword">if</span> in == <span class="string">&#x27;\n&#x27;</span> || in == <span class="string">&#x27;\r&#x27;</span> &#123;
			j--
			<span class="keyword">continue</span>
		&#125;

		<span class="keyword">if</span> <span class="type">rune</span>(in) != enc.padChar &#123;
			<span class="keyword">return</span> si, <span class="number">0</span>, CorruptInputError(si - <span class="number">1</span>)
		&#125;

		<span class="comment">// We&#x27;ve reached the end and there&#x27;s padding</span>
		<span class="keyword">switch</span> j &#123;
		<span class="keyword">case</span> <span class="number">0</span>, <span class="number">1</span>:
			<span class="comment">// incorrect padding</span>
			<span class="keyword">return</span> si, <span class="number">0</span>, CorruptInputError(si - <span class="number">1</span>)
		<span class="keyword">case</span> <span class="number">2</span>:
			<span class="comment">// &quot;==&quot; is expected, the first &quot;=&quot; is already consumed.</span>
			<span class="comment">// skip over newlines</span>
			<span class="keyword">for</span> si &lt; <span class="built_in">len</span>(src) &amp;&amp; (src[si] == <span class="string">&#x27;\n&#x27;</span> || src[si] == <span class="string">&#x27;\r&#x27;</span>) &#123;
				si++
			&#125;
			<span class="keyword">if</span> si == <span class="built_in">len</span>(src) &#123;
				<span class="comment">// not enough padding</span>
				<span class="keyword">return</span> si, <span class="number">0</span>, CorruptInputError(<span class="built_in">len</span>(src))
			&#125;
			<span class="keyword">if</span> <span class="type">rune</span>(src[si]) != enc.padChar &#123;
				<span class="comment">// incorrect padding</span>
				<span class="keyword">return</span> si, <span class="number">0</span>, CorruptInputError(si - <span class="number">1</span>)
			&#125;

			si++
		&#125;

		<span class="comment">// skip over newlines</span>
		<span class="keyword">for</span> si &lt; <span class="built_in">len</span>(src) &amp;&amp; (src[si] == <span class="string">&#x27;\n&#x27;</span> || src[si] == <span class="string">&#x27;\r&#x27;</span>) &#123;
			si++
		&#125;
		<span class="keyword">if</span> si &lt; <span class="built_in">len</span>(src) &#123;
			<span class="comment">// trailing garbage</span>
			err = CorruptInputError(si)
		&#125;
		dlen = j
		<span class="keyword">break</span>
	&#125;

	<span class="comment">// Convert 4x 6bit source bytes into 3 bytes</span>
	val := <span class="type">uint</span>(dbuf[<span class="number">0</span>])&lt;&lt;<span class="number">18</span> | <span class="type">uint</span>(dbuf[<span class="number">1</span>])&lt;&lt;<span class="number">12</span> | <span class="type">uint</span>(dbuf[<span class="number">2</span>])&lt;&lt;<span class="number">6</span> | <span class="type">uint</span>(dbuf[<span class="number">3</span>])
	dbuf[<span class="number">2</span>], dbuf[<span class="number">1</span>], dbuf[<span class="number">0</span>] = <span class="type">byte</span>(val&gt;&gt;<span class="number">0</span>), <span class="type">byte</span>(val&gt;&gt;<span class="number">8</span>), <span class="type">byte</span>(val&gt;&gt;<span class="number">16</span>)
	<span class="keyword">switch</span> dlen &#123;
	<span class="keyword">case</span> <span class="number">4</span>:
		dst[<span class="number">2</span>] = dbuf[<span class="number">2</span>]
		dbuf[<span class="number">2</span>] = <span class="number">0</span>
		<span class="keyword">fallthrough</span>
	<span class="keyword">case</span> <span class="number">3</span>:
		dst[<span class="number">1</span>] = dbuf[<span class="number">1</span>]
		<span class="keyword">if</span> enc.strict &amp;&amp; dbuf[<span class="number">2</span>] != <span class="number">0</span> &#123;
			<span class="keyword">return</span> si, <span class="number">0</span>, CorruptInputError(si - <span class="number">1</span>)
		&#125;
		dbuf[<span class="number">1</span>] = <span class="number">0</span>
		<span class="keyword">fallthrough</span>
	<span class="keyword">case</span> <span class="number">2</span>:
		dst[<span class="number">0</span>] = dbuf[<span class="number">0</span>]
		<span class="keyword">if</span> enc.strict &amp;&amp; (dbuf[<span class="number">1</span>] != <span class="number">0</span> || dbuf[<span class="number">2</span>] != <span class="number">0</span>) &#123;
			<span class="keyword">return</span> si, <span class="number">0</span>, CorruptInputError(si - <span class="number">2</span>)
		&#125;
	&#125;

	<span class="keyword">return</span> si, dlen - <span class="number">1</span>, err
&#125;

<span class="comment">// AppendDecode appends the base64 decoded src to dst</span>
<span class="comment">// and returns the extended buffer.</span>
<span class="comment">// If the input is malformed, it returns the partially decoded src and an error.</span>
<span class="comment">// New line characters (\r and \n) are ignored.</span>
<span class="function"><span class="keyword">func</span> <span class="params">(enc *Encoding)</span></span> AppendDecode(dst, src []<span class="type">byte</span>) ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;
	<span class="comment">// Compute the output size without padding to avoid over allocating.</span>
	n := <span class="built_in">len</span>(src)
	<span class="keyword">for</span> n &gt; <span class="number">0</span> &amp;&amp; <span class="type">rune</span>(src[n<span class="number">-1</span>]) == enc.padChar &#123;
		n--
	&#125;
	n = decodedLen(n, NoPadding)

	dst = slices.Grow(dst, n)
	n, err := enc.Decode(dst[<span class="built_in">len</span>(dst):][:n], src)
	<span class="keyword">return</span> dst[:<span class="built_in">len</span>(dst)+n], err
&#125;

<span class="comment">// DecodeString returns the bytes represented by the base64 string s.</span>
<span class="comment">// If the input is malformed, it returns the partially decoded data and</span>
<span class="comment">// [CorruptInputError]. New line characters (\r and \n) are ignored.</span>
<span class="function"><span class="keyword">func</span> <span class="params">(enc *Encoding)</span></span> DecodeString(s <span class="type">string</span>) ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;
	dbuf := <span class="built_in">make</span>([]<span class="type">byte</span>, enc.DecodedLen(<span class="built_in">len</span>(s)))
	n, err := enc.Decode(dbuf, []<span class="type">byte</span>(s))
	<span class="keyword">return</span> dbuf[:n], err
&#125;

<span class="keyword">type</span> decoder <span class="keyword">struct</span> &#123;
	err     <span class="type">error</span>
	readErr <span class="type">error</span> <span class="comment">// error from r.Read</span>
	enc     *Encoding
	r       io.Reader
	buf     [<span class="number">1024</span>]<span class="type">byte</span> <span class="comment">// leftover input</span>
	nbuf    <span class="type">int</span>
	out     []<span class="type">byte</span> <span class="comment">// leftover decoded output</span>
	outbuf  [<span class="number">1024</span> / <span class="number">4</span> * <span class="number">3</span>]<span class="type">byte</span>
&#125;

<span class="function"><span class="keyword">func</span> <span class="params">(d *decoder)</span></span> Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>) &#123;
	<span class="comment">// Use leftover decoded output from last read.</span>
	<span class="keyword">if</span> <span class="built_in">len</span>(d.out) &gt; <span class="number">0</span> &#123;
		n = <span class="built_in">copy</span>(p, d.out)
		d.out = d.out[n:]
		<span class="keyword">return</span> n, <span class="literal">nil</span>
	&#125;

	<span class="keyword">if</span> d.err != <span class="literal">nil</span> &#123;
		<span class="keyword">return</span> <span class="number">0</span>, d.err
	&#125;

	<span class="comment">// This code assumes that d.r strips supported whitespace (&#x27;\r&#x27; and &#x27;\n&#x27;).</span>

	<span class="comment">// Refill buffer.</span>
	<span class="keyword">for</span> d.nbuf &lt; <span class="number">4</span> &amp;&amp; d.readErr == <span class="literal">nil</span> &#123;
		nn := <span class="built_in">len</span>(p) / <span class="number">3</span> * <span class="number">4</span>
		<span class="keyword">if</span> nn &lt; <span class="number">4</span> &#123;
			nn = <span class="number">4</span>
		&#125;
		<span class="keyword">if</span> nn &gt; <span class="built_in">len</span>(d.buf) &#123;
			nn = <span class="built_in">len</span>(d.buf)
		&#125;
		nn, d.readErr = d.r.Read(d.buf[d.nbuf:nn])
		d.nbuf += nn
	&#125;

	<span class="keyword">if</span> d.nbuf &lt; <span class="number">4</span> &#123;
		<span class="keyword">if</span> d.enc.padChar == NoPadding &amp;&amp; d.nbuf &gt; <span class="number">0</span> &#123;
			<span class="comment">// Decode final fragment, without padding.</span>
			<span class="keyword">var</span> nw <span class="type">int</span>
			nw, d.err = d.enc.Decode(d.outbuf[:], d.buf[:d.nbuf])
			d.nbuf = <span class="number">0</span>
			d.out = d.outbuf[:nw]
			n = <span class="built_in">copy</span>(p, d.out)
			d.out = d.out[n:]
			<span class="keyword">if</span> n &gt; <span class="number">0</span> || <span class="built_in">len</span>(p) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(d.out) &gt; <span class="number">0</span> &#123;
				<span class="keyword">return</span> n, <span class="literal">nil</span>
			&#125;
			<span class="keyword">if</span> d.err != <span class="literal">nil</span> &#123;
				<span class="keyword">return</span> <span class="number">0</span>, d.err
			&#125;
		&#125;
		d.err = d.readErr
		<span class="keyword">if</span> d.err == io.EOF &amp;&amp; d.nbuf &gt; <span class="number">0</span> &#123;
			d.err = io.ErrUnexpectedEOF
		&#125;
		<span class="keyword">return</span> <span class="number">0</span>, d.err
	&#125;

	<span class="comment">// Decode chunk into p, or d.out and then p if p is too small.</span>
	nr := d.nbuf / <span class="number">4</span> * <span class="number">4</span>
	nw := d.nbuf / <span class="number">4</span> * <span class="number">3</span>
	<span class="keyword">if</span> nw &gt; <span class="built_in">len</span>(p) &#123;
		nw, d.err = d.enc.Decode(d.outbuf[:], d.buf[:nr])
		d.out = d.outbuf[:nw]
		n = <span class="built_in">copy</span>(p, d.out)
		d.out = d.out[n:]
	&#125; <span class="keyword">else</span> &#123;
		n, d.err = d.enc.Decode(p, d.buf[:nr])
	&#125;
	d.nbuf -= nr
	<span class="built_in">copy</span>(d.buf[:d.nbuf], d.buf[nr:])
	<span class="keyword">return</span> n, d.err
&#125;

<span class="comment">// Decode decodes src using the encoding enc. It writes at most</span>
<span class="comment">// [Encoding.DecodedLen](len(src)) bytes to dst and returns the number of bytes</span>
<span class="comment">// written. The caller must ensure that dst is large enough to hold all</span>
<span class="comment">// the decoded data. If src contains invalid base64 data, it will return the</span>
<span class="comment">// number of bytes successfully written and [CorruptInputError].</span>
<span class="comment">// New line characters (\r and \n) are ignored.</span>
<span class="function"><span class="keyword">func</span> <span class="params">(enc *Encoding)</span></span> Decode(dst, src []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>) &#123;
	<span class="keyword">if</span> <span class="built_in">len</span>(src) == <span class="number">0</span> &#123;
		<span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span>
	&#125;

	<span class="comment">// Lift the nil check outside of the loop. enc.decodeMap is directly</span>
	<span class="comment">// used later in this function, to let the compiler know that the</span>
	<span class="comment">// receiver can&#x27;t be nil.</span>
	_ = enc.decodeMap

	si := <span class="number">0</span>
	<span class="keyword">for</span> strconv.IntSize &gt;= <span class="number">64</span> &amp;&amp; <span class="built_in">len</span>(src)-si &gt;= <span class="number">8</span> &amp;&amp; <span class="built_in">len</span>(dst)-n &gt;= <span class="number">8</span> &#123;
		src2 := src[si : si+<span class="number">8</span>]
		<span class="keyword">if</span> dn, ok := assemble64(
			enc.decodeMap[src2[<span class="number">0</span>]],
			enc.decodeMap[src2[<span class="number">1</span>]],
			enc.decodeMap[src2[<span class="number">2</span>]],
			enc.decodeMap[src2[<span class="number">3</span>]],
			enc.decodeMap[src2[<span class="number">4</span>]],
			enc.decodeMap[src2[<span class="number">5</span>]],
			enc.decodeMap[src2[<span class="number">6</span>]],
			enc.decodeMap[src2[<span class="number">7</span>]],
		); ok &#123;
			binary.BigEndian.PutUint64(dst[n:], dn)
			n += <span class="number">6</span>
			si += <span class="number">8</span>
		&#125; <span class="keyword">else</span> &#123;
			<span class="keyword">var</span> ninc <span class="type">int</span>
			si, ninc, err = enc.decodeQuantum(dst[n:], src, si)
			n += ninc
			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;
				<span class="keyword">return</span> n, err
			&#125;
		&#125;
	&#125;

	<span class="keyword">for</span> <span class="built_in">len</span>(src)-si &gt;= <span class="number">4</span> &amp;&amp; <span class="built_in">len</span>(dst)-n &gt;= <span class="number">4</span> &#123;
		src2 := src[si : si+<span class="number">4</span>]
		<span class="keyword">if</span> dn, ok := assemble32(
			enc.decodeMap[src2[<span class="number">0</span>]],
			enc.decodeMap[src2[<span class="number">1</span>]],
			enc.decodeMap[src2[<span class="number">2</span>]],
			enc.decodeMap[src2[<span class="number">3</span>]],
		); ok &#123;
			binary.BigEndian.PutUint32(dst[n:], dn)
			n += <span class="number">3</span>
			si += <span class="number">4</span>
		&#125; <span class="keyword">else</span> &#123;
			<span class="keyword">var</span> ninc <span class="type">int</span>
			si, ninc, err = enc.decodeQuantum(dst[n:], src, si)
			n += ninc
			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;
				<span class="keyword">return</span> n, err
			&#125;
		&#125;
	&#125;

	<span class="keyword">for</span> si &lt; <span class="built_in">len</span>(src) &#123;
		<span class="keyword">var</span> ninc <span class="type">int</span>
		si, ninc, err = enc.decodeQuantum(dst[n:], src, si)
		n += ninc
		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;
			<span class="keyword">return</span> n, err
		&#125;
	&#125;
	<span class="keyword">return</span> n, err
&#125;

<span class="comment">// assemble32 assembles 4 base64 digits into 3 bytes.</span>
<span class="comment">// Each digit comes from the decode map, and will be 0xff</span>
<span class="comment">// if it came from an invalid character.</span>
<span class="function"><span class="keyword">func</span> <span class="title">assemble32</span><span class="params">(n1, n2, n3, n4 <span class="type">byte</span>)</span></span> (dn <span class="type">uint32</span>, ok <span class="type">bool</span>) &#123;
	<span class="comment">// Check that all the digits are valid. If any of them was 0xff, their</span>
	<span class="comment">// bitwise OR will be 0xff.</span>
	<span class="keyword">if</span> n1|n2|n3|n4 == <span class="number">0xff</span> &#123;
		<span class="keyword">return</span> <span class="number">0</span>, <span class="literal">false</span>
	&#125;
	<span class="keyword">return</span> <span class="type">uint32</span>(n1)&lt;&lt;<span class="number">26</span> |
			<span class="type">uint32</span>(n2)&lt;&lt;<span class="number">20</span> |
			<span class="type">uint32</span>(n3)&lt;&lt;<span class="number">14</span> |
			<span class="type">uint32</span>(n4)&lt;&lt;<span class="number">8</span>,
		<span class="literal">true</span>
&#125;

<span class="comment">// assemble64 assembles 8 base64 digits into 6 bytes.</span>
<span class="comment">// Each digit comes from the decode map, and will be 0xff</span>
<span class="comment">// if it came from an invalid character.</span>
<span class="function"><span class="keyword">func</span> <span class="title">assemble64</span><span class="params">(n1, n2, n3, n4, n5, n6, n7, n8 <span class="type">byte</span>)</span></span> (dn <span class="type">uint64</span>, ok <span class="type">bool</span>) &#123;
	<span class="comment">// Check that all the digits are valid. If any of them was 0xff, their</span>
	<span class="comment">// bitwise OR will be 0xff.</span>
	<span class="keyword">if</span> n1|n2|n3|n4|n5|n6|n7|n8 == <span class="number">0xff</span> &#123;
		<span class="keyword">return</span> <span class="number">0</span>, <span class="literal">false</span>
	&#125;
	<span class="keyword">return</span> <span class="type">uint64</span>(n1)&lt;&lt;<span class="number">58</span> |
			<span class="type">uint64</span>(n2)&lt;&lt;<span class="number">52</span> |
			<span class="type">uint64</span>(n3)&lt;&lt;<span class="number">46</span> |
			<span class="type">uint64</span>(n4)&lt;&lt;<span class="number">40</span> |
			<span class="type">uint64</span>(n5)&lt;&lt;<span class="number">34</span> |
			<span class="type">uint64</span>(n6)&lt;&lt;<span class="number">28</span> |
			<span class="type">uint64</span>(n7)&lt;&lt;<span class="number">22</span> |
			<span class="type">uint64</span>(n8)&lt;&lt;<span class="number">16</span>,
		<span class="literal">true</span>
&#125;

<span class="keyword">type</span> newlineFilteringReader <span class="keyword">struct</span> &#123;
	wrapped io.Reader
&#125;

<span class="function"><span class="keyword">func</span> <span class="params">(r *newlineFilteringReader)</span></span> Read(p []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;
	n, err := r.wrapped.Read(p)
	<span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;
		offset := <span class="number">0</span>
		<span class="keyword">for</span> i, b := <span class="keyword">range</span> p[:n] &#123;
			<span class="keyword">if</span> b != <span class="string">&#x27;\r&#x27;</span> &amp;&amp; b != <span class="string">&#x27;\n&#x27;</span> &#123;
				<span class="keyword">if</span> i != offset &#123;
					p[offset] = b
				&#125;
				offset++
			&#125;
		&#125;
		<span class="keyword">if</span> offset &gt; <span class="number">0</span> &#123;
			<span class="keyword">return</span> offset, err
		&#125;
		<span class="comment">// Previous buffer entirely whitespace, read again</span>
		n, err = r.wrapped.Read(p)
	&#125;
	<span class="keyword">return</span> n, err
&#125;

<span class="comment">// NewDecoder constructs a new base64 stream decoder.</span>
<span class="function"><span class="keyword">func</span> <span class="title">NewDecoder</span><span class="params">(enc *Encoding, r io.Reader)</span></span> io.Reader &#123;
	<span class="keyword">return</span> &amp;decoder&#123;enc: enc, r: &amp;newlineFilteringReader&#123;r&#125;&#125;
&#125;

<span class="comment">// DecodedLen returns the maximum length in bytes of the decoded data</span>
<span class="comment">// corresponding to n bytes of base64-encoded data.</span>
<span class="function"><span class="keyword">func</span> <span class="params">(enc *Encoding)</span></span> DecodedLen(n <span class="type">int</span>) <span class="type">int</span> &#123;
	<span class="keyword">return</span> decodedLen(n, enc.padChar)
&#125;

<span class="function"><span class="keyword">func</span> <span class="title">decodedLen</span><span class="params">(n <span class="type">int</span>, padChar <span class="type">rune</span>)</span></span> <span class="type">int</span> &#123;
	<span class="keyword">if</span> padChar == NoPadding &#123;
		<span class="comment">// Unpadded data may end with partial block of 2-3 characters.</span>
		<span class="keyword">return</span> n/<span class="number">4</span>*<span class="number">3</span> + n%<span class="number">4</span>*<span class="number">6</span>/<span class="number">8</span>
	&#125;
	<span class="comment">// Padded base64 should always be a multiple of 4 characters in length.</span>
	<span class="keyword">return</span> n / <span class="number">4</span> * <span class="number">3</span>
&#125;
</code></pre>
<p>调试了一下给出调用链</p>
<pre><code class="highlight plaintext">DecodeString 
	DecodeLen
		decodedLen
	Decode(dst,src[] byte)
	 	assemble64
	 	assemble32
	 	decodeQuantum</code></pre>
<p>后面吃不明白了。go没怎么学过，有兴趣的师傅可以拿去瞅一眼。有可以trick的利用点欢迎跟我交流一下(</p>
<h2 id="java"><a class="markdownIt-Anchor" href="#java"></a> Java</h2>
<p>学了java再来审(</p>
<h2 id="ruby"><a class="markdownIt-Anchor" href="#ruby"></a> Ruby</h2>
<p>一整个项目看不了一一点</p>
<h2 id="linux"><a class="markdownIt-Anchor" href="#linux"></a> Linux</h2>
<pre><code class="highlight c"><span class="comment">// SPDX-License-Identifier: GPL-2.0</span>
<span class="comment">/*</span>
<span class="comment"> * base64.c - RFC4648-compliant base64 encoding</span>
<span class="comment"> *</span>
<span class="comment"> * Copyright (c) 2020 Hannes Reinecke, SUSE</span>
<span class="comment"> *</span>
<span class="comment"> * Based on the base64url routines from fs/crypto/fname.c</span>
<span class="comment"> * (which are using the URL-safe base64 encoding),</span>
<span class="comment"> * modified to use the standard coding table from RFC4648 section 4.</span>
<span class="comment"> */</span>

<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span>
<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span>
<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/export.h&gt;</span></span>
<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/string.h&gt;</span></span>
<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/base64.h&gt;</span></span>

<span class="type">static</span> <span class="type">const</span> <span class="type">char</span> base64_table[<span class="number">65</span>] =
	<span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span>;

<span class="comment">/**</span>
<span class="comment"> * base64_encode() - base64-encode some binary data</span>
<span class="comment"> * @src: the binary data to encode</span>
<span class="comment"> * @srclen: the length of @src in bytes</span>
<span class="comment"> * @dst: (output) the base64-encoded string.  Not NUL-terminated.</span>
<span class="comment"> *</span>
<span class="comment"> * Encodes data using base64 encoding, i.e. the &quot;Base 64 Encoding&quot; specified</span>
<span class="comment"> * by RFC 4648, including the  &#x27;=&#x27;-padding.</span>
<span class="comment"> *</span>
<span class="comment"> * Return: the length of the resulting base64-encoded string in bytes.</span>
<span class="comment"> */</span>
<span class="type">int</span> <span class="title function_">base64_encode</span><span class="params">(<span class="type">const</span> u8 *src, <span class="type">int</span> srclen, <span class="type">char</span> *dst)</span>
&#123;
	u32 ac = <span class="number">0</span>;
	<span class="type">int</span> bits = <span class="number">0</span>;
	<span class="type">int</span> i;
	<span class="type">char</span> *cp = dst;

	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; srclen; i++) &#123;
		ac = (ac &lt;&lt; <span class="number">8</span>) | src[i];
		bits += <span class="number">8</span>;
		<span class="keyword">do</span> &#123;
			bits -= <span class="number">6</span>;
			*cp++ = base64_table[(ac &gt;&gt; bits) &amp; <span class="number">0x3f</span>];
		&#125; <span class="keyword">while</span> (bits &gt;= <span class="number">6</span>);
	&#125;
	<span class="keyword">if</span> (bits) &#123;
		*cp++ = base64_table[(ac &lt;&lt; (<span class="number">6</span> - bits)) &amp; <span class="number">0x3f</span>];
		bits -= <span class="number">6</span>;
	&#125;
	<span class="keyword">while</span> (bits &lt; <span class="number">0</span>) &#123;
		*cp++ = <span class="string">&#x27;=&#x27;</span>;
		bits += <span class="number">2</span>;
	&#125;
	<span class="keyword">return</span> cp - dst;
&#125;
EXPORT_SYMBOL_GPL(base64_encode);

<span class="comment">/**</span>
<span class="comment"> * base64_decode() - base64-decode a string</span>
<span class="comment"> * @src: the string to decode.  Doesn&#x27;t need to be NUL-terminated.</span>
<span class="comment"> * @srclen: the length of @src in bytes</span>
<span class="comment"> * @dst: (output) the decoded binary data</span>
<span class="comment"> *</span>
<span class="comment"> * Decodes a string using base64 encoding, i.e. the &quot;Base 64 Encoding&quot;</span>
<span class="comment"> * specified by RFC 4648, including the  &#x27;=&#x27;-padding.</span>
<span class="comment"> *</span>
<span class="comment"> * This implementation hasn&#x27;t been optimized for performance.</span>
<span class="comment"> *</span>
<span class="comment"> * Return: the length of the resulting decoded binary data in bytes,</span>
<span class="comment"> *	   or -1 if the string isn&#x27;t a valid base64 string.</span>
<span class="comment"> */</span>
<span class="type">int</span> <span class="title function_">base64_decode</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *src, <span class="type">int</span> srclen, u8 *dst)</span>
&#123;
	u32 ac = <span class="number">0</span>;
	<span class="type">int</span> bits = <span class="number">0</span>;
	<span class="type">int</span> i;
	u8 *bp = dst;

	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; srclen; i++) &#123;
		<span class="type">const</span> <span class="type">char</span> *p = <span class="built_in">strchr</span>(base64_table, src[i]);

		<span class="keyword">if</span> (src[i] == <span class="string">&#x27;=&#x27;</span>) &#123;
			ac = (ac &lt;&lt; <span class="number">6</span>);
			bits += <span class="number">6</span>;
			<span class="keyword">if</span> (bits &gt;= <span class="number">8</span>)
				bits -= <span class="number">8</span>;
			<span class="keyword">continue</span>;
		&#125;
		<span class="keyword">if</span> (p == <span class="literal">NULL</span> || src[i] == <span class="number">0</span>)
			<span class="keyword">return</span> <span class="number">-1</span>;
		ac = (ac &lt;&lt; <span class="number">6</span>) | (p - base64_table);
		bits += <span class="number">6</span>;
		<span class="keyword">if</span> (bits &gt;= <span class="number">8</span>) &#123;
			bits -= <span class="number">8</span>;
			*bp++ = (u8)(ac &gt;&gt; bits);
		&#125;
	&#125;
	<span class="keyword">if</span> (ac &amp; ((<span class="number">1</span> &lt;&lt; bits) - <span class="number">1</span>))
		<span class="keyword">return</span> <span class="number">-1</span>;
	<span class="keyword">return</span> bp - dst;
&#125;
EXPORT_SYMBOL_GPL(base64_decode);</code></pre>
<p>这里的padding也是几乎不会出什么大的问题，而且默认严格模式，包正经base64的</p>
<p>不喜欢看这个。。看着就感觉眼皮重了啊，但是还好最后基本都啃下来了(除了实在啃不了的)</p>
<p>本人也是臭菜鸟，哪里有分析的不到位的或者有哪里没分析出来的欢迎师傅加我QQ一起讨论!!</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>请我一杯咖啡吧！</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.jpg" alt="AyaN0 微信">
        <span>微信</span>
      </div>

  </div>
</div>

          <div class="post-tags">
              <a href="/tags/Web/" rel="tag"># Web</a>
              <a href="/tags/%E6%BA%90%E7%A0%81%E6%8C%96%E6%8E%98/" rel="tag"># 源码挖掘</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/09/17/GC%E6%9C%BA%E5%88%B6%E7%9A%84%E9%9A%90%E6%82%A3%E5%92%8C%E5%88%A9%E7%94%A8/" rel="prev" title="GC机制的隐患和利用">
                  <i class="fa fa-angle-left"></i> GC机制的隐患和利用
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">AyaN0</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">363k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">10:59</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
